%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{QMCPACK Manual}
\date{Jul 06, 2020}
\release{}
\author{QMCPACK Developers}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxhref{https://qmcpack.org/}{\sphinxincludegraphics[width=0.800\linewidth]{{QMCPACK_logo}.png}}


\chapter{Introduction}
\label{\detokenize{introduction:introduction}}\label{\detokenize{introduction:id1}}\label{\detokenize{introduction::doc}}
QMCPACK is an open\sphinxhyphen{}source, high\sphinxhyphen{}performance electronic structure code
that implements numerous Quantum Monte Carlo (QMC) algorithms. Its main
applications are electronic structure calculations of molecular,
periodic 2D, and periodic 3D solid\sphinxhyphen{}state systems. Variational Monte
Carlo (VMC), diffusion Monte Carlo (DMC), and a number of other advanced
QMC algorithms are implemented. By directly solving the Schrodinger
equation, QMC methods offer greater accuracy than methods such as
density functional theory but at a trade\sphinxhyphen{}off of much greater
computational expense. Distinct from many other correlated many\sphinxhyphen{}body
methods, QMC methods are readily applicable to both bulk (periodic) and
isolated molecular systems.

QMCPACK is written in C++ and is designed with the modularity afforded
by object\sphinxhyphen{}oriented programming. It makes extensive use of template
metaprogramming to achieve high computational efficiency. Because of the
modular architecture, the addition of new wavefunctions, algorithms, and
observables is relatively straightforward. For parallelization, QMCPACK
uses a fully hybrid (OpenMP,CUDA)/MPI approach to optimize memory usage
and to take advantage of the growing number of cores per SMP node or
graphical processing units (GPUs) and accelerators. High parallel and
computational efficiencies are achievable on the largest supercomputers.
Finally, QMCPACK uses standard file formats for input and output in XML
and HDF5 to facilitate data exchange.

This manual currently serves as an introduction to the essential
features of QMCPACK and as a guide to installing and running it. Over
time this manual will be expanded to include a fuller introduction to
QMC methods in general and to include more of the specialized features
in QMCPACK.


\section{Quickstart and a first QMCPACK calculation}
\label{\detokenize{introduction:quickstart-and-a-first-qmcpack-calculation}}
In case you are keen to get started, this section describes how to
quickly build and run QMCPACK on a standard UNIX or Linux\sphinxhyphen{}like system.
The autoconfiguring build system usually works without much fuss on
these systems. If C++, MPI, BLAS/LAPACK, FFTW, HDF5, and CMake are
already installed, QMCPACK can be built and run within five minutes. For
supercomputers, cross\sphinxhyphen{}compilation systems, and other computer clusters,
the build system might require hints on the locations of libraries and
which versions to use, typical of any code; see
{\hyperref[\detokenize{installation:obtaininginstalling}]{\sphinxcrossref{\DUrole{std,std-ref}{Obtaining, installing, and validating QMCPACK}}}}.
{\hyperref[\detokenize{installation:installexamples}]{\sphinxcrossref{\DUrole{std,std-ref}{Installation instructions for common workstations and supercomputers}}}} includes
complete examples of installations for common workstations and
supercomputers that you can reuse.

To build QMCPACK:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Download the latest QMCPACK distribution from \sphinxurl{http://www.qmcpack.org}.

\item {} 
Untar the archive (e.g., \sphinxcode{\sphinxupquote{tar xvf qmcpack\_v1.3.tar.gz}}).

\item {} 
Check the instructions in the README file.

\item {} 
Run CMake in a suitable build directory to configure QMCPACK for your
system: \sphinxcode{\sphinxupquote{cd qmcpack/build; cmake ..}}

\item {} 
If CMake is unable to find all needed libraries, see
{\hyperref[\detokenize{installation:obtaininginstalling}]{\sphinxcrossref{\DUrole{std,std-ref}{Obtaining, installing, and validating QMCPACK}}}} for
instructions and specific build instructions for common systems.

\item {} 
Build QMCPACK: \sphinxcode{\sphinxupquote{make}} or \sphinxcode{\sphinxupquote{make \sphinxhyphen{}j 16}}; use the latter for a faster parallel build on a
system using, for example, 16 processes.

\item {} 
The QMCPACK executable is \sphinxcode{\sphinxupquote{bin/qmcpack}}.

\end{enumerate}

QMCPACK is distributed with examples illustrating different
capabilities. Most of the examples are designed to run quickly with
modest resources. We’ll run a short diffusion Monte Carlo calculation of
a water molecule:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Go to the appropriate example directory: \sphinxcode{\sphinxupquote{cd ../examples/molecules/H2O.}}

\item {} 
\begin{DUlineblock}{0em}
\item[] (Optional) Put the QMCPACK binary on your path: \sphinxcode{\sphinxupquote{export PATH=\textbackslash{}\$PATH:location\sphinxhyphen{}of\sphinxhyphen{}qmcpack/build/bin}}
\end{DUlineblock}

\item {} 
Run QMCPACK: \sphinxcode{\sphinxupquote{../../../build/bin/qmcpack simple\sphinxhyphen{}H2O.xml}} or \sphinxcode{\sphinxupquote{qmcpack simple\sphinxhyphen{}H2O.xml}} if you followed the step above.

\item {} 
The run will output to the screen and generate a number of files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}ls H2O*
H2O.HF.wfs.xml      H2O.s001.scalar.dat H2O.s002.cont.xml
H2O.s002.qmc.xml    H2O.s002.stat.h5    H2O.s001.qmc.xml
H2O.s001.stat.h5    H2O.s002.dmc.dat    H2O.s002.scalar.dat
\end{sphinxVerbatim}

\item {} 
Partially summarized results are in the standard text files with the
suffixes scalar.dat and dmc.dat. They are viewable with any standard
editor.

\end{enumerate}

If you have Python and matplotlib installed, you can use the analysis
utility to produce statistics and plots of the data. See
{\hyperref[\detokenize{analyzing:analyzing}]{\sphinxcrossref{\DUrole{std,std-ref}{Analyzing QMCPACK data}}}} for information on
analyzing QMCPACK data.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
export PATH=\PYGZdl{}PATH:location\PYGZhy{}of\PYGZhy{}qmcpack/nexus/bin
export PYTHONPATH=\PYGZdl{}PYTHONPATH:location\PYGZhy{}of\PYGZhy{}qmcpack/nexus/library
qmca H2O.s002.scalar.dat         \PYGZsh{} For statistical analysis of the DMC data
qmca \PYGZhy{}t \PYGZhy{}q e H2O.s002.scalar.dat \PYGZsh{} Graphical plot of DMC energy
\end{sphinxVerbatim}

The last command will produce a graph as per
\hyperref[\detokenize{introduction:fig1}]{Fig.\@ \ref{\detokenize{introduction:fig1}}}. This
shows the average energy of the DMC walkers at each timestep. In a real
simulation we would have to check equilibration, convergence with walker
population, time step, etc.

Congratulations, you have completed a DMC calculation with QMCPACK!

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{quick_qmca_dmc_trace}.png}
\caption{Trace of walker energies produced by the qmca tool for a simple water
molecule example.}\label{\detokenize{introduction:id3}}\label{\detokenize{introduction:fig1}}\end{figure}


\section{Authors and History}
\label{\detokenize{introduction:authors-and-history}}\label{\detokenize{introduction:history}}
QMCPACK was initially written by Jeongnim Kim while in the group of
Professor David Ceperley at the University of Illinois at
Urbana\sphinxhyphen{}Champaign, with later contributations being made at Oak Ridge
National Laboratory (ORNL). Over the years, many others have
contributed, particularly students and researchers in the groups of
Professor David Ceperley and Professor Richard M. Martin, as well as
staff at Lawrence Livermore National Laboratory, Sandia National
Laboratories, Argonne National Laboratory, and ORNL.

Additional developers, contributors, and advisors include Anouar Benali,
Mark A. Berrill, David M. Ceperley, Simone Chiesa, Raymond C. III Clay,
Bryan Clark, Kris T. Delaney, Kenneth P. Esler, Paul R. C. Kent, Jaron
T. Krogel, Ying Wai Li, Ye Luo, Jeremy McMinis, Miguel A. Morales,
William D. Parker, Nichols A. Romero, Luke Shulenburger, Norman M.
Tubman, and Jordan E. Vincent.

If you should be added to this list, please let us know.

Development of QMCPACK has been supported financially by several grants,
including the following:
\begin{itemize}
\item {} 
“Network for ab initio many\sphinxhyphen{}body methods: development, education and
training” supported through the Predictive Theory and Modeling for
Materials and Chemical Science program by the U.S. Department of
Energy Office of Science, Basic Energy Sciences

\item {} 
“QMC Endstation,” supported by Accelerating Delivery of Petascale
Computing Environment at the DOE Leadership Computing Facility at
ORNL

\item {} 
PetaApps, supported by the US National Science Foundation

\item {} 
Materials Computation Center (MCC), supported by the US National
Science Foundation

\end{itemize}


\section{Support and Contacting the Developers}
\label{\detokenize{introduction:support-and-contacting-the-developers}}\label{\detokenize{introduction:support}}
Questions about installing, applying, or extending QMCPACK can be posted
on the QMCPACK Google group at
\sphinxurl{https://groups.google.com/forum/\#!forum/qmcpack}. You may also email any
of the developers, but we recommend checking the group first. Particular
attention is given to any problem reports.


\section{Performance}
\label{\detokenize{introduction:performance}}\label{\detokenize{introduction:id2}}
QMCPACK implements modern Monte Carlo (MC) algorithms, is highly
parallel, and is written using very efficient code for high per\sphinxhyphen{}CPU or
on\sphinxhyphen{}node performance. In particular, the code is highly vectorizable,
giving high performance on modern central processing units (CPUs) and
GPUs. We believe QMCPACK delivers performance either comparable to or
better than other QMC codes when similar calculations are run,
particularly for the most common QMC methods and for large systems. If
you find a calculation where this is not the case, or you simply find
performance slower than expected, please post on the Google group or
contact one of the developers. These reports are valuable. If your
calculation is sufficiently mainstream we will optimize QMCPACK to
improve the performance.


\section{Open Source License}
\label{\detokenize{introduction:open-source-license}}\label{\detokenize{introduction:license}}
QMCPACK is distributed under the University of Illinois at
Urbana\sphinxhyphen{}Champaign/National Center for Supercomputing Applications
(UIUC/NCSA) Open Source License.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
          University of Illinois/NCSA Open Source License

Copyright (c) 2003, University of Illinois Board of Trustees.
All rights reserved.

Developed by:
  Jeongnim Kim
  Condensed Matter Physics,
  National Center for Supercomputing Applications, University of Illinois
  Materials computation Center, University of Illinois
  http://www.mcc.uiuc.edu/qmc/

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software\PYGZsq{}\PYGZsq{}), to deal with the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimers.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimers in
          the documentation and/or other materials provided with the
          distribution.
        * Neither the names of the NCSA, the MCC, the University of Illinois,
          nor the names of its contributors may be used to endorse or promote
          products derived from this Software without specific prior written
          permission.

THE SOFTWARE IS PROVIDED \PYGZdq{}AS IS\PYGZdq{}, WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS WITH THE SOFTWARE.
\end{sphinxVerbatim}

Copyright is generally believed to remain with the authors of the
individual sections of code. See the various notations in the source
code as well as the code history.


\section{Contributing to QMCPACK}
\label{\detokenize{introduction:contributing-to-qmcpack}}\label{\detokenize{introduction:contributing}}
QMCPACK is fully open source, and we welcome contributions. If you are
planning a development, early discussions are encouraged. Please post on
the QMCPACK Google group or contact the developers. We can tell you
whether anyone else is working on a similar feature or whether any
related work has been done in the past. Credit for your contribution can
be obtained, for example, through citation of a paper or by becoming one
of the authors on the next version of the standard QMCPACK reference
citation.

A guide to developing for QMCPACK, including instructions on how to work
with GitHub and make pull requests (contributions) to the main source
are listed on the QMCPACK GitHub wiki:
\sphinxurl{https://github.com/QMCPACK/qmcpack/wiki}.

Contributions are made under the same license as QMCPACK, the UIUC/NCSA
open source license. If this is problematic, please discuss with a
developer.

Please note the following guidelines for contributions:
\begin{itemize}
\item {} 
Additions should be fully synchronized with the latest release
version and ideally the latest develop branch on github. Merging of
code developed on older versions is error prone.

\item {} 
Code should be cleanly formatted, commented, portable, and accessible
to other programmers. That is, if you need to use any clever tricks,
add a comment to note this, why the trick is needed, how it works,
etc. Although we like high performance, ease of maintenance and
accessibility are also considerations.

\item {} 
Comment your code. You are not only writing it for the compiler for
also for other humans! (We know this is a repeat of the previous
point, but it is important enough to repeat.)

\item {} 
Write a brief description of the method, algorithms, and inputs and
outputs suitable for inclusion in this manual.

\item {} 
Develop some short tests that exercise the functionality that can be
used for validation and for examples. We can help with this and their
integration into the test system.

\end{itemize}


\section{QMCPACK Roadmap}
\label{\detokenize{introduction:qmcpack-roadmap}}\label{\detokenize{introduction:roadmap}}
A general outline of the QMCPACK roadmap is given in the following sections. Suggestions for improvements are welcome, particularly those
that would facilitate new scientific applications. For example, if an
interface to a particular quantum chemical or density functional code
would help, this would be given strong consideration.


\subsection{Code}
\label{\detokenize{introduction:code}}
We will continue to improve the accessibility and usability of QMCPACK
through combinations of more convenient input parameters, improved
workflow, integration with more quantum chemical and density functional
codes, and a wider range of examples.

In terms of methodological development, we expect to significantly
increase the range of QMC algorithms in QMCPACK in the near future.

Computationally, we are porting QMCPACK to the next generation of
supercomputer systems. The internal changes required to run efficiently
on these systems are expected to benefit \sphinxstyleemphasis{all} platforms due to improved
vectorization, cache utilization, and memory performance.


\subsection{Documentation}
\label{\detokenize{introduction:documentation}}
This manual describes the core features of QMCPACK that are required for
routine research calculations, i.e., the VMC and DMC methods, how to
obtain and optimize trial wavefunctions, and simple observables. Over
time this manual will be expanded to include a broader introduction to
QMC methods and to describe more features of the code.

Because of its history as a research code, QMCPACK contains a variety of
additional QMC methods, trial wavefunction forms, potentials, etc.,
that, although not critical, might be very useful for specialized
calculations or particular material or chemical systems. These “secret
features” (every code has these) are not actually secret but simply lack
descriptions, example inputs, and tests. You are encouraged to browse
and read the source code to find them. New descriptions will be added
over time but can also be prioritized and added on request (e.g., if a
specialized Jastrow factor would help or a historical Jastrow form is
needed for benchmarking).


\chapter{Features of QMCPACK}
\label{\detokenize{features:features-of-qmcpack}}\label{\detokenize{features:chap-features}}\label{\detokenize{features::doc}}

\section{Production\sphinxhyphen{}level features}
\label{\detokenize{features:production-level-features}}
The following list contains the main production\sphinxhyphen{}level features of
QMCPACK. If you do not see a specific feature that you are interested
in, see the remainder of this manual and ask whether that specific
feature is available or can be quickly brought to the full production
level.
\begin{itemize}
\item {} 
Variational Monte Carlo (VMC)

\item {} 
Diffusion Monte Carlo (DMC)

\item {} 
Reptation Monte Carlo

\item {} 
Single and multideterminant Slater Jastrow wavefunctions

\item {} 
Wavefunction updates using optimized multideterminant algorithm of
Clark et al.

\item {} 
Backflow wavefunctions

\item {} 
One, two, and three\sphinxhyphen{}body Jastrow factors

\item {} 
Excited state calculations via flexible occupancy assignment of
Slater determinants

\item {} 
All electron and nonlocal pseudopotential calculations

\item {} 
Casula T\sphinxhyphen{}moves for variational evaluation of nonlocal
pseudopotentials (non\sphinxhyphen{}size\sphinxhyphen{}consistent and size\sphinxhyphen{}consistent variants)

\item {} 
Wavefunction optimization using the “linear method” of Umrigar and
coworkers, with arbitrary mix of variance and energy in the objective
function

\item {} 
Blocked, low memory adaptive shift optimizer of Zhao and Neuscamman

\item {} 
Gaussian, Slater, plane\sphinxhyphen{}wave, and real\sphinxhyphen{}space spline basis sets for
orbitals

\item {} 
Interface and conversion utilities for plane\sphinxhyphen{}wave wavefunctions from
Quantum Espresso (Plane\sphinxhyphen{}Wave Self\sphinxhyphen{}Consistent Field package {[}PWSCF{]})

\item {} 
Interface and conversion utilities for Gaussian\sphinxhyphen{}basis wavefunctions
from GAMESS

\item {} 
Easy extension and interfacing to other electronic structure codes
via standardized XML and HDF5 inputs

\item {} 
MPI parallelism

\item {} 
Fully threaded using OpenMP

\item {} 
GPU (NVIDIA CUDA) implementation (limited functionality)

\item {} 
HDF5 input/output for large data

\item {} 
Nexus: advanced workflow tool to automate all aspects of QMC
calculation from initial DFT calculations through to final analysis

\item {} 
Analysis tools for minimal environments (Perl only) through to
Python\sphinxhyphen{}based environments with graphs produced via matplotlib
(included with Nexus)

\end{itemize}


\section{SoA optimizations and improved algorithms}
\label{\detokenize{features:soa-optimizations-and-improved-algorithms}}
The Structure\sphinxhyphen{}of\sphinxhyphen{}Arrays (SoA) optimizations
\sphinxcite{features:ipcc-sc17} are a set of improved data layouts
facilitating vectorization on modern CPUs with wide SIMD units. \sphinxstylestrong{For
many calculations and architectures, the SoA implementation more than
doubles the speed of the code.} This so\sphinxhyphen{}called SoA implementation
replaces the older, less efficient Array\sphinxhyphen{}of\sphinxhyphen{}Structures (AoS) code and
can be enabled or disabled at compile time. The memory footprint is also
reduced in the SoA implementation by better algorithms, enabling more
systems to be run.

The SoA build was made the default for QMCPACK v3.7.0. As described in {\hyperref[\detokenize{installation:cmakeoptions}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration Options}}}}, the SoA
implementation can be disabled by configuring with \sphinxcode{\sphinxupquote{\sphinxhyphen{}DENABLE\_SOA=0}}.

The SoA code path currently does \sphinxstyleemphasis{not} support:
\begin{itemize}
\item {} 
Backflow wavefunctions

\item {} 
Many observables

\end{itemize}

The code should abort with a message referring to AoS vs SoA features if
any unsupported feature is invoked. In this case the AoS build should be
used by configuring with \sphinxcode{\sphinxupquote{\sphinxhyphen{}DENABLE\_SOA=0}}. In addition, please inform the developers via
GitHub or Google Groups so that porting these features can be
prioritized.

Core features are heavily tested in both SoA and AoS versions. If using
untested and noncore features in the SoA code, please compare the AoS
and SoA results carefully.


\section{Supported GPU features}
\label{\detokenize{features:supported-gpu-features}}
The GPU implementation supports multiple GPUs per node, with MPI tasks
assigned in a round\sphinxhyphen{}robin order to the GPUs. Currently, for large runs,
1 MPI task should be used per GPU per node. For smaller calculations,
use of multiple MPI tasks per GPU might yield improved performance.
Supported GPU features:
\begin{itemize}
\item {} 
VMC, wavefunction optimization, DMC.

\item {} 
Periodic and open boundary conditions. Mixed boundary conditions are
not yet supported.

\item {} 
Wavefunctions:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Single Slater determinants with 3D B\sphinxhyphen{}spline orbitals.
Twist\sphinxhyphen{}averaged boundary conditions and complex wavefunctions are
fully supported. Gaussian type orbitals are not yet supported.

\item {} 
Hybrid mixed basis representation in which orbitals are
represented as 1D splines times spherical harmonics in spherical
regions (muffin tins) around atoms and 3D B\sphinxhyphen{}splines in the
interstitial region.

\item {} 
One\sphinxhyphen{}body and two\sphinxhyphen{}body Jastrows represented as 1D B\sphinxhyphen{}splines.
Three\sphinxhyphen{}body Jastrow functions are not yet supported.

\end{enumerate}

\item {} 
Semilocal (nonlocal and local) pseudopotentials, Coulomb interaction
(electron\sphinxhyphen{}electron, electron\sphinxhyphen{}ion), and model periodic Coulomb (MPC)
interaction.

\end{itemize}


\section{Beta test features}
\label{\detokenize{features:beta-test-features}}
This section describes developmental features in QMCPACK that might be
ready for production but that require additional testing, features, or
documentation to be ready for general use. We describe them here because
they offer significant benefits and are well tested in specific cases.


\subsection{Auxiliary\sphinxhyphen{}Field Quantum Monte Carlo}
\label{\detokenize{features:auxiliary-field-quantum-monte-carlo}}
The orbital\sphinxhyphen{}space Auxiliary\sphinxhyphen{}Field Quantum Monte Carlo (AFMQC) method is
now available in QMCPACK. The main input for the code is the matrix
elements of the Hamiltonian in a given single particle basis set, which
must be produced from mean\sphinxhyphen{}field calculations such as Hartree\sphinxhyphen{}Fock or
density functional theory. The code and many features are in
development. Check the latest version of QMCPACK for an up\sphinxhyphen{}to\sphinxhyphen{}date
description of available features. A partial list of the current
capabilities of the code follows. For a detailed description of the
available features, see  {\hyperref[\detokenize{afqmc:afqmc}]{\sphinxcrossref{\DUrole{std,std-ref}{Auxiliary\sphinxhyphen{}Field Quantum Monte Carlo}}}}.
\begin{itemize}
\item {} 
Phaseless AFQMC algorithm of Zhang et al. (S. Zhang and H. Krakauer.
2003. “Quantum Monte Carlo Method using Phase\sphinxhyphen{}Free Random Walks with
Slater Determinants.” \sphinxstyleemphasis{PRL} 90: 136401).

\item {} 
“Hybrid” and “local energy” propagation schemes.

\item {} 
Hamiltonian matrix elements from (1) Molpro’s FCIDUMP format (which
can be produced by Molpro, PySCF, and VASP) and (2) internal HDF5
format produced by PySCF (see AFQMC section below).

\item {} 
AFQMC calculations with RHF (closed\sphinxhyphen{}shell doubly occupied), ROHF
(open\sphinxhyphen{}shell doubly occupied), and UHF (spin polarized broken
symmetry) symmetry.

\item {} 
Single and multideterminant trial wavefunctions. Multideterminant
expansions with either orthogonal or nonorthogonal determinants.

\item {} 
Fast update scheme for orthogonal multideterminant expansions.

\item {} 
Distributed propagation algorithms for large systems. Enables
calculations where data structures do not fit on a single node.

\item {} 
Complex implementation for PBC calculations with complex integrals.

\item {} 
Sparse representation of large matrices for reduced memory usage.

\item {} 
Mixed and back\sphinxhyphen{}propagated estimators.

\item {} 
Specialized implementation for solids with k\sphinxhyphen{}point symmetry (e.g.
primitive unit cells with kpoints).

\item {} 
Efficient GPU implementation (currently limited to solids with
k\sphinxhyphen{}point symmetry).

\end{itemize}


\subsection{Sharing of spline data across multiple GPUs}
\label{\detokenize{features:sharing-of-spline-data-across-multiple-gpus}}
Sharing of GPU spline data enables distribution of the data across
multiple GPUs on a given computational node. For example, on a
two\sphinxhyphen{}GPU\sphinxhyphen{}per\sphinxhyphen{}node system, each GPU would have half of the orbitals. This
allows use of larger overall spline tables than would fit in the memory
of individual GPUs and potentially up to the total GPU memory on a node.
To obtain high performance, large electron counts or a high\sphinxhyphen{}performing
CPU\sphinxhyphen{}GPU interconnect is required.

To use this feature, the following needs to be done:
\begin{itemize}
\item {} 
The CUDA Multi\sphinxhyphen{}Process Service (MPS) needs to be used (e.g., on OLCF
Summit/SummitDev use “\sphinxhyphen{}alloc\_flags gpumps” for bsub). If MPI is not
detected, sharing will be disabled.

\item {} 
CUDA\_VISIBLE\_DEVICES needs to be properly set to control each rank’s
visible CUDA devices (e.g., on OLCF Summit/SummitDev create a
resource set containing all GPUs with the respective number of ranks
with “jsrun \textendash{}task\sphinxhyphen{}per\sphinxhyphen{}rs Ngpus \sphinxhyphen{}g Ngpus”).

\item {} 
In the determinant set definition of the \textless{}wavefunction\textgreater{} section, the
“gpusharing” parameter needs to be set (i.e., \textless{}determinantset
gpusharing=“yes”\textgreater{}). See
{\hyperref[\detokenize{intro_wavefunction:spo-spline}]{\sphinxcrossref{\DUrole{std,std-ref}{Spline basis sets}}}}.

\end{itemize}




\chapter{Obtaining, installing, and validating QMCPACK}
\label{\detokenize{installation:obtaining-installing-and-validating-qmcpack}}\label{\detokenize{installation:obtaininginstalling}}\label{\detokenize{installation::doc}}
This chapter describes how to obtain, build, and validate QMCPACK. This
process is designed to be as simple as possible and should be no harder
than building a modern plane\sphinxhyphen{}wave density functional theory code such as
Quantum ESPRESSO, QBox, or VASP. Parallel builds enable a complete
compilation in under 2 minutes on a fast multicore system. If you are
unfamiliar with building codes we suggest working with your system
administrator to install QMCPACK.


\section{Installation steps}
\label{\detokenize{installation:installation-steps}}
To install QMCPACK, follow the steps below. Full details of each step
are given in the referenced sections.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Download the source code from {\hyperref[\detokenize{installation:obrelease}]{\sphinxcrossref{\DUrole{std,std-ref}{Obtaining the latest release version}}}}
or {\hyperref[\detokenize{installation:obdevelopment}]{\sphinxcrossref{\DUrole{std,std-ref}{Obtaining the latest development version}}}}.

\item {} 
Verify that you have the required compilers, libraries, and tools
installed ({\hyperref[\detokenize{installation:prerequisites}]{\sphinxcrossref{\DUrole{std,std-ref}{Prerequisites}}}}).

\item {} 
If you will use Quantum ESPRESSO, download and patch it. The patch
adds the pw2qmcpack utility
({\hyperref[\detokenize{installation:buildqe}]{\sphinxcrossref{\DUrole{std,std-ref}{Installing and patching Quantum ESPRESSO}}}}).

\item {} 
Run the cmake configure step and build with make
({\hyperref[\detokenize{installation:cmake}]{\sphinxcrossref{\DUrole{std,std-ref}{Building with CMake}}}} and {\hyperref[\detokenize{installation:cmakequick}]{\sphinxcrossref{\DUrole{std,std-ref}{Quick build instructions (try first)}}}}). Examples for
common systems are given in
{\hyperref[\detokenize{installation:installexamples}]{\sphinxcrossref{\DUrole{std,std-ref}{Installation instructions for common workstations and supercomputers}}}}.

\item {} 
Run the tests to verify QMCPACK
({\hyperref[\detokenize{installation:testing}]{\sphinxcrossref{\DUrole{std,std-ref}{Testing and validation of QMCPACK}}}}).

\item {} 
Build the ppconvert utility in QMCPACK
({\hyperref[\detokenize{installation:buildppconvert}]{\sphinxcrossref{\DUrole{std,std-ref}{Building ppconvert, a pseudopotential format converter}}}}).

\end{enumerate}

Hints for high performance are in
{\hyperref[\detokenize{installation:buildperformance}]{\sphinxcrossref{\DUrole{std,std-ref}{How to build the fastest executable version of QMCPACK}}}}.
Troubleshooting suggestions are in
{\hyperref[\detokenize{installation:troubleshoot}]{\sphinxcrossref{\DUrole{std,std-ref}{Troubleshooting the installation}}}}.

Note that there are two different QMCPACK executables that can be
produced: the general one, which is the default, and the “complex”
version, which supports periodic calculations at arbitrary twist angles
and k\sphinxhyphen{}points. This second version is enabled via a cmake configuration
parameter (see {\hyperref[\detokenize{installation:cmakeoptions}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration Options}}}}).
The general version supports only wavefunctions that can be made real.
If you run a calculation that needs the complex version, QMCPACK will
stop and inform you.


\section{Obtaining the latest release version}
\label{\detokenize{installation:obtaining-the-latest-release-version}}\label{\detokenize{installation:obrelease}}
Major releases of QMCPACK are distributed from \sphinxurl{http://www.qmcpack.org}.
Because these versions undergo the most testing, we encourage using them
for all production calculations unless there are specific reasons not to
do so.

Releases are usually compressed tar files that indicate the version
number, date, and often the source code revision control number
corresponding to the release. To obtain the latest release:
\begin{itemize}
\item {} 
Download the latest QMCPACK distribution from \sphinxurl{http://www.qmcpack.org}.

\item {} 
Untar the archive (e.g., \sphinxcode{\sphinxupquote{tar xvf qmcpack\_v1.3.tar.gz}}).

\end{itemize}

Releases can also be obtained from the ‘master’ branch of the QMCPACK
git repository, similar to obtaining the development version
({\hyperref[\detokenize{installation:obdevelopment}]{\sphinxcrossref{\DUrole{std,std-ref}{Obtaining the latest development version}}}}).


\section{Obtaining the latest development version}
\label{\detokenize{installation:obtaining-the-latest-development-version}}\label{\detokenize{installation:obdevelopment}}
The most recent development version of QMCPACK can be obtained
anonymously via

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{git} \PYG{n}{clone} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git}
\end{sphinxVerbatim}

Once checked out, updates can be made via the standard \sphinxcode{\sphinxupquote{git pull}}.

The ‘develop’ branch of the git repository contains the day\sphinxhyphen{}to\sphinxhyphen{}day
development source with the latest updates, bug fixes, etc. This version
might be useful for updates to the build system to support new machines,
for support of the latest versions of Quantum ESPRESSO, or for updates
to the documentation. Note that the development version might not be
fully consistent with the online documentation. We attempt to keep the
development version fully working. However, please be sure to run tests
and compare with previous release versions before using for any serious
calculations. We try to keep bugs out, but occasionally they crawl in!
Reports of any breakages are appreciated.


\section{Prerequisites}
\label{\detokenize{installation:prerequisites}}\label{\detokenize{installation:id1}}
The following items are required to build QMCPACK. For workstations,
these are available via the standard package manager. On shared
supercomputers this software is usually installed by default and is
often accessed via a modules environment—check your system
documentation.

\sphinxstylestrong{Use of the latest versions of all compilers and libraries is strongly
encouraged} but not absolutely essential. Generally, newer versions are
faster; see {\hyperref[\detokenize{installation:buildperformance}]{\sphinxcrossref{\DUrole{std,std-ref}{How to build the fastest executable version of QMCPACK}}}}
for performance suggestions.
\begin{itemize}
\item {} 
C/C++ compilers such as GNU, Clang, Intel, and IBM XL. C++ compilers
are required to support the C++ 14 standard. Use of recent (“current
year version”) compilers is strongly encouraged.

\item {} 
An MPI library such as OpenMPI (\sphinxurl{http://open-mpi.org}) or a
vendor\sphinxhyphen{}optimized MPI.

\item {} 
BLAS/LAPACK, numerical, and linear algebra libraries. Use
platform\sphinxhyphen{}optimized libraries where available, such as Intel MKL.
ATLAS or other optimized open source libraries can also be used
(\sphinxurl{http://math-atlas.sourceforge.net}).

\item {} 
CMake, build utility (\sphinxurl{http://www.cmake.org}).

\item {} 
Libxml2, XML parser (\sphinxurl{http://xmlsoft.org}).

\item {} 
HDF5, portable I/O library (\sphinxurl{http://www.hdfgroup.org/HDF5/}). Good
performance at large scale requires parallel version \(>=\) 1.10.

\item {} 
BOOST, peer\sphinxhyphen{}reviewed portable C++ source libraries
(\sphinxurl{http://www.boost.org}). Minimum version is 1.61.0.

\item {} 
FFTW, FFT library (\sphinxurl{http://www.fftw.org/}).

\end{itemize}

To build the GPU accelerated version of QMCPACK, an installation of
NVIDIA CUDA development tools is required. Ensure that this is
compatible with the C and C++ compiler versions you plan to use.
Supported versions are included in the NVIDIA release notes.

Many of the utilities provided with QMCPACK use Python (v2). The numpy
and matplotlib libraries are required for full functionality.

Note that the standalone einspline library used by previous versions of
QMCPACK is no longer required. A more optimized version is included
inside. The standalone version should \sphinxstyleemphasis{not} be on any standard search
paths because conflicts between the old and new include files can
result.


\section{C++ 14 standard library}
\label{\detokenize{installation:c-14-standard-library}}
The C++ standard consists of language features—which are implemented in
the compiler—and library features—which are implemented in the standard
library. GCC includes its own standard library and headers, but many
compilers do not and instead reuse those from an existing GCC install.
Depending on setup and installation, some of these compilers might not
default to using a GCC with C++ 14 headers (e.g., GCC 4.8 is common as a
base system compiler, but its standard library only supports C++ 11).

The symptom of having header files that do not support the C++ 14
standard is usually compile errors involving standard include header
files. Look for the GCC library version, which should be present in the
path to the include file in the error message, and ensure that it is 5.0
or greater. To avoid these errors occurring at compile time, QMCPACK
tests for a C++ 14 standard library during configuration and will halt
with an error if one is not found.

At sites that use modules, running is often sufficient to load a newer
GCC and resolve the issue.


\subsection{Intel compiler}
\label{\detokenize{installation:intel-compiler}}
The Intel compiler version must be 18 or newer. The version 17 compiler
cannot compile some of the C++ 14 constructs in the code.

If a newer GCC is needed, the \sphinxcode{\sphinxupquote{\sphinxhyphen{}cxxlib}} option can be used to point to a different
GCC installation. (Alternately, the \sphinxcode{\sphinxupquote{\sphinxhyphen{}gcc\sphinxhyphen{}name}} or \sphinxcode{\sphinxupquote{\sphinxhyphen{}gxx\sphinxhyphen{}name}} options can be used.) Be sure to
pass this flag to the C compiler in addition to the C++ compiler. This
is necessary because CMake extracts some library paths from the C
compiler, and those paths usually also contain to the C++ library. The
symptom of this problem is C++ 14 standard library functions not found
at link time.


\section{Building with CMake}
\label{\detokenize{installation:building-with-cmake}}\label{\detokenize{installation:cmake}}
The build system for QMCPACK is based on CMake. It will autoconfigure
based on the detected compilers and libraries. The most recent version
of CMake has the best detection for the greatest variety of systems. The
minimum required version of CMake is 3.6, which is the oldest version to
support correct application of C++ 14 flags for the Intel compiler. Most
computer installations have a sufficiently recent CMake, though it might
not be the default.

If no appropriate version CMake is available, building it from source is
straightforward. Download a version from \sphinxurl{https://cmake.org/download/} and
unpack the files. Run \sphinxcode{\sphinxupquote{./bootstrap}} from the CMake directory, and then run \sphinxcode{\sphinxupquote{make}} when that
finishes. The resulting CMake executable will be in the directory. The
executable can be run directly from that location.

Previously, QMCPACK made extensive use of toolchains, but the build
system has since been updated to eliminate the use of toolchain files
for most cases. The build system is verified to work with GNU, Intel,
and IBM XLC compilers. Specific compile options can be specified either
through specific environment or CMake variables. When the libraries are
installed in standard locations (e.g., /usr, /usr/local), there is no
need to set environment or CMake variables for the packages.


\subsection{Quick build instructions (try first)}
\label{\detokenize{installation:quick-build-instructions-try-first}}\label{\detokenize{installation:cmakequick}}
If you are feeling lucky and are on a standard UNIX\sphinxhyphen{}like system such as
a Linux workstation, the following might quickly give a working QMCPACK:

The safest quick build option is to specify the C and C++ compilers
through their MPI wrappers. Here we use Intel MPI and Intel compilers.
Move to the build directory, run CMake, and make

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{build}
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}C\PYGZus{}COMPILER}\PYG{o}{=}\PYG{n}{mpiicc} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}CXX\PYGZus{}COMPILER}\PYG{o}{=}\PYG{n}{mpiicpc} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{l+m+mi}{8}
\end{sphinxVerbatim}

You can increase the “8” to the number of cores on your system for
faster builds. Substitute mpicc and mpicxx or other wrapped compiler names to suit
your system. For example, with OpenMPI use

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{build}
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}C\PYGZus{}COMPILER}\PYG{o}{=}\PYG{n}{mpicc} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}CXX\PYGZus{}COMPILER}\PYG{o}{=}\PYG{n}{mpicxx} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{l+m+mi}{8}
\end{sphinxVerbatim}

If you are feeling particularly lucky, you can skip the compiler specification:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{build}
\PYG{n}{cmake} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{l+m+mi}{8}
\end{sphinxVerbatim}

The complexities of modern computer hardware and software systems are
such that you should check that the autoconfiguration system has made
good choices and picked optimized libraries and compiler settings
before doing significant production. That is, check the following details. We
give examples for a number of common systems in {\hyperref[\detokenize{installation:installexamples}]{\sphinxcrossref{\DUrole{std,std-ref}{Installation instructions for common workstations and supercomputers}}}}.


\subsection{Environment variables}
\label{\detokenize{installation:environment-variables}}\label{\detokenize{installation:envvar}}
A number of environment variables affect the build.  In particular
they can control the default paths for libraries, the default
compilers, etc.  The list of environment variables is given below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CXX}              \PYG{n}{C}\PYG{o}{+}\PYG{o}{+} \PYG{n}{compiler}
\PYG{n}{CC}               \PYG{n}{C} \PYG{n}{Compiler}
\PYG{n}{MKL\PYGZus{}ROOT}         \PYG{n}{Path} \PYG{k}{for} \PYG{n}{MKL}
\PYG{n}{HDF5\PYGZus{}ROOT}        \PYG{n}{Path} \PYG{k}{for} \PYG{n}{HDF5}
\PYG{n}{BOOST\PYGZus{}ROOT}       \PYG{n}{Path} \PYG{k}{for} \PYG{n}{Boost}
\PYG{n}{FFTW\PYGZus{}HOME}        \PYG{n}{Path} \PYG{k}{for} \PYG{n}{FFTW}
\end{sphinxVerbatim}


\subsection{Configuration Options}
\label{\detokenize{installation:configuration-options}}\label{\detokenize{installation:cmakeoptions}}
In addition to reading the environment variables, CMake provides a
number of optional variables that can be set to control the build and
configure steps.  When passed to CMake, these variables will take
precedent over the environment and default variables.  To set them,
add \sphinxhyphen{}D FLAG=VALUE to the configure line between the CMake command and
the path to the source directory.
\begin{itemize}
\item {} 
Key QMCPACK build options

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{QMC\PYGZus{}CUDA}              \PYG{n}{Enable} \PYG{n}{CUDA} \PYG{o+ow}{and} \PYG{n}{GPU} \PYG{n}{acceleration} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{yes}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{no}\PYG{p}{)}
\PYG{n}{QMC\PYGZus{}COMPLEX}           \PYG{n}{Build} \PYG{n}{the} \PYG{n+nb}{complex} \PYG{p}{(}\PYG{n}{general} \PYG{n}{twist}\PYG{o}{/}\PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{n}{point}\PYG{p}{)} \PYG{n}{version} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{yes}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{no}\PYG{p}{)}
\PYG{n}{QMC\PYGZus{}MIXED\PYGZus{}PRECISION}   \PYG{n}{Build} \PYG{n}{the} \PYG{n}{mixed} \PYG{n}{precision} \PYG{p}{(}\PYG{n}{mixing} \PYG{n}{double}\PYG{o}{/}\PYG{n+nb}{float}\PYG{p}{)} \PYG{n}{version}
                      \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{yes} \PYG{p}{(}\PYG{n}{GPU} \PYG{n}{default}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{no} \PYG{p}{(}\PYG{n}{CPU} \PYG{n}{default}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}
                      \PYG{n}{The} \PYG{n}{CPU} \PYG{n}{support} \PYG{o+ow}{is} \PYG{n}{experimental}\PYG{o}{.}
                      \PYG{n}{Use} \PYG{n+nb}{float} \PYG{o+ow}{and} \PYG{n}{double} \PYG{k}{for} \PYG{n}{base} \PYG{o+ow}{and} \PYG{n}{full} \PYG{n}{precision}\PYG{o}{.}
                      \PYG{n}{The} \PYG{n}{GPU} \PYG{n}{support} \PYG{o+ow}{is} \PYG{n}{quite} \PYG{n}{mature}\PYG{o}{.}
                      \PYG{n}{Use} \PYG{n}{always} \PYG{n}{double} \PYG{k}{for} \PYG{n}{host} \PYG{n}{side} \PYG{n}{base} \PYG{o+ow}{and} \PYG{n}{full} \PYG{n}{precision}
                      \PYG{o+ow}{and} \PYG{n}{use} \PYG{n+nb}{float} \PYG{o+ow}{and} \PYG{n}{double} \PYG{k}{for} \PYG{n}{CUDA} \PYG{n}{base} \PYG{o+ow}{and} \PYG{n}{full} \PYG{n}{precision}\PYG{o}{.}
\PYG{n}{ENABLE\PYGZus{}SOA}            \PYG{n}{Enable} \PYG{n}{data} \PYG{n}{layout} \PYG{o+ow}{and} \PYG{n}{algorithm} \PYG{n}{optimizations} \PYG{n}{using}
                      \PYG{n}{Structure}\PYG{o}{\PYGZhy{}}\PYG{n}{of}\PYG{o}{\PYGZhy{}}\PYG{n}{Array} \PYG{p}{(}\PYG{n}{SoA}\PYG{p}{)} \PYG{n}{datatypes} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{yes} \PYG{p}{(}\PYG{n}{default}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{no}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{ENABLE\PYGZus{}TIMERS}         \PYG{n}{Enable} \PYG{n}{fine}\PYG{o}{\PYGZhy{}}\PYG{n}{grained} \PYG{n}{timers} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{yes}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{no} \PYG{p}{(}\PYG{n}{default}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}
                      \PYG{n}{Timers} \PYG{n}{are} \PYG{n}{off} \PYG{n}{by} \PYG{n}{default} \PYG{n}{to} \PYG{n}{avoid} \PYG{n}{potential} \PYG{n}{slowdown} \PYG{o+ow}{in} \PYG{n}{small}
                      \PYG{n}{systems}\PYG{o}{.} \PYG{n}{For} \PYG{n}{large} \PYG{n}{systems} \PYG{p}{(}\PYG{l+m+mi}{100}\PYG{o}{+} \PYG{n}{electrons}\PYG{p}{)} \PYG{n}{there} \PYG{o+ow}{is} \PYG{n}{no} \PYG{n}{risk}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
General build options

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CMAKE\PYGZus{}BUILD\PYGZus{}TYPE}     \PYG{n}{A} \PYG{n}{variable} \PYG{n}{which} \PYG{n}{controls} \PYG{n}{the} \PYG{n+nb}{type} \PYG{n}{of} \PYG{n}{build}
                     \PYG{p}{(}\PYG{n}{defaults} \PYG{n}{to} \PYG{n}{Release}\PYG{p}{)}\PYG{o}{.} \PYG{n}{Possible} \PYG{n}{values} \PYG{n}{are}\PYG{p}{:}
                     \PYG{k+kc}{None} \PYG{p}{(}\PYG{n}{Do} \PYG{o+ow}{not} \PYG{n+nb}{set} \PYG{n}{debug}\PYG{o}{/}\PYG{n}{optmize} \PYG{n}{flags}\PYG{p}{,} \PYG{n}{use}
                     \PYG{n}{CMAKE\PYGZus{}C\PYGZus{}FLAGS} \PYG{o+ow}{or} \PYG{n}{CMAKE\PYGZus{}CXX\PYGZus{}FLAGS}\PYG{p}{)}
                     \PYG{n}{Debug} \PYG{p}{(}\PYG{n}{create} \PYG{n}{a} \PYG{n}{debug} \PYG{n}{build}\PYG{p}{)}
                     \PYG{n}{Release} \PYG{p}{(}\PYG{n}{create} \PYG{n}{a} \PYG{n}{release}\PYG{o}{/}\PYG{n}{optimized} \PYG{n}{build}\PYG{p}{)}
                     \PYG{n}{RelWithDebInfo} \PYG{p}{(}\PYG{n}{create} \PYG{n}{a} \PYG{n}{release}\PYG{o}{/}\PYG{n}{optimized} \PYG{n}{build} \PYG{k}{with} \PYG{n}{debug} \PYG{n}{info}\PYG{p}{)}
                     \PYG{n}{MinSizeRel} \PYG{p}{(}\PYG{n}{create} \PYG{n}{an} \PYG{n}{executable} \PYG{n}{optimized} \PYG{k}{for} \PYG{n}{size}\PYG{p}{)}
\PYG{n}{CMAKE\PYGZus{}SYSTEM\PYGZus{}NAME}    \PYG{n}{Set} \PYG{n}{value} \PYG{n}{to} \PYG{n}{CrayLinuxEnvironment} \PYG{n}{when} \PYG{n}{cross}\PYG{o}{\PYGZhy{}}\PYG{n}{compiling} \PYG{o+ow}{in} \PYG{n}{Cray} \PYG{n}{Programming} \PYG{n}{Environment}\PYG{o}{.}
\PYG{n}{CMAKE\PYGZus{}C\PYGZus{}COMPILER}     \PYG{n}{Set} \PYG{n}{the} \PYG{n}{C} \PYG{n}{compiler}
\PYG{n}{CMAKE\PYGZus{}CXX\PYGZus{}COMPILER}   \PYG{n}{Set} \PYG{n}{the} \PYG{n}{C}\PYG{o}{+}\PYG{o}{+} \PYG{n}{compiler}
\PYG{n}{CMAKE\PYGZus{}C\PYGZus{}FLAGS}        \PYG{n}{Set} \PYG{n}{the} \PYG{n}{C} \PYG{n}{flags}\PYG{o}{.}  \PYG{n}{Note}\PYG{p}{:} \PYG{n}{to} \PYG{n}{prevent} \PYG{n}{default}
                     \PYG{n}{debug}\PYG{o}{/}\PYG{n}{release} \PYG{n}{flags} \PYG{k+kn}{from} \PYG{n+nn}{being} \PYG{n}{used}\PYG{p}{,} \PYG{n+nb}{set} \PYG{n}{the} \PYG{n}{CMAKE\PYGZus{}BUILD\PYGZus{}TYPE}\PYG{o}{=}\PYG{k+kc}{None}
                     \PYG{n}{Also} \PYG{n}{supported}\PYG{p}{:} \PYG{n}{CMAKE\PYGZus{}C\PYGZus{}FLAGS\PYGZus{}DEBUG}\PYG{p}{,}
                     \PYG{n}{CMAKE\PYGZus{}C\PYGZus{}FLAGS\PYGZus{}RELEASE}\PYG{p}{,} \PYG{o+ow}{and} \PYG{n}{CMAKE\PYGZus{}C\PYGZus{}FLAGS\PYGZus{}RELWITHDEBINFO}
\PYG{n}{CMAKE\PYGZus{}CXX\PYGZus{}FLAGS}      \PYG{n}{Set} \PYG{n}{the} \PYG{n}{C}\PYG{o}{+}\PYG{o}{+} \PYG{n}{flags}\PYG{o}{.}  \PYG{n}{Note}\PYG{p}{:} \PYG{n}{to} \PYG{n}{prevent} \PYG{n}{default}
                     \PYG{n}{debug}\PYG{o}{/}\PYG{n}{release} \PYG{n}{flags} \PYG{k+kn}{from} \PYG{n+nn}{being} \PYG{n}{used}\PYG{p}{,} \PYG{n+nb}{set} \PYG{n}{the} \PYG{n}{CMAKE\PYGZus{}BUILD\PYGZus{}TYPE}\PYG{o}{=}\PYG{k+kc}{None}
                     \PYG{n}{Also} \PYG{n}{supported}\PYG{p}{:} \PYG{n}{CMAKE\PYGZus{}CXX\PYGZus{}FLAGS\PYGZus{}DEBUG}\PYG{p}{,}
                     \PYG{n}{CMAKE\PYGZus{}CXX\PYGZus{}FLAGS\PYGZus{}RELEASE}\PYG{p}{,} \PYG{o+ow}{and} \PYG{n}{CMAKE\PYGZus{}CXX\PYGZus{}FLAGS\PYGZus{}RELWITHDEBINFO}
\PYG{n}{CMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX} \PYG{n}{Set} \PYG{n}{the} \PYG{n}{install} \PYG{n}{location} \PYG{p}{(}\PYG{k}{if} \PYG{n}{using} \PYG{n}{the} \PYG{n}{optional} \PYG{n}{install} \PYG{n}{step}\PYG{p}{)}
\PYG{n}{INSTALL\PYGZus{}NEXUS}        \PYG{n}{Install} \PYG{n}{Nexus} \PYG{n}{alongside} \PYG{n}{QMCPACK} \PYG{p}{(}\PYG{k}{if} \PYG{n}{using} \PYG{n}{the} \PYG{n}{optional} \PYG{n}{install} \PYG{n}{step}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Additional QMCPACK build options

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{QE\PYGZus{}BIN}                    \PYG{n}{Location} \PYG{n}{of} \PYG{n}{Quantum} \PYG{n}{Espresso} \PYG{n}{binaries} \PYG{n}{including} \PYG{n}{pw2qmcpack}\PYG{o}{.}\PYG{n}{x}
\PYG{n}{QMC\PYGZus{}DATA}                  \PYG{n}{Specify} \PYG{n}{data} \PYG{n}{directory} \PYG{k}{for} \PYG{n}{QMCPACK} \PYG{n}{performance} \PYG{o+ow}{and} \PYG{n}{integration} \PYG{n}{tests}
\PYG{n}{QMC\PYGZus{}INCLUDE}               \PYG{n}{Add} \PYG{n}{extra} \PYG{n}{include} \PYG{n}{paths}
\PYG{n}{QMC\PYGZus{}EXTRA\PYGZus{}LIBS}            \PYG{n}{Add} \PYG{n}{extra} \PYG{n}{link} \PYG{n}{libraries}
\PYG{n}{QMC\PYGZus{}BUILD\PYGZus{}STATIC}          \PYG{n}{Add} \PYG{o}{\PYGZhy{}}\PYG{n}{static} \PYG{n}{flags} \PYG{n}{to} \PYG{n}{build}
\PYG{n}{QMC\PYGZus{}SYMLINK\PYGZus{}TEST\PYGZus{}FILES}    \PYG{n}{Set} \PYG{n}{to} \PYG{n}{zero} \PYG{n}{to} \PYG{n}{require} \PYG{n}{test} \PYG{n}{files} \PYG{n}{to} \PYG{n}{be} \PYG{n}{copied}\PYG{o}{.} \PYG{n}{Avoids} \PYG{n}{space}
                          \PYG{n}{saving} \PYG{n}{default} \PYG{n}{use} \PYG{n}{of} \PYG{n}{symbolic} \PYG{n}{links} \PYG{k}{for} \PYG{n}{test} \PYG{n}{files}\PYG{o}{.} \PYG{n}{Useful}
                          \PYG{k}{if} \PYG{n}{the} \PYG{n}{build} \PYG{o+ow}{is} \PYG{n}{on} \PYG{n}{a} \PYG{n}{separate} \PYG{n}{filesystem} \PYG{k+kn}{from} \PYG{n+nn}{the} \PYG{n}{source}\PYG{p}{,} \PYG{k}{as}
                          \PYG{n}{required} \PYG{n}{on} \PYG{n}{some} \PYG{n}{HPC} \PYG{n}{systems}\PYG{o}{.}
\PYG{n}{QMC\PYGZus{}VERBOSE\PYGZus{}CONFIGURATION} \PYG{n}{Print} \PYG{n}{additional} \PYG{n}{information} \PYG{n}{during} \PYG{n}{cmake} \PYG{n}{configuration}
                          \PYG{n}{including} \PYG{n}{details} \PYG{n}{of} \PYG{n}{which} \PYG{n}{tests} \PYG{n}{are} \PYG{n}{enabled}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
Intel MKL related

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ENABLE\PYGZus{}MKL}          \PYG{n}{Enable} \PYG{n}{Intel} \PYG{n}{MKL} \PYG{n}{libraries} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{yes} \PYG{p}{(}\PYG{n}{default} \PYG{k}{for} \PYG{n}{intel} \PYG{n}{compiler}\PYG{p}{)}\PYG{p}{,}
                                              \PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{no} \PYG{p}{(}\PYG{n}{default} \PYG{n}{otherwise}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{MKL\PYGZus{}ROOT}            \PYG{n}{Path} \PYG{n}{to} \PYG{n}{MKL} \PYG{n}{libraries} \PYG{p}{(}\PYG{n}{only} \PYG{n}{necessary} \PYG{k}{for} \PYG{n}{non} \PYG{n}{intel} \PYG{n}{compilers}
                    \PYG{o+ow}{or} \PYG{n}{intel} \PYG{n}{without} \PYG{n}{standard} \PYG{n}{environment} \PYG{n}{variables}\PYG{o}{.}\PYG{p}{)}
                    \PYG{n}{One} \PYG{n}{of} \PYG{n}{the} \PYG{n}{above} \PYG{n}{environment} \PYG{n}{variables} \PYG{n}{can} \PYG{n}{be} \PYG{n}{used}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
libxml2 related

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{LIBXML2\PYGZus{}INCLUDE\PYGZus{}DIR}   \PYG{n}{Include} \PYG{n}{directory} \PYG{k}{for} \PYG{n}{libxml2}

\PYG{n}{LIBXML2\PYGZus{}LIBRARY}       \PYG{n}{Libxml2} \PYG{n}{library}
\end{sphinxVerbatim}

\item {} 
HDF5 related

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{HDF5\PYGZus{}PREFER\PYGZus{}PARALLEL} \PYG{l+m+mi}{1}\PYG{p}{(}\PYG{n}{default} \PYG{k}{for} \PYG{n}{MPI} \PYG{n}{build}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{enables}\PYG{o}{/}\PYG{n}{disable} \PYG{n}{parallel} \PYG{n}{HDF5} \PYG{n}{library} \PYG{n}{searching}\PYG{o}{.}
\PYG{n}{ENABLE\PYGZus{}PHDF5}         \PYG{l+m+mi}{1}\PYG{p}{(}\PYG{n}{default} \PYG{k}{for} \PYG{n}{parallel} \PYG{n}{HDF5} \PYG{n}{library}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{enables}\PYG{o}{/}\PYG{n}{disable} \PYG{n}{parallel} \PYG{n}{collective} \PYG{n}{I}\PYG{o}{/}\PYG{n}{O}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
FFTW related

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{FFTW\PYGZus{}INCLUDE\PYGZus{}DIRS}   \PYG{n}{Specify} \PYG{n}{include} \PYG{n}{directories} \PYG{k}{for} \PYG{n}{FFTW}
\PYG{n}{FFTW\PYGZus{}LIBRARY\PYGZus{}DIRS}   \PYG{n}{Specify} \PYG{n}{library} \PYG{n}{directories} \PYG{k}{for} \PYG{n}{FFTW}
\end{sphinxVerbatim}

\item {} 
CTest related

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MPIEXEC\PYGZus{}EXECUTABLE}     \PYG{n}{Specify} \PYG{n}{the} \PYG{n}{mpi} \PYG{n}{wrapper}\PYG{p}{,} \PYG{n}{e}\PYG{o}{.}\PYG{n}{g}\PYG{o}{.} \PYG{n}{srun}\PYG{p}{,} \PYG{n}{aprun}\PYG{p}{,} \PYG{n}{mpirun}\PYG{p}{,} \PYG{n}{etc}\PYG{o}{.}
\PYG{n}{MPIEXEC\PYGZus{}NUMPROC\PYGZus{}FLAG}   \PYG{n}{Specify} \PYG{n}{the} \PYG{n}{number} \PYG{n}{of} \PYG{n}{mpi} \PYG{n}{processes} \PYG{n}{flag}\PYG{p}{,}
                       \PYG{n}{e}\PYG{o}{.}\PYG{n}{g}\PYG{o}{.} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}np}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{etc}\PYG{o}{.}
\PYG{n}{MPIEXEC\PYGZus{}PREFLAGS}       \PYG{n}{Flags} \PYG{n}{to} \PYG{k}{pass} \PYG{n}{to} \PYG{n}{MPIEXEC\PYGZus{}EXECUTABLE} \PYG{n}{directly} \PYG{n}{before} \PYG{n}{the} \PYG{n}{executable} \PYG{n}{to} \PYG{n}{run}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
LLVM/Clang Developer Options

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{LLVM\PYGZus{}SANITIZE\PYGZus{}ADDRES}  \PYG{n}{link} \PYG{k}{with} \PYG{n}{the} \PYG{n}{Clang} \PYG{n}{address} \PYG{n}{sanitizer} \PYG{n}{library}
\PYG{n}{LLVM\PYGZus{}SANITIZE\PYGZus{}MEMORY}  \PYG{n}{link} \PYG{k}{with} \PYG{n}{the} \PYG{n}{Clang} \PYG{n}{memory} \PYG{n}{sanitizer} \PYG{n}{library}
\end{sphinxVerbatim}

\end{itemize}

\sphinxhref{https://clang.llvm.org/docs/AddressSanitizer.html}{Clang address sanitizer library}

\sphinxhref{https://clang.llvm.org/docs/MemorySanitizer.html}{Clang memory sanitizer library}

See {\hyperref[\detokenize{external_tools:llvm-sanitizer-libraries}]{\sphinxcrossref{\DUrole{std,std-ref}{LLVM Sanitizer Libraries}}}} for more information.


\subsection{Installation from CMake}
\label{\detokenize{installation:installation-from-cmake}}
Installation is optional. The QMCPACK executable can be run from the \sphinxcode{\sphinxupquote{bin}} directory in the build location.
If the install step is desired, run the \sphinxcode{\sphinxupquote{make install}} command to install the QMCPACK executable, the converter,
and some additional executables.
Also installed is the \sphinxcode{\sphinxupquote{qmcpack.settings}} file that records options used to compile QMCPACK.
Specify the \sphinxcode{\sphinxupquote{CMAKE\_INSTALL\_PREFIX}} CMake variable during configuration to set the install location.


\subsection{Role of QMC\_DATA}
\label{\detokenize{installation:role-of-qmc-data}}
QMCPACK includes a variety of optional performance and integration
tests that use research quality wavefunctions to obtain meaningful
performance and to more thoroughly test the code. The necessarily
large input files are stored in the location pointed to by QMC\_DATA (e.g., scratch or long\sphinxhyphen{}lived project space on a supercomputer). These
files are not included in the source code distribution to minimize
size. The tests are activated if CMake detects the files when
configured. See tests/performance/NiO/README,
tests/solids/NiO\_afqmc/README, tests/performance/C\sphinxhyphen{}graphite/README, and tests/performance/C\sphinxhyphen{}molecule/README
for details of the current tests and input files and to download them.

Currently the files must be downloaded via \sphinxurl{https://anl.box.com/s/yxz1ic4kxtdtgpva5hcmlom9ixfl3v3c}.

The layout of current complete set of files is given below. If a file is missing, the appropriate performance test is skipped.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{C}\PYG{o}{\PYGZhy{}}\PYG{n}{graphite}\PYG{o}{/}\PYG{n}{lda}\PYG{o}{.}\PYG{n}{pwscf}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{C}\PYG{o}{\PYGZhy{}}\PYG{n}{molecule}\PYG{o}{/}\PYG{n}{C12}\PYG{o}{\PYGZhy{}}\PYG{n}{e48}\PYG{o}{\PYGZhy{}}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{C}\PYG{o}{\PYGZhy{}}\PYG{n}{molecule}\PYG{o}{/}\PYG{n}{C12}\PYG{o}{\PYGZhy{}}\PYG{n}{e72}\PYG{o}{\PYGZhy{}}\PYG{n}{ae}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{C}\PYG{o}{\PYGZhy{}}\PYG{n}{molecule}\PYG{o}{/}\PYG{n}{C18}\PYG{o}{\PYGZhy{}}\PYG{n}{e108}\PYG{o}{\PYGZhy{}}\PYG{n}{ae}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{C}\PYG{o}{\PYGZhy{}}\PYG{n}{molecule}\PYG{o}{/}\PYG{n}{C18}\PYG{o}{\PYGZhy{}}\PYG{n}{e72}\PYG{o}{\PYGZhy{}}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{C}\PYG{o}{\PYGZhy{}}\PYG{n}{molecule}\PYG{o}{/}\PYG{n}{C24}\PYG{o}{\PYGZhy{}}\PYG{n}{e144}\PYG{o}{\PYGZhy{}}\PYG{n}{ae}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{C}\PYG{o}{\PYGZhy{}}\PYG{n}{molecule}\PYG{o}{/}\PYG{n}{C24}\PYG{o}{\PYGZhy{}}\PYG{n}{e96}\PYG{o}{\PYGZhy{}}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{C}\PYG{o}{\PYGZhy{}}\PYG{n}{molecule}\PYG{o}{/}\PYG{n}{C30}\PYG{o}{\PYGZhy{}}\PYG{n}{e120}\PYG{o}{\PYGZhy{}}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{C}\PYG{o}{\PYGZhy{}}\PYG{n}{molecule}\PYG{o}{/}\PYG{n}{C30}\PYG{o}{\PYGZhy{}}\PYG{n}{e180}\PYG{o}{\PYGZhy{}}\PYG{n}{ae}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{C}\PYG{o}{\PYGZhy{}}\PYG{n}{molecule}\PYG{o}{/}\PYG{n}{C60}\PYG{o}{\PYGZhy{}}\PYG{n}{e240}\PYG{o}{\PYGZhy{}}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{\PYGZhy{}}\PYG{n}{fcc}\PYG{o}{\PYGZhy{}}\PYG{n}{supertwist111}\PYG{o}{\PYGZhy{}}\PYG{n}{supershift000}\PYG{o}{\PYGZhy{}}\PYG{n}{S1}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{\PYGZhy{}}\PYG{n}{fcc}\PYG{o}{\PYGZhy{}}\PYG{n}{supertwist111}\PYG{o}{\PYGZhy{}}\PYG{n}{supershift000}\PYG{o}{\PYGZhy{}}\PYG{n}{S2}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{\PYGZhy{}}\PYG{n}{fcc}\PYG{o}{\PYGZhy{}}\PYG{n}{supertwist111}\PYG{o}{\PYGZhy{}}\PYG{n}{supershift000}\PYG{o}{\PYGZhy{}}\PYG{n}{S4}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{\PYGZhy{}}\PYG{n}{fcc}\PYG{o}{\PYGZhy{}}\PYG{n}{supertwist111}\PYG{o}{\PYGZhy{}}\PYG{n}{supershift000}\PYG{o}{\PYGZhy{}}\PYG{n}{S8}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{\PYGZhy{}}\PYG{n}{fcc}\PYG{o}{\PYGZhy{}}\PYG{n}{supertwist111}\PYG{o}{\PYGZhy{}}\PYG{n}{supershift000}\PYG{o}{\PYGZhy{}}\PYG{n}{S16}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{\PYGZhy{}}\PYG{n}{fcc}\PYG{o}{\PYGZhy{}}\PYG{n}{supertwist111}\PYG{o}{\PYGZhy{}}\PYG{n}{supershift000}\PYG{o}{\PYGZhy{}}\PYG{n}{S32}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{\PYGZhy{}}\PYG{n}{fcc}\PYG{o}{\PYGZhy{}}\PYG{n}{supertwist111}\PYG{o}{\PYGZhy{}}\PYG{n}{supershift000}\PYG{o}{\PYGZhy{}}\PYG{n}{S64}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{\PYGZhy{}}\PYG{n}{fcc}\PYG{o}{\PYGZhy{}}\PYG{n}{supertwist111}\PYG{o}{\PYGZhy{}}\PYG{n}{supershift000}\PYG{o}{\PYGZhy{}}\PYG{n}{S128}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{\PYGZhy{}}\PYG{n}{fcc}\PYG{o}{\PYGZhy{}}\PYG{n}{supertwist111}\PYG{o}{\PYGZhy{}}\PYG{n}{supershift000}\PYG{o}{\PYGZhy{}}\PYG{n}{S256}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO\PYGZus{}afm\PYGZus{}fcidump}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO\PYGZus{}afm\PYGZus{}wfn}\PYG{o}{.}\PYG{n}{dat}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO\PYGZus{}nm\PYGZus{}choldump}\PYG{o}{.}\PYG{n}{h5}
\end{sphinxVerbatim}


\subsection{Configure and build using CMake and make}
\label{\detokenize{installation:configure-and-build-using-cmake-and-make}}
To configure and build QMCPACK, move to build directory, run CMake, and make

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{build}
\PYG{n}{cmake} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{l+m+mi}{8}
\end{sphinxVerbatim}

As you will have gathered, CMake encourages “out of source” builds,
where all the files for a specific build configuration reside in their
own directory separate from the source files. This allows multiple
builds to be created from the same source files, which is very useful
when the file system is shared between different systems. You can also
build versions with different settings (e.g., QMC\_COMPLEX) and
different compiler settings. The build directory does not have to be
called build—use something descriptive such as build\_machinename or
build\_complex. The “..” in the CMake line refers to the directory
containing CMakeLists.txt. Update the “..” for other build
directory locations.


\subsection{Example configure and build}
\label{\detokenize{installation:example-configure-and-build}}\begin{itemize}
\item {} 
Set the environments (the examples below assume bash, Intel compilers, and MKL library)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{export} \PYG{n}{CXX}\PYG{o}{=}\PYG{n}{icpc}
\PYG{n}{export} \PYG{n}{CC}\PYG{o}{=}\PYG{n}{icc}
\PYG{n}{export} \PYG{n}{MKL\PYGZus{}ROOT}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{n}{mkl}\PYG{o}{/}\PYG{l+m+mf}{10.0}\PYG{o}{.}\PYG{l+m+mf}{3.020}
\PYG{n}{export} \PYG{n}{HDF5\PYGZus{}ROOT}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}
\PYG{n}{export} \PYG{n}{BOOST\PYGZus{}ROOT}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n}{boost}
\PYG{n}{export} \PYG{n}{FFTW\PYGZus{}HOME}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n}{fftw}
\end{sphinxVerbatim}

\item {} 
Move to build directory, run CMake, and make

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{build}
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{n}{CMAKE\PYGZus{}BUILD\PYGZus{}TYPE}\PYG{o}{=}\PYG{n}{Release} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{l+m+mi}{8}
\end{sphinxVerbatim}

\end{itemize}


\subsection{Build scripts}
\label{\detokenize{installation:build-scripts}}
We recommended creating a helper script that contains the
configure line for CMake.  This is particularly useful when avoiding
environment variables, packages are installed in custom locations,
or the configure line is long or complex.  In this case it is also
recommended to add “rm \sphinxhyphen{}rf CMake*” before the configure line to remove
existing CMake configure files to ensure a fresh configure each time
the script is called. Deleting all the files in the build
directory is also acceptable. If you do so we recommend adding some sanity
checks in case the script is run from the wrong directory (e.g.,
checking for the existence of some QMCPACK files).

Some build script examples for different systems are given in the
config directory. For example, on Cray systems these scripts might
load the appropriate modules to set the appropriate programming
environment, specific library versions, etc.

An example script build.sh is given below. It is much more complex
than usually needed for comprehensiveness:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{export} \PYG{n}{CXX}\PYG{o}{=}\PYG{n}{mpic}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{export} \PYG{n}{CC}\PYG{o}{=}\PYG{n}{mpicc}
\PYG{n}{export} \PYG{n}{ACML\PYGZus{}HOME}\PYG{o}{=}\PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{acml}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.3}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{gfortran64}
\PYG{n}{export} \PYG{n}{HDF5\PYGZus{}ROOT}\PYG{o}{=}\PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{hdf5}
\PYG{n}{export} \PYG{n}{BOOST\PYGZus{}ROOT}\PYG{o}{=}\PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{boost}

\PYG{n}{rm} \PYG{o}{\PYGZhy{}}\PYG{n}{rf} \PYG{n}{CMake}\PYG{o}{*}

\PYG{n}{cmake}                                                \PYGZbs{}
  \PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{n}{CMAKE\PYGZus{}BUILD\PYGZus{}TYPE}\PYG{o}{=}\PYG{n}{Debug}                         \PYGZbs{}
  \PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{n}{LIBXML2\PYGZus{}INCLUDE\PYGZus{}DIR}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{include}\PYG{o}{/}\PYG{n}{libxml2}      \PYGZbs{}
  \PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{n}{LIBXML2\PYGZus{}LIBRARY}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{lib}\PYG{o}{/}\PYG{n}{x86\PYGZus{}64}\PYG{o}{\PYGZhy{}}\PYG{n}{linux}\PYG{o}{\PYGZhy{}}\PYG{n}{gnu}\PYG{o}{/}\PYG{n}{libxml2}\PYG{o}{.}\PYG{n}{so} \PYGZbs{}
  \PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{n}{FFTW\PYGZus{}INCLUDE\PYGZus{}DIRS}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{include}                 \PYGZbs{}
  \PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{n}{FFTW\PYGZus{}LIBRARY\PYGZus{}DIRS}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{lib}\PYG{o}{/}\PYG{n}{x86\PYGZus{}64}\PYG{o}{\PYGZhy{}}\PYG{n}{linux}\PYG{o}{\PYGZhy{}}\PYG{n}{gnu}    \PYGZbs{}
  \PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{n}{QMC\PYGZus{}EXTRA\PYGZus{}LIBS}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}ldl \PYGZdl{}}\PYG{l+s+si}{\PYGZob{}ACML\PYGZus{}HOME\PYGZcb{}}\PYG{l+s+s2}{/lib/libacml.a \PYGZhy{}lgfortran}\PYG{l+s+s2}{\PYGZdq{}} \PYGZbs{}
  \PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{=}\PYG{o}{/}\PYG{n}{projects}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZhy{}}\PYG{n}{data}            \PYGZbs{}
  \PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}


\subsection{Using vendor\sphinxhyphen{}optimized numerical libraries (e.g., Intel MKL)}
\label{\detokenize{installation:using-vendor-optimized-numerical-libraries-e-g-intel-mkl}}
Although QMC does not make extensive use of linear algebra, use of
vendor\sphinxhyphen{}optimized libraries is strongly recommended for highest
performance. BLAS routines are used in the Slater determinant update, the VMC wavefunction optimizer,
and to apply orbital coefficients in local basis calculations. Vectorized
math functions are also beneficial (e.g., for the phase factor
computation in solid\sphinxhyphen{}state calculations). CMake is generally successful
in finding these libraries, but specific combinations can require
additional hints, as described in the following:


\subsubsection{Using Intel MKL with non\sphinxhyphen{}Intel compilers}
\label{\detokenize{installation:using-intel-mkl-with-non-intel-compilers}}
To use Intel MKL with, e.g. an MPICH wrapped gcc:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cmake \PYGZbs{}
  \PYGZhy{}DCMAKE\PYGZus{}C\PYGZus{}COMPILER=mpicc \PYGZhy{}DCMAKE\PYGZus{}CXX\PYGZus{}COMPILER=mpicxx \PYGZbs{}
  \PYGZhy{}DENABLE\PYGZus{}MKL=1 \PYGZhy{}DMKL\PYGZus{}ROOT=\PYGZdl{}MKLROOT/lib \PYGZbs{}
  ..
\end{sphinxVerbatim}

MKLROOT is the directory containing the MKL binary, examples, and lib
directories (etc.) and is often /opt/intel/mkl.


\subsubsection{Serial or multithreaded library}
\label{\detokenize{installation:serial-or-multithreaded-library}}\label{\detokenize{installation:threadedlibrary}}
Vendors might provide both serial and multithreaded versions of their libraries.
Using the right version is critical to QMCPACK performance.
QMCPACK makes calls from both inside and outside threaded regions.
When being called from outside an OpenMP parallel region, the multithreaded version is preferred for the possibility of using all the available cores.
When being called from every thread inside an OpenMP parallel region, the serial version is preferred for not oversubscribing the cores.
Fortunately, nowadays the multithreaded versions of many vendor libraries (MKL, ESSL) are OpenMP aware.
They use only one thread when being called inside an OpenMP parallel region.
This behavior meets exactly both QMCPACK needs and thus is preferred.
If the multithreaded version does not provide this feature of dynamically adjusting the number of threads,
the serial version is preferred. In addition, thread safety is required no matter which version is used.


\subsection{Cross compiling}
\label{\detokenize{installation:cross-compiling}}
Cross compiling is often difficult but is required on supercomputers
with distinct host and compute processor generations or architectures.
QMCPACK tried to do its best with CMake to facilitate cross compiling.
\begin{itemize}
\item {} 
On a machine using a Cray programming environment, we rely on
compiler wrappers provided by Cray to correctly set architecture\sphinxhyphen{}specific
flags. Please also add \sphinxcode{\sphinxupquote{\sphinxhyphen{}DCMAKE\_SYSTEM\_NAME=CrayLinuxEnvironment}} to cmake.
The CMake configure log should indicate that a Cray machine was detected.

\item {} 
If not on a Cray machine, by default we assume building for
the host architecture (e.g., \sphinxhyphen{}xHost is added for the Intel compiler
and \sphinxhyphen{}march=native is added for GNU/Clang compilers).

\item {} 
If \sphinxhyphen{}x/\sphinxhyphen{}ax or \sphinxhyphen{}march is specified by the user in CMAKE\_C\_FLAGS and CMAKE\_CXX\_FLAGS,
we respect the user’s intention and do not add any architecture\sphinxhyphen{}specific flags.

\end{itemize}

The general strategy for cross compiling should therefore be to
manually set CMAKE\_C\_FLAGS and CMAKE\_CXX\_FLAGS for the target
architecture. Using \sphinxcode{\sphinxupquote{make VERBOSE=1}} is a useful way to check the
final compilation options.  If on a Cray machine, selection of the
appropriate programming environment should be sufficient.


\section{Installation instructions for common workstations and supercomputers}
\label{\detokenize{installation:installation-instructions-for-common-workstations-and-supercomputers}}\label{\detokenize{installation:installexamples}}
This section describes how to build QMCPACK on various common systems
including multiple Linux distributions, Apple OS X, and various
supercomputers. The examples should serve as good starting points for
building QMCPACK on similar machines. For example, the software
environment on modern Crays is very consistent. Note that updates to
operating systems and system software might require small modifications
to these recipes. See {\hyperref[\detokenize{installation:buildperformance}]{\sphinxcrossref{\DUrole{std,std-ref}{How to build the fastest executable version of QMCPACK}}}} for key
points to check to obtain highest performance and
{\hyperref[\detokenize{installation:troubleshoot}]{\sphinxcrossref{\DUrole{std,std-ref}{Troubleshooting the installation}}}} for troubleshooting hints.


\subsection{Installing on Ubuntu Linux or other apt\sphinxhyphen{}get\textendash{}based distributions}
\label{\detokenize{installation:installing-on-ubuntu-linux-or-other-apt-get-based-distributions}}\label{\detokenize{installation:buildubuntu}}
The following is designed to obtain a working QMCPACK build on, for example, a
student laptop, starting from a basic Linux installation with none of
the developer tools installed. Fortunately, all the required packages
are available in the default repositories making for a quick
installation. Note that for convenience we use a generic BLAS. For
production, a platform\sphinxhyphen{}optimized BLAS should be used.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{cmake} \PYG{n}{g}\PYG{o}{+}\PYG{o}{+} \PYG{n}{openmpi}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{bin} \PYG{n}{libopenmpi}\PYG{o}{\PYGZhy{}}\PYG{n}{dev} \PYG{n}{libboost}\PYG{o}{\PYGZhy{}}\PYG{n}{dev}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{libatlas}\PYG{o}{\PYGZhy{}}\PYG{n}{base}\PYG{o}{\PYGZhy{}}\PYG{n}{dev} \PYG{n}{liblapack}\PYG{o}{\PYGZhy{}}\PYG{n}{dev} \PYG{n}{libhdf5}\PYG{o}{\PYGZhy{}}\PYG{n}{dev} \PYG{n}{libxml2}\PYG{o}{\PYGZhy{}}\PYG{n}{dev} \PYG{n}{fftw3}\PYG{o}{\PYGZhy{}}\PYG{n}{dev}
\PYG{n}{export} \PYG{n}{CXX}\PYG{o}{=}\PYG{n}{mpiCC}
\PYG{n}{cd} \PYG{n}{build}
\PYG{n}{cmake} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{l+m+mi}{8}
\PYG{n}{ls} \PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{qmcpack}
\end{sphinxVerbatim}

For qmca and other tools to function, we install some Python libraries:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{python}\PYG{o}{\PYGZhy{}}\PYG{n}{numpy} \PYG{n}{python}\PYG{o}{\PYGZhy{}}\PYG{n}{matplotlib}
\end{sphinxVerbatim}


\subsection{Installing on CentOS Linux or other yum\sphinxhyphen{}based distributions}
\label{\detokenize{installation:installing-on-centos-linux-or-other-yum-based-distributions}}
The following is designed to obtain a working QMCPACK build on, for example, a
student laptop, starting from a basic Linux installation with none of
the developer tools installed. CentOS 7 (Red Hat compatible) is using
gcc 4.8.2. The installation is complicated only by the need to install
another repository to obtain HDF5 packages that are not available by
default. Note that for convenience we use a generic BLAS. For
production, a platform\sphinxhyphen{}optimized BLAS should be used.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{yum} \PYG{n}{install} \PYG{n}{make} \PYG{n}{cmake} \PYG{n}{gcc} \PYG{n}{gcc}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{+}\PYG{o}{+} \PYG{n}{openmpi} \PYG{n}{openmpi}\PYG{o}{\PYGZhy{}}\PYG{n}{devel} \PYG{n}{fftw} \PYG{n}{fftw}\PYG{o}{\PYGZhy{}}\PYG{n}{devel} \PYGZbs{}
                  \PYG{n}{boost} \PYG{n}{boost}\PYG{o}{\PYGZhy{}}\PYG{n}{devel} \PYG{n}{libxml2} \PYG{n}{libxml2}\PYG{o}{\PYGZhy{}}\PYG{n}{devel}
\PYG{n}{sudo} \PYG{n}{yum} \PYG{n}{install} \PYG{n}{blas}\PYG{o}{\PYGZhy{}}\PYG{n}{devel} \PYG{n}{lapack}\PYG{o}{\PYGZhy{}}\PYG{n}{devel} \PYG{n}{atlas}\PYG{o}{\PYGZhy{}}\PYG{n}{devel}
\PYG{n}{module} \PYG{n}{load} \PYG{n}{mpi}
\end{sphinxVerbatim}

To set up repoforge as a source for the HDF5 package, go to
\sphinxurl{http://repoforge.org/use}. Install the appropriate up\sphinxhyphen{}to\sphinxhyphen{}date
release package for your operating system. By default, CentOS Firefox will offer
to run the installer. The CentOS 6.5 settings were still usable for HDF5 on
CentOS 7 in 2016, but use CentOS 7 versions when they become
available.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{yum} \PYG{n}{install} \PYG{n}{hdf5} \PYG{n}{hdf5}\PYG{o}{\PYGZhy{}}\PYG{n}{devel}
\end{sphinxVerbatim}

To build QMCPACK:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{module} \PYG{n}{load} \PYG{n}{mpi}\PYG{o}{/}\PYG{n}{openmpi}\PYG{o}{\PYGZhy{}}\PYG{n}{x86\PYGZus{}64}
\PYG{n}{which} \PYG{n}{mpirun}
\PYG{c+c1}{\PYGZsh{} Sanity check; should print something like   /usr/lib64/openmpi/bin/mpirun}
\PYG{n}{export} \PYG{n}{CXX}\PYG{o}{=}\PYG{n}{mpiCC}
\PYG{n}{cd} \PYG{n}{build}
\PYG{n}{cmake} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{l+m+mi}{8}
\PYG{n}{ls} \PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{qmcpack}
\end{sphinxVerbatim}


\subsection{Installing on Mac OS X using Macports}
\label{\detokenize{installation:installing-on-mac-os-x-using-macports}}
These instructions assume a fresh installation of macports
and use the gcc 6.1 compiler. Older versions are fine, but it is vital to ensure that
matching compilers and libraries are used for all
packages and to force use of what is installed in /opt/local.  Performance should be very reasonable.
Note that we use the Apple\sphinxhyphen{}provided Accelerate framework for
optimized BLAS.

Follow the Macports install instructions at \sphinxurl{https://www.macports.org/}.
\begin{itemize}
\item {} 
Install Xcode and the Xcode Command Line Tools.

\item {} 
Agree to Xcode license in Terminal: sudo xcodebuild \sphinxhyphen{}license.

\item {} 
Install MacPorts for your version of OS X.

\end{itemize}

Install the required tools:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{port} \PYG{n}{install} \PYG{n}{gcc6}
\PYG{n}{sudo} \PYG{n}{port} \PYG{n}{select} \PYG{n}{gcc} \PYG{n}{mp}\PYG{o}{\PYGZhy{}}\PYG{n}{gcc6}
\PYG{n}{sudo} \PYG{n}{port} \PYG{n}{install} \PYG{n}{openmpi}\PYG{o}{\PYGZhy{}}\PYG{n}{devel}\PYG{o}{\PYGZhy{}}\PYG{n}{gcc6}
\PYG{n}{sudo} \PYG{n}{port} \PYG{n}{select} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set} \PYG{n}{mpi} \PYG{n}{openmpi}\PYG{o}{\PYGZhy{}}\PYG{n}{devel}\PYG{o}{\PYGZhy{}}\PYG{n}{gcc61}\PYG{o}{\PYGZhy{}}\PYG{n}{fortran}

\PYG{n}{sudo} \PYG{n}{port} \PYG{n}{install} \PYG{n}{fftw}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{o}{+}\PYG{n}{gcc6}
\PYG{n}{sudo} \PYG{n}{port} \PYG{n}{install} \PYG{n}{libxml2}
\PYG{n}{sudo} \PYG{n}{port} \PYG{n}{install} \PYG{n}{cmake}
\PYG{n}{sudo} \PYG{n}{post} \PYG{n}{install} \PYG{n}{boost} \PYG{o}{+}\PYG{n}{gcc6}
\PYG{n}{sudo} \PYG{n}{port} \PYG{n}{install} \PYG{n}{hdf5} \PYG{o}{+}\PYG{n}{gcc6}

\PYG{n}{sudo} \PYG{n}{port} \PYG{n}{select} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set} \PYG{n}{python} \PYG{n}{python27}
\PYG{n}{sudo} \PYG{n}{port} \PYG{n}{install} \PYG{n}{py27}\PYG{o}{\PYGZhy{}}\PYG{n}{numpy} \PYG{o}{+}\PYG{n}{gcc6}
\PYG{n}{sudo} \PYG{n}{port} \PYG{n}{install} \PYG{n}{py27}\PYG{o}{\PYGZhy{}}\PYG{n}{matplotlib}  \PYG{c+c1}{\PYGZsh{}For graphical plots with qmca}
\end{sphinxVerbatim}

QMCPACK build:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{build}
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}C\PYGZus{}COMPILER}\PYG{o}{=}\PYG{n}{mpicc} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}CXX\PYGZus{}COMPILER}\PYG{o}{=}\PYG{n}{mpiCXX} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{l+m+mi}{6} \PYG{c+c1}{\PYGZsh{} Adjust for available core count}
\PYG{n}{ls} \PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{qmcpack}
\end{sphinxVerbatim}

Cmake should pickup the versions of HDF5 and libxml (etc.) installed in
/opt/local by macports. If you have other copies of these libraries
installed and wish to force use of a specific version, use the
environment variables detailed in {\hyperref[\detokenize{installation:envvar}]{\sphinxcrossref{\DUrole{std,std-ref}{Environment variables}}}}.

This recipe was verified on July 1, 2016, on a Mac running OS X 10.11.5
“El Capitain.”


\subsection{Installing on Mac OS X using Homebrew (brew)}
\label{\detokenize{installation:installing-on-mac-os-x-using-homebrew-brew}}
Homebrew is a package manager for OS X that provides a convenient
route to install all the QMCPACK dependencies. The
following recipe will install the latest available versions of each
package. This was successfully tested under OS X 10.12 “Sierra” in December 2017. Note that it is necessary to build the MPI software from
source to use the brew\sphinxhyphen{}provided gcc instead of Apple CLANG.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Install Homebrew from \sphinxurl{http://brew.sh/}:

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{ruby} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}(curl \PYGZhy{}fsSL}
  \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{raw}\PYG{o}{.}\PYG{n}{githubusercontent}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{Homebrew}\PYG{o}{/}\PYG{n}{install}\PYG{o}{/}\PYG{n}{master}\PYG{o}{/}\PYG{n}{install}\PYG{p}{)}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Install the prerequisites:

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{brew} \PYG{n}{install} \PYG{n}{gcc} \PYG{c+c1}{\PYGZsh{} installs gcc 7.2.0 on 2017\PYGZhy{}12\PYGZhy{}19}
\PYG{n}{export} \PYG{n}{HOMEBREW\PYGZus{}CXX}\PYG{o}{=}\PYG{n}{g}\PYG{o}{+}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7}
\PYG{n}{export} \PYG{n}{HOMEBREW\PYGZus{}CC}\PYG{o}{=}\PYG{n}{gcc}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7}
\PYG{n}{brew} \PYG{n}{install} \PYG{n}{mpich2} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{build}\PYG{o}{\PYGZhy{}}\PYG{n}{from}\PYG{o}{\PYGZhy{}}\PYG{n}{source}
\PYG{c+c1}{\PYGZsh{} Build from source required to use homebrew compiled compilers as}
\PYG{c+c1}{\PYGZsh{} opposed to Apple CLANG. Check \PYGZdq{}mpicc \PYGZhy{}v\PYGZdq{} indicates Homebrew gcc}
\PYG{n}{brew} \PYG{n}{install} \PYG{n}{cmake}
\PYG{n}{brew} \PYG{n}{install} \PYG{n}{fftw}
\PYG{n}{brew} \PYG{n}{install} \PYG{n}{boost}
\PYG{n}{brew} \PYG{n}{install} \PYG{n}{homebrew}\PYG{o}{/}\PYG{n}{science}\PYG{o}{/}\PYG{n}{hdf5}
\PYG{c+c1}{\PYGZsh{}Note: Libxml2 is not required via brew since OS X already includes it.}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Configure and build QMCPACK:

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}C\PYGZus{}COMPILER}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{mpicc} \PYGZbs{}
      \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}CXX\PYGZus{}COMPILER}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{mpicxx} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{l+m+mi}{12}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Run the short tests. When MPICH is used for the first time, OSX will request approval of the network connection for each executable.

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ctest} \PYG{o}{\PYGZhy{}}\PYG{n}{R} \PYG{n}{short} \PYG{o}{\PYGZhy{}}\PYG{n}{LE} \PYG{n}{unstable}
\end{sphinxVerbatim}
\end{quote}


\subsection{Installing on ALCF Theta, Cray XC40}
\label{\detokenize{installation:installing-on-alcf-theta-cray-xc40}}
Theta is a 9.65 petaflops system manufactured by Cray with 3,624 compute nodes.
Each node features a second\sphinxhyphen{}generation Intel Xeon Phi 7230 processor and 192 GB DDR4 RAM.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{export} \PYG{n}{CRAYPE\PYGZus{}LINK\PYGZus{}TYPE}\PYG{o}{=}\PYG{n}{dynamic}
\PYG{n}{module} \PYG{n}{load} \PYG{n}{cmake}\PYG{o}{/}\PYG{l+m+mf}{3.16}\PYG{o}{.}\PYG{l+m+mi}{2}
\PYG{n}{module} \PYG{n}{unload} \PYG{n}{cray}\PYG{o}{\PYGZhy{}}\PYG{n}{libsci}
\PYG{n}{module} \PYG{n}{load} \PYG{n}{cray}\PYG{o}{\PYGZhy{}}\PYG{n}{hdf5}\PYG{o}{\PYGZhy{}}\PYG{n}{parallel}
\PYG{n}{module} \PYG{n}{load} \PYG{n}{gcc}   \PYG{c+c1}{\PYGZsh{} Make C++ 14 standard library available to the Intel compiler}
\PYG{n}{export} \PYG{n}{BOOST\PYGZus{}ROOT}\PYG{o}{=}\PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{libraries}\PYG{o}{/}\PYG{n}{boost}\PYG{o}{/}\PYG{l+m+mf}{1.64}\PYG{o}{.}\PYG{l+m+mi}{0}\PYG{o}{/}\PYG{n}{intel}
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}SYSTEM\PYGZus{}NAME}\PYG{o}{=}\PYG{n}{CrayLinuxEnvironment} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{l+m+mi}{24}
\PYG{n}{ls} \PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{qmcpack}
\end{sphinxVerbatim}


\subsection{Installing on ORNL OLCF Summit}
\label{\detokenize{installation:installing-on-ornl-olcf-summit}}
Summit is an IBM system at the ORNL OLCF built with IBM Power System AC922
nodes. They have two IBM Power 9 processors and six NVIDIA Volta V100
accelerators.


\subsubsection{Building QMCPACK}
\label{\detokenize{installation:building-qmcpack}}
Note that these build instructions are preliminary as the
software environment is subject to change. As of December 2018, the
IBM XL compiler does not support C++14, so we currently use the
gnu compiler.

For ease of reproducibility we provide build scripts for Summit.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{qmcpack}
\PYG{o}{.}\PYG{o}{/}\PYG{n}{config}\PYG{o}{/}\PYG{n}{build\PYGZus{}olcf\PYGZus{}summit}\PYG{o}{.}\PYG{n}{sh}
\PYG{n}{ls} \PYG{n+nb}{bin}
\end{sphinxVerbatim}


\subsubsection{Building Quantum Espresso}
\label{\detokenize{installation:building-quantum-espresso}}
We provide a build script for the v6.4.1 release of Quantum Espresso (QE).
The following can be used to build a CPU version of QE on Summit,
placing the script in the external\_codes/quantum\_espresso directory.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{external\PYGZus{}codes}\PYG{o}{/}\PYG{n}{quantum\PYGZus{}espresso}
\PYG{o}{.}\PYG{o}{/}\PYG{n}{build\PYGZus{}qe\PYGZus{}olcf\PYGZus{}summit}\PYG{o}{.}\PYG{n}{sh}
\end{sphinxVerbatim}

Note that performance is
not yet optimized although vendor libraries are
used. Alternatively, the wavefunction files can be generated on
another system and the converted HDF5 files copied over.


\subsection{Installing on NERSC Cori, Haswell Partition, Cray XC40}
\label{\detokenize{installation:installing-on-nersc-cori-haswell-partition-cray-xc40}}
Cori is a Cray XC40 that includes 16\sphinxhyphen{}core Intel “Haswell” nodes
installed at NERSC. In the following example, the source code is
cloned in \$HOME/qmc/git\_QMCPACK and QMCPACK is built in the scratch
space.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mkdir \PYGZdl{}HOME/qmc
mkdir \PYGZdl{}HOME/qmc/git\PYGZus{}QMCPACK
cd \PYGZdl{}HOME/qmc\PYGZus{}git\PYGZus{}QMCPACK
git clone https://github.com/QMCPACK/qmcpack.git
cd qmcpack
git checkout v3.7.0 \PYGZsh{} Edit for desired version
export CRAYPE\PYGZus{}LINK\PYGZus{}TYPE=dynamic
module unload cray\PYGZhy{}libsci
module load boost/1.70.0
module load cray\PYGZhy{}hdf5\PYGZhy{}parallel
module load cmake/3.14.4
module load gcc/8.3.0 \PYGZsh{} Make C++ 14 standard library available to the Intel compiler
cd \PYGZdl{}SCRATCH
mkdir build\PYGZus{}cori\PYGZus{}hsw
cd build\PYGZus{}cori\PYGZus{}hsw
cmake \PYGZhy{}DQMC\PYGZus{}SYMLINK\PYGZus{}TEST\PYGZus{}FILES=0 \PYGZhy{}DCMAKE\PYGZus{}SYSTEM\PYGZus{}NAME=CrayLinuxEnvironment \PYGZdl{}HOME/qmc/git\PYGZus{}QMCPACK/qmcpack/
nice make \PYGZhy{}j 8
ls \PYGZhy{}l bin/qmcpack
\end{sphinxVerbatim}

When the preceding was tested on June 15, 2020, the following module and
software versions were present:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{build\PYGZus{}cori\PYGZus{}hsw}\PYG{o}{\PYGZgt{}} \PYG{n}{module} \PYG{n+nb}{list}
\PYG{n}{Currently} \PYG{n}{Loaded} \PYG{n}{Modulefiles}\PYG{p}{:}
\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{modules}\PYG{o}{/}\PYG{l+m+mf}{3.2}\PYG{o}{.}\PYG{l+m+mf}{11.4}                                 \PYG{l+m+mi}{13}\PYG{p}{)} \PYG{n}{xpmem}\PYG{o}{/}\PYG{l+m+mf}{2.2}\PYG{o}{.}\PYG{l+m+mi}{20}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.0}\PYG{o}{.}\PYG{l+m+mf}{1.1\PYGZus{}4}\PYG{o}{.}\PYG{l+m+mi}{8}\PYG{n}{\PYGZus{}\PYGZus{}g0475745}\PYG{o}{.}\PYG{n}{ari}
\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{n}{nsg}\PYG{o}{/}\PYG{l+m+mf}{1.2}\PYG{o}{.}\PYG{l+m+mi}{0}                                        \PYG{l+m+mi}{14}\PYG{p}{)} \PYG{n}{job}\PYG{o}{/}\PYG{l+m+mf}{2.2}\PYG{o}{.}\PYG{l+m+mi}{4}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.0}\PYG{o}{.}\PYG{l+m+mf}{1.1\PYGZus{}3}\PYG{o}{.}\PYG{l+m+mi}{34}\PYG{n}{\PYGZus{}\PYGZus{}g36b56f4}\PYG{o}{.}\PYG{n}{ari}
\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{n}{altd}\PYG{o}{/}\PYG{l+m+mf}{2.0}                                         \PYG{l+m+mi}{15}\PYG{p}{)} \PYG{n}{dvs}\PYG{o}{/}\PYG{l+m+mf}{2.12\PYGZus{}2}\PYG{o}{.}\PYG{l+m+mf}{2.156}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.0}\PYG{o}{.}\PYG{l+m+mf}{1.1\PYGZus{}8}\PYG{o}{.}\PYG{l+m+mi}{6}\PYG{n}{\PYGZus{}\PYGZus{}g5aab709e}
\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{n}{darshan}\PYG{o}{/}\PYG{l+m+mf}{3.1}\PYG{o}{.}\PYG{l+m+mi}{7}                                    \PYG{l+m+mi}{16}\PYG{p}{)} \PYG{n}{alps}\PYG{o}{/}\PYG{l+m+mf}{6.6}\PYG{o}{.}\PYG{l+m+mi}{57}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.0}\PYG{o}{.}\PYG{l+m+mf}{1.1\PYGZus{}5}\PYG{o}{.}\PYG{l+m+mi}{10}\PYG{n}{\PYGZus{}\PYGZus{}g1b735148}\PYG{o}{.}\PYG{n}{ari}
\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mf}{19.0}\PYG{o}{.}\PYG{l+m+mf}{3.199}                                 \PYG{l+m+mi}{17}\PYG{p}{)} \PYG{n}{rca}\PYG{o}{/}\PYG{l+m+mf}{2.2}\PYG{o}{.}\PYG{l+m+mi}{20}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.0}\PYG{o}{.}\PYG{l+m+mf}{1.1\PYGZus{}4}\PYG{o}{.}\PYG{l+m+mi}{42}\PYG{n}{\PYGZus{}\PYGZus{}g8e3fb5b}\PYG{o}{.}\PYG{n}{ari}
\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{n}{craype}\PYG{o}{\PYGZhy{}}\PYG{n}{network}\PYG{o}{\PYGZhy{}}\PYG{n}{aries}                             \PYG{l+m+mi}{18}\PYG{p}{)} \PYG{n}{atp}\PYG{o}{/}\PYG{l+m+mf}{2.1}\PYG{o}{.}\PYG{l+m+mi}{3}
\PYG{l+m+mi}{7}\PYG{p}{)} \PYG{n}{craype}\PYG{o}{/}\PYG{l+m+mf}{2.6}\PYG{o}{.}\PYG{l+m+mi}{2}                                     \PYG{l+m+mi}{19}\PYG{p}{)} \PYG{n}{PrgEnv}\PYG{o}{\PYGZhy{}}\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mi}{5}
\PYG{l+m+mi}{8}\PYG{p}{)} \PYG{n}{udreg}\PYG{o}{/}\PYG{l+m+mf}{2.3}\PYG{o}{.}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.0}\PYG{o}{.}\PYG{l+m+mf}{1.1\PYGZus{}3}\PYG{o}{.}\PYG{l+m+mi}{29}\PYG{n}{\PYGZus{}\PYGZus{}g8175d3d}\PYG{o}{.}\PYG{n}{ari}           \PYG{l+m+mi}{20}\PYG{p}{)} \PYG{n}{craype}\PYG{o}{\PYGZhy{}}\PYG{n}{haswell}
\PYG{l+m+mi}{9}\PYG{p}{)} \PYG{n}{ugni}\PYG{o}{/}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mf}{14.0}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.0}\PYG{o}{.}\PYG{l+m+mf}{1.1\PYGZus{}7}\PYG{o}{.}\PYG{l+m+mi}{32}\PYG{n}{\PYGZus{}\PYGZus{}ge78e5b0}\PYG{o}{.}\PYG{n}{ari}         \PYG{l+m+mi}{21}\PYG{p}{)} \PYG{n}{cray}\PYG{o}{\PYGZhy{}}\PYG{n}{mpich}\PYG{o}{/}\PYG{l+m+mf}{7.7}\PYG{o}{.}\PYG{l+m+mi}{10}
\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{n}{pmi}\PYG{o}{/}\PYG{l+m+mf}{5.0}\PYG{o}{.}\PYG{l+m+mi}{14}                                      \PYG{l+m+mi}{22}\PYG{p}{)} \PYG{n}{craype}\PYG{o}{\PYGZhy{}}\PYG{n}{hugepages2M}
\PYG{l+m+mi}{11}\PYG{p}{)} \PYG{n}{dmapp}\PYG{o}{/}\PYG{l+m+mf}{7.1}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.0}\PYG{o}{.}\PYG{l+m+mf}{1.1\PYGZus{}4}\PYG{o}{.}\PYG{l+m+mi}{43}\PYG{n}{\PYGZus{}\PYGZus{}g38cf134}\PYG{o}{.}\PYG{n}{ari}          \PYG{l+m+mi}{23}\PYG{p}{)} \PYG{n}{gcc}\PYG{o}{/}\PYG{l+m+mf}{8.3}\PYG{o}{.}\PYG{l+m+mi}{0}
\PYG{l+m+mi}{12}\PYG{p}{)} \PYG{n}{gni}\PYG{o}{\PYGZhy{}}\PYG{n}{headers}\PYG{o}{/}\PYG{l+m+mf}{5.0}\PYG{o}{.}\PYG{l+m+mf}{12.0}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.0}\PYG{o}{.}\PYG{l+m+mf}{1.1\PYGZus{}6}\PYG{o}{.}\PYG{l+m+mi}{27}\PYG{n}{\PYGZus{}\PYGZus{}g3b1768f}\PYG{o}{.}\PYG{n}{ari} \PYG{l+m+mi}{24}\PYG{p}{)} \PYG{n}{cmake}\PYG{o}{/}\PYG{l+m+mf}{3.14}\PYG{o}{.}\PYG{l+m+mi}{4}
\end{sphinxVerbatim}

The following slurm job file can be used to run the tests:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{}!/bin/bash
\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}qos=debug
\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}time=00:10:00
\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}nodes=1
\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}tasks\PYGZhy{}per\PYGZhy{}node=32
\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}constraint=haswell
echo \PYGZhy{}\PYGZhy{}\PYGZhy{} Start `date`
echo \PYGZhy{}\PYGZhy{}\PYGZhy{} Working directory: `pwd`
ctest \PYGZhy{}VV \PYGZhy{}R deterministic
echo \PYGZhy{}\PYGZhy{}\PYGZhy{} End `date`
\end{sphinxVerbatim}


\subsection{Installing on NERSC Cori, Xeon Phi KNL partition, Cray XC40}
\label{\detokenize{installation:installing-on-nersc-cori-xeon-phi-knl-partition-cray-xc40}}
Cori is a Cray XC40 that includes Intel Xeon Phi Knight’s Landing (KNL) nodes. The following build recipe ensures that the code
generation is appropriate for the KNL nodes. The source is assumed to
be in \$HOME/qmc/git\_QMCPACK/qmcpack as per the Haswell example.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
export CRAYPE\PYGZus{}LINK\PYGZus{}TYPE=dynamic
module swap craype\PYGZhy{}haswell craype\PYGZhy{}mic\PYGZhy{}knl \PYGZsh{} Only difference between Haswell and KNL recipes
module unload cray\PYGZhy{}libsci
module load boost/1.70.0
module load cray\PYGZhy{}hdf5\PYGZhy{}parallel
module load cmake/3.14.4
module load gcc/8.3.0 \PYGZsh{} Make C++ 14 standard library available to the Intel compiler
cd \PYGZdl{}SCRATCH
mkdir build\PYGZus{}cori\PYGZus{}knl
cd build\PYGZus{}cori\PYGZus{}knl
cmake \PYGZhy{}DQMC\PYGZus{}SYMLINK\PYGZus{}TEST\PYGZus{}FILES=0 \PYGZhy{}DCMAKE\PYGZus{}SYSTEM\PYGZus{}NAME=CrayLinuxEnvironment \PYGZdl{}HOME/qmc/git\PYGZus{}QMCPACK/qmcpack/
nice make \PYGZhy{}j 8
ls \PYGZhy{}l bin/qmcpack
\end{sphinxVerbatim}

When the preceding was tested on June 15, 2020, the following module and
software versions were present:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{build\PYGZus{}cori\PYGZus{}knl}\PYG{o}{\PYGZgt{}} \PYG{n}{module} \PYG{n+nb}{list}
  \PYG{n}{Currently} \PYG{n}{Loaded} \PYG{n}{Modulefiles}\PYG{p}{:}
  \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{modules}\PYG{o}{/}\PYG{l+m+mf}{3.2}\PYG{o}{.}\PYG{l+m+mf}{11.4}                                 \PYG{l+m+mi}{13}\PYG{p}{)} \PYG{n}{xpmem}\PYG{o}{/}\PYG{l+m+mf}{2.2}\PYG{o}{.}\PYG{l+m+mi}{20}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.0}\PYG{o}{.}\PYG{l+m+mf}{1.1\PYGZus{}4}\PYG{o}{.}\PYG{l+m+mi}{8}\PYG{n}{\PYGZus{}\PYGZus{}g0475745}\PYG{o}{.}\PYG{n}{ari}
  \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{n}{nsg}\PYG{o}{/}\PYG{l+m+mf}{1.2}\PYG{o}{.}\PYG{l+m+mi}{0}                                        \PYG{l+m+mi}{14}\PYG{p}{)} \PYG{n}{job}\PYG{o}{/}\PYG{l+m+mf}{2.2}\PYG{o}{.}\PYG{l+m+mi}{4}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.0}\PYG{o}{.}\PYG{l+m+mf}{1.1\PYGZus{}3}\PYG{o}{.}\PYG{l+m+mi}{34}\PYG{n}{\PYGZus{}\PYGZus{}g36b56f4}\PYG{o}{.}\PYG{n}{ari}
  \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{n}{altd}\PYG{o}{/}\PYG{l+m+mf}{2.0}                                         \PYG{l+m+mi}{15}\PYG{p}{)} \PYG{n}{dvs}\PYG{o}{/}\PYG{l+m+mf}{2.12\PYGZus{}2}\PYG{o}{.}\PYG{l+m+mf}{2.156}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.0}\PYG{o}{.}\PYG{l+m+mf}{1.1\PYGZus{}8}\PYG{o}{.}\PYG{l+m+mi}{6}\PYG{n}{\PYGZus{}\PYGZus{}g5aab709e}
  \PYG{l+m+mi}{4}\PYG{p}{)} \PYG{n}{darshan}\PYG{o}{/}\PYG{l+m+mf}{3.1}\PYG{o}{.}\PYG{l+m+mi}{7}                                    \PYG{l+m+mi}{16}\PYG{p}{)} \PYG{n}{alps}\PYG{o}{/}\PYG{l+m+mf}{6.6}\PYG{o}{.}\PYG{l+m+mi}{57}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.0}\PYG{o}{.}\PYG{l+m+mf}{1.1\PYGZus{}5}\PYG{o}{.}\PYG{l+m+mi}{10}\PYG{n}{\PYGZus{}\PYGZus{}g1b735148}\PYG{o}{.}\PYG{n}{ari}
  \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mf}{19.0}\PYG{o}{.}\PYG{l+m+mf}{3.199}                                 \PYG{l+m+mi}{17}\PYG{p}{)} \PYG{n}{rca}\PYG{o}{/}\PYG{l+m+mf}{2.2}\PYG{o}{.}\PYG{l+m+mi}{20}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.0}\PYG{o}{.}\PYG{l+m+mf}{1.1\PYGZus{}4}\PYG{o}{.}\PYG{l+m+mi}{42}\PYG{n}{\PYGZus{}\PYGZus{}g8e3fb5b}\PYG{o}{.}\PYG{n}{ari}
  \PYG{l+m+mi}{6}\PYG{p}{)} \PYG{n}{craype}\PYG{o}{\PYGZhy{}}\PYG{n}{network}\PYG{o}{\PYGZhy{}}\PYG{n}{aries}                             \PYG{l+m+mi}{18}\PYG{p}{)} \PYG{n}{atp}\PYG{o}{/}\PYG{l+m+mf}{2.1}\PYG{o}{.}\PYG{l+m+mi}{3}
  \PYG{l+m+mi}{7}\PYG{p}{)} \PYG{n}{craype}\PYG{o}{/}\PYG{l+m+mf}{2.6}\PYG{o}{.}\PYG{l+m+mi}{2}                                     \PYG{l+m+mi}{19}\PYG{p}{)} \PYG{n}{PrgEnv}\PYG{o}{\PYGZhy{}}\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mi}{5}
  \PYG{l+m+mi}{8}\PYG{p}{)} \PYG{n}{udreg}\PYG{o}{/}\PYG{l+m+mf}{2.3}\PYG{o}{.}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.0}\PYG{o}{.}\PYG{l+m+mf}{1.1\PYGZus{}3}\PYG{o}{.}\PYG{l+m+mi}{29}\PYG{n}{\PYGZus{}\PYGZus{}g8175d3d}\PYG{o}{.}\PYG{n}{ari}           \PYG{l+m+mi}{20}\PYG{p}{)} \PYG{n}{craype}\PYG{o}{\PYGZhy{}}\PYG{n}{mic}\PYG{o}{\PYGZhy{}}\PYG{n}{knl}
  \PYG{l+m+mi}{9}\PYG{p}{)} \PYG{n}{ugni}\PYG{o}{/}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mf}{14.0}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.0}\PYG{o}{.}\PYG{l+m+mf}{1.1\PYGZus{}7}\PYG{o}{.}\PYG{l+m+mi}{32}\PYG{n}{\PYGZus{}\PYGZus{}ge78e5b0}\PYG{o}{.}\PYG{n}{ari}         \PYG{l+m+mi}{21}\PYG{p}{)} \PYG{n}{cray}\PYG{o}{\PYGZhy{}}\PYG{n}{mpich}\PYG{o}{/}\PYG{l+m+mf}{7.7}\PYG{o}{.}\PYG{l+m+mi}{10}
 \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{n}{pmi}\PYG{o}{/}\PYG{l+m+mf}{5.0}\PYG{o}{.}\PYG{l+m+mi}{14}                                       \PYG{l+m+mi}{22}\PYG{p}{)} \PYG{n}{craype}\PYG{o}{\PYGZhy{}}\PYG{n}{hugepages2M}
 \PYG{l+m+mi}{11}\PYG{p}{)} \PYG{n}{dmapp}\PYG{o}{/}\PYG{l+m+mf}{7.1}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.0}\PYG{o}{.}\PYG{l+m+mf}{1.1\PYGZus{}4}\PYG{o}{.}\PYG{l+m+mi}{43}\PYG{n}{\PYGZus{}\PYGZus{}g38cf134}\PYG{o}{.}\PYG{n}{ari}           \PYG{l+m+mi}{23}\PYG{p}{)} \PYG{n}{gcc}\PYG{o}{/}\PYG{l+m+mf}{8.3}\PYG{o}{.}\PYG{l+m+mi}{0}
 \PYG{l+m+mi}{12}\PYG{p}{)} \PYG{n}{gni}\PYG{o}{\PYGZhy{}}\PYG{n}{headers}\PYG{o}{/}\PYG{l+m+mf}{5.0}\PYG{o}{.}\PYG{l+m+mf}{12.0}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.0}\PYG{o}{.}\PYG{l+m+mf}{1.1\PYGZus{}6}\PYG{o}{.}\PYG{l+m+mi}{27}\PYG{n}{\PYGZus{}\PYGZus{}g3b1768f}\PYG{o}{.}\PYG{n}{ari}  \PYG{l+m+mi}{24}\PYG{p}{)} \PYG{n}{cmake}\PYG{o}{/}\PYG{l+m+mf}{3.14}\PYG{o}{.}\PYG{l+m+mi}{4}
\end{sphinxVerbatim}


\subsection{Installing on systems with ARMv8\sphinxhyphen{}based processors}
\label{\detokenize{installation:installing-on-systems-with-armv8-based-processors}}
The following build recipe was verified using the ‘Arm Compiler for HPC’ on the ANL JLSE Comanche system with Cavium ThunderX2 processors on November 6, 2018.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} load armclang compiler}
\PYG{n}{module} \PYG{n}{load} \PYG{n}{Generic}\PYG{o}{\PYGZhy{}}\PYG{n}{AArch64}\PYG{o}{/}\PYG{n}{RHEL}\PYG{o}{/}\PYG{l+m+mi}{7}\PYG{o}{/}\PYG{n}{arm}\PYG{o}{\PYGZhy{}}\PYG{n}{hpc}\PYG{o}{\PYGZhy{}}\PYG{n}{compiler}\PYG{o}{/}\PYG{l+m+mf}{18.4}
\PYG{c+c1}{\PYGZsh{} load Arm performance libraries}
\PYG{n}{module} \PYG{n}{load} \PYG{n}{ThunderX2CN99}\PYG{o}{/}\PYG{n}{RHEL}\PYG{o}{/}\PYG{l+m+mi}{7}\PYG{o}{/}\PYG{n}{arm}\PYG{o}{\PYGZhy{}}\PYG{n}{hpc}\PYG{o}{\PYGZhy{}}\PYG{n}{compiler}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{18.4}\PYG{o}{/}\PYG{n}{armpl}\PYG{o}{/}\PYG{l+m+mf}{18.4}\PYG{o}{.}\PYG{l+m+mi}{0}
\PYG{c+c1}{\PYGZsh{} define path to pre\PYGZhy{}installed packages}
\PYG{n}{export} \PYG{n}{HDF5\PYGZus{}ROOT}\PYG{o}{=}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{path}\PYG{o}{/}\PYG{n}{to}\PYG{o}{/}\PYG{n}{hdf5}\PYG{o}{/}\PYG{n}{install}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{n}{export} \PYG{n}{BOOST\PYGZus{}ROOT}\PYG{o}{=}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{path}\PYG{o}{/}\PYG{n}{to}\PYG{o}{/}\PYG{n}{boost}\PYG{o}{/}\PYG{n}{install}\PYG{o}{\PYGZgt{}} \PYG{c+c1}{\PYGZsh{} header\PYGZhy{}only, no need to build}
\end{sphinxVerbatim}

Then using the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mkdir} \PYG{n}{build\PYGZus{}armclang}
\PYG{n}{cd} \PYG{n}{build\PYGZus{}armclang}
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}C\PYGZus{}COMPILER}\PYG{o}{=}\PYG{n}{armclang} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}CXX\PYGZus{}COMPILER}\PYG{o}{=}\PYG{n}{armclang}\PYG{o}{+}\PYG{o}{+} \PYG{o}{\PYGZhy{}}\PYG{n}{DQMC\PYGZus{}MPI}\PYG{o}{=}\PYG{l+m+mi}{0} \PYGZbs{}
    \PYG{o}{\PYGZhy{}}\PYG{n}{DLAPACK\PYGZus{}LIBRARIES}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}L\PYGZdl{}ARMPL\PYGZus{}DIR/lib \PYGZhy{}larmpl\PYGZus{}mp}\PYG{l+s+s2}{\PYGZdq{}} \PYGZbs{}
    \PYG{o}{\PYGZhy{}}\PYG{n}{DFFTW\PYGZus{}INCLUDE\PYGZus{}DIR}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}ARMPL\PYGZus{}DIR/include}\PYG{l+s+s2}{\PYGZdq{}} \PYGZbs{}
    \PYG{o}{\PYGZhy{}}\PYG{n}{DFFTW\PYGZus{}LIBRARIES}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}ARMPL\PYGZus{}DIR/lib/libarmpl\PYGZus{}mp.a}\PYG{l+s+s2}{\PYGZdq{}} \PYGZbs{}
    \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{l+m+mi}{56}
\end{sphinxVerbatim}

Note that armclang is recognized as an ‘unknown’ compiler by CMake v3.13* and below. In this case, we need to force it as clang to apply necessary flags. To do so, pass the following additionals option to CMake:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}C\PYGZus{}COMPILER\PYGZus{}ID}\PYG{o}{=}\PYG{n}{Clang} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}CXX\PYGZus{}COMPILER\PYGZus{}ID}\PYG{o}{=}\PYG{n}{Clang} \PYGZbs{}
\PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}CXX\PYGZus{}COMPILER\PYGZus{}VERSION}\PYG{o}{=}\PYG{l+m+mf}{5.0} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}CXX\PYGZus{}STANDARD\PYGZus{}COMPUTED\PYGZus{}DEFAULT}\PYG{o}{=}\PYG{l+m+mi}{98} \PYGZbs{}
\end{sphinxVerbatim}


\subsection{Installing on Windows}
\label{\detokenize{installation:installing-on-windows}}
Install the Windows Subsystem for Linux and Bash on Windows.
Open a bash shell and follow the install directions for Ubuntu in {\hyperref[\detokenize{installation:buildubuntu}]{\sphinxcrossref{\DUrole{std,std-ref}{Installing on Ubuntu Linux or other apt\sphinxhyphen{}get\textendash{}based distributions}}}}.


\section{Installing via Spack}
\label{\detokenize{installation:installing-via-spack}}
Spack is a package manager for scientific software.
One of the primary goals of Spack is to reduce the barrier for users to install scientific
software. Spack is intended to work on everything from laptop
computers to high\sphinxhyphen{}end supercomputers. More information about Spack can
be found at \sphinxurl{https://spack.readthedocs.io/en/latest}. The major
advantage of installation with Spack is that all dependencies are
automatically built, potentially including all the compilers and libraries, and
different versions of QMCPACK can easily coexist with each other.
The QMCPACK Spack package also knows how to automatically build
and patch QE. In principle, QMCPACK can be installed with
a single Spack command.


\subsection{Known limitations}
\label{\detokenize{installation:known-limitations}}
The QMCPACK Spack package inherits the limitations of the underlying
Spack infrastructure and its dependencies. The main limitation is that
installation can fail when building a dependency such as HDF5, MPICH,
etc. For \sphinxcode{\sphinxupquote{spack install qmcpack}} to succeed, it is very
important to leverage preinstalled packages on your computer or
supercomputer. The other frequently encountered challenge is that the
compiler configuration is nonintuitive.  This is especially the case
with the Intel compiler. If you encounter any difficulties, we
recommend testing the Spack compiler configuration on a simpler
packages, e.g. HDF5.

Here are some additional limitations of the QMCPACK Spack package that
will be resolved in future releases:
\begin{itemize}
\item {} 
CUDA support in Spack still has some limitations.  It will
catch only some compiler\sphinxhyphen{}CUDA conflicts.

\item {} 
The Intel compiler must find a recent and compatible GCC
compiler in its path or one must be explicity set with the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}gcc\sphinxhyphen{}name}} and \sphinxcode{\sphinxupquote{\sphinxhyphen{}gxx\sphinxhyphen{}name}} flags.

\end{itemize}


\subsection{Setting up the Spack environment}
\label{\detokenize{installation:setting-up-the-spack-environment}}
Begin by cloning Spack from GitHub and configuring your shell as described at
\sphinxurl{https://spack.readthedocs.io/en/latest/getting\_started.html}.

The goal of the next several steps is to set up the Spack environment
for building. First, we highly recommend limiting the number of build jobs to
a reasonable value for your machine. This can be
accomplished by modifying your \sphinxcode{\sphinxupquote{\textasciitilde{}/.spack/config.yaml}} file as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{config}\PYG{p}{:}
  \PYG{n}{build\PYGZus{}jobs}\PYG{p}{:} \PYG{l+m+mi}{16}
\end{sphinxVerbatim}

Make sure any existing compilers are properly detected. For many
architectures, compilers are properly detected with no additional
effort.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{spack} \PYG{n}{compilers}
\PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{Available} \PYG{n}{compilers}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{gcc} \PYG{n}{sierra}\PYG{o}{\PYGZhy{}}\PYG{n}{x86\PYGZus{}64} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{n}{gcc}\PYG{o}{@}\PYG{l+m+mf}{7.2}\PYG{o}{.}\PYG{l+m+mi}{0}  \PYG{n}{gcc}\PYG{o}{@}\PYG{l+m+mf}{6.4}\PYG{o}{.}\PYG{l+m+mi}{0}  \PYG{n}{gcc}\PYG{o}{@}\PYG{l+m+mf}{5.5}\PYG{o}{.}\PYG{l+m+mi}{0}  \PYG{n}{gcc}\PYG{o}{@}\PYG{l+m+mf}{4.9}\PYG{o}{.}\PYG{l+m+mi}{4}  \PYG{n}{gcc}\PYG{o}{@}\PYG{l+m+mf}{4.8}\PYG{o}{.}\PYG{l+m+mi}{5}  \PYG{n}{gcc}\PYG{o}{@}\PYG{l+m+mf}{4.7}\PYG{o}{.}\PYG{l+m+mi}{4}  \PYG{n}{gcc}\PYG{o}{@}\PYG{l+m+mf}{4.6}\PYG{o}{.}\PYG{l+m+mi}{4}
\end{sphinxVerbatim}

However, if your compiler is not automatically detected, it is straightforward
to add one:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{spack} \PYG{n}{compiler} \PYG{n}{add} \PYG{o}{\PYGZlt{}}\PYG{n}{path}\PYG{o}{\PYGZhy{}}\PYG{n}{to}\PYG{o}{\PYGZhy{}}\PYG{n}{compiler}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

The Intel compiler, and other commerical compilers like PGI, typically
require extra environment variables to work properly. If you have an
module environment set\sphinxhyphen{}up by your system administrators, it is
recommended that you set the module name in
\sphinxcode{\sphinxupquote{\textasciitilde{}/.spack/linux/compilers.yaml}}. Here is an example for the
Intel compiler:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}} \PYG{n}{compiler}\PYG{p}{:}
  \PYG{n}{environment}\PYG{p}{:}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
  \PYG{n}{extra\PYGZus{}rpaths}\PYG{p}{:}  \PYG{p}{[}\PYG{p}{]}
  \PYG{n}{flags}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
  \PYG{n}{modules}\PYG{p}{:}
  \PYG{o}{\PYGZhy{}} \PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mf}{18.0}\PYG{o}{.}\PYG{l+m+mi}{3}
  \PYG{n}{operating\PYGZus{}system}\PYG{p}{:} \PYG{n}{ubuntu14}\PYG{o}{.}\PYG{l+m+mi}{04}
  \PYG{n}{paths}\PYG{p}{:}
    \PYG{n}{cc}\PYG{p}{:} \PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{com}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mi}{18}\PYG{o}{/}\PYG{n}{u3}\PYG{o}{/}\PYG{n}{compilers\PYGZus{}and\PYGZus{}libraries\PYGZus{}2018}\PYG{o}{.}\PYG{l+m+mf}{3.222}\PYG{o}{/}\PYG{n}{linux}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{intel64}\PYG{o}{/}\PYG{n}{icc}
    \PYG{n}{cxx}\PYG{p}{:} \PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{com}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mi}{18}\PYG{o}{/}\PYG{n}{u3}\PYG{o}{/}\PYG{n}{compilers\PYGZus{}and\PYGZus{}libraries\PYGZus{}2018}\PYG{o}{.}\PYG{l+m+mf}{3.222}\PYG{o}{/}\PYG{n}{linux}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{intel64}\PYG{o}{/}\PYG{n}{icpc}
    \PYG{n}{f77}\PYG{p}{:} \PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{com}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mi}{18}\PYG{o}{/}\PYG{n}{u3}\PYG{o}{/}\PYG{n}{compilers\PYGZus{}and\PYGZus{}libraries\PYGZus{}2018}\PYG{o}{.}\PYG{l+m+mf}{3.222}\PYG{o}{/}\PYG{n}{linux}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{intel64}\PYG{o}{/}\PYG{n}{ifort}
    \PYG{n}{fc}\PYG{p}{:} \PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{com}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mi}{18}\PYG{o}{/}\PYG{n}{u3}\PYG{o}{/}\PYG{n}{compilers\PYGZus{}and\PYGZus{}libraries\PYGZus{}2018}\PYG{o}{.}\PYG{l+m+mf}{3.222}\PYG{o}{/}\PYG{n}{linux}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{intel64}\PYG{o}{/}\PYG{n}{ifort}
  \PYG{n}{spec}\PYG{p}{:} \PYG{n}{intel}\PYG{o}{@}\PYG{l+m+mf}{18.0}\PYG{o}{.}\PYG{l+m+mi}{3}
  \PYG{n}{target}\PYG{p}{:} \PYG{n}{x86\PYGZus{}64}
\end{sphinxVerbatim}

If a module is not available, you will have to set\sphinxhyphen{}up the environment variables manually:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}} \PYG{n}{compiler}\PYG{p}{:}
  \PYG{n}{environment}\PYG{p}{:}
    \PYG{n+nb}{set}\PYG{p}{:}
      \PYG{n}{INTEL\PYGZus{}LICENSE\PYGZus{}FILE}\PYG{p}{:} \PYG{n}{server}\PYG{n+nd}{@national}\PYG{o}{\PYGZhy{}}\PYG{n}{lab}\PYG{o}{.}\PYG{n}{doe}\PYG{o}{.}\PYG{n}{gov}
  \PYG{n}{extra\PYGZus{}rpaths}\PYG{p}{:}
  \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/soft/com/packages/intel/18/u3/compilers\PYGZus{}and\PYGZus{}libraries\PYGZus{}2018.3.222/linux/compiler/lib/intel64}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/soft/apps/packages/gcc/gcc\PYGZhy{}6.2.0/lib64}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
  \PYG{n}{flags}\PYG{p}{:}
    \PYG{n}{cflags}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{n}{gcc}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{=}\PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{apps}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{/}\PYG{n}{gcc}\PYG{o}{/}\PYG{n}{gcc}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.2}\PYG{o}{.}\PYG{l+m+mi}{0}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{gcc}
    \PYG{n}{fflags}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{n}{gcc}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{=}\PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{apps}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{/}\PYG{n}{gcc}\PYG{o}{/}\PYG{n}{gcc}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.2}\PYG{o}{.}\PYG{l+m+mi}{0}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{gcc}
    \PYG{n}{cxxflags}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{n}{gxx}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{=}\PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{apps}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{/}\PYG{n}{gcc}\PYG{o}{/}\PYG{n}{gcc}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.2}\PYG{o}{.}\PYG{l+m+mi}{0}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{g}\PYG{o}{+}\PYG{o}{+}
  \PYG{n}{modules}\PYG{p}{:} \PYG{p}{[}\PYG{p}{]}
  \PYG{n}{operating\PYGZus{}system}\PYG{p}{:} \PYG{n}{ubuntu14}\PYG{o}{.}\PYG{l+m+mi}{04}
  \PYG{n}{paths}\PYG{p}{:}
    \PYG{n}{cc}\PYG{p}{:} \PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{com}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mi}{18}\PYG{o}{/}\PYG{n}{u3}\PYG{o}{/}\PYG{n}{compilers\PYGZus{}and\PYGZus{}libraries\PYGZus{}2018}\PYG{o}{.}\PYG{l+m+mf}{3.222}\PYG{o}{/}\PYG{n}{linux}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{intel64}\PYG{o}{/}\PYG{n}{icc}
    \PYG{n}{cxx}\PYG{p}{:} \PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{com}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mi}{18}\PYG{o}{/}\PYG{n}{u3}\PYG{o}{/}\PYG{n}{compilers\PYGZus{}and\PYGZus{}libraries\PYGZus{}2018}\PYG{o}{.}\PYG{l+m+mf}{3.222}\PYG{o}{/}\PYG{n}{linux}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{intel64}\PYG{o}{/}\PYG{n}{icpc}
    \PYG{n}{f77}\PYG{p}{:} \PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{com}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mi}{18}\PYG{o}{/}\PYG{n}{u3}\PYG{o}{/}\PYG{n}{compilers\PYGZus{}and\PYGZus{}libraries\PYGZus{}2018}\PYG{o}{.}\PYG{l+m+mf}{3.222}\PYG{o}{/}\PYG{n}{linux}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{intel64}\PYG{o}{/}\PYG{n}{ifort}
    \PYG{n}{fc}\PYG{p}{:} \PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{com}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mi}{18}\PYG{o}{/}\PYG{n}{u3}\PYG{o}{/}\PYG{n}{compilers\PYGZus{}and\PYGZus{}libraries\PYGZus{}2018}\PYG{o}{.}\PYG{l+m+mf}{3.222}\PYG{o}{/}\PYG{n}{linux}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{intel64}\PYG{o}{/}\PYG{n}{ifort}
  \PYG{n}{spec}\PYG{p}{:} \PYG{n}{intel}\PYG{o}{@}\PYG{l+m+mf}{18.0}\PYG{o}{.}\PYG{l+m+mi}{3}
  \PYG{n}{target}\PYG{p}{:} \PYG{n}{x86\PYGZus{}64}
\end{sphinxVerbatim}

This last step is the most troublesome. Pre\sphinxhyphen{}installed packages are not
automatically detected. If vendor optimized libraries are already
installed, you will need to manually add them to your
\sphinxcode{\sphinxupquote{\textasciitilde{}/.spack/packages.yaml}}. For example, this works on Mac OS X
for the Intel MKL package.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{cat} \PYGZbs{}\PYG{o}{\PYGZti{}}\PYG{o}{/}\PYG{o}{.}\PYG{n}{spack}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{.}\PYG{n}{yaml}
\PYG{n}{packages}\PYG{p}{:}
  \PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{n}{mkl}\PYG{p}{:}
      \PYG{n}{paths}\PYG{p}{:}
          \PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{n}{mkl}\PYG{o}{@}\PYG{l+m+mf}{2018.0}\PYG{o}{.}\PYG{l+m+mi}{128}\PYG{p}{:} \PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{n}{compilers\PYGZus{}and\PYGZus{}libraries\PYGZus{}2018}\PYG{o}{.}\PYG{l+m+mf}{0.104}\PYG{o}{/}\PYG{n}{mac}\PYG{o}{/}\PYG{n}{mkl}
      \PYG{n}{buildable}\PYG{p}{:} \PYG{k+kc}{False}
\end{sphinxVerbatim}

Some trial\sphinxhyphen{}and\sphinxhyphen{}error might be involved to set the directories
correctly. If you do not include enough of the tree path, Spack will
not be able to register the package in its database. More information
about system packages can be found at
\sphinxurl{http://spack.readthedocs.io/en/latest/getting\_started.html\#system-packages}.

Beginning with QMCPACK v3.9.0, Python 3.x is required. However,
installing Python with a compiler besides GCC is tricky. We recommend
leveraging your local Python installation by adding an entry in
\sphinxcode{\sphinxupquote{\textasciitilde{}/.spack/packages.yaml}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{packages}\PYG{p}{:}
  \PYG{n}{python}\PYG{p}{:}
     \PYG{n}{modules}\PYG{p}{:}
       \PYG{n}{python}\PYG{o}{@}\PYG{l+m+mf}{3.7}\PYG{o}{.}\PYG{l+m+mi}{4}\PYG{p}{:} \PYG{n}{anaconda3}\PYG{o}{/}\PYG{l+m+mf}{2019.10}
\end{sphinxVerbatim}

Or if a module is not available

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{packages}\PYG{p}{:}
  \PYG{n}{python}\PYG{p}{:}
     \PYG{n}{paths}\PYG{p}{:}
        \PYG{n}{python}\PYG{o}{@}\PYG{l+m+mf}{3.7}\PYG{o}{.}\PYG{l+m+mi}{4}\PYG{p}{:} \PYG{o}{/}\PYG{n}{nfs}\PYG{o}{/}\PYG{n}{gce}\PYG{o}{/}\PYG{n}{software}\PYG{o}{/}\PYG{n}{custom}\PYG{o}{/}\PYG{n}{linux}\PYG{o}{\PYGZhy{}}\PYG{n}{ubuntu18}\PYG{o}{.}\PYG{l+m+mi}{04}\PYG{o}{\PYGZhy{}}\PYG{n}{x86\PYGZus{}64}\PYG{o}{/}\PYG{n}{anaconda3}\PYG{o}{/}\PYG{l+m+mf}{2019.10}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{python}
   \PYG{n}{buildable}\PYG{p}{:} \PYG{k+kc}{False}
\end{sphinxVerbatim}


\subsection{Building QMCPACK}
\label{\detokenize{installation:id2}}
The QMCPACK Spack package has a number of variants to support different compile time
options and different versions of the application. A full list can be displayed by typing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your} \PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{spack} \PYG{n}{info} \PYG{n}{qmcpack}
\PYG{n}{CMakePackage}\PYG{p}{:}   \PYG{n}{qmcpack}

\PYG{n}{Description}\PYG{p}{:}
  \PYG{n}{QMCPACK}\PYG{p}{,} \PYG{o+ow}{is} \PYG{n}{a} \PYG{n}{modern} \PYG{n}{high}\PYG{o}{\PYGZhy{}}\PYG{n}{performance} \PYG{n+nb}{open}\PYG{o}{\PYGZhy{}}\PYG{n}{source} \PYG{n}{Quantum} \PYG{n}{Monte} \PYG{n}{Carlo}
  \PYG{p}{(}\PYG{n}{QMC}\PYG{p}{)} \PYG{n}{simulation} \PYG{n}{code}\PYG{o}{.}

\PYG{n}{Homepage}\PYG{p}{:} \PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{www}\PYG{o}{.}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{org}\PYG{o}{/}

\PYG{n}{Tags}\PYG{p}{:}
  \PYG{n}{ecp}  \PYG{n}{ecp}\PYG{o}{\PYGZhy{}}\PYG{n}{apps}

\PYG{n}{Preferred} \PYG{n}{version}\PYG{p}{:}
  \PYG{l+m+mf}{3.9}\PYG{o}{.}\PYG{l+m+mi}{1}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{9.1}

\PYG{n}{Safe} \PYG{n}{versions}\PYG{p}{:}
  \PYG{n}{develop}  \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git}
  \PYG{l+m+mf}{3.9}\PYG{o}{.}\PYG{l+m+mi}{1}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{9.1}
  \PYG{l+m+mf}{3.9}\PYG{o}{.}\PYG{l+m+mi}{0}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{9.0}
  \PYG{l+m+mf}{3.8}\PYG{o}{.}\PYG{l+m+mi}{0}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{8.0}
  \PYG{l+m+mf}{3.7}\PYG{o}{.}\PYG{l+m+mi}{0}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{7.0}
  \PYG{l+m+mf}{3.6}\PYG{o}{.}\PYG{l+m+mi}{0}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{6.0}
  \PYG{l+m+mf}{3.5}\PYG{o}{.}\PYG{l+m+mi}{0}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{5.0}
  \PYG{l+m+mf}{3.4}\PYG{o}{.}\PYG{l+m+mi}{0}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{4.0}
  \PYG{l+m+mf}{3.3}\PYG{o}{.}\PYG{l+m+mi}{0}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{3.0}
  \PYG{l+m+mf}{3.2}\PYG{o}{.}\PYG{l+m+mi}{0}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{2.0}
  \PYG{l+m+mf}{3.1}\PYG{o}{.}\PYG{l+m+mi}{1}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{1.1}
  \PYG{l+m+mf}{3.1}\PYG{o}{.}\PYG{l+m+mi}{0}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{1.0}

\PYG{n}{Variants}\PYG{p}{:}
  \PYG{n}{Name} \PYG{p}{[}\PYG{n}{Default}\PYG{p}{]}          \PYG{n}{Allowed} \PYG{n}{values}          \PYG{n}{Description}


  \PYG{n}{build\PYGZus{}type} \PYG{p}{[}\PYG{n}{Release}\PYG{p}{]}    \PYG{n}{Debug}\PYG{p}{,} \PYG{n}{Release}\PYG{p}{,}         \PYG{n}{The} \PYG{n}{build} \PYG{n+nb}{type} \PYG{n}{to} \PYG{n}{build}
                          \PYG{n}{RelWithDebInfo}
  \PYG{n}{afqmc} \PYG{p}{[}\PYG{n}{off}\PYG{p}{]}             \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Install} \PYG{k}{with} \PYG{n}{AFQMC} \PYG{n}{support}\PYG{o}{.}
                                                  \PYG{n}{NOTE} \PYG{n}{that} \PYG{k}{if} \PYG{n}{used} \PYG{o+ow}{in}
                                                  \PYG{n}{combination} \PYG{k}{with} \PYG{n}{CUDA}\PYG{p}{,} \PYG{n}{only}
                                                  \PYG{n}{AFQMC} \PYG{n}{will} \PYG{n}{have} \PYG{n}{CUDA}\PYG{o}{.}
  \PYG{n+nb}{complex} \PYG{p}{[}\PYG{n}{off}\PYG{p}{]}           \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Build} \PYG{n}{the} \PYG{n+nb}{complex} \PYG{p}{(}\PYG{n}{general}
                                                  \PYG{n}{twist}\PYG{o}{/}\PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{n}{point}\PYG{p}{)} \PYG{n}{version}
  \PYG{n}{cuda} \PYG{p}{[}\PYG{n}{off}\PYG{p}{]}              \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Build} \PYG{k}{with} \PYG{n}{CUDA}
  \PYG{n}{cuda\PYGZus{}arch} \PYG{p}{[}\PYG{n}{none}\PYG{p}{]}        \PYG{n}{none}\PYG{p}{,} \PYG{l+m+mi}{53}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{62}\PYG{p}{,}       \PYG{n}{CUDA} \PYG{n}{architecture}
                          \PYG{l+m+mi}{60}\PYG{p}{,} \PYG{l+m+mi}{61}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{75}\PYG{p}{,} \PYG{l+m+mi}{70}\PYG{p}{,}
                          \PYG{l+m+mi}{72}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{52}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{35}
  \PYG{n}{da} \PYG{p}{[}\PYG{n}{off}\PYG{p}{]}                \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Install} \PYG{k}{with} \PYG{n}{support} \PYG{k}{for} \PYG{n}{basic}
                                                  \PYG{n}{data} \PYG{n}{analysis} \PYG{n}{tools}
  \PYG{n}{gui} \PYG{p}{[}\PYG{n}{off}\PYG{p}{]}               \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Install} \PYG{k}{with} \PYG{n}{Matplotlib} \PYG{p}{(}\PYG{n}{long}
                                                  \PYG{n}{installation} \PYG{n}{time}\PYG{p}{)}
  \PYG{n}{mixed} \PYG{p}{[}\PYG{n}{off}\PYG{p}{]}             \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Build} \PYG{n}{the} \PYG{n}{mixed} \PYG{n}{precision}
                                                  \PYG{p}{(}\PYG{n}{mixture} \PYG{n}{of} \PYG{n}{single} \PYG{o+ow}{and} \PYG{n}{double}
                                                  \PYG{n}{precision}\PYG{p}{)} \PYG{n}{version} \PYG{k}{for} \PYG{n}{gpu} \PYG{o+ow}{and}
                                                  \PYG{n}{cpu}
  \PYG{n}{mpi} \PYG{p}{[}\PYG{n}{on}\PYG{p}{]}                \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Build} \PYG{k}{with} \PYG{n}{MPI} \PYG{n}{support}
  \PYG{n}{phdf5} \PYG{p}{[}\PYG{n}{on}\PYG{p}{]}              \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Build} \PYG{k}{with} \PYG{n}{parallel} \PYG{n}{collective}
                                                  \PYG{n}{I}\PYG{o}{/}\PYG{n}{O}
  \PYG{n}{ppconvert} \PYG{p}{[}\PYG{n}{off}\PYG{p}{]}         \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Install} \PYG{k}{with} \PYG{n}{pseudopotential}
                                                  \PYG{n}{converter}\PYG{o}{.}
  \PYG{n}{qe} \PYG{p}{[}\PYG{n}{on}\PYG{p}{]}                 \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Install} \PYG{k}{with} \PYG{n}{patched} \PYG{n}{Quantum}
                                                  \PYG{n}{Espresso} \PYG{l+m+mf}{6.4}\PYG{o}{.}\PYG{l+m+mi}{0}
  \PYG{n}{soa} \PYG{p}{[}\PYG{n}{on}\PYG{p}{]}                \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Build} \PYG{k}{with} \PYG{n}{Structure}\PYG{o}{\PYGZhy{}}\PYG{n}{of}\PYG{o}{\PYGZhy{}}\PYG{n}{Array}
                                                  \PYG{n}{instead} \PYG{n}{of} \PYG{n}{Array}\PYG{o}{\PYGZhy{}}\PYG{n}{of}\PYG{o}{\PYGZhy{}}\PYG{n}{Structure}
                                                  \PYG{n}{code}\PYG{o}{.} \PYG{n}{Only} \PYG{k}{for} \PYG{n}{CPU} \PYG{n}{codeand}
                                                  \PYG{n}{only} \PYG{o+ow}{in} \PYG{n}{mixed} \PYG{n}{precision}
  \PYG{n}{timers} \PYG{p}{[}\PYG{n}{off}\PYG{p}{]}            \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Build} \PYG{k}{with} \PYG{n}{support} \PYG{k}{for} \PYG{n}{timers}

\PYG{n}{Installation} \PYG{n}{Phases}\PYG{p}{:}
  \PYG{n}{cmake}    \PYG{n}{build}    \PYG{n}{install}

\PYG{n}{Build} \PYG{n}{Dependencies}\PYG{p}{:}
  \PYG{n}{blas}  \PYG{n}{boost}  \PYG{n}{cmake}  \PYG{n}{cuda}  \PYG{n}{fftw}\PYG{o}{\PYGZhy{}}\PYG{n}{api}  \PYG{n}{hdf5}  \PYG{n}{lapack}  \PYG{n}{libxml2}  \PYG{n}{mpi}  \PYG{n}{python}

\PYG{n}{Link} \PYG{n}{Dependencies}\PYG{p}{:}
  \PYG{n}{blas}  \PYG{n}{boost}  \PYG{n}{cuda}  \PYG{n}{fftw}\PYG{o}{\PYGZhy{}}\PYG{n}{api}  \PYG{n}{hdf5}  \PYG{n}{lapack}  \PYG{n}{libxml2}  \PYG{n}{mpi}  \PYG{n}{python}

\PYG{n}{Run} \PYG{n}{Dependencies}\PYG{p}{:}
  \PYG{n}{py}\PYG{o}{\PYGZhy{}}\PYG{n}{matplotlib}  \PYG{n}{py}\PYG{o}{\PYGZhy{}}\PYG{n}{numpy}  \PYG{n}{quantum}\PYG{o}{\PYGZhy{}}\PYG{n}{espresso}

\PYG{n}{Virtual} \PYG{n}{Packages}\PYG{p}{:}
  \PYG{k+kc}{None}
\end{sphinxVerbatim}

For example, to install the complex\sphinxhyphen{}valued version of QMCPACK in mixed\sphinxhyphen{}precision use:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{spack} \PYG{n}{install} \PYG{n}{qmcpack}\PYG{o}{+}\PYG{n}{mixed}\PYG{o}{+}\PYG{n+nb}{complex}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc}\PYG{o}{@}\PYG{l+m+mf}{7.2}\PYG{o}{.}\PYG{l+m+mi}{0} \PYG{o}{\PYGZca{}}\PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{n}{mkl}
\end{sphinxVerbatim}

where

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{n}{gcc}\PYG{o}{@}\PYG{l+m+mf}{7.2}\PYG{o}{.}\PYG{l+m+mi}{0}
\end{sphinxVerbatim}

specifies the compiler version to be used and

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZca{}}\PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{n}{mkl}
\end{sphinxVerbatim}

specifies that the Intel MKL should be used as the BLAS and LAPACK
provider. The \sphinxcode{\sphinxupquote{\textasciicircum{}}} symbol indicates the the package to the right of the
symbol should be used to fulfill the dependency needed by the installation.

It is also possible to run the QMCPACK regression tests as part of the
installation process, for example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{spack} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{test}\PYG{o}{=}\PYG{n}{root} \PYG{n}{qmcpack}\PYG{o}{+}\PYG{n}{mixed}\PYG{o}{+}\PYG{n+nb}{complex}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc}\PYG{o}{@}\PYG{l+m+mf}{7.2}\PYG{o}{.}\PYG{l+m+mi}{0} \PYG{o}{\PYGZca{}}\PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{n}{mkl}
\end{sphinxVerbatim}

will run the unit and short tests. The current behavior of the QMCPACK
Spack package is to complete the install as long as all the unit tests
pass. If the short tests fail, a warning is issued at the command prompt.

For CUDA, you will need to specify and extra \sphinxcode{\sphinxupquote{cuda\_arch}}
parameter otherwise, it will default to \sphinxcode{\sphinxupquote{cuda\_arch=61}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{spack} \PYG{n}{install} \PYG{n}{qmcpack}\PYG{o}{+}\PYG{n}{cuda}\PYG{o}{\PYGZpc{}}\PYG{n}{intel}\PYG{o}{@}\PYG{l+m+mf}{18.0}\PYG{o}{.}\PYG{l+m+mi}{3} \PYG{n}{cuda\PYGZus{}arch}\PYG{o}{=}\PYG{l+m+mi}{61} \PYG{o}{\PYGZca{}}\PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{n}{mkl}
\end{sphinxVerbatim}

Due to limitations in the Spack CUDA package, if your compiler and
CUDA combination conflict, you will need to set a
specific verison of CUDA that is compatible with your compiler on the
command line. For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{spack} \PYG{n}{install} \PYG{n}{qmcpack}\PYG{o}{+}\PYG{n}{cuda}\PYG{o}{\PYGZpc{}}\PYG{n}{intel}\PYG{o}{@}\PYG{l+m+mf}{18.0}\PYG{o}{.}\PYG{l+m+mi}{3} \PYG{n}{cuda\PYGZus{}arch}\PYG{o}{=}\PYG{l+m+mi}{61} \PYG{o}{\PYGZca{}}\PYG{n}{cuda}\PYG{o}{@}\PYG{l+m+mf}{10.0}\PYG{o}{.}\PYG{l+m+mi}{130} \PYG{o}{\PYGZca{}}\PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{n}{mkl}
\end{sphinxVerbatim}


\subsection{Loading QMCPACK into your environment}
\label{\detokenize{installation:loading-qmcpack-into-your-environment}}
If you already have modules set\sphinxhyphen{}up in your enviroment, the Spack
modules will be detected automatically. Otherwise, Spack will not
automatically find the additional packages. A few additional steps are
needed.  Please see the main Spack documentation for additional details: \sphinxurl{https://spack.readthedocs.io/en/latest/module\_file\_support.html}.


\subsection{Dependencies that need to be compiled with GCC}
\label{\detokenize{installation:dependencies-that-need-to-be-compiled-with-gcc}}
Failing to compile a QMCPACK dependency is the most common reason that
a Spack build fails. We recommend that you compile the following
dependencies with GCC:

For MPI, using MPICH as the provider, try:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{spack} \PYG{n}{install} \PYG{n}{qmcpack}\PYG{o}{\PYGZpc{}}\PYG{n}{intel}\PYG{o}{@}\PYG{l+m+mf}{18.0}\PYG{o}{.}\PYG{l+m+mi}{3} \PYG{o}{\PYGZca{}}\PYG{n}{boost}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc} \PYG{o}{\PYGZca{}}\PYG{n}{pkgconf}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc} \PYG{o}{\PYGZca{}}\PYG{n}{perl}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc} \PYG{o}{\PYGZca{}}\PYG{n}{libpciaccess}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc} \PYG{o}{\PYGZca{}}\PYG{n}{cmake}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc} \PYG{o}{\PYGZca{}}\PYG{n}{findutils}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc} \PYG{o}{\PYGZca{}}\PYG{n}{m4}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc}
\end{sphinxVerbatim}

For serial,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{spack} \PYG{n}{install} \PYG{n}{qmcpack}\PYG{o}{\PYGZti{}}\PYG{n}{mpi}\PYG{o}{\PYGZpc{}}\PYG{n}{intel}\PYG{o}{@}\PYG{l+m+mf}{18.0}\PYG{o}{.}\PYG{l+m+mi}{3} \PYG{o}{\PYGZca{}}\PYG{n}{boost}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc} \PYG{o}{\PYGZca{}}\PYG{n}{pkgconf}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc} \PYG{o}{\PYGZca{}}\PYG{n}{perl}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc} \PYG{o}{\PYGZca{}}\PYG{n}{cmake}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc}
\end{sphinxVerbatim}


\subsection{Installing QMCPACK with Spack on Linux}
\label{\detokenize{installation:installing-qmcpack-with-spack-on-linux}}
Spack works robustly on the standard flavors of Linux (Ubuntu, CentOS,
Ubuntu, etc.) using GCC, Clang, PGI, and Intel compilers.


\subsection{Installing QMCPACK with Spack on Mac OS X}
\label{\detokenize{installation:installing-qmcpack-with-spack-on-mac-os-x}}
Spack works on Mac OS X but requires installation of a few packages
using Homebrew. You will need to install at minimum the GCC compilers,
CMake, and pkg\sphinxhyphen{}config. The Intel compiler for Mac on OS X is not well
supported by Spack packages and will most likely lead to a compile
time failure in one of QMCPACK’s dependencies.


\subsection{Installing QMCPACK with Spack on Cray Supercomputers}
\label{\detokenize{installation:installing-qmcpack-with-spack-on-cray-supercomputers}}
Spack now works with the Cray environment. To leverage the installed
Cray environment, both a \sphinxcode{\sphinxupquote{compilers.yaml}} and
\sphinxcode{\sphinxupquote{packages.yaml}} file should be provided by the supercomputing
facility. Additionally, Spack packages compiled by the facility can be
reused by chaining Spack installations
\sphinxurl{https://spack.readthedocs.io/en/latest/chain.html}.

Instructions for DOE supercomputing facilities that support Spack directly will be forthcoming.


\subsection{Installing Quantum\sphinxhyphen{}Espresso with Spack}
\label{\detokenize{installation:installing-quantum-espresso-with-spack}}
More information about the QE Spack package can be obtained directly
from Spack

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{spack} \PYG{n}{info} \PYG{n}{quantum}\PYG{o}{\PYGZhy{}}\PYG{n}{espresso}
\end{sphinxVerbatim}

There are many variants available for QE, most, but not all, are
compatible with QMCPACK patch. Here is a minimalistic example of the
Spack installation command that needs to be invoked:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{spack} \PYG{n}{install} \PYG{n}{quantum}\PYG{o}{\PYGZhy{}}\PYG{n}{espresso}\PYG{o}{+}\PYG{n}{qmcpack}\PYG{o}{\PYGZti{}}\PYG{n}{patch}\PYG{o}{@}\PYG{l+m+mf}{6.4}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc} \PYG{n}{hdf5}\PYG{o}{=}\PYG{n}{parallel}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{\textasciitilde{}}} decorator means deactivate the \sphinxcode{\sphinxupquote{patch}}
variant. This refers not to the QMCPACK patch, but to the upstream
patching that is present for some versions of QE. These upstream QE
patches fix specific critical autoconf/configure fixes. Unfortunately,
some of these QE upstream patches are incompatible with the QMCPACK
patch. Note that the Spack package will prevent you from installing
incompatible variants and will emit an error message explaining the
nature of the incompatibility.

A serial (no MPI) installation is also available, but the Spack installation command
is non\sphinxhyphen{}intuitive for Spack newcomers:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{spack} \PYG{n}{install} \PYG{n}{quantum}\PYG{o}{\PYGZhy{}}\PYG{n}{espresso}\PYG{o}{+}\PYG{n}{qmcpack}\PYG{o}{\PYGZti{}}\PYG{n}{patch}\PYG{o}{\PYGZti{}}\PYG{n}{mpi}\PYG{o}{\PYGZti{}}\PYG{n}{scalapack}\PYG{o}{@}\PYG{l+m+mf}{6.4}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc} \PYG{n}{hdf5}\PYG{o}{=}\PYG{n}{serial}
\end{sphinxVerbatim}

QE Spack package is well tested with GCC and Intel compilers, but will not work
with the PGI compiler or in a cross\sphinxhyphen{}compile environment.


\subsection{Reporting Bugs}
\label{\detokenize{installation:reporting-bugs}}
Bugs with the QMCPACK Spack package should be filed at the main GitHub
Spack repo \sphinxurl{https://github.com/spack/spack/issues}.

In the GitHub issue, include \sphinxcode{\sphinxupquote{@naromero77}} to get the attention
of our developer.


\section{Testing and validation of QMCPACK}
\label{\detokenize{installation:testing-and-validation-of-qmcpack}}\label{\detokenize{installation:testing}}
We \sphinxstylestrong{strongly encourage} running the included tests each time
QMCPACK is built. A range of unit and integration tests ensure that
the code behaves as expected and that results are consistent with
known\sphinxhyphen{}good mean\sphinxhyphen{}field, quantum chemical, and historical QMC results.

The tests include the following:
\begin{itemize}
\item {} 
Unit tests: to check fundamental behavior. These should always pass.

\item {} 
Stochastic integration tests: to check computed results from
the Monte Carlo methods. These might fail statistically, but rarely
because of the use of three sigma level statistics. These tests are
further split into “short” tests, which have just sufficient
length to have valid statistics, and “long” tests, to check
behavior to higher statistical accuracy.

\item {} 
Converter tests: to check conversion of trial wavefunctions
from codes such as QE and GAMESS to QMCPACK’s
formats. These should always pass.

\item {} 
Workflow tests: in the case of QE, we test the
entire cycle of DFT calculation, trial wavefunction conversion, and
a subsequent VMC run.

\item {} 
Performance: to help performance monitoring. Only the timing of
these runs is relevant.

\end{itemize}

The test types are differentiated by prefixes in their names, for example, \sphinxcode{\sphinxupquote{short\sphinxhyphen{}LiH\_dimer\_ae\_vmc\_hf\_noj\_16\sphinxhyphen{}1}} indicates a short VMC test
for the LiH dime.

QMCPACK also includes tests for developmental features and features
that are unsupported on certain platforms. To indicate these, tests
that are unstable are labeled with the CTest label
“unstable.” For example, they are unreliable, unsupported, or known to fail
from partial implementation or bugs.

When installing QMCPACK you should run at least the unit tests:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ctest} \PYG{o}{\PYGZhy{}}\PYG{n}{R} \PYG{n}{unit}
\end{sphinxVerbatim}

These tests take only a few seconds to run. All should pass. A
failure here could indicate a major problem with the installation.

A wider range of deterministic integration
tests are being developed. The goal is to test much more of QMCPACK than the unit tests
do and to do so in a manner that is reproducible
across platforms. All of these should eventually pass 100\% reliably
and quickly. At present, some fail on some platforms and for certain
build types.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ctest} \PYG{o}{\PYGZhy{}}\PYG{n}{R} \PYG{n}{deterministic} \PYG{o}{\PYGZhy{}}\PYG{n}{LE} \PYG{n}{unstable}
\end{sphinxVerbatim}

If time allows, the “short” stochastic tests should also be run.
The short tests take a few minutes each on a 16\sphinxhyphen{}core machine—about 1 hour total depending on the platform. You can run these tests using the following command in the
build directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ctest} \PYG{o}{\PYGZhy{}}\PYG{n}{R} \PYG{n}{short} \PYG{o}{\PYGZhy{}}\PYG{n}{LE} \PYG{n}{unstable}  \PYG{c+c1}{\PYGZsh{} Run the tests with \PYGZdq{}short\PYGZdq{} in their name.}
                             \PYG{c+c1}{\PYGZsh{} Exclude any known unstable tests.}
\end{sphinxVerbatim}

The output should be similar to the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Test} \PYG{n}{project} \PYG{n}{build\PYGZus{}gcc}
    \PYG{n}{Start}  \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{n}{short}\PYG{o}{\PYGZhy{}}\PYG{n}{LiH\PYGZus{}dimer\PYGZus{}ae}\PYG{o}{\PYGZhy{}}\PYG{n}{vmc\PYGZus{}hf\PYGZus{}noj}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{16}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{44} \PYG{n}{Test}  \PYG{c+c1}{\PYGZsh{}1: short\PYGZhy{}LiH\PYGZus{}dimer\PYGZus{}ae\PYGZhy{}vmc\PYGZus{}hf\PYGZus{}noj\PYGZhy{}16\PYGZhy{}1 ..............  Passed   11.20 sec}
    \PYG{n}{Start}  \PYG{l+m+mi}{2}\PYG{p}{:} \PYG{n}{short}\PYG{o}{\PYGZhy{}}\PYG{n}{LiH\PYGZus{}dimer\PYGZus{}ae}\PYG{o}{\PYGZhy{}}\PYG{n}{vmc\PYGZus{}hf\PYGZus{}noj}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{16}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{kinetic}
\PYG{l+m+mi}{2}\PYG{o}{/}\PYG{l+m+mi}{44} \PYG{n}{Test}  \PYG{c+c1}{\PYGZsh{}2: short\PYGZhy{}LiH\PYGZus{}dimer\PYGZus{}ae\PYGZhy{}vmc\PYGZus{}hf\PYGZus{}noj\PYGZhy{}16\PYGZhy{}1\PYGZhy{}kinetic ......  Passed    0.13 sec}
\PYG{o}{.}\PYG{o}{.}
\PYG{l+m+mi}{42}\PYG{o}{/}\PYG{l+m+mi}{44} \PYG{n}{Test} \PYG{c+c1}{\PYGZsh{}42: short\PYGZhy{}monoO\PYGZus{}1x1x1\PYGZus{}pp\PYGZhy{}vmc\PYGZus{}sdj\PYGZhy{}1\PYGZhy{}16 ...............  Passed   10.02 sec}
    \PYG{n}{Start} \PYG{l+m+mi}{43}\PYG{p}{:} \PYG{n}{short}\PYG{o}{\PYGZhy{}}\PYG{n}{monoO\PYGZus{}1x1x1\PYGZus{}pp}\PYG{o}{\PYGZhy{}}\PYG{n}{vmc\PYGZus{}sdj}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{16}\PYG{o}{\PYGZhy{}}\PYG{n}{totenergy}
\PYG{l+m+mi}{43}\PYG{o}{/}\PYG{l+m+mi}{44} \PYG{n}{Test} \PYG{c+c1}{\PYGZsh{}43: short\PYGZhy{}monoO\PYGZus{}1x1x1\PYGZus{}pp\PYGZhy{}vmc\PYGZus{}sdj\PYGZhy{}1\PYGZhy{}16\PYGZhy{}totenergy .....  Passed    0.08 sec}
    \PYG{n}{Start} \PYG{l+m+mi}{44}\PYG{p}{:} \PYG{n}{short}\PYG{o}{\PYGZhy{}}\PYG{n}{monoO\PYGZus{}1x1x1\PYGZus{}pp}\PYG{o}{\PYGZhy{}}\PYG{n}{vmc\PYGZus{}sdj}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{16}\PYG{o}{\PYGZhy{}}\PYG{n}{samples}
\PYG{l+m+mi}{44}\PYG{o}{/}\PYG{l+m+mi}{44} \PYG{n}{Test} \PYG{c+c1}{\PYGZsh{}44: short\PYGZhy{}monoO\PYGZus{}1x1x1\PYGZus{}pp\PYGZhy{}vmc\PYGZus{}sdj\PYGZhy{}1\PYGZhy{}16\PYGZhy{}samples .......  Passed    0.08 sec}

\PYG{l+m+mi}{100}\PYG{o}{\PYGZpc{}} \PYG{n}{tests} \PYG{n}{passed}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{n}{tests} \PYG{n}{failed} \PYG{n}{out} \PYG{n}{of} \PYG{l+m+mi}{44}

\PYG{n}{Total} \PYG{n}{Test} \PYG{n}{time} \PYG{p}{(}\PYG{n}{real}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{167.14} \PYG{n}{sec}
\end{sphinxVerbatim}

Note that the number of tests run varies between the
standard, complex, and GPU compilations. These tests should pass with three sigma reliability. That is, they should nearly always pass, and when rerunning a failed test it should usually pass. Overly frequent failures suggest a problem that should be addressed before any scientific production.

The  full set of tests consist of significantly longer versions of the short
tests, as well as tests of the conversion utilities. The runs require
several hours each for improved statistics and a much more
stringent test of the code. To run all the tests, simply run CTest in the build
directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ctest} \PYG{o}{\PYGZhy{}}\PYG{n}{LE} \PYG{n}{unstable}           \PYG{c+c1}{\PYGZsh{} Run all the stable tests. This will take several hours.}
\end{sphinxVerbatim}

You can also run verbose tests, which direct the QMCPACK
output to the standard output:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ctest} \PYG{o}{\PYGZhy{}}\PYG{n}{V} \PYG{o}{\PYGZhy{}}\PYG{n}{R} \PYG{n}{short}   \PYG{c+c1}{\PYGZsh{} Verbose short tests}
\end{sphinxVerbatim}

The test system includes specific tests for the complex version of the code.

The input data files for the tests are located in the \sphinxcode{\sphinxupquote{tests}} directory.
The system\sphinxhyphen{}level test directories are grouped into \sphinxcode{\sphinxupquote{heg}}, \sphinxcode{\sphinxupquote{molecules}}, and \sphinxcode{\sphinxupquote{solids}}, with particular physical systems under each (for example \sphinxcode{\sphinxupquote{molecules/H4\_ae}} %
\begin{footnote}[1]\sphinxAtStartFootnote
The suffix “ae” is short for “all\sphinxhyphen{}electron,” and “pp” is short for “pseudopotential.”
%
\end{footnote} ).
Under each physical system directory there might be tests for multiple QMC methods or parameter variations.
The numerical comparisons and test definitions are in the \sphinxcode{\sphinxupquote{CMakeLists.txt}} file in each physical system directory.

If \sphinxstyleemphasis{all} the QMC tests fail it is likely
that the appropriate mpiexec (or mpirun, aprun, srun, jsrun) is not being
called or found. If the QMC runs appear to work but all the other
tests fail, it is possible that Python is not working on your system. We suggest checking some of the test console output in \sphinxcode{\sphinxupquote{build/Testing/Temporary/LastTest.log}}
or the output files under \sphinxcode{\sphinxupquote{build/tests/}}.

Note that because most of the tests are very small, consisting of only a few
electrons, the performance is not representative of larger
calculations. For example, although the calculations might fit in cache,
there will be essentially no vectorization because of the small electron
counts. \sphinxstylestrong{These tests should therefore not be used for any benchmarking or
performance analysis}. Example runs that can be used for testing performance are described in
{\hyperref[\detokenize{installation:perftests}]{\sphinxcrossref{\DUrole{std,std-ref}{Performance tests}}}}.


\subsection{Deterministic and unit tests}
\label{\detokenize{installation:deterministic-and-unit-tests}}
QMCPACK has a set of deterministic tests, predominantly unit tests.
All of these tests can be run with the following command (in the build directory):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ctest} \PYG{o}{\PYGZhy{}}\PYG{n}{R} \PYG{n}{deterministic} \PYG{o}{\PYGZhy{}}\PYG{n}{LE} \PYG{n}{unstable}
\end{sphinxVerbatim}

These tests should always pass. Failure could indicate a major problem
with the compiler, compiler settings, or a linked library that would
give incorrect results.

The output should look similar to the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Test} \PYG{n}{project} \PYG{n}{qmcpack}\PYG{o}{/}\PYG{n}{build}
    \PYG{n}{Start}  \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{n}{unit\PYGZus{}test\PYGZus{}numerics}
\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{11} \PYG{n}{Test}  \PYG{c+c1}{\PYGZsh{}1: unit\PYGZus{}test\PYGZus{}numerics ...............   Passed    0.06 sec}
    \PYG{n}{Start}  \PYG{l+m+mi}{2}\PYG{p}{:} \PYG{n}{unit\PYGZus{}test\PYGZus{}utilities}
\PYG{l+m+mi}{2}\PYG{o}{/}\PYG{l+m+mi}{11} \PYG{n}{Test}  \PYG{c+c1}{\PYGZsh{}2: unit\PYGZus{}test\PYGZus{}utilities ..............   Passed    0.02 sec}
    \PYG{n}{Start}  \PYG{l+m+mi}{3}\PYG{p}{:} \PYG{n}{unit\PYGZus{}test\PYGZus{}einspline}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{l+m+mi}{10}\PYG{o}{/}\PYG{l+m+mi}{11} \PYG{n}{Test} \PYG{c+c1}{\PYGZsh{}10: unit\PYGZus{}test\PYGZus{}hamiltonian ............   Passed    1.88 sec}
    \PYG{n}{Start} \PYG{l+m+mi}{11}\PYG{p}{:} \PYG{n}{unit\PYGZus{}test\PYGZus{}drivers}
\PYG{l+m+mi}{11}\PYG{o}{/}\PYG{l+m+mi}{11} \PYG{n}{Test} \PYG{c+c1}{\PYGZsh{}11: unit\PYGZus{}test\PYGZus{}drivers ................   Passed    0.01 sec}

\PYG{l+m+mi}{100}\PYG{o}{\PYGZpc{}} \PYG{n}{tests} \PYG{n}{passed}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{n}{tests} \PYG{n}{failed} \PYG{n}{out} \PYG{n}{of} \PYG{l+m+mi}{11}

\PYG{n}{Label} \PYG{n}{Time} \PYG{n}{Summary}\PYG{p}{:}
\PYG{n}{unit}    \PYG{o}{=}   \PYG{l+m+mf}{2.20} \PYG{n}{sec}

\PYG{n}{Total} \PYG{n}{Test} \PYG{n}{time} \PYG{p}{(}\PYG{n}{real}\PYG{p}{)} \PYG{o}{=}   \PYG{l+m+mf}{2.31} \PYG{n}{sec}
\end{sphinxVerbatim}

Individual unit test executables can be found in \sphinxcode{\sphinxupquote{build/tests/bin}}.
The source for the unit tests is located in the \sphinxcode{\sphinxupquote{tests}} directory under each directory in \sphinxcode{\sphinxupquote{src}} (e.g. \sphinxcode{\sphinxupquote{src/QMCWavefunctions/tests}}).

See {\hyperref[\detokenize{unit_testing:unit-testing}]{\sphinxcrossref{\DUrole{std,std-ref}{Unit Testing}}}} for more details about unit tests.


\subsection{Integration tests with Quantum Espresso}
\label{\detokenize{installation:integration-tests-with-quantum-espresso}}\label{\detokenize{installation:integtestqe}}
As described in {\hyperref[\detokenize{installation:buildqe}]{\sphinxcrossref{\DUrole{std,std-ref}{Installing and patching Quantum ESPRESSO}}}}, it is possible to test entire
workflows of trial wavefunction generation, conversion, and eventual
QMC calculation. A patched QE must be installed so that the
pw2qmcpack converter is available.

By adding \sphinxcode{\sphinxupquote{\sphinxhyphen{}D QE\_BIN=your\_QE\_binary\_path}} in the CMake command line when building your QMCPACK,
tests named with the “qe\sphinxhyphen{}” prefix will be included in the test set of your build.
You can test the whole \sphinxcode{\sphinxupquote{pw \textgreater{} pw2qmcpack \textgreater{} qmcpack}} workflow by

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ctest} \PYG{o}{\PYGZhy{}}\PYG{n}{R} \PYG{n}{qe}
\end{sphinxVerbatim}

This provides a very solid test of the entire QMC
toolchain for plane wave\textendash{}generated wavefunctions.


\subsection{Performance tests}
\label{\detokenize{installation:performance-tests}}\label{\detokenize{installation:perftests}}
Performance tests representative of real research runs are included in the
tests/performance directory. They can be used for benchmarking, comparing machine
performance, or assessing optimizations. This is in
contrast to the majority of the conventional integration tests in which the particle
counts are too small to be representative. Care is still needed to
remove initialization, I/O, and compute a representative performance
measure.

The CTest integration is sufficient to run the benchmarks and measure
relative performance from version to version of QMCPACK and to assess
proposed code changes. Performance tests are prefixed with
“performance.” To obtain the highest performance on a particular
platform, you must run the benchmarks in a standalone manner and tune
thread counts, placement, walker count (etc.). This is essential to
fairly compare different machines. Check with the
developers if you are unsure of what is a fair change.

For the largest problem sizes, the initialization of spline orbitals might
take a large portion of overall runtime. When QMCPACK is run at scale,
the initialization is fast because it is fully
parallelized. However, the performance tests usually run on a single node.
Consider running QMCPACK once with \sphinxcode{\sphinxupquote{save\_coefs="yes"}} XML input tag
added to the line of ‘determinantset’ to save the converted spline
coefficients to the disk and load them for later runs in the same folder.
See {\hyperref[\detokenize{intro_wavefunction:spo-spline}]{\sphinxcrossref{\DUrole{std,std-ref}{Spline basis sets}}}} for more information.

The delayed update algorithm in {\hyperref[\detokenize{intro_wavefunction:singledeterminant}]{\sphinxcrossref{\DUrole{std,std-ref}{Single determinant wavefunctons}}}}
significantly changes the performance characteristics of QMCPACK.  A
parameter scan of the maximal number of delays specific to every
architecture and problem size is required to achieve the best
performance.


\subsubsection{NiO performance tests}
\label{\detokenize{installation:nio-performance-tests}}
Follow the instructions in tests/performance/NiO/README to
enable and run the NiO tests.

The NiO tests are for bulk supercells of varying size. The QMC runs consist of short blocks of (1) VMC
without drift (2) VMC with drift term included, and (3) DMC with
constant population. The tests use spline wavefunctions that must be
downloaded as described in the README file because of their large size. You
will need to set \sphinxcode{\sphinxupquote{\sphinxhyphen{}DQMC\_DATA=YOUR\_DATA\_FOLDER \sphinxhyphen{}DENABLE\_TIMERS=1}}
when running CMake as
described in the README file.

Two sets of wavefunction are tested: spline orbitals with one\sphinxhyphen{} and
two\sphinxhyphen{}body Jastrow functions and a more complex form with an additional
three\sphinxhyphen{}body Jastrow function. The Jastrows are the same for each run
and are not reoptimized, as might be done for research purposes.  Runs
in the hundreds of electrons up to low thousands of electrons are representative of
research runs performed in 2017. The largest runs target
future machines and require very large memory.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{System sizes and names for NiO performance tests. GPU performance
  tests are named similarly but have different walker counts.}\label{\detokenize{installation:id4}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Performance test name
&\sphinxstyletheadfamily 
Historical name
&\sphinxstyletheadfamily 
Atoms
&\sphinxstyletheadfamily 
Electrons
&\sphinxstyletheadfamily 
Electrons/spin
\\
\hline
performance\sphinxhyphen{}NiO\sphinxhyphen{}cpu\sphinxhyphen{}a32\sphinxhyphen{}e384
&
S8
&
32
&
384
&
192
\\
\hline
performance\sphinxhyphen{}NiO\sphinxhyphen{}cpu\sphinxhyphen{}a64\sphinxhyphen{}e768
&
S16
&
64
&
768
&
384
\\
\hline
performance\sphinxhyphen{}NiO\sphinxhyphen{}cpu\sphinxhyphen{}a128\sphinxhyphen{}e1536
&
S32
&
128
&
1536
&
768
\\
\hline
performance\sphinxhyphen{}NiO\sphinxhyphen{}cpu\sphinxhyphen{}a256\sphinxhyphen{}e3072
&
S64
&
256
&
3072
&
1536
\\
\hline
performance\sphinxhyphen{}NiO\sphinxhyphen{}cpu\sphinxhyphen{}a512\sphinxhyphen{}e6144
&
S128
&
512
&
6144
&
3072
\\
\hline
performance\sphinxhyphen{}NiO\sphinxhyphen{}cpu\sphinxhyphen{}a1024\sphinxhyphen{}e12288
&
S256
&
1024
&
12288
&
6144
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Troubleshooting tests}
\label{\detokenize{installation:troubleshooting-tests}}
CTest reports briefly pass or fail of tests in printout and also collects all the standard outputs to help investigating how tests fail.
If the CTest execution is completed, look at \sphinxcode{\sphinxupquote{Testing/Temporary/LastTest.log}}.
If you manually stop the testing (ctrl+c), look at \sphinxcode{\sphinxupquote{Testing/Temporary/LastTest.log.tmp}}.
You can locate the failing tests by searching for the key word “Fail.”


\subsection{Slow testing with OpenMPI}
\label{\detokenize{installation:slow-testing-with-openmpi}}
OpenMPI has a default binding policy that makes all the threads run on a single core during testing when there are two or fewer MPI ranks.
This significantly increases testing time. If you are authorized to change the default setting, you can just add “hwloc\_base\_binding\_policy=none” in /etc/openmpi/openmpi\sphinxhyphen{}mca\sphinxhyphen{}params.conf.


\section{Automated testing of QMCPACK}
\label{\detokenize{installation:automated-testing-of-qmcpack}}
The QMCPACK developers run automatic tests of QMCPACK on several
different computer systems,  many on a continuous basis. See the reports at
\sphinxurl{https://cdash.qmcpack.org/CDash/index.php?project=QMCPACK}.
The combinations that are currently tested can be seen on CDash and are also listed in
\sphinxurl{https://github.com/QMCPACK/qmcpack/blob/develop/README.md}. They include GCC, Clang, Intel, and PGI compilers in combinations
with various library versions and different MPI implementations. NVIDIA GPUs are also tested.


\section{Building ppconvert, a pseudopotential format converter}
\label{\detokenize{installation:building-ppconvert-a-pseudopotential-format-converter}}\label{\detokenize{installation:buildppconvert}}
QMCPACK includes a utility—ppconvert—to convert between different
pseudopotential formats. Examples include effective core potential
formats (in Gaussians), the UPF format used by QE, and
the XML format used by QMCPACK itself. The utility also enables the
atomic orbitals to be recomputed via a numerical density functional
calculation if they need to be reconstructed for use in an
electronic structure calculation.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.800\linewidth]{{QMCPACK_CDash_CTest_Results_20160129}.png}
\caption{Example test results for QMCPACK showing data for a
workstation (Intel, GCC, both CPU and GPU builds) and for two ORNL
supercomputers. In this example, four errors were found. This
dashboard is accessible at \sphinxurl{https://cdash.qmcpack.org}}\label{\detokenize{installation:id5}}\label{\detokenize{installation:fig2}}\end{figure}


\section{Installing and patching Quantum ESPRESSO}
\label{\detokenize{installation:installing-and-patching-quantum-espresso}}\label{\detokenize{installation:buildqe}}
For trial wavefunctions obtained in a plane\sphinxhyphen{}wave basis, we mainly
support QE. Note that ABINIT and QBox were supported historically
and could be reactivated.

QE stores wavefunctions in a nonstandard internal
“save” format. To convert these to a conventional HDF5 format file
we have developed a converter—pw2qmcpack—which is an add\sphinxhyphen{}on to the
QE distribution.

To simplify the process of patching QE we have developed
a script that will automatically download and patch the source
code. The patches are specific to each version. For example, to download and
patch QE v6.3:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{external\PYGZus{}codes}\PYG{o}{/}\PYG{n}{quantum\PYGZus{}espresso}
\PYG{o}{.}\PYG{o}{/}\PYG{n}{download\PYGZus{}and\PYGZus{}patch\PYGZus{}qe6}\PYG{o}{.}\PYG{l+m+mf}{3.}\PYG{n}{sh}
\end{sphinxVerbatim}

After running the patch, you must configure QE with
the HDF5 capability enabled in either way:
\begin{itemize}
\item {} 
If your system already has HDF5 installed with Fortran, use the \sphinxhyphen{}\{\}\sphinxhyphen{}with\sphinxhyphen{}hdf5 configuration option.

\end{itemize}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{qe}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.3}
\PYG{o}{.}\PYG{o}{/}\PYG{n}{configure} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{k}{with}\PYG{o}{\PYGZhy{}}\PYG{n}{hdf5}\PYG{o}{=}\PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{local}   \PYG{c+c1}{\PYGZsh{} Specify HDF5 base directory}
\end{sphinxVerbatim}

\sphinxstylestrong{Check} the end of the configure output if HDF5 libraries are found properly.
If not, either install a complete library or use the other scheme. If using a parallel HDF5 library, be sure to use
the same MPI with QE as used to build the parallel HDF5 library.

Currently, HDF5 support in QE itself is preliminary. To enable use of pw2qmcpack
but use the old non\sphinxhyphen{}HDF5 I/O within QE, replace \sphinxcode{\sphinxupquote{\sphinxhyphen{}D\_\_HDF5}} with \sphinxcode{\sphinxupquote{\{\sphinxhyphen{}D\_\_HDF5\_C\}}} in make.inc.
\end{quote}
\begin{itemize}
\item {} 
If your system has HDF5 with C only, manually edit make.inc by adding \sphinxcode{\sphinxupquote{\sphinxhyphen{}D\_\_HDF5\_C}} and \sphinxcode{\sphinxupquote{\sphinxhyphen{}DH5\_USE\_16\_API}}
in \sphinxcode{\sphinxupquote{DFLAGS}} and provide include and library path in \sphinxcode{\sphinxupquote{IFLAGS}} and \sphinxcode{\sphinxupquote{HDF5\_LIB}}.

\end{itemize}

The complete process is described in external\_codes/quantum\_espresso/README.

The tests involving pw.x and pw2qmcpack.x have been integrated into the test suite of QMCPACK.
By adding \sphinxcode{\sphinxupquote{\sphinxhyphen{}D QE\_BIN=your\_QE\_binary\_path}} in the CMake command line when building your QMCPACK,
tests named with the “qe\sphinxhyphen{}” prefix will be included in the test set of your build.
You can test the whole \sphinxcode{\sphinxupquote{pw \textgreater{} pw2qmcpack \textgreater{} qmcpack workflow}} by

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ctest} \PYG{o}{\PYGZhy{}}\PYG{n}{R} \PYG{n}{qe}
\end{sphinxVerbatim}

See {\hyperref[\detokenize{installation:integtestqe}]{\sphinxcrossref{\DUrole{std,std-ref}{Integration tests with Quantum Espresso}}}} and the testing section for more details.


\section{How to build the fastest executable version of QMCPACK}
\label{\detokenize{installation:how-to-build-the-fastest-executable-version-of-qmcpack}}\label{\detokenize{installation:buildperformance}}
To build the fastest version of QMCPACK we recommend the following:
\begin{itemize}
\item {} 
Use the latest C++ compilers available for your
system. Substantial gains have been made optimizing C++ in recent
years.

\item {} 
Use a vendor\sphinxhyphen{}optimized BLAS library such as Intel MKL and AMD ACML. Although
QMC does not make extensive use of linear algebra, it is used in the
VMC wavefunction optimizer to apply the orbital coefficients in local basis
calculations and in the Slater determinant update.

\item {} 
Use a vector math library such as Intel VML.  For periodic
calculations, the calculation of the structure factor and Ewald
potential benefit from vectorized evaluation of sin and
cos. Currently we only autodetect Intel VML, as provided with MKL,
but support for MASSV and AMD LibM is included via \#defines. See,
for example, src/Numerics/e2iphi.h. For
large supercells, this optimization can gain 10\% in performance.

\end{itemize}

Note that greater speedups of QMC calculations can usually be obtained by
carefully choosing the required statistics for each
investigation. That is, do not compute smaller error bars than necessary.


\section{Troubleshooting the installation}
\label{\detokenize{installation:troubleshooting-the-installation}}\label{\detokenize{installation:troubleshoot}}
Some tips to help troubleshoot installations of QMCPACK:
\begin{itemize}
\item {} 
First, build QMCPACK on a workstation you control or on any
system with a simple and up\sphinxhyphen{}to\sphinxhyphen{}date set of development
tools. You can compare the results of CMake and QMCPACK on this
system with any more difficult systems you encounter.

\item {} 
Use up\sphinxhyphen{}to\sphinxhyphen{}date development software, particularly a recent
CMake.

\item {} 
Verify that the compilers and libraries you expect are
being configured. It is common to have multiple versions
installed. The configure system will stop at the first version it
finds, which might not be the most recent. If this occurs, directly specify the appropriate
directories and files ({\hyperref[\detokenize{installation:cmakeoptions}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration Options}}}}). For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}C\PYGZus{}COMPILER}\PYG{o}{=}\PYG{o}{/}\PYG{n}{full}\PYG{o}{/}\PYG{n}{path}\PYG{o}{/}\PYG{n}{to}\PYG{o}{/}\PYG{n}{mpicc} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}CXX\PYGZus{}COMPILER}\PYG{o}{=}\PYG{o}{/}\PYG{n}{full}\PYG{o}{/}\PYG{n}{path}\PYG{o}{/}\PYG{n}{to}\PYG{o}{/}\PYG{n}{mpicxx} \PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
To monitor the compiler and linker settings, use a verbose build, \sphinxcode{\sphinxupquote{make
VERBOSE=1}}. If an individual source file fails to compile you
can experiment by hand using the output of the verbose build to
reconstruct the full compilation line.

\end{itemize}

If you still have problems please post to the QMCPACK Google group with full
details, or contact a developer.


\chapter{Running QMCPACK}
\label{\detokenize{running:running-qmcpack}}\label{\detokenize{running:running}}\label{\detokenize{running::doc}}
QMCPACK requires at least one xml input file, and is invoked via:

\sphinxcode{\sphinxupquote{qmcpack {[}command line options{]} \textless{}XML input file(s)\textgreater{}}}


\section{Command line options}
\label{\detokenize{running:command-line-options}}\label{\detokenize{running:commandline}}
QMCPACK offers several command line options that affect how calculations
are performed. If the flag is absent, then the corresponding
option is disabled:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}dryrun}} Validate the input file without performing the simulation. This is a good way to ensure that QMCPACK will do what you think it will.

\item {} 
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}enable\sphinxhyphen{}timers=none|coarse|medium|fine}} Control the timer granularity when the build option \sphinxcode{\sphinxupquote{ENABLE\_TIMERS}} is enabled.

\item {} 
\sphinxcode{\sphinxupquote{help}} Print version information as well as a list of optional
command\sphinxhyphen{}line arguments.

\item {} 
\sphinxcode{\sphinxupquote{noprint}} Do not print extra information on Jastrow or pseudopotential.
If this flag is not present, QMCPACK will create several \sphinxcode{\sphinxupquote{.dat}} files
that contain information about pseudopotentials (one file per PP) and Jastrow
factors (one per Jastrow factor). These file might be useful for visual inspection
of the Jastrow, for example.

\item {} 
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}verbosity=low|high|debug}} Control the output verbosity. The default low verbosity is concise and, for example, does not include all electron or atomic positions for large systems to reduce output size. Use “high” to see this information and more details of initialization, allocations, QMC method settings, etc.

\item {} 
\sphinxcode{\sphinxupquote{version}} Print version information and optional arguments. Same as \sphinxcode{\sphinxupquote{help}}.

\end{itemize}


\section{Input files}
\label{\detokenize{running:input-files}}\label{\detokenize{running:inputs}}
The input is one or more XML file(s), documented in {\hyperref[\detokenize{input_overview:input-overview}]{\sphinxcrossref{\DUrole{std,std-ref}{Input file overview}}}}.


\section{Output files}
\label{\detokenize{running:output-files}}
QMCPACK generates multiple files documented in {\hyperref[\detokenize{output_overview:output-overview}]{\sphinxcrossref{\DUrole{std,std-ref}{Output Overview}}}}.


\section{Running in parallel with MPI}
\label{\detokenize{running:running-in-parallel-with-mpi}}\label{\detokenize{running:parallelrunning}}
QMCPACK is fully parallelized with MPI. When performing an ensemble job, all
the MPI ranks are first equally divided into groups that perform individual
QMC calculations. Within one calculation, all the walkers are fully distributed
across all the MPI ranks in the group. Since MPI requires distributed memory,
there must be at least one MPI per node. To maximize the efficiency, more facts
should be taken into account. When using MPI+threads on compute nodes with more
than one NUMA domain (e.g., AMD Interlagos CPU on Titan or a node with multiple
CPU sockets), it is recommended to place as many MPI ranks as the number of
NUMA domains if the memory is sufficient (e.g., one MPI task per socket). On clusters with more than one
GPU per node (NVIDIA Tesla K80), it is necessary to use the same number of MPI
ranks as the number of GPUs per node to let each MPI rank take one GPU.


\section{Using OpenMP threads}
\label{\detokenize{running:using-openmp-threads}}\label{\detokenize{running:openmprunning}}
Modern processors integrate multiple identical cores even with
hardware threads on a single die to increase the total performance and
maintain a reasonable power draw. QMCPACK takes advantage of this
compute capability by using threads and the OpenMP programming model
as well as threaded linear algebra libraries. By default, QMCPACK is
always built with OpenMP enabled. When launching calculations, users
should instruct QMCPACK to create the right number of threads per MPI
rank by specifying environment variable OMP\_NUM\_THREADS. Assuming
one MPI rank per socket, the number of threads should typically be the
number of cores on that socket. Even in the GPU\sphinxhyphen{}accelerated version,
using threads significantly reduces the time spent on the calculations
performed by the CPU.


\subsection{Nested OpenMP threads}
\label{\detokenize{running:nested-openmp-threads}}
Nested threading is an advanced feature requiring experienced users to finely tune runtime parameters to reach the best performance.

For small\sphinxhyphen{}to\sphinxhyphen{}medium problem sizes, using one thread per walker or for multiple walkers is most efficient. This is the default in QMCPACK and achieves the shortest time to solution.

For large problems of at least 1,000 electrons, use of nested OpenMP threading can be enabled to reduce the time to solution further, although at some loss of efficiency. In this scheme multiple threads are used in the computations of each walker. This capability is implemented for some of the key computational kernels: the 3D spline orbital evaluation, certain portions of the distance tables, and implicitly the BLAS calls in the determinant update. Use of the batched nonlocal pseudopotential evaluation is also recommended.

Nested threading is enabled by setting \sphinxcode{\sphinxupquote{OMP\_NUM\_THREADS=AA,BB}}, \sphinxcode{\sphinxupquote{OMP\_MAX\_ACTIVE\_LEVELS=2}} and \sphinxcode{\sphinxupquote{OMP\_NESTED=TRUE}} where the additional \sphinxcode{\sphinxupquote{BB}} is the number of second\sphinxhyphen{}level threads.  Choosing the thread affinity is critical to the performance.
QMCPACK provides a tool qmc\sphinxhyphen{}check\sphinxhyphen{}affinity (source file src/QMCTools/check\sphinxhyphen{}affinity.cpp for details), which might help users investigate the affinity. Knowledge of how the operating system logical CPU cores (/prco/cpuinfo) are bound to the hardware is also needed.

For example, on Blue Gene/Q with a Clang compiler, the best way to fully use the 16 cores each with 4 hardware threads is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{OMP\PYGZus{}NESTED}\PYG{o}{=}\PYG{n}{TRUE}
\PYG{n}{OMP\PYGZus{}NUM\PYGZus{}THREADS}\PYG{o}{=}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{4}
\PYG{n}{MAX\PYGZus{}ACTIVE\PYGZus{}LEVELS}\PYG{o}{=}\PYG{l+m+mi}{2}
\PYG{n}{OMP\PYGZus{}PLACES}\PYG{o}{=}\PYG{n}{threads}
\PYG{n}{OMP\PYGZus{}PROC\PYGZus{}BIND}\PYG{o}{=}\PYG{n}{spread}\PYG{p}{,}\PYG{n}{close}
\end{sphinxVerbatim}

On Intel Xeon Phi KNL with an Intel compiler, to use 64 cores without using hardware threads:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{OMP\PYGZus{}NESTED}\PYG{o}{=}\PYG{n}{TRUE}
\PYG{n}{OMP\PYGZus{}WAIT\PYGZus{}POLICY}\PYG{o}{=}\PYG{n}{ACTIVE}
\PYG{n}{OMP\PYGZus{}NUM\PYGZus{}THREADS}\PYG{o}{=}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{4}
\PYG{n}{MAX\PYGZus{}ACTIVE\PYGZus{}LEVELS}\PYG{o}{=}\PYG{l+m+mi}{2}
\PYG{n}{OMP\PYGZus{}PLACES}\PYG{o}{=}\PYG{n}{cores}
\PYG{n}{OMP\PYGZus{}PROC\PYGZus{}BIND}\PYG{o}{=}\PYG{n}{spread}\PYG{p}{,}\PYG{n}{close}
\PYG{n}{KMP\PYGZus{}HOT\PYGZus{}TEAMS\PYGZus{}MODE}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{n}{KMP\PYGZus{}HOT\PYGZus{}TEAMS\PYGZus{}MAX\PYGZus{}LEVEL}\PYG{o}{=}\PYG{l+m+mi}{2}
\end{sphinxVerbatim}

Most multithreaded BLAS/LAPACK libraries do not spawn threads by default
when being called from an OpenMP parallel region. See the explanation in {\hyperref[\detokenize{installation:threadedlibrary}]{\sphinxcrossref{\DUrole{std,std-ref}{Serial or multithreaded library}}}}.
This results in the use of only a single thread in each second\sphinxhyphen{}level thread team for BLAS/LAPACK operations.
Some vendor libraries like MKL support using multiple threads when being called from an OpenMP parallel region.
One way to enable this feature is using environment variables to override the default behavior.
However, this forces all the calls to the library to use the same number of threads.
As a result, small function calls are penalized with heavy overhead and heavy function calls are slow for not being able to use more threads.
Instead, QMCPACK uses the library APIs to turn on nested threading only at selected performance critical calls.
In the case of using a serial library, QMCPACK implements nested threading to distribute the workload wherever necessary.
Users do not need to control the threading behavior of the library.


\subsection{Performance considerations}
\label{\detokenize{running:performance-considerations}}\label{\detokenize{running:cpu-performance}}
As walkers are the basic units of workload in QMC algorithms, they are loosely coupled and distributed across all the threads. For this reason, the best strategy to run QMCPACK efficiently is to feed enough walkers to the available threads.

In a VMC calculation, the code automatically raises the actual number of walkers per MPI rank to the number of available threads
if the user\sphinxhyphen{}specified number of walkers is smaller, see “walkers/mpi=XXX” in the VMC output.

In DMC, for typical small to mid\sphinxhyphen{}sized calculations choose the total number of walkers to be a significant multiple of the total number of
threads (MPI tasks * threads per task). This will ensure a good load balance. e.g., for a calculation on a few nodes with a total
512 threads, using 5120 walkers may keep the load imbalance around 10\%. For the very largest calculations, the target number of
walkers should be chosen to be slightly smaller than a multiple of the total number of available threads across all the MPI ranks.
This will reduce occurrences worse\sphinxhyphen{}case load imbalance e.g. where one thread has two walkers while all the others have one.

To achieve better performance, a mixed\sphinxhyphen{}precision version (experimental) has been developed in the CPU code. The mixed\sphinxhyphen{}precision
CPU code uses a mixed of single precision (SP) and double precision (DP) operations, while the default code use DP exclusively.
This mixed precision version is more aggressive than the GPU CUDA version in using single precision (SP) operations. The Current implementation uses SP on most
calculations, except for matrix inversions and reductions where double precision is required to retain high accuracy. All the
constant spline data in wavefunction, pseudopotentials, and Coulomb potentials are initialized in double precision and later
stored in single precision. The mixed\sphinxhyphen{}precision code is as accurate as the double\sphinxhyphen{}precision code up to a certain system size, and
may have double the throughput.
Cross checking and verification of accuracy is always required but is particularly important above approximately 1,500 electrons.


\subsection{Memory considerations}
\label{\detokenize{running:memory-considerations}}
When using threads, some memory objects are shared by all the threads. Usually these memory objects are read only when the walkers are evolving, for instance the ionic distance table and wavefunction coefficients.
If a wavefunction is represented by B\sphinxhyphen{}splines, the whole table is shared by all the threads. It usually takes a large chunk of memory when a large primitive cell was used in the simulation. Its actual size is reported as “MEMORY increase XXX MB BsplineSetReader” in the output file.
See details about how to reduce it in {\hyperref[\detokenize{intro_wavefunction:spo-spline}]{\sphinxcrossref{\DUrole{std,std-ref}{Spline basis sets}}}}.

The other memory objects that are distinct for each walker during random walks need to be
associated with individual walkers and cannot be shared. This part of memory grows linearly as the number of walkers per MPI rank. Those objects include wavefunction values (Slater determinants) at given electronic configurations and electron\sphinxhyphen{}related distance tables (electron\sphinxhyphen{}electron distance table). Those matrices dominate the \(N^2\) scaling of the memory usage per walker.


\section{Running on GPU machines}
\label{\detokenize{running:running-on-gpu-machines}}\label{\detokenize{running:gpurunning}}
The GPU version for the NVIDIA CUDA platform is fully incorporated into
the main source code. Commonly used functionalities for
solid\sphinxhyphen{}state and molecular systems using B\sphinxhyphen{}spline single\sphinxhyphen{}particle
orbitals are supported. Use of Gaussian basis sets, three\sphinxhyphen{}body
Jastrow functions, and many observables are not yet supported. A detailed description of the GPU
implementation can be found in \sphinxcite{running:eslerkimceperleyshulenburger2012}.

The current GPU implementation assumes one MPI process per GPU. To use
nodes with multiple GPUs, use multiple MPI processes per node.
Vectorization is achieved over walkers, that is, all walkers are
propagated in parallel. In each GPU kernel, loops over electrons,
atomic cores, or orbitals are further vectorized to exploit an
additional level of parallelism and to allow coalesced memory access.


\subsection{Performance considerations}
\label{\detokenize{running:gpu-performance}}\label{\detokenize{running:id2}}
To run with high performance on GPUs it is crucial to perform some
benchmarking runs: the optimum configuration is system size, walker
count, and GPU model dependent. The GPU implementation vectorizes
operations over multiple walkers, so generally the more walkers that
are placed on a GPU, the higher the performance that will be
obtained. Performance also increases with electron count, up until the
memory on the GPU is exhausted. A good strategy is to perform a short
series of VMC runs with walker count increasing in multiples of
two. For systems with 100s of electrons, typically 128\textendash{}256 walkers per
GPU use a sufficient number of GPU threads to operate the GPU
efficiently and to hide memory\sphinxhyphen{}access latency. For smaller systems,
thousands of walkers might be required. For QMC algorithms where the number of
walkers is fixed such as VMC, choosing a walker count the is a multiple of the
number of streaming multiprocessors can be most efficient. For
variable population DMC runs, this exact match is not possible.

To achieve better performance, the current GPU implementation uses
single\sphinxhyphen{}precision operations for most of the calculations. Double
precision is used in matrix inversions and the Coulomb interaction to
retain high accuracy. The mixed\sphinxhyphen{}precision GPU code is as accurate as
the double\sphinxhyphen{}precision CPU code up to a certain system size. Cross
checking and verification of accuracy are encouraged for systems with
more than approximately 1,500 electrons. For typical calculations on
smaller electron counts, the statistical error bars are much larger
then the error introduced by mixed precision.


\subsection{Memory considerations}
\label{\detokenize{running:id3}}
In the GPU implementation, each walker has a buffer in the GPU’s
global memory to store temporary data associated with the
wavefunctions. Therefore, the amount of memory available on a GPU
limits the number of walkers and eventually the system size that it
can process. Additionally, for calculations using B\sphinxhyphen{}splines, this data
is stored on the GPU in a shared read\sphinxhyphen{}only buffer. Often the size of the
B\sphinxhyphen{}spline data limits the calculations that can be run on the GPU.

If the GPU memory is exhausted, first try reducing the number of walkers per GPU.
Coarsening the grids of the B\sphinxhyphen{}splines representation (by decreasing
the value of the mesh factor in the input file) can also lower the memory
usage, at the expense (risk) of obtaining inaccurate results. Proceed
with caution if this option has to be considered.  It is also possible
to distribute the B\sphinxhyphen{}spline coefficients table between the host and GPU
memory, see option Spline\_Size\_Limit\_MB in
{\hyperref[\detokenize{intro_wavefunction:spo-spline}]{\sphinxcrossref{\DUrole{std,std-ref}{Spline basis sets}}}}.




\chapter{Units used in QMCPACK}
\label{\detokenize{units:units-used-in-qmcpack}}\label{\detokenize{units:units}}\label{\detokenize{units::doc}}
Internally, QMCPACK uses atomic units throughout. Unless stated, all inputs and outputs are also in atomic units. For convenience the analysis tools offer conversions to eV, Ry, Angstrom, Bohr, etc.


\chapter{Input file overview}
\label{\detokenize{input_overview:input-file-overview}}\label{\detokenize{input_overview:input-overview}}\label{\detokenize{input_overview::doc}}
This chapter introduces XML as it is used in the QMCPACK input file.  The focus is on the XML file format itself and the general structure of the input file rather than an exhaustive discussion of all keywords and structure elements.

QMCPACK uses XML to represent structured data in its input file.  Instead of text blocks like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{begin} \PYG{n}{project}
  \PYG{n+nb}{id}     \PYG{o}{=} \PYG{n}{vmc}
  \PYG{n}{series} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{end} \PYG{n}{project}

\PYG{n}{begin} \PYG{n}{vmc}
  \PYG{n}{move}     \PYG{o}{=} \PYG{n}{pbyp}
  \PYG{n}{blocks}   \PYG{o}{=} \PYG{l+m+mi}{200}
  \PYG{n}{steps}    \PYG{o}{=}  \PYG{l+m+mi}{10}
  \PYG{n}{timestep} \PYG{o}{=} \PYG{l+m+mf}{0.4}
\PYG{n}{end} \PYG{n}{vmc}
\end{sphinxVerbatim}

QMCPACK input looks like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{project} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{vmc}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{series}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{project}\PYG{o}{\PYGZgt{}}

\PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{vmc}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pbyp}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{200} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{steps}\PYG{l+s+s2}{\PYGZdq{}}   \PYG{o}{\PYGZgt{}}   \PYG{l+m+mi}{10} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mf}{0.4} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

XML elements start with \sphinxcode{\sphinxupquote{\textless{}element\_name\textgreater{}}}, end with \sphinxcode{\sphinxupquote{\textless{}/element\_name\textgreater{}\}}}, and can be nested within each other to denote substructure (the trial wavefunction is composed of a Slater determinant and a Jastrow factor, which are each further composed of \(...\)).  \sphinxcode{\sphinxupquote{id}} and \sphinxcode{\sphinxupquote{series}} are attributes of the \sphinxcode{\sphinxupquote{\textless{}project/\textgreater{}}} element.  XML attributes are generally used to represent simple values, like names, integers, or real values.  Similar functionality is also commonly provided by \sphinxcode{\sphinxupquote{\textless{}parameter/\textgreater{}}} elements like those previously shown.

The overall structure of the input file reflects different aspects of the QMC simulation: the simulation cell, particles, trial wavefunction, Hamiltonian, and QMC run parameters.  A condensed version of the actual input file is shown as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}?xml version=\PYGZdq{}1.0\PYGZdq{}?\PYGZgt{}
\PYGZlt{}simulation\PYGZgt{}

\PYGZlt{}project id=\PYGZdq{}vmc\PYGZdq{} series=\PYGZdq{}0\PYGZdq{}\PYGZgt{}
  ...
\PYGZlt{}/project\PYGZgt{}

\PYGZlt{}qmcsystem\PYGZgt{}

  \PYGZlt{}simulationcell\PYGZgt{}
    ...
  \PYGZlt{}/simulationcell\PYGZgt{}

  \PYGZlt{}particleset name=\PYGZdq{}e\PYGZdq{}\PYGZgt{}
    ...
  \PYGZlt{}/particleset\PYGZgt{}

  \PYGZlt{}particleset name=\PYGZdq{}ion0\PYGZdq{}\PYGZgt{}
    ...
  \PYGZlt{}/particleset\PYGZgt{}

  \PYGZlt{}wavefunction name=\PYGZdq{}psi0\PYGZdq{} ... \PYGZgt{}
    ...
    \PYGZlt{}determinantset\PYGZgt{}
      \PYGZlt{}slaterdeterminant\PYGZgt{}
        ..
      \PYGZlt{}/slaterdeterminant\PYGZgt{}
    \PYGZlt{}/determinantset\PYGZgt{}
    \PYGZlt{}jastrow type=\PYGZdq{}One\PYGZhy{}Body\PYGZdq{} ... \PYGZgt{}
       ...
    \PYGZlt{}/jastrow\PYGZgt{}
    \PYGZlt{}jastrow type=\PYGZdq{}Two\PYGZhy{}Body\PYGZdq{} ... \PYGZgt{}
      ...
    \PYGZlt{}/jastrow\PYGZgt{}
  \PYGZlt{}/wavefunction\PYGZgt{}

  \PYGZlt{}hamiltonian name=\PYGZdq{}h0\PYGZdq{} ... \PYGZgt{}
    \PYGZlt{}pairpot type=\PYGZdq{}coulomb\PYGZdq{} name=\PYGZdq{}ElecElec\PYGZdq{} ... /\PYGZgt{}
    \PYGZlt{}pairpot type=\PYGZdq{}coulomb\PYGZdq{} name=\PYGZdq{}IonIon\PYGZdq{}   ... /\PYGZgt{}
    \PYGZlt{}pairpot type=\PYGZdq{}pseudo\PYGZdq{} name=\PYGZdq{}PseudoPot\PYGZdq{} ... \PYGZgt{}
      ...
    \PYGZlt{}/pairpot\PYGZgt{}
  \PYGZlt{}/hamiltonian\PYGZgt{}

 \PYGZlt{}/qmcsystem\PYGZgt{}

 \PYGZlt{}qmc method=\PYGZdq{}vmc\PYGZdq{} move=\PYGZdq{}pbyp\PYGZdq{}\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}warmupSteps\PYGZdq{}\PYGZgt{}   20 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}blocks\PYGZdq{}     \PYGZgt{}  200 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}steps\PYGZdq{}      \PYGZgt{}   10 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}timestep\PYGZdq{}   \PYGZgt{}  0.4 \PYGZlt{}/parameter\PYGZgt{}
 \PYGZlt{}/qmc\PYGZgt{}

\PYGZlt{}/simulation\PYGZgt{}
\end{sphinxVerbatim}

The omitted portions \sphinxcode{\sphinxupquote{...}} are more fine\sphinxhyphen{}grained inputs such as the axes of the simulation cell, the number of up and down electrons, positions of atomic species, external orbital files, starting Jastrow parameters, and external pseudopotential files.


\section{Project}
\label{\detokenize{input_overview:project}}
The \sphinxcode{\sphinxupquote{\textless{}project\textgreater{}}} tag uses the \sphinxcode{\sphinxupquote{id}} and \sphinxcode{\sphinxupquote{series}} attributes.
The value of \sphinxcode{\sphinxupquote{id}} is the first part of the prefix for output file names.

Output file names also contain the series number, starting at the value given by the
\sphinxcode{\sphinxupquote{series}} tag.  After every \sphinxcode{\sphinxupquote{\textless{}qmc\textgreater{}}} section, the series value will increment, giving each section a unique prefix.

For the input file shown previously, the output files will start with \sphinxcode{\sphinxupquote{vmc.s000}}, for example, \sphinxcode{\sphinxupquote{vmc.s000.scalar.dat}}.
If there were another \sphinxcode{\sphinxupquote{\textless{}qmc\textgreater{}}} section in the input file, the corresponding output files would use the prefix \sphinxcode{\sphinxupquote{vmc.s001}}.


\section{Random number initialization}
\label{\detokenize{input_overview:random-number-initialization}}
The random number generator state is initialized from the \sphinxcode{\sphinxupquote{random}} element using the \sphinxcode{\sphinxupquote{seed}} attribute:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{random} \PYG{n}{seed}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1000}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

If the random element is not present, or the seed value is negative, the seed will be generated from the current time.

To initialize the many independent random number generators (one per thread and MPI process), the seed value is used (modulo 1024) as a starting index into a list of prime numbers.
Entries in this offset list of prime numbers are then used as the seed for the random generator on each thread and process.

If checkpointing is enabled, the random number state is written to an HDF file at the end of each block (suffix: \sphinxcode{\sphinxupquote{.random.h5}}).
This file will be read if the \sphinxcode{\sphinxupquote{mcwalkerset}} tag is present to perform a restart.
For more information, see the \sphinxcode{\sphinxupquote{checkpoint}} element in the QMC methods {\hyperref[\detokenize{methods:qmcmethods}]{\sphinxcrossref{\DUrole{std,std-ref}{Quantum Monte Carlo Methods}}}} and {\hyperref[\detokenize{output_overview:checkpoint-files}]{\sphinxcrossref{\DUrole{std,std-ref}{Checkpoint and restart files}}}} on checkpoint and restart files.


\chapter{Specifying the system to be simulated}
\label{\detokenize{simulationcell:specifying-the-system-to-be-simulated}}\label{\detokenize{simulationcell:simulationcell}}\label{\detokenize{simulationcell::doc}}

\section{Specifying the Simulation Cell}
\label{\detokenize{simulationcell:specifying-the-simulation-cell}}
The \sphinxcode{\sphinxupquote{simulationcell}} block specifies the geometry of the cell, how the boundary
conditions should be handled, and how ewald summation should be broken
up.

\sphinxcode{\sphinxupquote{simulationcell}} Element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements:
&
\sphinxcode{\sphinxupquote{qmcsystem}}
\\
\hline
Child elements:
&
None
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Attribute:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{parameter name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{description}
\\
\hline
\sphinxcode{\sphinxupquote{lattice}}
&
9 floats
&
any float
&
Must be specified
&
Specification of lattice vectors.
\\
\hline
\sphinxcode{\sphinxupquote{bconds}}
&
string
&
“p” or “n”
&
“n n n “
&
Boundary conditions for each axis.
\\
\hline
\sphinxcode{\sphinxupquote{vacuum}}
&
float
&
\(\geq 1.0\)
&
1.0
&
Vacuum scale.
\\
\hline
\sphinxcode{\sphinxupquote{LR\_dim\_cutoff}}
&
float
&
float
&
15
&
Ewald breakup distance.
\\
\hline
\sphinxcode{\sphinxupquote{LR\_tol}}
&
float
&
float
&
3e\sphinxhyphen{}4
&
Tolerance in Ha for Ewald ion\sphinxhyphen{}ion energy per atom.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

An example of a block is given below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{simulationcell}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lattice}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{l+m+mf}{3.8}       \PYG{l+m+mf}{0.0}       \PYG{l+m+mf}{0.0}
      \PYG{l+m+mf}{0.0}       \PYG{l+m+mf}{3.8}       \PYG{l+m+mf}{0.0}
      \PYG{l+m+mf}{0.0}       \PYG{l+m+mf}{0.0}       \PYG{l+m+mf}{3.8}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bconds}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
       \PYG{n}{p} \PYG{n}{p} \PYG{n}{p}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LR\PYGZus{}dim\PYGZus{}cutoff}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{20} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{simulationcell}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Here, a cubic cell 3.8 bohr on a side will be used. This simulation will
use periodic boundary conditions, and the maximum \(k\) vector will
be \(20/r_{wigner-seitz}\) of the cell.


\subsection{Lattice}
\label{\detokenize{simulationcell:lattice}}
The cell is specified using 3 lattice vectors.


\subsection{Boundary conditions}
\label{\detokenize{simulationcell:boundary-conditions}}
QMCPACK offers the capability to use a mixture of open and periodic
boundary conditions. The parameter expects a single string of three
characters separated by spaces, \sphinxstyleemphasis{e.g.} “p p p” for purely periodic
boundary conditions. These characters control the behavior of the
\(x\), \(y\), and \(z\), axes, respectively. Non periodic
directions must be placed after the periodic ones. Examples of valid
include:

\sphinxstylestrong{“p p p”} Periodic boundary conditions. Corresponds to a 3D crystal.

\sphinxstylestrong{“p p n”} Slab geometry. Corresponds to a 2D crystal.

\sphinxstylestrong{“p n n”} Wire geometry. Corresponds to a 1D crystal.

\sphinxstylestrong{“n n n”}
Open boundary conditions. Corresponds to an isolated molecule in a vacuum.


\subsection{Vacuum}
\label{\detokenize{simulationcell:vacuum}}
The vacuum option allows adding a vacuum region in slab or wire boundary
conditions (\sphinxcode{\sphinxupquote{bconds= p p n}} or \sphinxcode{\sphinxupquote{bconds= p n n}}, respectively). The main use is to save memory with
spline or plane\sphinxhyphen{}wave basis trial wavefunctions, because no basis
functions are required inside the vacuum region. For example, a large
vacuum region can be added above and below a graphene sheet without
having to generate the trial wavefunction in such a large box or to have
as many splines as would otherwise be required. Note that the trial
wavefunction must still be generated in a large enough box to
sufficiently reduce periodic interactions in the underlying electronic
structure calculation.

With the vacuum option, the box used for Ewald summation increases along
the axis labeled by a factor of \sphinxcode{\sphinxupquote{vacuum}}. Note that all the particles remain in
the original box without altering their positions. i.e. Bond lengths are
not changed by this option. The default value is 1, no change to the
specified axes.

An example of a \sphinxcode{\sphinxupquote{simulationcell}} block using is given below. The size of the box along
the z\sphinxhyphen{}axis increases from 12 to 18 by the vacuum scale of 1.5.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{simulationcell}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lattice}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{l+m+mf}{3.8}       \PYG{l+m+mf}{0.0}       \PYG{l+m+mf}{0.0}
      \PYG{l+m+mf}{0.0}       \PYG{l+m+mf}{3.8}       \PYG{l+m+mf}{0.0}
      \PYG{l+m+mf}{0.0}       \PYG{l+m+mf}{0.0}      \PYG{l+m+mf}{12.0}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bconds}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
       \PYG{n}{p} \PYG{n}{p} \PYG{n}{n}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{vacuum}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1.5} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LR\PYGZus{}dim\PYGZus{}cutoff}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{20} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{simulationcell}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{LR\_dim\_cutoff}
\label{\detokenize{simulationcell:lr-dim-cutoff}}
When using periodic boundary conditions direct calculation of the
Coulomb energy is not well behaved. As a result, QMCPACK uses an
optimized Ewald summation technique to compute the Coulomb
interaction. \sphinxcite{design_features:natoli1995}

In the Ewald summation, the energy is broken into short\sphinxhyphen{} and long\sphinxhyphen{}ranged
terms. The short\sphinxhyphen{}ranged term is computed directly in real space, while
the long\sphinxhyphen{}ranged term is computed in reciprocal space. controls where the
short\sphinxhyphen{}ranged term ends and the long\sphinxhyphen{}ranged term begins. The real\sphinxhyphen{}space
cutoff, reciprocal\sphinxhyphen{}space cutoff, and are related via:
\begin{equation*}
\begin{split}\mathrm{LR\_dim\_cutoff} = r_{c} \times k_{c}\end{split}
\end{equation*}
where \(r_{c}\) is the Wigner\sphinxhyphen{}Seitz radius, and \(k_{c}\) is the
length of the maximum \(k\)\sphinxhyphen{}vector used in the long\sphinxhyphen{}ranged term.
Larger values of increase the accuracy of the evaluation. A value of 15
tends to be conservative.


\section{Specifying the particle set}
\label{\detokenize{simulationcell:specifying-the-particle-set}}\label{\detokenize{simulationcell:particleset}}
The \sphinxcode{\sphinxupquote{particleset}} blocks specify the particles in the QMC simulations: their types,
attributes (mass, charge, valence), and positions.


\subsection{Input specification}
\label{\detokenize{simulationcell:input-specification}}
\sphinxcode{\sphinxupquote{particleset}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements
&
\sphinxcode{\sphinxupquote{simulation}}
\\
\hline
Child elements
&
\sphinxcode{\sphinxupquote{group}}, \sphinxcode{\sphinxupquote{attrib}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Attribute:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Datatype
&\sphinxstyletheadfamily 
Values
&\sphinxstyletheadfamily 
Default
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{name/id}}
&
Text
&
\sphinxstyleemphasis{Any}
&
e
&
Name of particle set
\\
\hline
\sphinxcode{\sphinxupquote{size}}\(^o\)
&
Integer
&
\sphinxstyleemphasis{Any}
&
0
&
Number of particles in set
\\
\hline
\sphinxcode{\sphinxupquote{random}}\(^o\)
&
Text
&
Yes/no
&
No
&
Randomize starting positions
\\
\hline
\sphinxcode{\sphinxupquote{randomsrc}}/\sphinxcode{\sphinxupquote{randomsrc}}\(^o\)
&
Text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
\sphinxstyleemphasis{None}
&
Particle set to randomize
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\subsection{Detailed attribute description}
\label{\detokenize{simulationcell:detailed-attribute-description}}

\subsubsection{Required particleset attributes}
\label{\detokenize{simulationcell:required-particleset-attributes}}\begin{itemize}
\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{name/id}}
\item[] Unique name for the particle set. Default is “e” for electrons. “i”
or “ion0” is typically used for ions. For special cases where an
empty particle set is needed, the special name “empty” can be used
to bypass the zero\sphinxhyphen{}size error check.
\end{DUlineblock}

\end{itemize}


\subsubsection{Optional particleset attributes}
\label{\detokenize{simulationcell:optional-particleset-attributes}}\begin{itemize}
\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{size}}
\item[] Number of particles in set.
\end{DUlineblock}

\end{itemize}

\sphinxcode{\sphinxupquote{Group}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements
&
\sphinxcode{\sphinxupquote{particleset}}
\\
\hline
Child elements
&
\sphinxcode{\sphinxupquote{parameter}}, \sphinxcode{\sphinxupquote{attrib}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Attribute:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Datatype
&\sphinxstyletheadfamily 
Values
&\sphinxstyletheadfamily 
Default
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{name}}
&
Text
&
\sphinxstyleemphasis{Any}
&
e
&
Name of particle set
\\
\hline
\sphinxcode{\sphinxupquote{size}}\(^o\)
&
Integer
&
\sphinxstyleemphasis{Any}
&
0
&
Number of particles in set
\\
\hline
\sphinxcode{\sphinxupquote{mass}}\(^o\)
&
Real
&
\sphinxstyleemphasis{Any}
&
1
&
Mass of particles in set
\\
\hline
\sphinxcode{\sphinxupquote{unit}}\(^o\)
&
Text
&
au/amu
&
au
&
Units for mass of particles
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Parameters:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Datatype
&\sphinxstyletheadfamily 
Values
&\sphinxstyletheadfamily 
Default
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{charge}}
&
Real
&
\sphinxstyleemphasis{Any}
&
0
&
Charge of particles in set
\\
\hline
\sphinxcode{\sphinxupquote{valence}}
&
Real
&
\sphinxstyleemphasis{Any}
&
0
&
Valence charge of particles in set
\\
\hline
\sphinxcode{\sphinxupquote{atomicnumber}}
&
Integer
&
\sphinxstyleemphasis{Any}
&
0
&
Atomic number of particles in set
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

\sphinxcode{\sphinxupquote{attrib}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements
&
\sphinxcode{\sphinxupquote{particleset}}, \sphinxcode{\sphinxupquote{group}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Attribute:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{name}}
&
String
&
\sphinxstyleemphasis{Any}
&
\sphinxstyleemphasis{None}
&
Name of attrib
\\
\hline
\sphinxcode{\sphinxupquote{datatype}}
&
String
&
IntArray, realArray, posArray, stringArray
&
\sphinxstyleemphasis{None}
&
Type of data in attrib
\\
\hline
\sphinxcode{\sphinxupquote{size}}\(^o\)
&
String
&
\sphinxstyleemphasis{Any}
&
\sphinxstyleemphasis{None}
&
Size of data in attrib
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}
\begin{itemize}
\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{random}}
\item[] Randomize starting positions of particles. Each component of each
particle’s position is randomized independently in the range of the
simulation cell in that component’s direction.
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{randomsrc}}/\sphinxcode{\sphinxupquote{random\_source}}
\item[] Specify source particle set around which to randomize the initial
positions of this particle set.
\end{DUlineblock}

\end{itemize}


\subsubsection{Required name attributes}
\label{\detokenize{simulationcell:required-name-attributes}}\begin{itemize}
\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{name}}/\sphinxcode{\sphinxupquote{id}}
\item[] Unique name for the particle set group. Typically, element symbols
are used for ions and “u” or “d” for spin\sphinxhyphen{}up and spin\sphinxhyphen{}down electron
groups, respectively.
\end{DUlineblock}

\end{itemize}


\subsubsection{Optional group attributes}
\label{\detokenize{simulationcell:optional-group-attributes}}\begin{itemize}
\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{mass}}
\item[] Mass of particles in set.
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{unit}}
\item[] Units for mass of particles in set (au{[}\(m_e\) = 1{]} or
amu{[}\(\frac{1}{12}m_{\rm ^{12}C}\) = 1{]}).
\end{DUlineblock}

\end{itemize}


\subsection{Example use cases}
\label{\detokenize{simulationcell:example-use-cases}}\phantomsection\label{\detokenize{simulationcell:listing1}}
\begin{center}Particleset elements for ions and electrons randomizing electron start positions.
\end{center}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{particleset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Li}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{3.000000}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{valence}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{3.000000}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{atomicnumber}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{3.000000}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1.000000}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{valence}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1.000000}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{atomicnumber}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1.000000}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{attrib} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{position}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{datatype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{posArray}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{condition}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{l+m+mf}{0.0}   \PYG{l+m+mf}{0.0}   \PYG{l+m+mf}{0.0}
  \PYG{l+m+mf}{0.5}   \PYG{l+m+mf}{0.5}   \PYG{l+m+mf}{0.5}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{attrib}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{attrib} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ionid}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{datatype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{stringArray}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
     \PYG{n}{Li} \PYG{n}{H}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{attrib}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{particleset}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{particleset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{random}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{randomsrc}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{particleset}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\begin{center}Particleset elements for ions and electrons specifying electron start positions.
\end{center}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{particleset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{attrib} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{position}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{datatype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{posArray}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{l+m+mf}{2.9151687332e\PYGZhy{}01} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.5123272502e\PYGZhy{}01} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.2188463918e\PYGZhy{}01}
  \PYG{l+m+mf}{5.8423636048e\PYGZhy{}01}  \PYG{l+m+mf}{4.2730406357e\PYGZhy{}01} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.5964306231e\PYGZhy{}03}
  \PYG{l+m+mf}{3.5228575807e\PYGZhy{}01} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.5027014639e\PYGZhy{}01}  \PYG{l+m+mf}{5.2644808295e\PYGZhy{}01}
     \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.1686250912e\PYGZhy{}01} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.6648002292e+00}  \PYG{l+m+mf}{6.5837023441e\PYGZhy{}01}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{attrib}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{attrib} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{position}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{datatype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{posArray}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{l+m+mf}{3.1443445436e\PYGZhy{}01}  \PYG{l+m+mf}{6.5068682609e\PYGZhy{}01} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.0983449009e\PYGZhy{}02}
     \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.8686061749e\PYGZhy{}01} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{9.3744432997e\PYGZhy{}02} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0456005388e\PYGZhy{}01}
  \PYG{l+m+mf}{2.4978241724e\PYGZhy{}02} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.2862514649e\PYGZhy{}02} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.2266047173e\PYGZhy{}01}
     \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.0352404772e\PYGZhy{}01}  \PYG{l+m+mf}{1.1927734805e+00}  \PYG{l+m+mf}{5.5610824921e\PYGZhy{}01}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{attrib}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{particleset}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{particleset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{O}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{6}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{valence}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{4}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{atomicnumber}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{8}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{valence}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{atomicnumber}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{attrib} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{position}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{datatype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{posArray}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{l+m+mf}{0.0000000000e+00}  \PYG{l+m+mf}{0.0000000000e+00}  \PYG{l+m+mf}{0.0000000000e+00}
    \PYG{l+m+mf}{0.0000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.4308249289e+00}  \PYG{l+m+mf}{1.1078707576e+00}
    \PYG{l+m+mf}{0.0000000000e+00}  \PYG{l+m+mf}{1.4308249289e+00}  \PYG{l+m+mf}{1.1078707576e+00}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{attrib}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{attrib} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ionid}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{datatype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{stringArray}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{O} \PYG{n}{H} \PYG{n}{H}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{attrib}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{particleset}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\begin{center}Particleset elements for ions specifying positions by ion type.
\end{center}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{particleset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{O}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{6}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{valence}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{4}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{atomicnumber}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{8}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{attrib} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{position}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{datatype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{posArray}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{l+m+mf}{0.0000000000e+00}  \PYG{l+m+mf}{0.0000000000e+00}  \PYG{l+m+mf}{0.0000000000e+00}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{attrib}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{valence}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{atomicnumber}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{attrib} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{position}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{datatype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{posArray}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{l+m+mf}{0.0000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.4308249289e+00}  \PYG{l+m+mf}{1.1078707576e+00}
      \PYG{l+m+mf}{0.0000000000e+00}  \PYG{l+m+mf}{1.4308249289e+00}  \PYG{l+m+mf}{1.1078707576e+00}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{attrib}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{particleset}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}




\chapter{Trial wavefunction specificaion}
\label{\detokenize{intro_wavefunction:trial-wavefunction-specificaion}}\label{\detokenize{intro_wavefunction:intro-wavefunction}}\label{\detokenize{intro_wavefunction::doc}}

\section{Introduction}
\label{\detokenize{intro_wavefunction:introduction}}\label{\detokenize{intro_wavefunction:trial-intro}}
This section describes the input blocks associated with the specification of the trial wavefunction in a QMCPACK calculation. These sections are contained within the \sphinxcode{\sphinxupquote{\textless{}wavefunction\textgreater{}}} \(...\)  \sphinxcode{\sphinxupquote{\textless{}/wavefunction\textgreater{}}} xml blocks. \sphinxstylestrong{Users are expected to rely on converters to generate the input blocks described in this section.} The converters and the workflows are designed such that input blocks require minimum modifications from users. Unless the workflow requires modification of wavefunction blocks (e.g., setting the cutoff in a multideterminant calculation), only expert users should directly alter them.

The trial wavefunction in QMCPACK has a general product form:
\begin{equation}\label{equation:intro_wavefunction:eq1}
\begin{split}\Psi_T(\vec{r}) = \prod_k \Theta_k(\vec{r}) ,\end{split}
\end{equation}
where each \(\Theta_k(\vec{r})\) is a function of the electron coordinates
(and possibly ionic coordinates and variational parameters).
For problems involving electrons, the overall trial wavefunction
must be antisymmetric with respect to electron exchange,
so at least one of the functions in the product must be
antisymmetric. Notice that, although QMCPACK allows for the
construction of arbitrary trial wavefunctions based on the
functions implemented in the code
(e.g., slater determinants, jastrow functions),
the user must make sure that a correct wavefunction is
used for the problem at hand. From here on, we assume a
standard trial wavefunction for an electronic structure problem
\begin{equation}\label{equation:intro_wavefunction:eq2}
\begin{split}Psi_T(\vec{r}) =  \textit{A}(\vec{r}) \prod_k \textit{J}_k(\vec{r}),\end{split}
\end{equation}
where \(\textit{A}(\vec{r})\)
is one of the antisymmetric functions: (1) slater determinant, (2) multislater determinant, or (3) pfaffian and \(\textit{J}_k\)
is any of the Jastrow functions (described in {\hyperref[\detokenize{intro_wavefunction:jastrow}]{\sphinxcrossref{\DUrole{std,std-ref}{Jastrow Factors}}}}).  The antisymmetric functions are built from a set of single particle orbitals \sphinxcode{\sphinxupquote{(sposet)}}. QMCPACK implements four different types of \sphinxcode{\sphinxupquote{sposet}}, described in the following section. Each \sphinxcode{\sphinxupquote{sposet}} is designed for a different type of calculation, so their definition and generation varies accordingly.


\section{Single determinant wavefunctons}
\label{\detokenize{intro_wavefunction:single-determinant-wavefunctons}}\label{\detokenize{intro_wavefunction:singledeterminant}}
Placing a single determinant for each spin is the most used ansatz for the antisymmetric part of a trial wavefunction.
The input xml block for \sphinxcode{\sphinxupquote{slaterdeterminant}} is given in {\hyperref[\detokenize{intro_wavefunction:listing-1}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 1}}}}. A list of options is given in
\hyperref[\detokenize{intro_wavefunction:table2}]{Table \ref{\detokenize{intro_wavefunction:table2}}}.

\sphinxcode{\sphinxupquote{slaterdeterminant}} element:


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{intro_wavefunction:table2}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements
&
\sphinxcode{\sphinxupquote{determinantset}}
\\
\hline
Child elements
&
\sphinxcode{\sphinxupquote{determinant}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Attribute:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Datatype
&\sphinxstyletheadfamily 
Values
&\sphinxstyletheadfamily 
Default
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{delay\_rank}}
&
Integer
&
\textgreater{}=0
&
1
&
Number of delayed updates.
\\
\hline
\sphinxcode{\sphinxupquote{optimize}}
&
Text
&
yes/no
&
yes
&
Enable orbital optimization.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{center}Table 2 Options for the \sphinxcode{\sphinxupquote{slaterdeterminant}} xml\sphinxhyphen{}block.
\end{center}\sphinxSetupCaptionForVerbatim{Slaterdeterminant set XML element.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-1}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{slaterdeterminant} \PYG{n}{delay\PYGZus{}rank}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{32}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{determinant} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{updet}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{208}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{occupation} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ground}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{spindataset}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{occupation}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinant}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{determinant} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{downdet}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{208}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{occupation} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ground}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{spindataset}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{occupation}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinant}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{slaterdeterminant}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{delay\_rank}} This option enables delayed updates of the Slater matrix inverse when particle\sphinxhyphen{}by\sphinxhyphen{}particle move is used.
By default or if \sphinxcode{\sphinxupquote{delay\_rank=0}} given in the input file, QMCPACK sets 1 for Slater matrices with a leading dimension \(<192\) and 32 otherwise.
\sphinxcode{\sphinxupquote{delay\_rank=1}} uses the Fahy’s variant \sphinxcite{intro_wavefunction:fahy1990} of the Sherman\sphinxhyphen{}Morrison rank\sphinxhyphen{}1 update, which is mostly using memory bandwidth\sphinxhyphen{}bound BLAS\sphinxhyphen{}2 calls.
With \sphinxcode{\sphinxupquote{delay\_rank\textgreater{}1}}, the delayed update algorithm \sphinxcite{intro_wavefunction:luo2018delayedupdate}\sphinxcite{intro_wavefunction:mcdaniel2017} turns most of the computation to compute bound BLAS\sphinxhyphen{}3 calls.
Tuning this parameter is highly recommended to gain the best performance on medium\sphinxhyphen{}to\sphinxhyphen{}large problem sizes (\(>200\) electrons).
We have seen up to an order of magnitude speedup on large problem sizes.
When studying the performance of QMCPACK, a scan of this parameter is required and we recommend starting from 32.
The best \sphinxcode{\sphinxupquote{delay\_rank}} giving the maximal speedup depends on the problem size.
Usually the larger \sphinxcode{\sphinxupquote{delay\_rank}} corresponds to a larger problem size.
On CPUs, \sphinxcode{\sphinxupquote{delay\_rank}} must be chosen as a multiple of SIMD vector length for good performance of BLAS libraries.
The best \sphinxcode{\sphinxupquote{delay\_rank}} depends on the processor microarchitecture.
GPU support is under development.

\end{itemize}


\section{Single\sphinxhyphen{}particle orbitals}
\label{\detokenize{intro_wavefunction:single-particle-orbitals}}\label{\detokenize{intro_wavefunction:singleparticle}}

\subsection{Spline basis sets}
\label{\detokenize{intro_wavefunction:spline-basis-sets}}\label{\detokenize{intro_wavefunction:spo-spline}}
In this section we describe the use of spline basis sets to expand the \sphinxcode{\sphinxupquote{sposet}}.
Spline basis sets are designed to work seamlessly with plane wave DFT code (e.g.,Quantum ESPRESSO as a trial wavefunction generator).

In QMC algorithms, all the SPOs \(\{\phi(\vec{r})\}\) need to be updated
every time a single electron moves. Evaluating SPOs takes a very large portion of computation time.
In principle, PW basis set can be used to express SPOs directly in QMC, as in DFT.
But it introduces an unfavorable scaling because the basis set size increases linearly as the system size.
For this reason, it is efficient to use a localized basis with compact
support and a good transferability from the plane wave basis.

In particular, 3D tricubic B\sphinxhyphen{}splines provide a basis in which only
64 elements are nonzero at any given point in \sphinxcite{intro_wavefunction:blips4qmc}.
The 1D cubic B\sphinxhyphen{}spline is given by
\begin{equation}\label{equation:intro_wavefunction:eq3}
\begin{split}f(x) = \sum_{i'=i-1}^{i+2} b^{i'\!,3}(x)\,\,  p_{i'},\end{split}
\end{equation}
where \(b^{i}(x)\) is the piecewise cubic polynomial basis functions
and \(i = \text{floor}(\Delta^{-1} x)\) is the index of the first
grid point \(\le x\). Constructing a tensor product in each
Cartesian direction, we can represent a 3D orbital as
\begin{equation}\label{equation:intro_wavefunction:eq4}
\begin{split}\phi_n(x,y,z) =
    \!\!\!\!\sum_{i'=i-1}^{i+2} \!\! b_x^{i'\!,3}(x)
    \!\!\!\!\sum_{j'=j-1}^{j+2} \!\! b_y^{j'\!,3}(y)
    \!\!\!\!\sum_{k'=k-1}^{k+2} \!\! b_z^{k'\!,3}(z) \,\, p_{i', j', k',n}.\end{split}
\end{equation}
This allows the rapid evaluation of each orbital in constant time.
Furthermore, this basis is systematically improvable with a single spacing
parameter so that accuracy is not compromised compared with the plane wave basis.

The use of 3D tricubic B\sphinxhyphen{}splines greatly improves computational efficiency.
The gain in computation time from a plane wave basis set to an equivalent B\sphinxhyphen{}spline basis set
becomes increasingly large as the system size grows.
On the downside, this computational efficiency comes at
the expense of increased memory use, which is easily overcome, however, by the large
aggregate memory available per node through OpenMP/MPI hybrid QMC.

The input xml block for the spline SPOs is given in {\hyperref[\detokenize{intro_wavefunction:listing-2}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 2}}}}. A list of options is given in
\hyperref[\detokenize{intro_wavefunction:table3}]{Table \ref{\detokenize{intro_wavefunction:table3}}}.
\sphinxSetupCaptionForVerbatim{Determinant set XML element.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-2}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{determinantset} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pwscf.h5}\PYG{l+s+s2}{\PYGZdq{}}
                \PYG{n}{tilematrix}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1 1 3 1 2 \PYGZhy{}1 \PYGZhy{}2 1 0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{twistnum}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{gpu}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{meshfactor}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.8}\PYG{l+s+s2}{\PYGZdq{}}
                \PYG{n}{twist}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0  0  0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{precision}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{double}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{slaterdeterminant}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{determinant} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{updet}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{208}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{occupation} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ground}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{spindataset}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{occupation}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinant}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{determinant} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{downdet}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{208}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{occupation} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ground}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{spindataset}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{occupation}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinant}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{slaterdeterminant}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinantset}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{determinantset}} element:


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{intro_wavefunction:table3}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements
&
\sphinxcode{\sphinxupquote{wavefunction}}
\\
\hline
Child elements
&
\sphinxcode{\sphinxupquote{slaterdeterminant}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

attribute:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Datatype
&\sphinxstyletheadfamily 
Values
&\sphinxstyletheadfamily 
Default
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{type}}
&
Text
&
Bspline
&&
Type of \sphinxcode{\sphinxupquote{sposet}}
\\
\hline
\sphinxcode{\sphinxupquote{href}}
&
Text
&&&
Path to hdf5 file from pw2qmcpack.x.
\\
\hline
\sphinxcode{\sphinxupquote{tilematrix}}
&
9 integers
&&&
Tiling matrix used to expand supercell.
\\
\hline
\sphinxcode{\sphinxupquote{twistnum}}
&
Integer
&&&
Index of the super twist.
\\
\hline
\sphinxcode{\sphinxupquote{twist}}
&
3 floats
&&&
Super twist.
\\
\hline
\sphinxcode{\sphinxupquote{meshfactor}}
&
Float
&
\(\le 1.0\)
&&
Grid spacing ratio.
\\
\hline
\sphinxcode{\sphinxupquote{precision}}
&
Text
&
Single/double
&&
Precision of spline coefficients
\\
\hline
\sphinxcode{\sphinxupquote{gpu}}
&
Text
&
Yes/no
&&
GPU switch.
\\
\hline
\sphinxcode{\sphinxupquote{gpusharing}}
&
Text
&
Yes/no
&
No
&
Share B\sphinxhyphen{}spline table across GPUs.
\\
\hline
\sphinxcode{\sphinxupquote{Spline\_Size\_Limit\_MB}}
&
Integer
&&&
Limit B\sphinxhyphen{}spline table size on GPU.
\\
\hline
\sphinxcode{\sphinxupquote{check\_orb\_norm}}
&
Text
&
Yes/no
&
Yes
&
Check norms of orbitals from h5 file.
\\
\hline
\sphinxcode{\sphinxupquote{save\_coefs}}
&
Text
&
Yes/no
&
No
&
Save the spline coefficients to h5 file.
\\
\hline
\sphinxcode{\sphinxupquote{source}}
&
Text
&
Any
&
Ion0
&
Particle set with atomic positions.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{center}Table 3 Options for the \sphinxcode{\sphinxupquote{determinantset}} xml\sphinxhyphen{}block associated with B\sphinxhyphen{}spline single particle orbital sets.
\end{center}
Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{precision}}. Only effective on CPU versions without mixed
precision, “single” is always imposed with mixed precision. Using
single precision not only saves memory use but also speeds up the
B\sphinxhyphen{}spline evaluation. We recommend using single precision since we saw
little chance of really compromising the accuracy of calculation.

\item {} 
\sphinxcode{\sphinxupquote{meshfactor}}. The ratio of actual grid spacing of B\sphinxhyphen{}splines used in
QMC calculation with respect to the original one calculated from h5.
A smaller meshfactor saves memory use but reduces accuracy. The
effects are similar to reducing plane wave cutoff in DFT
calculations. Use with caution!

\item {} 
\sphinxcode{\sphinxupquote{twistnum}}. If positive, it is the index. We recommend not taking
this way since the indexing might show some uncertainty. If negative,
the super twist is referred by \sphinxcode{\sphinxupquote{twist}}.

\item {} 
\sphinxcode{\sphinxupquote{save\_coefs}}. If yes, dump the real\sphinxhyphen{}space B\sphinxhyphen{}spline coefficient
table into an h5 file on the disk. When the orbital transformation
from k space to B\sphinxhyphen{}spline requires more than the available amount of
scratch memory on the compute nodes, users can perform this step on
fat nodes and transfer back the h5 file for QMC calculations.

\item {} 
\sphinxcode{\sphinxupquote{gpusharing}}. If enabled, spline data is shared across multiple
GPUs on a given computational node. For example, on a
two\sphinxhyphen{}GPU\sphinxhyphen{}per\sphinxhyphen{}node system, each GPU would have half of the orbitals.
This enables larger overall spline tables than would normally fit in
the memory of individual GPUs to be used, potentially up to the total
GPU memory on a node. To obtain high performance, large electron
counts or a high\sphinxhyphen{}performing CPU\sphinxhyphen{}GPU interconnect is required. To use
this feature, the following needs to be done:
\begin{quote}
\begin{itemize}
\item {} 
The CUDA Multi\sphinxhyphen{}Process Service (MPS) needs to be used (e.g., on

\end{itemize}

Summit/SummitDev use “\sphinxhyphen{}alloc\_flags gpumps” for bsub). If MPS is not
detected, sharing will be disabled.
\begin{itemize}
\item {} 
CUDA\_VISIBLE\_DEVICES needs to be properly set to control each rank’s

\end{itemize}

visible CUDA devices (e.g., on OLCF Summit/SummitDev one needs to
create a resource set containing all GPUs with the respective number
of ranks with “jsrun \textendash{}task\sphinxhyphen{}per\sphinxhyphen{}rs Ngpus \sphinxhyphen{}g Ngpus”).
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{Spline\_Size\_Limit\_MB}}. Allows distribution of the B\sphinxhyphen{}spline
coefficient table between the host and GPU memory. The compute kernels
access host memory via zero\sphinxhyphen{}copy. Although the performance penalty
introduced by it is significant, it allows large calculations to go
through.

\end{itemize}


\subsection{Gaussian basis tests}
\label{\detokenize{intro_wavefunction:gaussian-basis-tests}}\label{\detokenize{intro_wavefunction:gaussianbasis}}
In this section we describe the use of localized basis sets to expand the \sphinxcode{\sphinxupquote{sposet}}. The general form of a single particle orbital in this case is given by:
\begin{equation}\label{equation:intro_wavefunction:eq5}
\begin{split}\phi_i(\vec{r}) = \sum_k C_{i,k} \ \eta_k(\vec{r}),\end{split}
\end{equation}
where \(\{\eta_k(\vec{r})\}\) is a set of M atom\sphinxhyphen{}centered basis
functions and \(C_{i,k}\) is a coefficient matrix. This should be
used in calculations of finite systems employing an atom\sphinxhyphen{}centered basis
set and is typically generated by the \sphinxstyleemphasis{convert4qmc} converter. Examples
include calculations of molecules using Gaussian basis sets or
Slater\sphinxhyphen{}type basis functions. Initial support for periodic systems is
described in {\hyperref[\detokenize{LCAO:lcao}]{\sphinxcrossref{\DUrole{std,std-ref}{Periodic LCAO for Solids}}}}. Even though this section is called
“Gaussian basis sets” (by far the most common atom\sphinxhyphen{}centered basis set),
QMCPACK works with any atom\sphinxhyphen{}centered basis set based on either spherical
harmonic angular functions or Cartesian angular expansions. The radial
functions in the basis set can be expanded in either Gaussian functions,
Slater\sphinxhyphen{}type functions, or numerical radial functions.

In this section we describe the input sections for the atom\sphinxhyphen{}centered basis set and the \sphinxcode{\sphinxupquote{sposet}} for a single Slater determinant trial wavefunction. The input sections for multideterminant trial wavefunctions are described in {\hyperref[\detokenize{intro_wavefunction:multideterminants}]{\sphinxcrossref{\DUrole{std,std-ref}{Multideterminant wavefunctions}}}}. The basic structure for the input block of a single Slater determinant is given in {\hyperref[\detokenize{intro_wavefunction:listing-3}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 3}}}}.
A list of options for \sphinxcode{\sphinxupquote{determinantset}} associated with this \sphinxcode{\sphinxupquote{sposet}} is given in \hyperref[\detokenize{intro_wavefunction:table4}]{Table \ref{\detokenize{intro_wavefunction:table4}}}.
\sphinxSetupCaptionForVerbatim{Basic input block for a single determinant trial wavefunction using a \sphinxcode{\sphinxupquote{sposet}} expanded on an atom\sphinxhyphen{}centered basis set.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-3}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{o}{\PYGZlt{}}\PYG{n}{wavefunction} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{psi0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{determinantset}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{basisset}\PYG{o}{\PYGZgt{}}
       \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
     \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{basisset}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{slaterdeterminant}\PYG{o}{\PYGZgt{}}
       \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
     \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{slaterdeterminant}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinantset}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{wavefunction}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

The definition of the set of atom\sphinxhyphen{}centered basis functions is given by the \sphinxcode{\sphinxupquote{basisset}} block, and the \sphinxcode{\sphinxupquote{sposet}} is defined within \sphinxcode{\sphinxupquote{slaterdeterminant}}. The \sphinxcode{\sphinxupquote{basisset}} input block is composed from a collection of \sphinxcode{\sphinxupquote{atomicBasisSet}} input blocks, one for each atomic species in the simulation where basis functions are centered. The general structure for \sphinxcode{\sphinxupquote{basisset}} and \sphinxcode{\sphinxupquote{atomicBasisSet}} are given in {\hyperref[\detokenize{intro_wavefunction:listing-4}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 4}}}}, and the corresponding lists of options are given in
\hyperref[\detokenize{intro_wavefunction:table5}]{Table \ref{\detokenize{intro_wavefunction:table5}}} and \hyperref[\detokenize{intro_wavefunction:table6}]{Table \ref{\detokenize{intro_wavefunction:table6}}}.

\sphinxcode{\sphinxupquote{determinantset}} element:


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{intro_wavefunction:table4}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements
&
\sphinxcode{\sphinxupquote{wavefunction}}
\\
\hline
Child elements
&
\sphinxcode{\sphinxupquote{basisset}} , \sphinxcode{\sphinxupquote{slaterdeterminant}} , \sphinxcode{\sphinxupquote{sposet}} , \sphinxcode{\sphinxupquote{multideterminant}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Attribute:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{name/id}}
&
Text
&
\sphinxstyleemphasis{Any}
&
‘’ ‘’
&
Name of determinant set
\\
\hline
\sphinxcode{\sphinxupquote{type}}
&
Text
&
See below
&
‘’ ‘’
&
Type of \sphinxcode{\sphinxupquote{sposet}}
\\
\hline
\sphinxcode{\sphinxupquote{keyword}}
&
Text
&
NMO, GTO, STO
&
NMO
&
Type of orbital set generated
\\
\hline
\sphinxcode{\sphinxupquote{transform}}
&
Text
&
Yes/no
&
Yes
&
Transform to numerical radial functions?
\\
\hline
\sphinxcode{\sphinxupquote{source}}
&
Text
&
\sphinxstyleemphasis{Any}
&
Ion0
&
Particle set with the position of atom centers
\\
\hline
\sphinxcode{\sphinxupquote{cuspCorrection}}
&
Text
&
Yes/no
&
No
&
Apply cusp correction scheme to \sphinxcode{\sphinxupquote{sposet}}?
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{center}Table 4 Options for the \sphinxcode{\sphinxupquote{determinantset}} xml\sphinxhyphen{}block associated with atom\sphinxhyphen{}centered single particle orbital sets.
\end{center}\sphinxSetupCaptionForVerbatim{Basic input block for \sphinxcode{\sphinxupquote{basisset}}.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-4}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{basisset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LCAOBSet}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{atomicBasisSet} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gaussian\PYGZhy{}G2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{angular}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cartesian}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{normalized}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{grid} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{log}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{ri}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1.e\PYGZhy{}6}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rf}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1.e2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{npts}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1001}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{basisGroup} \PYG{n}{rid}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C00}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{n}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{l}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gaussian}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{radfunc} \PYG{n}{exponent}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{5.134400000000e\PYGZhy{}02}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{contraction}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1.399098787100e\PYGZhy{}02}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
      \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{basisGroup}\PYG{o}{\PYGZgt{}}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{atomicBasisSet}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{atomicBasisSet} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gaussian\PYGZhy{}G2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{angular}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cartesian}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gaussian}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{normalized}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{atomicBasisSet}\PYG{o}{\PYGZgt{}}
  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{basisset}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{basisset}} element:


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{intro_wavefunction:table5}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements
&
\sphinxcode{\sphinxupquote{determinantset}}
\\
\hline
Child elements
&
\sphinxcode{\sphinxupquote{atomicBasisSet}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Attribute:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{name}} / \sphinxcode{\sphinxupquote{id}}
&
Text
&
\sphinxstyleemphasis{Any}
&
” “
&
Name of atom\sphinxhyphen{}centered basis set
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{center}Table 5 Options for the \sphinxcode{\sphinxupquote{basisset}} xml\sphinxhyphen{}block associated with atom\sphinxhyphen{}centered single particle orbital sets.
\end{center}
\sphinxcode{\sphinxupquote{AtomicBasisSet}} element:


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{intro_wavefunction:table6}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements
&
\sphinxcode{\sphinxupquote{basisset}}
\\
\hline
Child elements
&
\sphinxcode{\sphinxupquote{grid}} , \sphinxcode{\sphinxupquote{basisGroup}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Attribute:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{name}} / \sphinxcode{\sphinxupquote{id}}
&
Text
&
\sphinxstyleemphasis{Any}
&
” “
&
Name of atomic basis set
\\
\hline
\sphinxcode{\sphinxupquote{angular}}
&
Text
&
See below
&
Default
&
Type of angular functions
\\
\hline
\sphinxcode{\sphinxupquote{expandYlm}}
&
Text
&
See below
&
Yes
&
Expand Ylm shells?
\\
\hline
\sphinxcode{\sphinxupquote{expM}}
&
Text
&
See below
&
Yes
&
Add sign for \((-1)^{m}\)?
\\
\hline
\sphinxcode{\sphinxupquote{elementType/species}}
&
Text
&
\sphinxstyleemphasis{Any}
&
e
&
Atomic species where functions are centered
\\
\hline
\sphinxcode{\sphinxupquote{normalized}}
&
Text
&
Yes/no
&
Yes
&
Are single particle functions normalized?
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{center}Table 6 Options for the \sphinxcode{\sphinxupquote{atomicBasisSet}} xml\sphinxhyphen{}block.
\end{center}
\sphinxcode{\sphinxupquote{basicGroup}} element:


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{intro_wavefunction:table7}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements
&
\sphinxcode{\sphinxupquote{AtomicBasisSet}}
\\
\hline
Child elements
&
\sphinxcode{\sphinxupquote{radfunc}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Attribute:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{rid/id}}
&
Text
&
\sphinxstyleemphasis{Any}
&
‘’ ‘’
&
Name of the basisGroup
\\
\hline
\sphinxcode{\sphinxupquote{type}}
&
Text
&
\sphinxstyleemphasis{Any}
&
‘’ ‘’
&
Type of basisGroup
\\
\hline
\sphinxcode{\sphinxupquote{n/l/m/s}}
&
Integer
&
\sphinxstyleemphasis{Any}
&
0
&
Quantum numbers of basisGroup
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{center}\hyperref[\detokenize{intro_wavefunction:table7}]{Table \ref{\detokenize{intro_wavefunction:table7}}} Options for the \sphinxcode{\sphinxupquote{basisGroup}} xml\sphinxhyphen{}block.
\end{center}\sphinxSetupCaptionForVerbatim{Basic input block for \sphinxcode{\sphinxupquote{slaterdeterminant}} with an atom\sphinxhyphen{}centered \sphinxcode{\sphinxupquote{sposet}}.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-5}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{o}{\PYGZlt{}}\PYG{n}{slaterdeterminant}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{slaterdeterminant}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

element:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements:
&\\
\hline
Child elements:
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Attribute:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{name/id}}
&
Text
&
\sphinxstyleemphasis{Any}
&
‘’ ‘’
&
Name of determinant set
\\
\hline&
Text
&
\sphinxstyleemphasis{Any}
&
‘’ ‘’
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Detailed description of attributes:}
\label{\detokenize{intro_wavefunction:detailed-description-of-attributes}}
In the following, we give a more detailed description of all the options presented in the various xml\sphinxhyphen{}blocks described in this section. Only nontrivial attributes are described. Those with simple yes/no options and whose previous description is enough to explain the intended behavior are not included.

\sphinxcode{\sphinxupquote{determinantset}} attributes:
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{type}}}] \leavevmode
Type of \sphinxcode{\sphinxupquote{sposet}}. For atom\sphinxhyphen{}centered based \sphinxcode{\sphinxupquote{sposets}}, use type=”MolecularOrbital” or type=“MO.”
Other options described elsewhere in this manual are “spline,”
“composite,” “pw,” “heg,” “linearopt,” etc.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{keyword/key}}}] \leavevmode
Type of basis set generated, which does not necessarily match the type of basis set on the input block. The three possible options are: NMO (numerical molecular orbitals), GTO (Gaussian\sphinxhyphen{}type orbitals), and STO (Slater\sphinxhyphen{}type orbitals). The default option is NMO. By default, QMCPACK will generate numerical orbitals from both GTO and STO types and use cubic or quintic spline interpolation to evaluate the radial functions. This is typically more efficient than evaluating the radial functions in the native basis (Gaussians or exponents) and allows for arbitrarily large contractions without any additional cost. To force use of the native expansion (not recommended), use GTO or STO for each type of input basis set.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{transform}}}] \leavevmode
Request (or avoid) a transformation of the radial functions to NMO type. The default and recommended behavior is to transform to numerical radial functions. If \sphinxcode{\sphinxupquote{transform}} is set to \sphinxstyleemphasis{yes}, the option \sphinxcode{\sphinxupquote{keyword}} is ignored.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{cuspCorrection}}}] \leavevmode
Enable (disable) use of the cusp correction algorithm (CASINO REFERENCE) for a \sphinxcode{\sphinxupquote{basisset}} built with GTO functions. The algorithm is implemented as described in (CASINO REFERENCE) and works only with transform=”yes” and an input GTO basis set. No further input is needed.

\end{description}

\end{itemize}

\sphinxcode{\sphinxupquote{atomicBasisSet}} attributes:
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{name/id}}}] \leavevmode
Name of the basis set. Names should be unique.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{angular}}}] \leavevmode
Type of angular functions used in the expansion. In general, two angular basis functions are allowed: “spherical” (for spherical Ylm functions) and “Cartesian” (for functions of the type \(x^{n}y^{m}z^{l}\)).

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{expandYlm}}}] \leavevmode
Determines whether each basis group is expanded across the corresponding shell of m values (for spherical type) or consistent powers (for Cartesian functions). Options:
\begin{itemize}
\item {} 
“No”: Do not expand angular functions across corresponding angular shell.

\item {} 
“Gaussian”: Expand according to Gaussian03 format. This function is compatible only with angular=”spherical.” For a given input (l,m), the resulting order of the angular functions becomes (1,\sphinxhyphen{}1,0) for l=1 and (0,1,\sphinxhyphen{}1,2,\sphinxhyphen{}2,…,l,\sphinxhyphen{}l) for general l.

\item {} 
“Natural”: Expand angular functions according to (\sphinxhyphen{}l,\sphinxhyphen{}l+1,…,l\sphinxhyphen{}1,l).

\item {} 
“Gamess”: Expand according to Gamess’ format for Cartesian functions. Notice that this option is compatible only with angular=”Cartesian.” If angular=”Cartesian” is used, this option is not necessary.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{expM}}}] \leavevmode
Determines whether the sign of the spherical Ylm function associated with m (\(-1^{m}\)) is included in the coefficient matrix or not.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{elementType/species}}}] \leavevmode
Name of the species where basis functions are centered. Only one \sphinxcode{\sphinxupquote{atomicBasisSet}} block is allowed per species. Additional blocks are ignored. The corresponding species must exist in the \sphinxcode{\sphinxupquote{particleset}} given as the \sphinxcode{\sphinxupquote{source}} option to \sphinxcode{\sphinxupquote{determinantset}}. Basis functions for all the atoms of the corresponding species are included in the basis set, based on the order of atoms in the \sphinxcode{\sphinxupquote{particleset}}.

\end{description}

\end{itemize}

\sphinxcode{\sphinxupquote{basisGroup}} attributes:
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{type}}}] \leavevmode
Type of input basis radial function. Note that this refers to the type of radial function in the input xml\sphinxhyphen{}block, which might not match the radial function generated internally and used in the calculation (if \sphinxcode{\sphinxupquote{transform}} is set to “yes”). Also note that different \sphinxcode{\sphinxupquote{basisGroup}} blocks within a given \sphinxcode{\sphinxupquote{atomicBasisSet}} can have different \sphinxcode{\sphinxupquote{types}}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{n/l/m/s}}}] \leavevmode
Quantum numbers of the basis function. Note that if
\sphinxcode{\sphinxupquote{expandYlm}} is set to \sphinxstyleemphasis{“yes”} in \sphinxcode{\sphinxupquote{atomicBasisSet}}, a
full shell of basis functions with the appropriate values of
\sphinxstyleemphasis{“m”} will be defined for the corresponding value of
\sphinxstyleemphasis{“l.”} Otherwise a single basis function will be given for the
specific combination of \sphinxstyleemphasis{“(l,m).”}

\end{description}

\end{itemize}

\sphinxcode{\sphinxupquote{radfunc}} attributes for \sphinxcode{\sphinxupquote{type}} = \sphinxstyleemphasis{“Gaussian”}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{TBDoc}}

\end{itemize}

\sphinxcode{\sphinxupquote{slaterdeterminant}} attributes:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{TBDoc}}

\end{itemize}


\subsection{Hybrid orbital representation}
\label{\detokenize{intro_wavefunction:hybrid-orbital-representation}}\label{\detokenize{intro_wavefunction:spo-hybrid}}
The hybrid representation of the single particle orbitals combines a localized atomic basis set around atomic cores and B\sphinxhyphen{}splines in the interstitial regions to reduce memory use while retaining high evaluation speed and either retaining or increasing overall accuracy. Full details are provided in \sphinxcite{intro_wavefunction:luo2018hyb}, and \sphinxstylestrong{users of this feature are kindly requested to cite this paper}.
In practice, we have seen that using a meshfactor=0.5 is often possible and achieves huge memory savings.
\hyperref[\detokenize{intro_wavefunction:fig3}]{Fig.\@ \ref{\detokenize{intro_wavefunction:fig3}}} illustrates how the regions are assigned.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{hybrid_new}.jpg}
\caption{Regular and hybrid orbital representation. Regular B\sphinxhyphen{}spline representation (left panel) contains only one region and a sufficiently fine mesh to resolve orbitals near the nucleus. The hybrid orbital representation (right panel) contains near nucleus regions (A) where spherical harmonics and radial functions are used, buffers or interpolation regions (B), and an interstitial region (C) where a coarse B\sphinxhyphen{}spline mesh is used.}\label{\detokenize{intro_wavefunction:id29}}\label{\detokenize{intro_wavefunction:fig3}}\end{figure}

Orbitals within region A are computed as
\begin{equation*}
\begin{split}\phi^A_n({\bf r})=R_{n,l,m}(r)Y_{l,m}(\hat{r})\end{split}
\end{equation*}
Orbitals in region C are computed as the regular B\sphinxhyphen{}spline basis described in {\hyperref[\detokenize{intro_wavefunction:spo-spline}]{\sphinxcrossref{\DUrole{std,std-ref}{Spline basis sets}}}} above. The region B interpolates between A and C as
\begin{equation}\label{equation:intro_wavefunction:eq6}
\begin{split}\phi^B_n({\bf r}) = S(r) \phi^A_n({\bf r}) + (1-S(r))\phi^C_n({\bf r})\end{split}
\end{equation}\begin{equation}\label{equation:intro_wavefunction:eq7}
\begin{split}(S(r) = \frac{1}{2}-\frac{1}{2} tanh \left[\alpha\left(\frac{r-r_{\rm A/B}}{r_{\rm B/C}-r_{\rm A/B}}-\frac{1}{2}\right)\right]\end{split}
\end{equation}
To enable hybrid orbital representation, the input XML needs to see the tag \sphinxcode{\sphinxupquote{hybridrep="yes"}} shown in {\hyperref[\detokenize{intro_wavefunction:listing-6}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 6}}}}.
\sphinxSetupCaptionForVerbatim{Hybrid orbital representation input example.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-6}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{determinantset} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pwscf.h5}\PYG{l+s+s2}{\PYGZdq{}}
              \PYG{n}{tilematrix}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1 1 3 1 2 \PYGZhy{}1 \PYGZhy{}2 1 0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{twistnum}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{gpu}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{meshfactor}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.8}\PYG{l+s+s2}{\PYGZdq{}}
              \PYG{n}{twist}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0  0  0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{precision}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{single}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{hybridrep}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinantset}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Second, the information describing the atomic regions is required in the particle set, shown in {\hyperref[\detokenize{intro_wavefunction:listing-7}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 7}}}}.
\sphinxSetupCaptionForVerbatim{particleset elements for ions with information needed by hybrid orbital representation.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-7}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ni}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}          \PYG{l+m+mi}{18} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{valence}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}         \PYG{l+m+mi}{18} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{atomicnumber}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZgt{}}   \PYG{l+m+mi}{28} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cutoff\PYGZus{}radius}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1.6} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{inner\PYGZus{}cutoff}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZgt{}}  \PYG{l+m+mf}{1.3} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lmax}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZgt{}}            \PYG{l+m+mi}{5} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spline\PYGZus{}radius}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1.8} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spline\PYGZus{}npoints}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{91} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

The parameters specific to hybrid representation are listed as

\sphinxcode{\sphinxupquote{attrib}} element

Attribute:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{cutoff\_radius}}
&
Real
&
\textgreater{}=0.0
&
\sphinxstyleemphasis{None}
&
Cutoff radius for B/C boundary
\\
\hline
\sphinxcode{\sphinxupquote{lmax}}
&
Integer
&
\textgreater{}=0
&
\sphinxstyleemphasis{None}
&
Largest angular channel
\\
\hline
\sphinxcode{\sphinxupquote{inner\_cutoff}}
&
Real
&
\textgreater{}=0.0
&
Dep.
&
Cutoff radius for A/B boundary
\\
\hline
\sphinxcode{\sphinxupquote{spline\_radius}}
&
Real
&
\textgreater{}0.0
&
Dep.
&
Radial function radius used in spine
\\
\hline
\sphinxcode{\sphinxupquote{spline\_npoints}}
&
Integer
&
\textgreater{}0
&
Dep.
&
Number of spline knots
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{cutoff\_radius}}  is required for every species. If a species is intended to not be covered by atomic regions, setting the value 0.0 will put default values for all the reset parameters. A good value is usually a bit larger than the core radius listed in the pseudopotential file. After a parametric scan, pick the one from the flat energy region with the smallest variance.

\item {} 
\sphinxcode{\sphinxupquote{lmax}} is required if \sphinxcode{\sphinxupquote{cutoff\_radius}} \(>\) 0.0. This value usually needs to be at least the highest angular momentum plus 2.

\item {} 
\sphinxcode{\sphinxupquote{inner\_cutoff}} is optional and set as \sphinxcode{\sphinxupquote{cutoff\_radius}} \(-0.3\) by default, which is fine in most cases.

\item {} 
\sphinxcode{\sphinxupquote{spline\_radius}} and \sphinxcode{\sphinxupquote{spline\_npoints}} are optional. By default, they are calculated based on \sphinxcode{\sphinxupquote{cutoff\_radius}} and a grid displacement 0.02 bohr.
If users prefer inputing them, it is required that \sphinxcode{\sphinxupquote{cutoff\_radius}} \textless{}=  \sphinxcode{\sphinxupquote{spline\_radius}} \(-\) 2 \(\times\) \sphinxcode{\sphinxupquote{spline\_radius}}/(\sphinxcode{\sphinxupquote{spline\_npoints}} \(-\) 1).

\end{itemize}

In addition, the hybrid orbital representation allows extra optimization to speed up the nonlocal pseudopotential evaluation using the batched algorithm listed in {\hyperref[\detokenize{hamiltonianobservable:nlpp}]{\sphinxcrossref{\DUrole{std,std-ref}{Pseudopotentials}}}}.


\subsection{Plane\sphinxhyphen{}wave basis sets}
\label{\detokenize{intro_wavefunction:plane-wave-basis-sets}}\label{\detokenize{intro_wavefunction:pwbasis}}

\subsection{Homogeneous electron gas}
\label{\detokenize{intro_wavefunction:homogeneous-electron-gas}}\label{\detokenize{intro_wavefunction:hegbasis}}
The interacting Fermi liquid has its own special \sphinxcode{\sphinxupquote{determinantset}} for filling up a
Fermi surface.  The shell number can be specified separately for both spin\sphinxhyphen{}up and spin\sphinxhyphen{}down.
This determines how many electrons to include of each time; only closed shells are currently
implemented.  The shells are filled according to the rules of a square box; if other lattice
vectors are used, the electrons might not fill up a complete shell.

This following example can also be used for Helium simulations by specifying the
proper pair interaction in the Hamiltonian section.
\sphinxSetupCaptionForVerbatim{2D Fermi liquid example: particle specification}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-8}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{qmcsystem}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{simulationcell} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{global}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{rs}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{pol}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{condition}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{74}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{6.5}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bconds}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{p} \PYG{n}{p} \PYG{n}{p}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LR\PYGZus{}dim\PYGZus{}cutoff}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{15}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{simulationcell}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{particleset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{random}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{37}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mass}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{37}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mass}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{particleset}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmcsystem}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{2D Fermi liquid example (Slater Jastrow wavefunction)}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-9}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{qmcsystem}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{wavefunction} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{psi0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{determinantset} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{electron\PYGZhy{}gas}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{shell}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{7}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{shell2}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{7}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{randomize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{true}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinantset}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{J2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Two\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{function}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{print}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{speciesA}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{speciesB}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{cusp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{uu}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{speciesA}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{speciesB}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{cusp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ud}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\section{Jastrow Factors}
\label{\detokenize{intro_wavefunction:jastrow-factors}}\label{\detokenize{intro_wavefunction:jastrow}}
Jastrow factors are among the simplest and most effective ways of including
dynamical correlation in the trial many body wavefunction.  The resulting many body
wavefunction is expressed as the product of an antisymmetric (in the case
of Fermions) or symmetric (for Bosons) part and a correlating Jastrow factor
like so:
\begin{equation}\label{equation:intro_wavefunction:eq8}
\begin{split}\Psi(\vec{R}) = \mathcal{A}(\vec{R}) \exp\left[J(\vec{R})\right]\end{split}
\end{equation}
In this section we will detail the types and forms of Jastrow factor used
in QMCPACK.  Note that each type of Jastrow factor needs to be specified using
its own individual \sphinxcode{\sphinxupquote{jastrow}} XML element.  For this reason, we have repeated the
specification of the \sphinxcode{\sphinxupquote{jastrow}} tag in each section, with specialization for the
options available for that given type of Jastrow.


\subsection{One\sphinxhyphen{}body Jastrow functions}
\label{\detokenize{intro_wavefunction:one-body-jastrow-functions}}\label{\detokenize{intro_wavefunction:onebodyjastrow}}
The one\sphinxhyphen{}body Jastrow factor is a form that allows for the direct inclusion
of correlations between particles that are included in the wavefunction with
particles that are not explicitly part of it.  The most common example of
this are correlations between electrons and ions.

The Jastrow function is specified within a \sphinxcode{\sphinxupquote{wavefunction}} element
and must contain one or more \sphinxcode{\sphinxupquote{correlation}} elements specifying
additional parameters as well as the actual coefficients.
{\hyperref[\detokenize{intro_wavefunction:bjsplineexamples}]{\sphinxcrossref{\DUrole{std,std-ref}{Example use cases}}}} gives examples of the typical nesting of
\sphinxcode{\sphinxupquote{jastrow}}, \sphinxcode{\sphinxupquote{correlation}}, and \sphinxcode{\sphinxupquote{coefficient}} elements.


\subsubsection{Input Specification}
\label{\detokenize{intro_wavefunction:input-specification}}
Jastrow element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

\sphinxstylestrong{name}
&
\sphinxstylestrong{datatype}
&
\sphinxstylestrong{values}
&
\sphinxstylestrong{defaults}
&
\sphinxstylestrong{description}
\\
\hline
name
&
text
&&
(required)
&
Unique name
for this
Jastrow
function
\\
\hline
type
&
text
&
One\sphinxhyphen{}body
&
(required)
&
Define a
one\sphinxhyphen{}body
function
\\
\hline
function
&
text
&
Bspline
&
(required)
&
BSpline
Jastrow
\\
\hline&
text
&
pade2
&&
Pade form
\\
\hline&
text
&
…
&&
…
\\
\hline
source
&
text
&
name
&
(required)
&
Name of
attribute of
classical
particle set
\\
\hline
print
&
text
&
yes / no
&
yes
&
Jastrow
factor
printed in
external
file?
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

elements
&&&&\\
\hline&
Correlation
&&&\\
\hline
Contents
&&&&\\
\hline&
(None)
&&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

To be more concrete, the one\sphinxhyphen{}body Jastrow factors used to describe correlations
between electrons and ions take the form below:
\begin{equation}\label{equation:intro_wavefunction:eq9}
\begin{split}J1=\sum_I^{ion0}\sum_i^e u_{ab}(|r_i-R_I|)\end{split}
\end{equation}
where I runs over all of the ions in the calculation, i runs over the
electrons and \(u_{ab}\) describes the functional form of the
correlation between them. Many different forms of \(u_{ab}\) are
implemented in QMCPACK. We will detail two of the most common ones
below.


\paragraph{Spline form}
\label{\detokenize{intro_wavefunction:spline-form}}\label{\detokenize{intro_wavefunction:onebodyjastrowspline}}
The one\sphinxhyphen{}body spline Jastrow function is the most commonly used one\sphinxhyphen{}body
Jastrow for solids. This form was first described and used in
\sphinxcite{running:eslerkimceperleyshulenburger2012}. Here
\(u_{ab}\) is an interpolating 1D B\sphinxhyphen{}spline (tricublc spline on a
linear grid) between zero distance and \(r_{cut}\). In 3D periodic
systems the default cutoff distance is the Wigner Seitz cell radius. For
other periodicities, including isolated molecules, the \(r_{cut}\)
must be specified. The cusp can be set. \(r_i\) and \(R_I\) are
most commonly the electron and ion positions, but any particlesets that
can provide the needed centers can be used.

Correlation element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

\sphinxstylestrong{Name}
&
\sphinxstylestrong{Datatype}
&
\sphinxstylestrong{Values}
&
\sphinxstylestrong{Defaults}
&
\sphinxstylestrong{Description}
\\
\hline
ElementType
&
Text
&
Name
&
See below
&
Classical
particle
target
\\
\hline
SpeciesA
&
Text
&
Name
&
See below
&
Classical
particle
target
\\
\hline
SpeciesB
&
Text
&
Name
&
See below
&
Quantum
species
target
\\
\hline
Size
&
Integer
&
\(> 0\)
&
(Required)
&
Number of
coefficients
\\
\hline
Rcut
&
Real
&
\(> 0\)
&
See below
&
Distance at
which the
correlation
goes to 0
\\
\hline
Cusp
&
Real
&
\(\ge 0\)
&
0
&
Value for
use in Kato
cusp
condition
\\
\hline
Spin
&
Text
&
Yes or no
&
No
&
Spin
dependent
Jastrow
factor
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

Elements
&&&&\\
\hline&
Coefficients
&&&\\
\hline
Contents
&&&&\\
\hline&
(None)
&&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{elementType, speciesA, speciesB, spin}}}] \leavevmode
For a spin\sphinxhyphen{}independent Jastrow factor (spin = “no”), elementType
should be the name of the group of ions in the classical particleset to
which the quantum particles should be correlated. For a spin\sphinxhyphen{}dependent
Jastrow factor (spin = “yes”), set speciesA to the group name in the
classical particleset and speciesB to the group name in the quantum
particleset.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{rcut}}}] \leavevmode
The cutoff distance for the function in atomic units (bohr). For 3D
fully periodic systems, this parameter is optional, and a default of the
Wigner Seitz cell radius is used. Otherwise this parameter is required.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{cusp}}}] \leavevmode
The one\sphinxhyphen{}body Jastrow factor can be used to make the wavefunction
satisfy the electron\sphinxhyphen{}ion cusp condition :cite:\sphinxcode{\sphinxupquote{kato}}. In this
case, the derivative of the Jastrow factor as the electron approaches
the nucleus will be given by

\end{description}

\end{itemize}
\begin{equation}\label{equation:intro_wavefunction:eq10}
\begin{split}\left(\frac{\partial J}{\partial r_{iI}}\right)_{r_{iI} = 0} = -Z .\end{split}
\end{equation}
Note that if the antisymmetric part of the wavefunction satisfies the electron\sphinxhyphen{}ion cusp
condition (for instance by using single\sphinxhyphen{}particle orbitals that respect the cusp condition)
or if a nondivergent pseudopotential is used, the Jastrow should be cuspless at the
nucleus and this value should be kept at its default of 0.

Coefficients element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

\sphinxstylestrong{Name}
&
\sphinxstylestrong{Datatype}
&
\sphinxstylestrong{Values}
&
\sphinxstylestrong{Defaults}
&
\sphinxstylestrong{Description}
\\
\hline
Id
&
Text
&&
(Required)
&
Unique
identifier
\\
\hline
Type
&
Text
&
Array
&
(Required)
&\\
\hline
Optimize
&
Text
&
Yes or no
&
Yes
&
if no,
values are
fixed in
optimizations
\\
\hline&&&&\\
\hline
Elements
&&&&\\
\hline
(None)
&&&&\\
\hline
Contents
&&&&\\
\hline
(No name)
&
Real array
&&
Zeros
&
Jastrow
coefficients
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\paragraph{Example use cases}
\label{\detokenize{intro_wavefunction:example-use-cases}}\label{\detokenize{intro_wavefunction:bjsplineexamples}}
Specify a spin\sphinxhyphen{}independent function with four parameters. Because rcut  is not
specified, the default cutoff of the Wigner Seitz cell radius is used; this
Jastrow must be used with a 3D periodic system such as a bulk solid. The name of
the particleset holding the ionic positions is “i.”

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{J1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{One\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{function}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{print}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{cusp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}  \PYG{l+m+mi}{0}  \PYG{l+m+mi}{0}  \PYG{l+m+mi}{0}  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Specify a spin\sphinxhyphen{}dependent function with seven up\sphinxhyphen{}spin and seven down\sphinxhyphen{}spin parameters.
The cutoff distance is set to 6 atomic units.  Note here that the particleset holding
the ions is labeled as ion0 rather than “i,” as in the other example.  Also in this case,
the ion is lithium with a coulomb potential, so the cusp condition is satisfied by
setting cusp=”d.”

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{J1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{One\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{function}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{spin}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{speciesA}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Li}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{speciesB}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{7}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{eLiu}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{cusp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{speciesA}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{speciesB}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{7}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{eLid}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{cusp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\paragraph{Pade form}
\label{\detokenize{intro_wavefunction:pade-form}}\label{\detokenize{intro_wavefunction:onebodyjastrowpade}}
Although the spline Jastrow factor is the most flexible and most commonly used form implemented in QMCPACK,
there are times where its flexibility can make it difficult to optimize.  As an example, a spline Jastrow
with a very large cutoff can be difficult to optimize for isolated systems such as molecules because of the small
number of samples present in the tail of the function.  In such cases, a simpler functional
form might be advantageous.  The second\sphinxhyphen{}order Pade Jastrow factor, given in \eqref{equation:intro_wavefunction:eq11}, is a good choice
in such cases.
\begin{equation}\label{equation:intro_wavefunction:eq11}
\begin{split}u_{ab}(r) = \frac{a*r+c*r^2}{1+b*r}\end{split}
\end{equation}
Unlike the spline Jastrow factor, which includes a cutoff, this form has an infinite range and will be applied to every particle
pair (subject to the minimum image convention).  It also is a cuspless Jastrow factor,
so it should be used either in combination with a single particle basis set that contains the proper cusp or
with a smooth pseudopotential.

Correlation element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

\sphinxstylestrong{Name}
&
\sphinxstylestrong{Datatype}
&
\sphinxstylestrong{Values}
&
\sphinxstylestrong{Defaults}
&
\sphinxstylestrong{Description}
\\
\hline
ElementType
&
Text
&
Name
&
See below
&
Classical particle target
\\
\hline
Elements
&&&&\\
\hline&
Coefficients
&&&\\
\hline
Contents
&&&&\\
\hline&
(None)
&&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Parameter element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

\sphinxstylestrong{Name}
&
\sphinxstylestrong{Datatype}
&
\sphinxstylestrong{Values}
&
\sphinxstylestrong{Defaults}
&
\sphinxstylestrong{Description}
\\
\hline
Id
&
String
&
Name
&
(Required)
&
Name for
variable
\\
\hline
Name
&
String
&
A or B or C
&
(Required)
&
See
\eqref{equation:intro_wavefunction:eq11}
\\
\hline
Optimize
&
Text
&
Yes or no
&
Yes
&
If no,
values are
fixed in
optimizations
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

Elements
&&&&\\
\hline
(None)
&&&&\\
\hline
Contents
&&&&\\
\hline
(No name)
&
Real
&
Parameter
value
&
(Required)
&
Jastrow
coefficients
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\paragraph{Example use case}
\label{\detokenize{intro_wavefunction:example-use-case}}\label{\detokenize{intro_wavefunction:bjpadeexamples}}
Specify a spin\sphinxhyphen{}independent function with independent Jastrow factors for two different species (Li and H).
The name of the particleset holding the ionic positions is “i.”

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{J1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{function}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pade2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{One\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{print}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Li}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{var} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LiA}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mf}{0.34} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{var}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{var} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LiB}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{B}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{12.78} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{var}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{var} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LiC}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mf}{1.62} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{var}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{var} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HA}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mf}{0.14} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{var}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{var} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HB}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{B}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{6.88} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{var}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{var} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HC}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.237} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{var}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\paragraph{Short Range Cusp Form}
\label{\detokenize{intro_wavefunction:short-range-cusp-form}}
The idea behind this functor is to encode nuclear cusps and other details at very
short range around a nucleus in the region that the Gaussian orbitals of quantum
chemistry are not capable of describing correctly.
The functor is kept short ranged, because outside this small region, quantum chemistry
orbital expansions are already capable of taking on the correct shapes.
Unlike a pre\sphinxhyphen{}computed cusp correction, this optimizable functor can respond to
changes in the wave function during VMC optimization.
The functor’s form is
\begin{equation}\label{equation:intro_wavefunction:eq12}
\begin{split}u(r) = -\exp{\left(-r/R_0\right)} \left( A R_0 + \sum_{k=0}^{N-1} B_k \frac{ (r/R_0)^{k+2} }{ 1 + (r/R_0)^{k+2} } \right)\end{split}
\end{equation}
in which \(R_0\) acts as a soft cutoff radius (\(u(r)\) decays to zero quickly beyond roughly this distance)
and \(A\) determines the cusp condition.
\begin{equation}\label{equation:intro_wavefunction:eq13}
\begin{split}\lim_{r \to 0} \frac{\partial u}{\partial r} = A\end{split}
\end{equation}
The simple exponential decay is modified by the \(N\) coefficients
\(B_k\) that define an expansion in sigmoidal functions, thus adding
detailed structure in a short\sphinxhyphen{}ranged region around a nucleus while
maintaining the correct cusp condition at the nucleus. Note that
sigmoidal functions are used instead of, say, a bare polynomial
expansion, as they trend to unity past the soft cutoff radius and so
interfere less with the exponential decay that keeps the functor short
ranged. Although \(A\), \(R_0\), and the \(B_k\)
coefficients can all be optimized as variational parameters, \(A\)
will typically be fixed as the desired cusp condition is known.

To specify this one\sphinxhyphen{}body Jastrow factor, use an input section like the following.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{J1Cusps}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{One\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{function}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{shortrangecusp}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{print}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{cusp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Li}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{var} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LiCuspR0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{R0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.06} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{var}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LiCuspB}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{cusp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{var} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HCuspR0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{R0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.2} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{var}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HCuspB}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Here “rcut” is specified as the range beyond which the functor is
assumed to be zero. The value of \(A\) can either be specified via
the “cusp” option as shown above, in which case its optimization is
disabled, or through its own “var” line as for \(R_0\), in which
case it can be specified as either optimizable (“yes”) or not (“no”).
The coefficients \(B_k\) are specified via the “coefficients”
section, with the length \(N\) of the expansion determined
automatically based on the length of the array.

Note that this one\sphinxhyphen{}body Jastrow form can (and probably should) be used in conjunction
with a longer ranged one\sphinxhyphen{}body Jastrow, such as a spline form.
Be sure to set the longer\sphinxhyphen{}ranged Jastrow to be cusp\sphinxhyphen{}free!


\subsection{Two\sphinxhyphen{}body Jastrow functions}
\label{\detokenize{intro_wavefunction:two-body-jastrow-functions}}
The two\sphinxhyphen{}body Jastrow factor is a form that allows for the explicit inclusion
of dynamic correlation between two particles included in the wavefunction.  It
is almost always given in a spin dependent form so as to satisfy the Kato cusp
condition between electrons of different spins \sphinxcite{intro_wavefunction:kato}.

The two body Jastrow function is specified within a \sphinxcode{\sphinxupquote{wavefunction}} element
and must contain one or more correlation elements specifying additional parameters
as well as the actual coefficients.  {\hyperref[\detokenize{intro_wavefunction:id11}]{\sphinxcrossref{\DUrole{std,std-ref}{Example use cases}}}} gives
examples of the typical nesting of \sphinxcode{\sphinxupquote{jastrow}}, \sphinxcode{\sphinxupquote{correlation}} and
\sphinxcode{\sphinxupquote{coefficient}} elements.


\subsubsection{Input Specification}
\label{\detokenize{intro_wavefunction:id8}}
Jastrow element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

\sphinxstylestrong{name}
&
\sphinxstylestrong{datatype}
&
\sphinxstylestrong{values}
&
\sphinxstylestrong{defaults}
&
\sphinxstylestrong{description}
\\
\hline
name
&
text
&&
(required)
&
Unique name
for this
Jastrow
function
\\
\hline
type
&
text
&
Two\sphinxhyphen{}body
&
(required)
&
Define a
one\sphinxhyphen{}body
function
\\
\hline
function
&
text
&
Bspline
&
(required)
&
BSpline
Jastrow
\\
\hline
print
&
text
&
yes / no
&
yes
&
Jastrow
factor
printed in
external
file?
\\
\hline&&&&\\
\hline
elements
&&&&\\
\hline&
Correlation
&&&\\
\hline
Contents
&&&&\\
\hline&
(None)
&&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

The two\sphinxhyphen{}body Jastrow factors used to describe correlations between electrons take the form
\begin{equation}\label{equation:intro_wavefunction:eq14}
\begin{split}J2=\sum_i^{e}\sum_{j>i}^{e} u_{ab}(|r_i-r_j|)\end{split}
\end{equation}
The most commonly used form of two body Jastrow factor supported by the code is a splined
Jastrow factor, with many similarities to the one body spline Jastrow.


\paragraph{Spline form}
\label{\detokenize{intro_wavefunction:twobodyjastrowspline}}\label{\detokenize{intro_wavefunction:id9}}
The two\sphinxhyphen{}body spline Jastrow function is the most commonly used two\sphinxhyphen{}body
Jastrow for solids. This form was first described and used in
\sphinxcite{running:eslerkimceperleyshulenburger2012}. Here
\(u_{ab}\) is an interpolating 1D B\sphinxhyphen{}spline (tricublc spline on a
linear grid) between zero distance and \(r_{cut}\). In 3D periodic
systems, the default cutoff distance is the Wigner Seitz cell radius.
For other periodicities, including isolated molecules, the
\(r_{cut}\) must be specified. \(r_i\) and \(r_j\) are
typically electron positions. The cusp condition as \(r_i\)
approaches \(r_j\) is set by the relative spin of the electrons.

Correlation element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

\sphinxstylestrong{Name}
&
\sphinxstylestrong{Datatype}
&
\sphinxstylestrong{Values}
&
\sphinxstylestrong{Defaults}
&
\sphinxstylestrong{Description}
\\
\hline
SpeciesA
&
Text
&
U or d
&
(Required)
&
Quantum
species
target
\\
\hline
SpeciesB
&
Text
&
U or d
&
(Required)
&
Quantum
species
target
\\
\hline
Size
&
Integer
&
\(> 0\)
&
(Required)
&
Number of
coefficients
\\
\hline
Rcut
&
Real
&
\(> 0\)
&
See below
&
Distance at
which the
correlation
goes to 0
\\
\hline
Spin
&
Text
&
Yes or no
&
No
&
Spin\sphinxhyphen{}dependent
Jastrow factor
\\
\hline&&&&\\
\hline
Elements
&&&&\\
\hline&
Coefficients
&&&\\
\hline
Contents
&&&&\\
\hline&
(None)
&&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{speciesA, speciesB}} The scale function u(r) is defined for species pairs uu and ud.

\end{itemize}

There is no need to define ud or dd since uu=dd and ud=du.  The cusp condition is computed internally
based on the charge of the quantum particles.

Coefficients element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

\sphinxstylestrong{Name}
&
\sphinxstylestrong{Datatype}
&
\sphinxstylestrong{Values}
&
\sphinxstylestrong{Defaults}
&
\sphinxstylestrong{Description}
\\
\hline
Id
&
Text
&&
(Required)
&
Unique
identifier
\\
\hline
Type
&
Text
&
Array
&
(Required)
&\\
\hline
Optimize
&
Text
&
Yes or no
&
Yes
&
If no,
values are
fixed in
optimizations
\\
\hline&&&&\\
\hline
Elements
&&&&\\
\hline
(None)
&&&&\\
\hline
Contents
&&&&\\
\hline
(No name)
&
Real array
&&
Zeros
&
Jastrow
coefficients
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\paragraph{Example use cases}
\label{\detokenize{intro_wavefunction:id11}}\label{\detokenize{intro_wavefunction:id12}}
Specify a spin\sphinxhyphen{}dependent function with four parameters for each channel.  In this case, the cusp is set at
a radius of 4.0 bohr (rather than to the default of the Wigner Seitz cell radius).  Also, in this example,
the coefficients are set to not be optimized during an optimization step.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{J2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Two\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{function}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{print}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{speciesA}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{speciesB}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{uu}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.2309049836} \PYG{l+m+mf}{0.1312646071} \PYG{l+m+mf}{0.05464141356} \PYG{l+m+mf}{0.01306231516}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{speciesA}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{speciesB}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ud}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.4351561096} \PYG{l+m+mf}{0.2377951747} \PYG{l+m+mf}{0.1129144262} \PYG{l+m+mf}{0.0356789236}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{User defined functional form}
\label{\detokenize{intro_wavefunction:user-defined-functional-form}}\label{\detokenize{intro_wavefunction:jastrowuserform}}
To aid in implementing different forms for \(u_{ab}(r)\), there is a
script that uses a symbolic expression to generate the appropriate code
(with spatial and parameter derivatives). The script is located in
\sphinxcode{\sphinxupquote{src/QMCWaveFunctions/Jastrow/codegen/user\_jastrow.py}}. The script
requires Sympy (www.sympy.org) for symbolic mathematics and code
generation.

To use the script, modify it to specify the functional form and a list
of variational parameters. Optionally, there may be fixed parameters \sphinxhyphen{}
ones that are specified in the input file, but are not part of the
variational optimization. Also one symbol may be specified that accepts
a cusp value in order to satisfy the cusp condition. There are several
example forms in the script. The default form is the simple Padé.

Once the functional form and parameters are specified in the script, run
the script from the \sphinxcode{\sphinxupquote{codegen}} directory and recompile QMCPACK. The
main output of the script is the file
\sphinxcode{\sphinxupquote{src/QMCWaveFunctions/Jastrow/UserFunctor.h}}. The script also prints
information to the screen, and one section is a sample XML input block
containing all the parameters.

There is a unit test in
\sphinxcode{\sphinxupquote{src/QMCWaveFunctions/test/test\_user\_jastrow.cpp}} to perform some
minimal testing of the Jastrow factor. The unit test will need updating
to properly test new functional forms. Most of the changes relate to the
number and name of variational parameters.

Jastrow element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

\sphinxstylestrong{name}
&
\sphinxstylestrong{datatype}
&
\sphinxstylestrong{values}
&
\sphinxstylestrong{defaults}
&
\sphinxstylestrong{description}
\\
\hline
name
&
text
&&
(required)
&
Unique name
for this
Jastrow
function
\\
\hline
type
&
text
&
One\sphinxhyphen{}body
&
(required)
&
Define a
one\sphinxhyphen{}body
function
\\
\hline&&
Two\sphinxhyphen{}body
&
(required)
&
Define a
two\sphinxhyphen{}body
function
\\
\hline
function
&
text
&
user
&
(required)
&
User\sphinxhyphen{}defined
functor
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

See other parameters as appropriate for one or two\sphinxhyphen{}body functions


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

elements
&&&&\\
\hline&
Correlation
&&&\\
\hline
Contents
&&&&\\
\hline&
(None)
&&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\subsection{Long\sphinxhyphen{}ranged Jastrow factors}
\label{\detokenize{intro_wavefunction:long-ranged-jastrow-factors}}
While short\sphinxhyphen{}ranged Jastrow factors capture the majority of the benefit
for minimizing the total energy and the energy variance, long\sphinxhyphen{}ranged
Jastrow factors are important to accurately reproduce the short\sphinxhyphen{}ranged
(long wavelength) behavior of quantities such as the static structure
factor, and are therefore essential for modern accurate finite size
corrections in periodic systems.

Below two types of long\sphinxhyphen{}ranged Jastrow factors are described. The first
(the k\sphinxhyphen{}space Jastrow) is simply an expansion of the one and/or two body
correlation functions in plane waves, with the coefficients comprising
the optimizable parameters. The second type have few variational
parameters and use the optimized breakup method of Natoli and
Ceperley \sphinxcite{design_features:natoli1995} (the Yukawa and Gaskell RPA
Jastrows).


\subsubsection{Long\sphinxhyphen{}ranged Jastrow: k\sphinxhyphen{}space Jastrow}
\label{\detokenize{intro_wavefunction:long-ranged-jastrow-k-space-jastrow}}
The k\sphinxhyphen{}space Jastrow introduces explicit long\sphinxhyphen{}ranged dependence commensurate with the periodic supercell.  This Jastrow is to be used in periodic boundary conditions only.

The input for the k\sphinxhyphen{}space Jastrow fuses both one and two\sphinxhyphen{}body forms into a single element and so they are discussed together here.  The one\sphinxhyphen{} and two\sphinxhyphen{}body terms in the k\sphinxhyphen{}Space Jastrow have the form:
\begin{equation}\label{equation:intro_wavefunction:eq15}
\begin{split}J_1 = \sum_{G\ne 0}b_G\rho_G^I\rho_{-G}\end{split}
\end{equation}\begin{equation}\label{equation:intro_wavefunction:eq16}
\begin{split}J_2 = \sum_{G\ne 0}a_G\rho_G\rho_{-G}\end{split}
\end{equation}
Here \(\rho_G\) is the Fourier transform of the instantaneous electron density:
\begin{equation}\label{equation:intro_wavefunction:eq17}
\begin{split}\rho_G=\sum_{n\in electrons}e^{iG\cdot r_n}\end{split}
\end{equation}
and \(\rho_G^I\) has the same form, but for the fixed ions. In both cases the coefficients are restricted to be real, though in general the coefficients for the one\sphinxhyphen{}body term need not be.  See {\hyperref[\detokenize{design_features:feature-kspace-jastrow}]{\sphinxcrossref{\DUrole{std,std-ref}{Feature: Reciprocal\sphinxhyphen{}space Jastrow factors}}}} for more detail.

Input for the k\sphinxhyphen{}space Jastrow follows the familar nesting of \sphinxcode{\sphinxupquote{jastrow\sphinxhyphen{}correlation\sphinxhyphen{}coefficients}} elements, with attributes unique to the k\sphinxhyphen{}space Jastrow at the \sphinxcode{\sphinxupquote{correlation}} input level.

\sphinxcode{\sphinxupquote{jastrow type=kSpace}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{wavefunction}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{correlation}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{kSpace}
&&
must be kSpace
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
0
&
Unique name for Jastrow
\\
\hline
\sphinxcode{\sphinxupquote{source}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&&
Ion particleset name
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

\sphinxcode{\sphinxupquote{correlation}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{jastrow type=kSpace}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{coefficients}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{One\sphinxhyphen{}body, Two\sphinxhyphen{}Body}
&&
Must be One\sphinxhyphen{}body/Two\sphinxhyphen{}body
\\
\hline
\sphinxcode{\sphinxupquote{kc}}\(^r\)
&
real
&
kc \(\ge\) 0
&
0.0
&
k\sphinxhyphen{}space cutoff in a.u.
\\
\hline
\sphinxcode{\sphinxupquote{symmetry}}\(^o\)
&
text
&
crystal,isotropic,none
&
crystal
&
symmetry of coefficients
\\
\hline
\sphinxcode{\sphinxupquote{spinDependent}}\(^o\)
&
boolean
&
yes,no
&
no
&
\sphinxstyleemphasis{No current function}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

\sphinxcode{\sphinxupquote{coefficients}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{correlation}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{id}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
cG1/cG2
&
Label for coeffs
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{Array}}
&
0
&
Must be Array
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

body text: The body text is a list of real values for the parameters.
\end{quote}

Additional information:
\begin{itemize}
\item {} 
It is normal to provide no coefficients as an initial guess. The
number of coefficients will be automatically calculated according to
the k\sphinxhyphen{}space cutoff + symmetry and set to zero.

\item {} 
Providing an incorrect number of parameters also results in all
parameters being set to zero.

\item {} 
There is currently no way to turn optimization on/off for the k\sphinxhyphen{}space
Jastrow. The coefficients are always optimized.

\item {} 
Spin dependence is currently not implemented for this Jastrow.

\item {} 
\sphinxcode{\sphinxupquote{kc}}: Parameters with G vectors magnitudes less than \sphinxcode{\sphinxupquote{kc}} are
included in the Jastrow. If \sphinxcode{\sphinxupquote{kc}} is zero, it is the same as
excluding the k\sphinxhyphen{}space term.

\item {} 
\sphinxcode{\sphinxupquote{symmetry=crystal}}: Impose crystal symmetry on coefficients
according to the structure factor.

\item {} 
\sphinxcode{\sphinxupquote{symmetry=isotropic}}: Impose spherical symmetry on coefficients
according to G\sphinxhyphen{}vector magnitude.

\item {} 
\sphinxcode{\sphinxupquote{symmetry=none}}: Impose no symmetry on the coefficients.

\end{itemize}
\sphinxSetupCaptionForVerbatim{k\sphinxhyphen{}space Jastrow with one\sphinxhyphen{} and two\sphinxhyphen{}body terms.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-10}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{kSpace}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Jk}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{kc}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{One\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{symmetry}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cystal}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cG1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{kc}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Two\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{symmetry}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{crystal}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cG2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{k\sphinxhyphen{}space Jastrow with one\sphinxhyphen{}body term only.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-11}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{kSpace}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Jk}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{kc}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{One\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{symmetry}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{crystal}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cG1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{k\sphinxhyphen{}space Jastrow with two\sphinxhyphen{}body term only.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-12}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{kSpace}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Jk}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{kc}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Two\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{symmetry}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{crystal}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cG2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\paragraph{Long\sphinxhyphen{}ranged Jastrows: Gaskell RPA and Yukawa forms}
\label{\detokenize{intro_wavefunction:long-ranged-jastrows-gaskell-rpa-and-yukawa-forms}}\label{\detokenize{intro_wavefunction:twobodyjastrowlr}}
\sphinxstylestrong{NOTE: The Yukawa and RPA Jastrows do not work at present
and are currently being revived.  Please contact the developers if
you are interested in using them.}

The exact Jastrow correlation functions contain terms which have a
form similar to the Coulomb pair potential.  In periodic systems
the Coulomb potential is replaced by an Ewald summation of the
bare potential over all periodic image cells.  This sum is often
handled by the optimized breakup method \sphinxcite{design_features:natoli1995} and this
same approach is applied to the long\sphinxhyphen{}ranged Jastrow factors in QMCPACK.

There are two main long\sphinxhyphen{}ranged Jastrow factors of this type
implemented in QMCPACK: the Gaskell RPA \sphinxcite{intro_wavefunction:gaskell1961}\sphinxcite{intro_wavefunction:gaskell1962}
form and the \sphinxcite{intro_wavefunction:ceperley1978} form.  Both of these forms
were used by Ceperley in early studies of the electron gas \sphinxcite{intro_wavefunction:ceperley1978},
but they are also appropriate starting points for general solids.

The Yukawa form is defined in real space.  It’s long\sphinxhyphen{}range form is
formally defined as
\begin{equation}\label{equation:intro_wavefunction:eq18}
\begin{split}u_Y^{PBC}(r) = \sum_{L\ne 0}\sum_{i<j}u_Y(\left|{r_i-r_j+L}\right|)\end{split}
\end{equation}
with \(u_Y(r)\) given by
\begin{equation}\label{equation:intro_wavefunction:eq19}
\begin{split}u_Y(r) = \frac{a}{r}\left(1-e^{-r/b}\right)\end{split}
\end{equation}
In QMCPACK a slightly more restricted form is used:
\begin{equation}\label{equation:intro_wavefunction:eq20}
\begin{split}u_Y(r) = \frac{r_s}{r}\left(1-e^{-r/\sqrt{r_s}}\right)\end{split}
\end{equation}
here “\(r_s\)” is understood to be a variational parameter.

The Gaskell RPA form—which contains correct short/long range limits
and minimizes the total energy of the electron gas within the RPA—is
defined directly in k\sphinxhyphen{}space:
\begin{equation}\label{equation:intro_wavefunction:eq21}
\begin{split}u_{RPA}(k) = -\frac{1}{2S_0(k)}+\frac{1}{2}\left(\frac{1}{S_0(k)^2}+\frac{4m_ev_k}{\hbar^2k^2}\right)^{1/2}\end{split}
\end{equation}
where \$v\_k\$ is the Fourier transform of the Coulomb potential and
\(S_0(k)\) is the static structure factor of the non\sphinxhyphen{}interacting
electron gas:
\begin{equation*}
\begin{split}S_0(k) = \left.
    \begin{cases}
      1 &  k>2k_F \\
      \frac{3k}{4k_F}-\frac{1}{2}\left(\frac{k}{2k_F}\right)^3 & k<2k_F
    \end{cases}
    \right.\end{split}
\end{equation*}
When written in atomic units, RPA Jastrow implemented in QMCPACK has the
form
\begin{equation}\label{equation:intro_wavefunction:eq22}
\begin{split}u_{RPA}(k) = \frac{1}{2N_e}\left(-\frac{1}{S_0(k)}+\left(\frac{1}{S_0(k)^2}+\frac{12}{r_s^3k^4}\right)^{1/2}\right)\end{split}
\end{equation}
Here “\(r_s\)” is again a variational parameter and \(k_F\equiv(\tfrac{9\pi}{4r_s^3})^{1/3}\).

For both the Yukawa and Gaskell RPA Jastrows, the default value for \(r_s\) is \(r_s=(\tfrac{3\Omega}{4\pi N_e})^{1/3}\).

\sphinxcode{\sphinxupquote{jastrow type=Two\sphinxhyphen{}Body function=rpa/yukawa}} element:
\begin{quote}
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{wavefunction}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{correlation}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{Two\sphinxhyphen{}body}
&&
Must be two\sphinxhyphen{}body
\\
\hline
\sphinxcode{\sphinxupquote{function}}\(^r\)
&
text
&
\sphinxstylestrong{rpa/yukawa}
&&
Must be rpa or yukawa
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
RPA\_Jee
&
Unique name for Jastrow
\\
\hline
\sphinxcode{\sphinxupquote{longrange}}\(^o\)
&
boolean
&
yes/no
&
yes
&
Use long\sphinxhyphen{}range part
\\
\hline
\sphinxcode{\sphinxupquote{shortrange}}\(^o\)
&
boolean
&
yes/no
&
yes
&
Use short\sphinxhyphen{}range part
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

parameters:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{rs}}\(^o\)
&
rs
&
\(r_s>0\)
&
\(\tfrac{3\Omega}{4\pi N_e}\)
&
Avg. elec\sphinxhyphen{}elec distance
\\
\hline
\sphinxcode{\sphinxupquote{kc}}\(^o\)
&
kc
&
\(k_c>0\)
&
\(2\left(\tfrac{9\pi}{4}\right)^{1/3}\tfrac{4\pi N_e}{3\Omega}\)
&
k\sphinxhyphen{}space cutoff
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}
\end{quote}
\sphinxSetupCaptionForVerbatim{Two body RPA Jastrow with long\sphinxhyphen{} and short\sphinxhyphen{}ranged parts.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-13}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{n}{Jee}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{n}{Two}\PYG{o}{\PYGZhy{}}\PYG{n}{Body}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{n}{function}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{n}{rpa}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Three\sphinxhyphen{}body Jastrow functions}
\label{\detokenize{intro_wavefunction:three-body-jastrow-functions}}
Explicit three\sphinxhyphen{}body correlations can be included in the wavefunction via
the three\sphinxhyphen{}body Jastrow factor. The three\sphinxhyphen{}body electron\sphinxhyphen{}electron\sphinxhyphen{}ion
correlation function (\(u_{\sigma\sigma'I}\)) currently used in is
identical to the one proposed in \sphinxcite{intro_wavefunction:drummond2004}:
\begin{equation}\label{equation:intro_wavefunction:eq23}
\begin{split} \begin{aligned}
 u_{\sigma\sigma'I}(r_{\sigma I},r_{\sigma'I},r_{\sigma\sigma'}) &= \sum_{\ell=0}^{M_{eI}}\sum_{m=0}^{M_{eI}}\sum_{n=0}^{M_{ee}}\gamma_{\ell mn} r_{\sigma I}^\ell r_{\sigma'I}^m r_{\sigma\sigma'}^n \\
    &\times \left(r_{\sigma I}-\frac{r_c}{2}\right)^3 \Theta\left(r_{\sigma I}-\frac{r_c}{2}\right) \nonumber \\
    &\times \left(r_{\sigma' I}-\frac{r_c}{2}\right)^3 \Theta\left(r_{\sigma' I}-\frac{r_c}{2}\right) \nonumber\end{aligned}\end{split}
\end{equation}
Here \(M_{eI}\) and \(M_{ee}\) are the maximum polynomial orders
of the electron\sphinxhyphen{}ion and electron\sphinxhyphen{}electron distances, respectively,
\(\{\gamma_{\ell mn}\}\) are the optimizable parameters (modulo
constraints), \(r_c\) is a cutoff radius, and \(r_{ab}\) are the
distances between electrons or ions \(a\) and \(b\). i.e. The
correlation function is only a function of the interparticle distances
and not a more complex function of the particle positions,
\(\mathbf{r}\). As indicated by the \(\Theta\) functions,
correlations are set to zero beyond a distance of \(r_c/2\) in
either of the electron\sphinxhyphen{}ion distances and the largest meaningful
electron\sphinxhyphen{}electron distance is \(r_c\). This is the highest\sphinxhyphen{}order
Jastrow correlation function currently implemented.

Today, solid state applications of QMCPACK usually utilize one and
two\sphinxhyphen{}body B\sphinxhyphen{}spline Jastrow functions, with calculations on heavier
elements often also using the three\sphinxhyphen{}body term described above.


\subsubsection{Example use case}
\label{\detokenize{intro_wavefunction:id20}}
Here is an example of H2O molecule. After optimizing one and two body Jastrow factors, add the following block in the wavefunction.
The coefficients will be filled zero automatically if not given.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{J3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{eeI}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{function}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{polynomial}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{print}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{ispecies}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{O}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{especies}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{isize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{esize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{uuO}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{ispecies}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{O}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{especies1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{especies2}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{isize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{esize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{udO}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{ispecies}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{especies}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{isize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{esize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{uuH}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{ispecies}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{especies1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{especies2}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{isize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{esize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{udH}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\section{Multideterminant wavefunctions}
\label{\detokenize{intro_wavefunction:multideterminant-wavefunctions}}\label{\detokenize{intro_wavefunction:multideterminants}}
Multiple schemes to generate a multideterminant wavefunction are
possible, from CASSF to full CI or selected CI. The QMCPACK converter can
convert MCSCF multideterminant wavefunctions from
GAMESS \sphinxcite{intro_wavefunction:schmidt93} and CIPSI \sphinxcite{sCI:caffarel2013} wavefunctions from
Quantum Package \sphinxcite{sCI:qp} (QP). Full details of how to run a CIPSI
calculation and convert the wavefunction for QMCPACK are given in
{\hyperref[\detokenize{sCI:cipsi}]{\sphinxcrossref{\DUrole{std,std-ref}{CIPSI wavefunction interface}}}}.

The script \sphinxcode{\sphinxupquote{utils/determinants\_tools.py}} can be used to generate
useful information about the multideterminant wavefunction. This script takes, as a required argument, the path of an h5 file corresponding to the wavefunction. Used without optional arguments, it prints the number of determinants, the number of CSFs, and a histogram of the excitation degree.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}} \PYG{n}{determinants\PYGZus{}tools}\PYG{o}{.}\PYG{n}{py} \PYG{o}{.}\PYG{o}{/}\PYG{n}{tests}\PYG{o}{/}\PYG{n}{molecules}\PYG{o}{/}\PYG{n}{C2\PYGZus{}pp}\PYG{o}{/}\PYG{n}{C2}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{Summary}\PYG{p}{:}
\PYG{n}{excitation} \PYG{n}{degree} \PYG{l+m+mi}{0} \PYG{n}{count}\PYG{p}{:} \PYG{l+m+mi}{1}
\PYG{n}{excitation} \PYG{n}{degree} \PYG{l+m+mi}{1} \PYG{n}{count}\PYG{p}{:} \PYG{l+m+mi}{6}
\PYG{n}{excitation} \PYG{n}{degree} \PYG{l+m+mi}{2} \PYG{n}{count}\PYG{p}{:} \PYG{l+m+mi}{148}
\PYG{n}{excitation} \PYG{n}{degree} \PYG{l+m+mi}{3} \PYG{n}{count}\PYG{p}{:} \PYG{l+m+mi}{27}
\PYG{n}{excitation} \PYG{n}{degree} \PYG{l+m+mi}{4} \PYG{n}{count}\PYG{p}{:} \PYG{l+m+mi}{20}

\PYG{n}{n\PYGZus{}det} \PYG{l+m+mi}{202}
\PYG{n}{n\PYGZus{}csf} \PYG{l+m+mi}{104}
\end{sphinxVerbatim}

If the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}verbose}} argument is used, the script will print each determinant,
the associated CSF, and the excitation degree relative to the first determinant.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}} \PYG{n}{determinants\PYGZus{}tools}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{v} \PYG{o}{.}\PYG{o}{/}\PYG{n}{tests}\PYG{o}{/}\PYG{n}{molecules}\PYG{o}{/}\PYG{n}{C2\PYGZus{}pp}\PYG{o}{/}\PYG{n}{C2}\PYG{o}{.}\PYG{n}{h5} \PYG{o}{|} \PYG{n}{head}
\PYG{l+m+mi}{1}
\PYG{n}{alpha}  \PYG{l+m+mi}{1111000000000000000000000000000000000000000000000000000000}
\PYG{n}{beta}   \PYG{l+m+mi}{1111000000000000000000000000000000000000000000000000000000}
\PYG{n}{scf}    \PYG{l+m+mi}{2222000000000000000000000000000000000000000000000000000000}
\PYG{n}{excitation} \PYG{n}{degree}  \PYG{l+m+mi}{0}

\PYG{l+m+mi}{2}
\PYG{n}{alpha}  \PYG{l+m+mi}{1011100000000000000000000000000000000000000000000000000000}
\PYG{n}{beta}   \PYG{l+m+mi}{1011100000000000000000000000000000000000000000000000000000}
\PYG{n}{scf}    \PYG{l+m+mi}{2022200000000000000000000000000000000000000000000000000000}
\PYG{n}{excitation} \PYG{n}{degree}  \PYG{l+m+mi}{2}
\end{sphinxVerbatim}


\section{Backflow Wavefunctions}
\label{\detokenize{intro_wavefunction:backflow-wavefunctions}}\label{\detokenize{intro_wavefunction:backflow}}
One can perturb the nodal surface of a single\sphinxhyphen{}Slater/multi\sphinxhyphen{}Slater
wavefunction through use of a backflow transformation. Specifically, if
we have an antisymmetric function
\(D(\mathbf{x}_{0\uparrow},\cdots,\mathbf{x}_{N\uparrow}, \mathbf{x}_{0\downarrow},\cdots,\mathbf{x}_{N\downarrow})\),
and if \(i_\alpha\) is the \(i\)\sphinxhyphen{}th particle of species type
\(\alpha\), then the backflow transformation works by making the
coordinate transformation
\(\mathbf{x}_{i_\alpha} \to \mathbf{x}'_{i_\alpha}\) and evaluating
\(D\) at these new “quasiparticle” coordinates. QMCPACK currently
supports quasiparticle transformations given by
\begin{equation}\label{equation:intro_wavefunction:eq24}
\begin{split}\mathbf{x}'_{i_\alpha}=\mathbf{x}_{i_\alpha}+\sum_{\alpha \leq \beta} \sum_{i_\alpha \neq j_\beta} \eta^{\alpha\beta}(|\mathbf{x}_{i_\alpha}-\mathbf{x}_{j_\beta}|)(\mathbf{x}_{i_\alpha}-\mathbf{x}_{j_\beta})\:.\end{split}
\end{equation}
Here, \(\eta^{\alpha\beta}(|\mathbf{x}_{i_\alpha}-\mathbf{x}_{j_\beta}|)\)
is a radially symmetric backflow transformation between species
\(\alpha\) and \(\beta\). In QMCPACK, particle \(i_\alpha\)
is known as the “target” particle and \(j_\beta\) is known as the
“source.” The main types of transformations are so\sphinxhyphen{}called one\sphinxhyphen{}body
terms, which are between an electron and an ion
\(\eta^{eI}(|\mathbf{x}_{i_e}-\mathbf{x}_{j_I}|)\) and two\sphinxhyphen{}body
terms. Two\sphinxhyphen{}body terms are distinguished as those between like and
opposite spin electrons:
\(\eta^{e(\uparrow)e(\uparrow)}(|\mathbf{x}_{i_e(\uparrow)}-\mathbf{x}_{j_e(\uparrow)}|)\)
and
\(\eta^{e(\uparrow)e(\downarrow)}(|\mathbf{x}_{i_e(\uparrow)}-\mathbf{x}_{j_e(\downarrow)}|)\).
Henceforth, we will assume that
\(\eta^{e(\uparrow)e(\uparrow)}=\eta^{e(\downarrow)e(\downarrow)}\).

In the following, we explain how to describe general terms such as
\eqref{equation:intro_wavefunction:eq24} in a QMCPACK XML file. For specificity, we will
consider a particle set consisting of H and He (in that order). This
ordering will be important when we build the XML file, so you can find
this out either through your specific declaration of \textless{}particleset\textgreater{}, by
looking at the hdf5 file in the case of plane waves, or by looking at
the QMCPACK output file in the section labeled “Summary of QMC systems.”


\subsection{Input specifications}
\label{\detokenize{intro_wavefunction:input-specifications}}
All backflow declarations occur within a single \sphinxcode{\sphinxupquote{\textless{}backflow\textgreater{} ... \textless{}/backflow\textgreater{}}} block.  Backflow transformations occur in \sphinxcode{\sphinxupquote{\textless{}transformation\textgreater{}}} blocks and have the following input parameters:

Transformation element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
name
&
Text
&&
(Required)
&
Unique name for this Jastrow function.
\\
\hline
type
&
Text
&
“e\sphinxhyphen{}I”
&
(Required)
&
Define a one\sphinxhyphen{}body backflow transformation.
\\
\hline&
Text
&
“e\sphinxhyphen{}e”
&&
Define a two\sphinxhyphen{}body backflow transformation.
\\
\hline
function
&
Text
&
B\sphinxhyphen{}spline
&
(Required)
&
B\sphinxhyphen{}spline type transformation (no other types supported).
\\
\hline
source
&
Text
&&&
“e” if two body, ion particle set if one body.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Just like one\sphinxhyphen{} and two\sphinxhyphen{}body jastrows, parameterization of the backflow transformations are specified within the \sphinxcode{\sphinxupquote{\textless{}transformation\textgreater{}}} blocks by  \sphinxcode{\sphinxupquote{\textless{}correlation\textgreater{}}} blocks.  Please refer to {\hyperref[\detokenize{intro_wavefunction:onebodyjastrowspline}]{\sphinxcrossref{\DUrole{std,std-ref}{Spline form}}}} for more information.


\subsection{Example Use Case}
\label{\detokenize{intro_wavefunction:id24}}
Having specified the general form, we present a general example of one\sphinxhyphen{}body and two\sphinxhyphen{}body backflow transformations in a hydrogen\sphinxhyphen{}helium mixture.  The hydrogen and helium ions have independent backflow transformations, as do the like and unlike\sphinxhyphen{}spin two\sphinxhyphen{}body terms.  One caveat is in order:  ionic backflow transformations must be listed in the order they appear in the particle set.  If in our example, helium is listed first and hydrogen is listed second, the following example would be correct.  However, switching backflow declaration to hydrogen first then helium, will result in an error.  Outside of this, declaration of one\sphinxhyphen{}body blocks and two\sphinxhyphen{}body blocks are not sensitive to ordering.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}backflow\PYGZgt{}
\PYGZlt{}!\PYGZhy{}\PYGZhy{}The One\PYGZhy{}Body term with independent e\PYGZhy{}He and e\PYGZhy{}H terms. IN THAT ORDER \PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZlt{}transformation name=\PYGZdq{}eIonB\PYGZdq{} type=\PYGZdq{}e\PYGZhy{}I\PYGZdq{} function=\PYGZdq{}Bspline\PYGZdq{} source=\PYGZdq{}ion0\PYGZdq{}\PYGZgt{}
    \PYGZlt{}correlation cusp=\PYGZdq{}0.0\PYGZdq{} size=\PYGZdq{}8\PYGZdq{} type=\PYGZdq{}shortrange\PYGZdq{} init=\PYGZdq{}no\PYGZdq{} elementType=\PYGZdq{}He\PYGZdq{} rcut=\PYGZdq{}3.0\PYGZdq{}\PYGZgt{}
        \PYGZlt{}coefficients id=\PYGZdq{}eHeC\PYGZdq{} type=\PYGZdq{}Array\PYGZdq{} optimize=\PYGZdq{}yes\PYGZdq{}\PYGZgt{}
            0 0 0 0 0 0 0 0
        \PYGZlt{}/coefficients\PYGZgt{}
    \PYGZlt{}/correlation\PYGZgt{}
    \PYGZlt{}correlation cusp=\PYGZdq{}0.0\PYGZdq{} size=\PYGZdq{}8\PYGZdq{} type=\PYGZdq{}shortrange\PYGZdq{} init=\PYGZdq{}no\PYGZdq{} elementType=\PYGZdq{}H\PYGZdq{} rcut=\PYGZdq{}3.0\PYGZdq{}\PYGZgt{}
        \PYGZlt{}coefficients id=\PYGZdq{}eHC\PYGZdq{} type=\PYGZdq{}Array\PYGZdq{} optimize=\PYGZdq{}yes\PYGZdq{}\PYGZgt{}
            0 0 0 0 0 0 0 0
        \PYGZlt{}/coefficients\PYGZgt{}
    \PYGZlt{}/correlation\PYGZgt{}
\PYGZlt{}/transformation\PYGZgt{}

\PYGZlt{}!\PYGZhy{}\PYGZhy{}The Two\PYGZhy{}Body Term with Like and Unlike Spins \PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZlt{}transformation name=\PYGZdq{}eeB\PYGZdq{} type=\PYGZdq{}e\PYGZhy{}e\PYGZdq{} function=\PYGZdq{}Bspline\PYGZdq{} \PYGZgt{}
    \PYGZlt{}correlation cusp=\PYGZdq{}0.0\PYGZdq{} size=\PYGZdq{}7\PYGZdq{} type=\PYGZdq{}shortrange\PYGZdq{} init=\PYGZdq{}no\PYGZdq{} speciesA=\PYGZdq{}u\PYGZdq{} speciesB=\PYGZdq{}u\PYGZdq{} rcut=\PYGZdq{}1.2\PYGZdq{}\PYGZgt{}
        \PYGZlt{}coefficients id=\PYGZdq{}uuB1\PYGZdq{} type=\PYGZdq{}Array\PYGZdq{} optimize=\PYGZdq{}yes\PYGZdq{}\PYGZgt{}
            0 0 0 0 0 0 0
        \PYGZlt{}/coefficients\PYGZgt{}
    \PYGZlt{}/correlation\PYGZgt{}
    \PYGZlt{}correlation cusp=\PYGZdq{}0.0\PYGZdq{} size=\PYGZdq{}7\PYGZdq{} type=\PYGZdq{}shortrange\PYGZdq{} init=\PYGZdq{}no\PYGZdq{} speciesA=\PYGZdq{}d\PYGZdq{} speciesB=\PYGZdq{}u\PYGZdq{} rcut=\PYGZdq{}1.2\PYGZdq{}\PYGZgt{}
        \PYGZlt{}coefficients id=\PYGZdq{}udB1\PYGZdq{} type=\PYGZdq{}Array\PYGZdq{} optimize=\PYGZdq{}yes\PYGZdq{}\PYGZgt{}
            0 0 0 0 0 0 0
        \PYGZlt{}/coefficients\PYGZgt{}
    \PYGZlt{}/correlation\PYGZgt{}
\PYGZlt{}/transformation\PYGZgt{}
\PYGZlt{}/backflow\PYGZgt{}
\end{sphinxVerbatim}

Currently, backflow works only with single\sphinxhyphen{}Slater determinant wavefunctions.  When a backflow transformation has been declared, it should be placed within the \sphinxcode{\sphinxupquote{\textless{}determinantset\textgreater{}}} block, but outside of the \sphinxcode{\sphinxupquote{\textless{}slaterdeterminant\textgreater{}}} blocks, like so:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}determinantset ... \PYGZgt{}
    \PYGZlt{}!\PYGZhy{}\PYGZhy{}basis set declarations go here, if there are any \PYGZhy{}\PYGZhy{}\PYGZgt{}

    \PYGZlt{}backflow\PYGZgt{}
        \PYGZlt{}transformation ...\PYGZgt{}
          \PYGZlt{}!\PYGZhy{}\PYGZhy{}Here is where one and two\PYGZhy{}body terms are defined \PYGZhy{}\PYGZhy{}\PYGZgt{}
         \PYGZlt{}/transformation\PYGZgt{}
     \PYGZlt{}/backflow\PYGZgt{}

     \PYGZlt{}slaterdeterminant\PYGZgt{}
         \PYGZlt{}!\PYGZhy{}\PYGZhy{}Usual determinant definitions \PYGZhy{}\PYGZhy{}\PYGZgt{}
     \PYGZlt{}/slaterdeterminant\PYGZgt{}
 \PYGZlt{}/determinantset\PYGZgt{}
\end{sphinxVerbatim}


\subsection{Optimization Tips}
\label{\detokenize{intro_wavefunction:optimization-tips}}
Backflow is notoriously difficult to optimize—it is extremely nonlinear in the variational parameters and moves the nodal surface around.  As such, it is likely that a full Jastrow+Backflow optimization with all parameters initialized to zero might not converge in a reasonable time.  If you are experiencing this problem, the following pointers are suggested (in no particular order).


\subsubsection{Get a good starting guess for \protect\(\Psi_T\protect\):}
\label{\detokenize{intro_wavefunction:get-a-good-starting-guess-for-psi-t}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Try optimizing the Jastrow first without backflow.

\item {} 
Freeze the Jastrow parameters, introduce only the e\sphinxhyphen{}e terms in the
backflow transformation, and optimize these parameters.

\item {} 
Freeze the e\sphinxhyphen{}e backflow parameters, and then optimize the e\sphinxhyphen{}I terms.
\begin{itemize}
\item {} 
If difficulty is encountered here, try optimizing each species
independently.

\end{itemize}

\item {} 
Unfreeze all Jastrow, e\sphinxhyphen{}e backflow, and e\sphinxhyphen{}I backflow parameters, and
reoptimize.

\end{enumerate}


\subsubsection{Optimizing Backflow Terms}
\label{\detokenize{intro_wavefunction:optimizing-backflow-terms}}
It is possible that the previous prescription might grind to a halt in steps 2 or 3 with the inability to optimize the e\sphinxhyphen{}e or e\sphinxhyphen{}I backflow transformation independently, especially if it is initialized to zero.  One way to get around this is to build a good starting guess for the e\sphinxhyphen{}e or e\sphinxhyphen{}I backflow terms iteratively as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Start off with a small number of knots initialized to zero. Set
\(r_{cut}\) to be small (much smaller than an interatomic distance).

\item {} 
Optimize the backflow function.

\item {} 
If this works, slowly increase \(r_{cut}\) and/or the number of
knots.

\item {} 
Repeat steps 2 and 3 until there is no noticeable change in energy or
variance of \(\Psi_T\).

\end{enumerate}


\subsubsection{Tweaking the Optimization Run}
\label{\detokenize{intro_wavefunction:tweaking-the-optimization-run}}
The following modifications are worth a try in the optimization block:
\begin{itemize}
\item {} 
Try setting “useDrift” to “no.” This eliminates the use of
wavefunction gradients and force biasing in the VMC algorithm. This
could be an issue for poorly optimized wavefunctions with
pathological gradients.

\item {} 
Try increasing “exp0” in the optimization block. Larger values of
exp0 cause the search directions to more closely follow those
predicted by steepest\sphinxhyphen{}descent than those by the linear method.

\end{itemize}

Note that the new adaptive shift optimizer has not yet been tried with
backflow wavefunctions. It should perform better than the older
optimizers, but a considered optimization process is still recommended.


\section{Finite\sphinxhyphen{}difference linear response wave functions}
\label{\detokenize{intro_wavefunction:finite-difference-linear-response-wave-functions}}\label{\detokenize{intro_wavefunction:fdlr}}
The finite\sphinxhyphen{}difference linear response wavefunction (FDLR) is an
experimental wavefunction type described in detail in
\sphinxcite{intro_wavefunction:blunt-charge-transfer-2017}. In this method, the wavefunction is formed as the linear response of some existing trial wavefunction in QMCPACK. This derivatives of this linear response are
approximated by a simple finite difference.

Forming a wavefunction within the linear response space of an existing ansatz can be very powerful. For example, a configuration interaction singles (CIS) wavefunction can be formed as a linear combination of the first derivatives of a Slater determinant (with respect to its orbital rotation parameters). Thus, in this sense, CIS is the linear response of Hartree\textendash{}Fock theory.

Forming a CIS wavefunction as the linear response of an optimizable Slater determinant is where all testing of this wavefunction has been performed. In theory, the implementation is flexible and can be used with other trial wavefunctions in QMCPACK, but this has not been tested; the FDLR trial wavefunction is experimental.

Mathematically, the FDLR wavefunction has the form
\begin{equation}\label{equation:intro_wavefunction:eq25}
\begin{split}\Psi_{\textrm{FDLR}} (\mathbf{\mu}, \mathbf{X}) = \Psi (\mathbf{X} + \mathbf{\mu}) - \Psi (\mathbf{X} - \mathbf{\mu})\: ,\end{split}
\end{equation}
where \(\Psi(\mathbf{P})\) is some trial wavefunction in QMCPACK,
and \(\mathbf{P}\) is its optimizable parameters. \(\mathbf{X}\)
is the “base” parameters about which the finite difference is performed
(for example, an overall orbital rotation). \(\mathbf{\mu}\) is the
“finite\sphinxhyphen{}difference” parameters, which define the direction of the
derivative, and whose magnitude determines the magnitude of the finite
difference. In the limit that the magnitude of \(\mathbf{mu}\) goes
to \(0\), the \(\Psi_{\textrm{FDLR}}\) object just defined
becomes equivalent to
\begin{equation}\label{equation:intro_wavefunction:eq26}
\begin{split}\Psi_{\textrm{FDLR}} (\mathbf{\mu}, \mathbf{X}) = \sum_{pq} \mu_{pq} \: \frac{\partial \Psi_{\textrm{det}} (\mathbf{X}) }{\partial X_{pq}}\: ,\end{split}
\end{equation}
which is the desired linear response wavefunction we are approximating.
In the case that \(\Psi(\mathbf{P})\) is a determinant with orbital
rotation parameters \(\mathbf{P}\), the previous equation is a CIS
wavefunction with CIS expansion coefficients \(\mathbf{\mu}\) and
orbital rotation \(\mathbf{X}\).


\subsection{Input specifications}
\label{\detokenize{intro_wavefunction:id26}}
An FDLR wavefunction is specified within a \sphinxcode{\sphinxupquote{\textless{}fdlr\textgreater{} ... \textless{}/fdlr\textgreater{}}} block.

To fully specify an FDLR wavefunction as done previously, we require the
initial parameters for both \(\mathbf{X}\) and \(\mathbf{\mu}\)
to be input. This therefore requires two trial wavefunctions to be
provided on input. Each of these is best specified in its own XML file.
The names of these two files are provided in an \sphinxcode{\sphinxupquote{\textless{}include\textgreater{}}} tag via
\sphinxcode{\sphinxupquote{\textless{}include wfn\_x\_href=“ ... ” wfn\_d\_href=“ ... ”\textgreater{}}}. \sphinxcode{\sphinxupquote{wfn\_x\_href}}
specifies the file that will hold the \(\mathbf{X}\) parameters.
\sphinxcode{\sphinxupquote{wfn\_d\_href}} specifies the file that will hold the
\(\mathbf{\mu}\) parameters.

Other options inside the \sphinxcode{\sphinxupquote{\textless{}include\textgreater{}}} tag are \sphinxcode{\sphinxupquote{opt\_x}} and \sphinxcode{\sphinxupquote{opt\_d}},
which specify whether or not \(\mathbf{X}\) and \(\mathbf{\mu}\)
parameters are optimizable, respectively.


\subsection{Example Use Case}
\label{\detokenize{intro_wavefunction:id27}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{fdlrwfn} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{FDLR}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{include} \PYG{n}{wfn\PYGZus{}x\PYGZus{}href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{h2.wfn\PYGZus{}x.xml}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{wfn\PYGZus{}d\PYGZus{}href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{h2.wfn\PYGZus{}d.xml}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{opt\PYGZus{}x}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{opt\PYGZus{}d}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{fdlrwfn}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

with the \sphinxcode{\sphinxupquote{h2.wfn\_x.xml}} file containing one of the wavefunctions and
corresponding set of \(\mathbf{X}\) parameters, such as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}?xml version=\PYGZdq{}1.0\PYGZdq{}?\PYGZgt{}
\PYGZlt{}wfn\PYGZus{}x\PYGZgt{}
    \PYGZlt{}determinantset name=\PYGZdq{}LCAOBSet\PYGZdq{} type=\PYGZdq{}MolecularOrbital\PYGZdq{} transform=\PYGZdq{}yes\PYGZdq{} source=\PYGZdq{}ion0\PYGZdq{}\PYGZgt{}
      \PYGZlt{}basisset name=\PYGZdq{}LCAOBSet\PYGZdq{}\PYGZgt{}
        \PYGZlt{}atomicBasisSet name=\PYGZdq{}Gaussian\PYGZhy{}G2\PYGZdq{} angular=\PYGZdq{}cartesian\PYGZdq{} type=\PYGZdq{}Gaussian\PYGZdq{} elementType=\PYGZdq{}H\PYGZdq{} normalized=\PYGZdq{}no\PYGZdq{}\PYGZgt{}
          \PYGZlt{}grid type=\PYGZdq{}log\PYGZdq{} ri=\PYGZdq{}1.e\PYGZhy{}6\PYGZdq{} rf=\PYGZdq{}1.e2\PYGZdq{} npts=\PYGZdq{}1001\PYGZdq{}/\PYGZgt{}
          \PYGZlt{}basisGroup rid=\PYGZdq{}H00\PYGZdq{} n=\PYGZdq{}0\PYGZdq{} l=\PYGZdq{}0\PYGZdq{} type=\PYGZdq{}Gaussian\PYGZdq{}\PYGZgt{}
            \PYGZlt{}radfunc exponent=\PYGZdq{}1.923840000000e+01\PYGZdq{} contraction=\PYGZdq{}3.282799101900e\PYGZhy{}02\PYGZdq{}/\PYGZgt{}
            \PYGZlt{}radfunc exponent=\PYGZdq{}2.898720000000e+00\PYGZdq{} contraction=\PYGZdq{}2.312039367510e\PYGZhy{}01\PYGZdq{}/\PYGZgt{}
            \PYGZlt{}radfunc exponent=\PYGZdq{}6.534720000000e\PYGZhy{}01\PYGZdq{} contraction=\PYGZdq{}8.172257764360e\PYGZhy{}01\PYGZdq{}/\PYGZgt{}
          \PYGZlt{}/basisGroup\PYGZgt{}
          \PYGZlt{}basisGroup rid=\PYGZdq{}H10\PYGZdq{} n=\PYGZdq{}1\PYGZdq{} l=\PYGZdq{}0\PYGZdq{} type=\PYGZdq{}Gaussian\PYGZdq{}\PYGZgt{}
            \PYGZlt{}radfunc exponent=\PYGZdq{}1.630642000000e\PYGZhy{}01\PYGZdq{} contraction=\PYGZdq{}1.000000000000e+00\PYGZdq{}/\PYGZgt{}
          \PYGZlt{}/basisGroup\PYGZgt{}
        \PYGZlt{}/atomicBasisSet\PYGZgt{}
      \PYGZlt{}/basisset\PYGZgt{}

    \PYGZlt{}slaterdeterminant optimize=\PYGZdq{}yes\PYGZdq{}\PYGZgt{}
      \PYGZlt{}determinant id=\PYGZdq{}det\PYGZus{}up\PYGZdq{} sposet=\PYGZdq{}spo\PYGZhy{}up\PYGZdq{}\PYGZgt{}
        \PYGZlt{}opt\PYGZus{}vars size=\PYGZdq{}3\PYGZdq{}\PYGZgt{}
          0.0 0.0 0.0
        \PYGZlt{}/opt\PYGZus{}vars\PYGZgt{}
      \PYGZlt{}/determinant\PYGZgt{}

      \PYGZlt{}determinant id=\PYGZdq{}det\PYGZus{}down\PYGZdq{} sposet=\PYGZdq{}spo\PYGZhy{}dn\PYGZdq{}\PYGZgt{}
        \PYGZlt{}opt\PYGZus{}vars size=\PYGZdq{}3\PYGZdq{}\PYGZgt{}
          0.0 0.0 0.0
        \PYGZlt{}/opt\PYGZus{}vars\PYGZgt{}
      \PYGZlt{}/determinant\PYGZgt{}
    \PYGZlt{}/slaterdeterminant\PYGZgt{}

      \PYGZlt{}sposet basisset=\PYGZdq{}LCAOBSet\PYGZdq{} name=\PYGZdq{}spo\PYGZhy{}up\PYGZdq{} size=\PYGZdq{}4\PYGZdq{} optimize=\PYGZdq{}yes\PYGZdq{}\PYGZgt{}
        \PYGZlt{}occupation mode=\PYGZdq{}ground\PYGZdq{}/\PYGZgt{}
        \PYGZlt{}coefficient size=\PYGZdq{}4\PYGZdq{} id=\PYGZdq{}updetC\PYGZdq{}\PYGZgt{}
  2.83630000000000e\PYGZhy{}01  3.35683000000000e\PYGZhy{}01  2.83630000000000e\PYGZhy{}01  3.35683000000000e\PYGZhy{}01
  1.66206000000000e\PYGZhy{}01  1.22367400000000e+00 \PYGZhy{}1.66206000000000e\PYGZhy{}01 \PYGZhy{}1.22367400000000e+00
  8.68279000000000e\PYGZhy{}01 \PYGZhy{}6.95081000000000e\PYGZhy{}01  8.68279000000000e\PYGZhy{}01 \PYGZhy{}6.95081000000000e\PYGZhy{}01
 \PYGZhy{}9.77898000000000e\PYGZhy{}01  1.19682400000000e+00  9.77898000000000e\PYGZhy{}01 \PYGZhy{}1.19682400000000e+00
\PYGZlt{}/coefficient\PYGZgt{}
      \PYGZlt{}/sposet\PYGZgt{}
      \PYGZlt{}sposet basisset=\PYGZdq{}LCAOBSet\PYGZdq{} name=\PYGZdq{}spo\PYGZhy{}dn\PYGZdq{} size=\PYGZdq{}4\PYGZdq{} optimize=\PYGZdq{}yes\PYGZdq{}\PYGZgt{}
        \PYGZlt{}occupation mode=\PYGZdq{}ground\PYGZdq{}/\PYGZgt{}
        \PYGZlt{}coefficient size=\PYGZdq{}4\PYGZdq{} id=\PYGZdq{}downdetC\PYGZdq{}\PYGZgt{}
  2.83630000000000e\PYGZhy{}01  3.35683000000000e\PYGZhy{}01  2.83630000000000e\PYGZhy{}01  3.35683000000000e\PYGZhy{}01
  1.66206000000000e\PYGZhy{}01  1.22367400000000e+00 \PYGZhy{}1.66206000000000e\PYGZhy{}01 \PYGZhy{}1.22367400000000e+00
  8.68279000000000e\PYGZhy{}01 \PYGZhy{}6.95081000000000e\PYGZhy{}01  8.68279000000000e\PYGZhy{}01 \PYGZhy{}6.95081000000000e\PYGZhy{}01
 \PYGZhy{}9.77898000000000e\PYGZhy{}01  1.19682400000000e+00  9.77898000000000e\PYGZhy{}01 \PYGZhy{}1.19682400000000e+00
\PYGZlt{}/coefficient\PYGZgt{}
      \PYGZlt{}/sposet\PYGZgt{}

    \PYGZlt{}/determinantset\PYGZgt{}
\PYGZlt{}/wfn\PYGZus{}x\PYGZgt{}
\end{sphinxVerbatim}

and similarly for the \sphinxcode{\sphinxupquote{h2.wfn\_d.xml}} file, which will hold the initial
\(\mathbf{\mu}\) parameters.

This use case is a wavefunction file for an optimizable determinant
wavefunction for H\(_2\), in a double zeta valence basis set.
Thus, the FDLR wavefunction here would perform CIS on H\(_2\) in a
double zeta basis set.


\section{Gaussian Product Wavefunction}
\label{\detokenize{intro_wavefunction:gaussian-product-wavefunction}}\label{\detokenize{intro_wavefunction:ionwf}}
The Gaussian Product wavefunction implements \eqref{equation:intro_wavefunction:eq27}
\begin{equation}\label{equation:intro_wavefunction:eq27}
\begin{split}\Psi(\vec{R}) = \prod_{i=1}^N \exp\left[ -\frac{(\vec{R}_i-\vec{R}_i^o)^2}{2\sigma_i^2} \right]\end{split}
\end{equation}
where \(\vec{R}_i\) is the position of the \(i^{\text{th}}\)
quantum particle and \(\vec{R}_i^o\) is its center. \(\sigma_i\)
is the width of the Gaussian orbital around center \(i\).

This variational wavefunction enhances single\sphinxhyphen{}particle density at chosen
spatial locations with adjustable strengths. It is useful whenever such
localization is physically relevant yet not captured by other parts of
the trial wavefunction. For example, in an electron\sphinxhyphen{}ion simulation of a
solid, the ions are localized around their crystal lattice sites. This
single\sphinxhyphen{}particle localization is not captured by the ion\sphinxhyphen{}ion Jastrow.
Therefore, the addition of this localization term will improve the
wavefunction. The simplest use case of this wavefunction is perhaps the
quantum harmonic oscillator (please see the “tests/models/sho” folder
for examples).

\begin{center}Input specification
\end{center}
Gaussian Product Wavefunction (ionwf):
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
Name
&
Text
&
ionwf
&
(Required)
&
Unique name for this wavefunction
\\
\hline
Width
&
Floats
&
1.0 \sphinxhyphen{}1
&
(Required)
&
Widths of Gaussian orbitals
\\
\hline
Source
&
Text
&
ion0
&
(Required)
&
Name of classical particle set
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{width}} There must be one width provided for each quantum particle.
If a negative width is given, then its corresponding Gaussian orbital
is removed. Negative width is useful if one wants to use Gaussian
wavefunction for a subset of the quantum particles.

\item {} 
\sphinxcode{\sphinxupquote{source}} The Gaussian centers must be specified in the form of a
classical particle set. This classical particle set is likely the ion
positions “ion0,” hence the name “ionwf.” However, arbitrary centers
can be defined using a different particle set. Please refer to the
examples in “tests/models/sho.”

\end{itemize}


\subsection{Example Use Case}
\label{\detokenize{intro_wavefunction:id28}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{qmcsystem}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{simulationcell}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bconds}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
          \PYG{n}{n} \PYG{n}{n} \PYG{n}{n}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{simulationcell}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{particleset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mass}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{5.0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{attrib} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{position}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{datatype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{posArray}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{condition}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{l+m+mf}{0.0001} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0001} \PYG{l+m+mf}{0.0002}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{attrib}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{particleset}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{particleset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{attrib} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{position}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{datatype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{posArray}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{condition}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{attrib}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{particleset}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{wavefunction} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{psi0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{ionwf} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{iwf}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{width}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.8165}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{wavefunction}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{hamiltonian} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{h0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{generic}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{extpot} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HarmonicExt}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{mass}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{5.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{energy}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{latticedeviation}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{latdev}\PYG{l+s+s2}{\PYGZdq{}}
      \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}    \PYG{n}{tgroup}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}}
      \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{sgroup}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{hamiltonian}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmcsystem}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}




\chapter{Hamiltonian and Observables}
\label{\detokenize{hamiltonianobservable:hamiltonian-and-observables}}\label{\detokenize{hamiltonianobservable:hamiltobs}}\label{\detokenize{hamiltonianobservable::doc}}
QMCPACK is capable of the simultaneous measurement of the Hamiltonian and many other quantum operators.  The Hamiltonian attains a special status among the available operators (also referred to as observables) because it ultimately generates all available information regarding the quantum system.  This is evident from an algorithmic standpoint as well since the Hamiltonian (embodied in the projector) generates the imaginary time dynamics of the walkers in DMC and reptation Monte Carlo (RMC).

This section covers how the Hamiltonian can be specified, component by component, by the user in the XML format native to qmcpack. It also covers the input structure of statistical estimators corresponding to quantum observables such as the density, static structure factor, and forces.


\section{The Hamiltonian}
\label{\detokenize{hamiltonianobservable:the-hamiltonian}}
The many\sphinxhyphen{}body Hamiltonian in Hartree units is given by
\begin{equation}\label{equation:hamiltonianobservable:eq28}
\begin{split}\hat{H} = -\sum_i\frac{1}{2m_i}\nabla_i^2 + \sum_iv^{ext}(r_i) + \sum_{i<j}v^{qq}(r_i,r_j)   + \sum_{i\ell}v^{qc}(r_i,r_\ell)   + \sum_{\ell<m}v^{cc}(r_\ell,r_m)\:.\end{split}
\end{equation}
Here, the sums indexed by \(i/j\) are over quantum particles, while
\(\ell/m\) are reserved for classical particles. Often the quantum
particles are electrons, and the classical particles are ions, though is
not limited in this way. The mass of each quantum particle is denoted
\(m_i\), \(v^{qq}/v^{qc}/v^{cc}\) are pair potentials between
quantum\sphinxhyphen{}quantum/quantum\sphinxhyphen{}classical/classical\sphinxhyphen{}classical particles, and
\(v^{ext}\) denotes a purely external potential.

QMCPACK is designed modularly so that any potential can be supported with
minimal additions to the code base. Potentials currently supported
include Coulomb interactions in open and periodic boundary conditions,
the MPC potential, nonlocal pseudopotentials, helium pair potentials,
and various model potentials such as hard sphere, Gaussian, and modified
Poschl\sphinxhyphen{}Teller.

Reference information and examples for the \sphinxcode{\sphinxupquote{\textless{}hamiltonian/\textgreater{}}} XML
element are provided subsequently. Detailed descriptions of the input
for individual potentials is given in the sections that follow.

\sphinxcode{\sphinxupquote{hamiltonian}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{simulation, qmcsystem}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{pairpot extpot estimator constant}} (deprecated)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{name/id}}\(^o\)
&
text
&
\sphinxstyleemphasis{anything}
&
h0
&
Unique id for this Hamiltonian instance
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^o\)
&
text
&&
generic
&
\sphinxstyleemphasis{No current function}
\\
\hline
\sphinxcode{\sphinxupquote{role}}\(^o\)
&
text
&
primary/extra
&
extra
&
Designate as Hamiltonian or not
\\
\hline
\sphinxcode{\sphinxupquote{source}}\(^o\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
i
&
Identify classical \sphinxcode{\sphinxupquote{particleset}}
\\
\hline
\sphinxcode{\sphinxupquote{target}}\(^o\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
e
&
Identify quantum \sphinxcode{\sphinxupquote{particleset}}
\\
\hline
\sphinxcode{\sphinxupquote{default}}\(^o\)
&
boolean
&
yes/no
&
yes
&
Include kinetic energy term implicitly
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxstylestrong{target:} Must be set to the name of the quantum \sphinxcode{\sphinxupquote{particleset}}.
The default value is typically sufficient. In normal usage, no other
attributes are provided.

\end{itemize}
\sphinxSetupCaptionForVerbatim{All electron Hamiltonian XML element.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-14}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{hamiltonian} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ElecElec}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coulomb}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ElecIon}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coulomb}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{IonIon}\PYG{l+s+s2}{\PYGZdq{}}   \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coulomb}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{hamiltonian}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{Pseudopotential Hamiltonian XML element.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-15}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{hamiltonian} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ElecElec}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coulomb}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PseudoPot}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pseudo}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{wavefunction}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{psi0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{pseudo} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Li}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Li.xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{pseudo} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H.xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{pairpot}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{IonIon}\PYG{l+s+s2}{\PYGZdq{}}    \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coulomb}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{hamiltonian}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\section{Pair potentials}
\label{\detokenize{hamiltonianobservable:pair-potentials}}
Many pair potentials are supported.  Though only the most commonly used pair potentials are covered in detail in this section, all currently available potentials are listed subsequently.  If a potential you desire is not listed, or is not present at all, feel free to contact the developers.

\sphinxcode{\sphinxupquote{pairpot}} factory element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{type}} attribute
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxstylestrong{type options}
&
coulomb
&
Coulomb/Ewald potential
\\
\hline&
pseudo
&
Semilocal pseudopotential
\\
\hline&
mpc
&
Model periodic Coulomb interaction/correction
\\
\hline&
cpp
&
Core polarization potential
\\
\hline&
skpot
&
\sphinxstyleemphasis{Unknown}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

shared attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstyleemphasis{See above}
&
0
&
Select pairpot type
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{Anything}
&
any
&
Unique name for this pairpot
\\
\hline
\sphinxcode{\sphinxupquote{source}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
\sphinxcode{\sphinxupquote{hamiltonian.target}}
&
Identify interacting particles
\\
\hline
\sphinxcode{\sphinxupquote{target}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
\sphinxcode{\sphinxupquote{hamiltonian.target}}
&
Identify interacting particles
\\
\hline
\sphinxcode{\sphinxupquote{units}}\(^o\)
&
text
&&
hartree
&
\sphinxstyleemphasis{No current function}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxstylestrong{type:} Used to select the desired pair potential. Must be selected
from the list of type options.

\item {} 
\sphinxstylestrong{name:} A unique name used to identify this pair potential. Block
averaged output data will appear under this name in \sphinxcode{\sphinxupquote{scalar.dat}}
and/or \sphinxcode{\sphinxupquote{stat.h5}} files.

\item {} 
\sphinxstylestrong{source/target:} These specify the particles involved in a pair
interaction. If an interaction is between classical (e.g., ions) and
quantum (e.g., electrons), \sphinxcode{\sphinxupquote{source}}/\sphinxcode{\sphinxupquote{target}} should be the name
of the classical/quantum \sphinxcode{\sphinxupquote{particleset}}.

\item {} 
Only \sphinxcode{\sphinxupquote{Coulomb, pseudo}}, and \sphinxcode{\sphinxupquote{mpc}} are described in detail in the
following subsections. The older or less\sphinxhyphen{}used types (\sphinxcode{\sphinxupquote{cpp, skpot}})
are not covered.

\item {} 
Available only if \sphinxcode{\sphinxupquote{QMC\_CUDA}} is not defined: \sphinxcode{\sphinxupquote{skpot}}.

\item {} 
Available only if \sphinxcode{\sphinxupquote{OHMMS\_DIM==3}}: \sphinxcode{\sphinxupquote{mpc, vhxc, pseudo}}.

\item {} 
Available only if \sphinxcode{\sphinxupquote{OHMMS\_DIM==3}} and \sphinxcode{\sphinxupquote{QMC\_CUDA}} is not defined:
\sphinxcode{\sphinxupquote{cpp}}.

\end{itemize}


\subsection{Coulomb potentials}
\label{\detokenize{hamiltonianobservable:coulomb-potentials}}
The bare Coulomb potential is used in open boundary conditions:
\begin{equation}\label{equation:hamiltonianobservable:eq29}
\begin{split}V_c^{open} = \sum_{i<j}\frac{q_iq_j}{\left|{r_i-r_j}\right|}\:.\end{split}
\end{equation}
When periodic boundary conditions are selected, Ewald summation is used automatically:
\begin{equation}\label{equation:hamiltonianobservable:eq30}
\begin{split}V_c^{pbc} = \sum_{i<j}\frac{q_iq_j}{\left|{r_i-r_j}\right|} + \frac{1}{2}\sum_{L\ne0}\sum_{i,j}\frac{q_iq_j}{\left|{r_i-r_j+L}\right|}\:.\end{split}
\end{equation}
The sum indexed by \(L\) is over all nonzero simulation cell lattice vectors.  In practice, the Ewald sum is broken into short\sphinxhyphen{} and long\sphinxhyphen{}range parts in a manner optimized for efficiency (see \sphinxcite{design_features:natoli1995}) for details.

For information on how to set the boundary conditions, consult {\hyperref[\detokenize{simulationcell:simulationcell}]{\sphinxcrossref{\DUrole{std,std-ref}{Specifying the system to be simulated}}}}.

\sphinxcode{\sphinxupquote{pairpot type=coulomb}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{coulomb}
&&
Must be coulomb
\\
\hline
\sphinxcode{\sphinxupquote{name/id}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
ElecElec
&
Unique name for interaction
\\
\hline
\sphinxcode{\sphinxupquote{source}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
\sphinxcode{\sphinxupquote{hamiltonian.target}}
&
Identify interacting particles
\\
\hline
\sphinxcode{\sphinxupquote{target}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
\sphinxcode{\sphinxupquote{hamiltonian.target}}
&
Identify interacting particles
\\
\hline
\sphinxcode{\sphinxupquote{pbc}}\(^o\)
&
boolean
&
yes/no
&
yes
&
Use Ewald summation
\\
\hline
\sphinxcode{\sphinxupquote{physical}}\(^o\)
&
boolean
&
yes/no
&
yes
&
Hamiltonian(yes)/Observable(no)
\\
\hline
\sphinxcode{\sphinxupquote{forces}}
&
boolean
&
yes/no
&
no
&
\sphinxstyleemphasis{Deprecated}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxstylestrong{type/source/target:} See description for the previous generic
\sphinxcode{\sphinxupquote{pairpot}} factory element.

\item {} 
\sphinxstylestrong{name:} Traditional user\sphinxhyphen{}specified names for electron\sphinxhyphen{}electron,
electron\sphinxhyphen{}ion, and ion\sphinxhyphen{}ion terms are \sphinxcode{\sphinxupquote{ElecElec}}, \sphinxcode{\sphinxupquote{ElecIon}}, and
\sphinxcode{\sphinxupquote{IonIon}}, respectively. Although any choice can be used, the data
analysis tools expect to find columns in \sphinxcode{\sphinxupquote{*.scalar.dat}} with these
names.

\item {} 
\sphinxstylestrong{pbc}: Ewald summation will not be performed if
\sphinxcode{\sphinxupquote{simulationcell.bconds== n n n}}, regardless of the value of
\sphinxcode{\sphinxupquote{pbc}}. Similarly, the \sphinxcode{\sphinxupquote{pbc}} attribute can only be used to turn
off Ewald summation if \sphinxcode{\sphinxupquote{simulationcell.bconds!= n n n}}. The default
value is recommended.

\item {} 
\sphinxstylestrong{physical}: If \sphinxcode{\sphinxupquote{physical==yes}}, this pair potential is included
in the Hamiltonian and will factor into the \sphinxcode{\sphinxupquote{LocalEnergy}} reported
by QMCPACK and also in the DMC branching weight. If \sphinxcode{\sphinxupquote{physical==no}},
then the pair potential is treated as a passive observable but not as
part of the Hamiltonian itself. As such it does not contribute to the
outputted \sphinxcode{\sphinxupquote{LocalEnergy}}. Regardless of the value of \sphinxcode{\sphinxupquote{physical}}
output data will appear in \sphinxcode{\sphinxupquote{scalar.dat}} in a column headed by
\sphinxcode{\sphinxupquote{name}}.

\end{itemize}
\sphinxSetupCaptionForVerbatim{QMCPXML element for Coulomb interaction between electrons.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-16}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ElecElec}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coulomb}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{QMCPXML element for Coulomb interaction between electrons and ions (all\sphinxhyphen{}electron only).}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-17}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ElecIon}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coulomb}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{QMCPXML element for Coulomb interaction between ions.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-18}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{IonIon}\PYG{l+s+s2}{\PYGZdq{}}   \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coulomb}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Pseudopotentials}
\label{\detokenize{hamiltonianobservable:pseudopotentials}}\label{\detokenize{hamiltonianobservable:nlpp}}
QMCPACK supports pseudopotentials in semilocal form, which is local in the
radial coordinate and nonlocal in angular coordinates. When all angular
momentum channels above a certain threshold (\(\ell_{max}\)) are
well approximated by the same potential
(\(V_{\bar{\ell}}\equiv V_{loc}\)), the pseudopotential separates
into a fully local channel and an angularly nonlocal component:
\begin{equation}\label{equation:hamiltonianobservable:eq31}
\begin{split}V^{PP} = \sum_{ij}\Big(V_{\bar{\ell}}(\left|{r_i-\tilde{r}_j}\right|) + \sum_{\ell\ne\bar{\ell}}^{\ell_{max}}\sum_{m=-\ell}^\ell |{Y_{\ell m}}\rangle{\big[V_\ell(\left|{r_i-\tilde{r}_j}\right|) - V_{\bar{\ell}}(\left|{r_i-\tilde{r}_j}\right|) \big]}\langle{Y_{\ell m}}| \Big)\:.\end{split}
\end{equation}
Here the electron/ion index is \(i/j\), and only one type of ion is
shown for simplicity.

Evaluation of the localized pseudopotential energy
\(\Psi_T^{-1}V^{PP}\Psi_T\) requires additional angular integrals.
These integrals are evaluated on a randomly shifted angular grid. The
size of this grid is determined by \(\ell_{max}\). See
\sphinxcite{hamiltonianobservable:mitas1991} for further detail.

uses the FSAtom pseudopotential file format associated with the “Free
Software Project for Atomic\sphinxhyphen{}scale Simulations” initiated in 2002. See
\sphinxurl{http://www.tddft.org/fsatom/manifest.php} for more information. The
FSAtom format uses XML for structured data. Files in this format do not
use a specific identifying file extension; instead they are simply
suffixed with “\sphinxcode{\sphinxupquote{.xml}}.” The tabular data format of CASINO is also
supported.

\sphinxcode{\sphinxupquote{pairpot type=pseudo}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{pseudo}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{pseudo}
&&
Must be pseudo
\\
\hline
\sphinxcode{\sphinxupquote{name/id}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
PseudoPot
&
\sphinxstyleemphasis{No current function}
\\
\hline
\sphinxcode{\sphinxupquote{source}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
i
&
Ion \sphinxcode{\sphinxupquote{particleset}} name
\\
\hline
\sphinxcode{\sphinxupquote{target}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
\sphinxcode{\sphinxupquote{hamiltonian.target}}
&
Electron \sphinxcode{\sphinxupquote{particleset}} name
\\
\hline
\sphinxcode{\sphinxupquote{pbc}}\(^o\)
&
boolean
&
yes/no
&
yes*
&
Use Ewald summation
\\
\hline
\sphinxcode{\sphinxupquote{forces}}
&
boolean
&
yes/no
&
no
&
\sphinxstyleemphasis{Deprecated}
\\
\hline
\sphinxcode{\sphinxupquote{wavefunction}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{wavefunction.name}}
&
invalid
&
Identify wavefunction
\\
\hline
\sphinxcode{\sphinxupquote{format}}\(^r\)
&
text
&
xml/table
&
table
&
Select file format
\\
\hline
\sphinxcode{\sphinxupquote{algorithm}}\(^o\)
&
text
&
batched/default
&
default
&
Choose NLPP algorithm
\\
\hline
\sphinxcode{\sphinxupquote{DLA}}\(^o\)
&
text
&
yes/no
&
no
&
Use determinant localization approximation
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxstylestrong{type/source/target} See description for the generic \sphinxcode{\sphinxupquote{pairpot}}
factory element.

\item {} 
\sphinxstylestrong{name:} Ignored. Instead, default names will be present in
\sphinxcode{\sphinxupquote{*scalar.dat}} output files when pseudopotentials are used. The
field \sphinxcode{\sphinxupquote{LocalECP}} refers to the local part of the pseudopotential.
If nonlocal channels are present, a \sphinxcode{\sphinxupquote{NonLocalECP}} field will be
added that contains the nonlocal energy summed over all angular
momentum channels.

\item {} 
\sphinxstylestrong{pbc:} Ewald summation will not be performed if
\sphinxcode{\sphinxupquote{simulationcell.bconds== n n n}}, regardless of the value of
\sphinxcode{\sphinxupquote{pbc}}. Similarly, the \sphinxcode{\sphinxupquote{pbc}} attribute can only be used to turn
off Ewald summation if \sphinxcode{\sphinxupquote{simulationcell.bconds!= n n n}}.

\item {} 
\sphinxstylestrong{format:} If \sphinxcode{\sphinxupquote{format}}==table, QMCPACK looks for \sphinxcode{\sphinxupquote{*.psf}} files
containing pseudopotential data in a tabular format. The files must
be named after the ionic species provided in \sphinxcode{\sphinxupquote{particleset}} (e.g.,
\sphinxcode{\sphinxupquote{Li.psf}} and \sphinxcode{\sphinxupquote{H.psf}}). If \sphinxcode{\sphinxupquote{format}}==xml, additional
\sphinxcode{\sphinxupquote{pseudo}} child XML elements must be provided (see the following).
These elements specify individual file names and formats (both the
FSAtom XML and CASINO tabular data formats are supported).

\item {} 
\sphinxstylestrong{algorithm} The default algorithm evaluates the ratios of
wavefunction components together for each quadrature point and then
one point after another. The batched algorithm evaluates the ratios
of quadrature points together for each wavefunction component and
then one component after another. Internally, it uses
\sphinxcode{\sphinxupquote{VirtualParticleSet}} for quadrature points. Hybrid orbital
representation has an extra optimization enabled when using the
batched algorithm.

\item {} 
\sphinxstylestrong{DLA} Determinant localization approximation
(DLA) \sphinxcite{hamiltonianobservable:zen2019dla} uses only the fermionic part of
the wavefunction when calculating NLPP.

\end{itemize}
\sphinxSetupCaptionForVerbatim{QMCPXML element for pseudopotential electron\sphinxhyphen{}ion interaction (psf files).}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-19}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PseudoPot}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pseudo}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{wavefunction}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{psi0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{psf}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{QMCPXML element for pseudopotential electron\sphinxhyphen{}ion interaction (xml files).}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-20}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PseudoPot}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pseudo}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{wavefunction}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{psi0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{pseudo} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Li}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Li.xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{pseudo} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H.xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{pairpot}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Details of \sphinxcode{\sphinxupquote{\textless{}pseudo/\textgreater{}}} input elements are shown in the following. It
is possible to include (or construct) a full pseudopotential directly in
the input file without providing an external file via \sphinxcode{\sphinxupquote{href}}. The full
XML format for pseudopotentials is not yet covered.

\sphinxcode{\sphinxupquote{pseudo}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{pairpot type=pseudo}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{header local grid}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{elementType/symbol}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{groupe.name}}
&
none
&
Identify ionic species
\\
\hline
\sphinxcode{\sphinxupquote{href}}\(^r\)
&
text
&
\sphinxstyleemphasis{filepath}
&
none
&
Pseudopotential file path
\\
\hline
\sphinxcode{\sphinxupquote{format}}\(^r\)
&
text
&
xml/casino
&
xml
&
Specify file format
\\
\hline
\sphinxcode{\sphinxupquote{cutoff}}\(^o\)
&
real
&&&
Nonlocal cutoff radius
\\
\hline
\sphinxcode{\sphinxupquote{lmax}}\(^o\)
&
integer
&&&
Largest angular momentum
\\
\hline
\sphinxcode{\sphinxupquote{nrule}}\(^o\)
&
integer
&&&
Integration grid order
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}
\sphinxSetupCaptionForVerbatim{QMCPXML element for pseudopotential of single ionic species.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-21}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{o}{\PYGZlt{}}\PYG{n}{pseudo} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Li}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Li.xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{MPC Interaction/correction}
\label{\detokenize{hamiltonianobservable:mpc-interaction-correction}}
The MPC interaction is an alternative to direct Ewald summation. The MPC
corrects the exchange correlation hole to more closely match its
thermodynamic limit. Because of this, the MPC exhibits smaller
finite\sphinxhyphen{}size errors than the bare Ewald interaction, though a few
alternative and competitive finite\sphinxhyphen{}size correction schemes now exist.
The MPC is itself often used just as a finite\sphinxhyphen{}size correction in
post\sphinxhyphen{}processing (set \sphinxcode{\sphinxupquote{physical=false}} in the input).

\sphinxcode{\sphinxupquote{pairpot type=mpc}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{mpc}
&&
Must be MPC
\\
\hline
\sphinxcode{\sphinxupquote{name/id}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
MPC
&
Unique name for interaction
\\
\hline
\sphinxcode{\sphinxupquote{source}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
\sphinxcode{\sphinxupquote{hamiltonian.target}}
&
Identify interacting particles
\\
\hline
\sphinxcode{\sphinxupquote{target}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
\sphinxcode{\sphinxupquote{hamiltonian.target}}
&
Identify interacting particles
\\
\hline
\sphinxcode{\sphinxupquote{physical}}\(^o\)
&
boolean
&
yes/no
&
no
&
Hamiltonian(yes)/observable(no)
\\
\hline
\sphinxcode{\sphinxupquote{cutoff}}
&
real
&
\(>0\)
&
30.0
&
Kinetic energy cutoff
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Remarks:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{physical}}: Typically set to \sphinxcode{\sphinxupquote{no}}, meaning the standard Ewald
interaction will be used during sampling and MPC will be measured as
an observable for finite\sphinxhyphen{}size post\sphinxhyphen{}correction. If \sphinxcode{\sphinxupquote{physical}} is
\sphinxcode{\sphinxupquote{yes}}, the MPC interaction will be used during sampling. In this
case an electron\sphinxhyphen{}electron Coulomb \sphinxcode{\sphinxupquote{pairpot}} element should not be
supplied.

\item {} 
\sphinxstylestrong{Developer note:} Currently the \sphinxcode{\sphinxupquote{name}} attribute for the MPC
interaction is ignored. The name is always reset to \sphinxcode{\sphinxupquote{MPC}}.

\end{itemize}
\sphinxSetupCaptionForVerbatim{MPC for finite\sphinxhyphen{}size postcorrection.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-22}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MPC}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MPC}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{ecut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{60.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{physical}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\section{General estimators}
\label{\detokenize{hamiltonianobservable:general-estimators}}
A broad range of estimators for physical observables are available in QMCPACK.
The following sections contain input details for the total number
density (\sphinxcode{\sphinxupquote{density}}), number density resolved by particle spin
(\sphinxcode{\sphinxupquote{spindensity}}), spherically averaged pair correlation function
(\sphinxcode{\sphinxupquote{gofr}}), static structure factor (\sphinxcode{\sphinxupquote{sk}}), static structure factor
(\sphinxcode{\sphinxupquote{skall}}), energy density (\sphinxcode{\sphinxupquote{energydensity}}), one body reduced
density matrix (\sphinxcode{\sphinxupquote{dm1b}}), \(S(k)\) based kinetic energy correction
(\sphinxcode{\sphinxupquote{chiesa}}), forward walking (\sphinxcode{\sphinxupquote{ForwardWalking}}), and force
(\sphinxcode{\sphinxupquote{Force}}) estimators. Other estimators are not yet covered.

When an \sphinxcode{\sphinxupquote{\textless{}estimator/\textgreater{}}} element appears in \sphinxcode{\sphinxupquote{\textless{}hamiltonian/\textgreater{}}}, it is
evaluated for all applicable chained QMC runs (e.g.,
VMC\(\rightarrow\)DMC\(\rightarrow\)DMC). Estimators are
generally not accumulated during wavefunction optimization sections. If
an \sphinxcode{\sphinxupquote{\textless{}estimator/\textgreater{}}} element is instead provided in a particular
\sphinxcode{\sphinxupquote{\textless{}qmc/\textgreater{}}} element, that estimator is only evaluated for that specific
section (e.g., during VMC only).

\sphinxcode{\sphinxupquote{estimator}} factory element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
type selector:
&
\sphinxcode{\sphinxupquote{type}} attribute
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxstylestrong{type options}
&
density
&
Density on a grid
\\
\hline&
spindensity
&
Spin density on a grid
\\
\hline&
gofr
&
Pair correlation function (quantum species)
\\
\hline&
sk
&
Static structure factor
\\
\hline&
SkAll
&
Static structure factor needed for finite size correction
\\
\hline&
structurefactor
&
Species resolved structure factor
\\
\hline&
species kinetic
&
Species resolved kinetic energy
\\
\hline&
latticedeviation
&
Spatial deviation between two particlesets
\\
\hline&
momentum
&
Momentum distribution
\\
\hline&
energydensity
&
Energy density on uniform or Voronoi grid
\\
\hline&
dm1b
&
One body density matrix in arbitrary basis
\\
\hline&
chiesa
&
Chiesa\sphinxhyphen{}Ceperley\sphinxhyphen{}Martin\sphinxhyphen{}Holzmann kinetic energy correction
\\
\hline&
Force
&
Family of “force” estimators (see {\hyperref[\detokenize{hamiltonianobservable:force-est}]{\sphinxcrossref{\DUrole{std,std-ref}{“Force” estimators}}}})
\\
\hline&
ForwardWalking
&
Forward walking values for existing estimators
\\
\hline&
orbitalimages
&
Create image files for orbitals, then exit
\\
\hline&
flux
&
Checks sampling of kinetic energy
\\
\hline&
localmoment
&
Atomic spin polarization within cutoff radius
\\
\hline&
Pressure
&
\sphinxstyleemphasis{No current function}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

shared attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstyleemphasis{See above}
&
0
&
Select estimator type
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
any
&
Unique name for this estimator
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\subsection{Chiesa\sphinxhyphen{}Ceperley\sphinxhyphen{}Martin\sphinxhyphen{}Holzmann kinetic energy correction}
\label{\detokenize{hamiltonianobservable:chiesa-ceperley-martin-holzmann-kinetic-energy-correction}}
This estimator calculates a finite\sphinxhyphen{}size correction to the kinetic energy following the formalism laid out in \sphinxcite{hamiltonianobservable:chiesa2006}.  The total energy can be corrected for finite\sphinxhyphen{}size effects by using this estimator in conjunction with the MPC correction.

\sphinxcode{\sphinxupquote{estimator type=chiesa}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{chiesa}
&&
Must be chiesa
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^o\)
&
text
&
\sphinxstyleemphasis{anything}
&
KEcorr
&
Always reset to KEcorr
\\
\hline
\sphinxcode{\sphinxupquote{source}}\(^o\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
e
&
Identify quantum particles
\\
\hline
\sphinxcode{\sphinxupquote{psi}}\(^o\)
&
text
&
\sphinxcode{\sphinxupquote{wavefunction.name}}
&
psi0
&
Identify wavefunction
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}
\sphinxSetupCaptionForVerbatim{“Chiesa” kinetic energy finite\sphinxhyphen{}size postcorrection.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-23}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
   \PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{KEcorr}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{chiesa}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{psi}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{psi0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Density estimator}
\label{\detokenize{hamiltonianobservable:density-estimator}}
The particle number density operator is given by
\begin{equation}\label{equation:hamiltonianobservable:eq32}
\begin{split}\hat{n}_r = \sum_i\delta(r-r_i)\:.\end{split}
\end{equation}
The \sphinxcode{\sphinxupquote{density}} estimator accumulates the number density on a uniform
histogram grid over the simulation cell. The value obtained for a grid
cell \(c\) with volume \(\Omega_c\) is then the average number
of particles in that cell:
\begin{equation}\label{equation:hamiltonianobservable:eq33}
\begin{split}n_c = \int dR \left|{\Psi}\right|^2 \int_{\Omega_c}dr \sum_i\delta(r-r_i)\:.\end{split}
\end{equation}
\sphinxcode{\sphinxupquote{estimator type=density}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{density}
&&
Must be density
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
any
&
Unique name for estimator
\\
\hline
\sphinxcode{\sphinxupquote{delta}}\(^o\)
&
real array(3)
&
\(0\le v_i \le 1\)
&
0.1 0.1 0.1
&
Grid cell spacing, unit coords
\\
\hline
\sphinxcode{\sphinxupquote{x\_min}}\(^o\)
&
real
&
\(>0\)
&
0
&
Grid starting point in x (Bohr)
\\
\hline
\sphinxcode{\sphinxupquote{x\_max}}\(^o\)
&
real
&
\(>0\)
&
\(|\) \sphinxcode{\sphinxupquote{lattice{[}0{]}}} \(|\)
&
Grid ending point in x (Bohr)
\\
\hline
\sphinxcode{\sphinxupquote{y\_min}}\(^o\)
&
real
&
\(>0\)
&
0
&
Grid starting point in y (Bohr)
\\
\hline
\sphinxcode{\sphinxupquote{y\_max}}\(^o\)
&
real
&
\(>0\)
&
\(|\) \sphinxcode{\sphinxupquote{lattice{[}1{]}}} \(|\)
&
Grid ending point in y (Bohr)
\\
\hline
\sphinxcode{\sphinxupquote{z\_min}}\(^o\)
&
real
&
\(>0\)
&
0
&
Grid starting point in z (Bohr)
\\
\hline
\sphinxcode{\sphinxupquote{z\_max}}\(^o\)
&
real
&
\(>0\)
&
\(|\) \sphinxcode{\sphinxupquote{lattice{[}2{]}}} \(|\)
&
Grid ending point in z (Bohr)
\\
\hline
\sphinxcode{\sphinxupquote{potential}}\(^o\)
&
boolean
&
yes/no
&
no
&
Accumulate local potential, \sphinxstyleemphasis{deprecated}
\\
\hline
\sphinxcode{\sphinxupquote{debug}}\(^o\)
&
boolean
&
yes/no
&
no
&
\sphinxstyleemphasis{No current function}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name}}: The name provided will be used as a label in the
\sphinxcode{\sphinxupquote{stat.h5}} file for the blocked output data. Postprocessing tools
expect \sphinxcode{\sphinxupquote{name="Density."}}

\item {} 
\sphinxcode{\sphinxupquote{delta}}: This sets the histogram grid size used to accumulate the
density:
\sphinxcode{\sphinxupquote{delta="0.1 0.1 0.05"}}\(\rightarrow 10\times 10\times 20\)
grid,
\sphinxcode{\sphinxupquote{delta="0.01 0.01 0.01"}}\(\rightarrow 100\times 100\times 100\)
grid. The density grid is written to a \sphinxcode{\sphinxupquote{stat.h5}} file at the end of
each MC block. If you request many \(blocks\) in a \sphinxcode{\sphinxupquote{\textless{}qmc/\textgreater{}}}
element, or select a large grid, the resulting \sphinxcode{\sphinxupquote{stat.h5}} file could
be many gigabytes in size.

\item {} 
\sphinxcode{\sphinxupquote{*\_min/*\_max}}: Can be used to select a subset of the simulation
cell for the density histogram grid. For example if a (cubic)
simulation cell is 20 Bohr on a side, setting \sphinxcode{\sphinxupquote{*\_min=5.0}} and
\sphinxcode{\sphinxupquote{*\_max=15.0}} will result in a density histogram grid spanning a
\(10\times 10\times 10\) Bohr cube about the center of the box.
Use of \sphinxcode{\sphinxupquote{x\_min, x\_max, y\_min, y\_max, z\_min, z\_max}} is only
appropriate for orthorhombic simulation cells with open boundary
conditions.

\item {} 
When open boundary conditions are used, a \sphinxcode{\sphinxupquote{\textless{}simulationcell/\textgreater{}}}
element must be explicitly provided as the first subelement of
\sphinxcode{\sphinxupquote{\textless{}qmcsystem/\textgreater{}}} for the density estimator to work. In this case the
molecule should be centered around the middle of the simulation cell
(\(L/2\)) and not the origin (\(0\) since the space within
the cell, and hence the density grid, is defined from \(0\) to
\(L\)).

\end{itemize}
\sphinxSetupCaptionForVerbatim{QMCPXML,caption=Density estimator (uniform grid).}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-24}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
   \PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Density}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{density}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{delta}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.05 0.05 0.05}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Spin density estimator}
\label{\detokenize{hamiltonianobservable:spin-density-estimator}}
The spin density is similar to the total density described previously.  In this case, the sum over particles is performed independently for each spin component.

\sphinxcode{\sphinxupquote{estimator type=spindensity}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{spindensity}
&&
Must be spindensity
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
any
&
Unique name for estimator
\\
\hline
\sphinxcode{\sphinxupquote{report}}\(^o\)
&
boolean
&
yes/no
&
no
&
Write setup details to stdout
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

parameters:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{grid}}\(^o\)
&
integer array(3)
&
\(v_i>\)
&&
Grid cell count
\\
\hline
\sphinxcode{\sphinxupquote{dr}}\(^o\)
&
real array(3)
&
\(v_i>\)
&&
Grid cell spacing (Bohr)
\\
\hline
\sphinxcode{\sphinxupquote{cell}}\(^o\)
&
real array(3,3)
&
\sphinxstyleemphasis{anything}
&&
Volume grid exists in
\\
\hline
\sphinxcode{\sphinxupquote{corner}}\(^o\)
&
real array(3)
&
\sphinxstyleemphasis{anything}
&&
Volume corner location
\\
\hline
\sphinxcode{\sphinxupquote{center}}\(^o\)
&
real array (3)
&
\sphinxstyleemphasis{anything}
&&
Volume center/origin location
\\
\hline
\sphinxcode{\sphinxupquote{voronoi}}\(^o\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&&
\sphinxstyleemphasis{Under development}
\\
\hline
\sphinxcode{\sphinxupquote{test\_moves}}\(^o\)
&
integer
&
\(>=0\)
&
0
&
Test estimator with random moves
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name}}: The name provided will be used as a label in the
\sphinxcode{\sphinxupquote{stat.h5}} file for the blocked output data. Postprocessing tools
expect \sphinxcode{\sphinxupquote{name="SpinDensity."}}

\item {} 
\sphinxcode{\sphinxupquote{grid}}: The grid sets the dimension of the histogram grid. Input
like \sphinxcode{\sphinxupquote{\textless{}parameter name="grid"\textgreater{} 40 40 40 \textless{}/parameter\textgreater{}}} requests a
\(40 \times 40\times 40\) grid. The shape of individual grid
cells is commensurate with the supercell shape.

\item {} 
\sphinxcode{\sphinxupquote{dr}}: The \sphinxcode{\sphinxupquote{dr}} sets the real\sphinxhyphen{}space dimensions of grid cell edges
(Bohr units). Input like
\sphinxcode{\sphinxupquote{\textless{}parameter name="dr"\textgreater{} 0.5 0.5 0.5 \textless{}/parameter\textgreater{}}} in a supercell
with axes of length 10 Bohr each (but of arbitrary shape) will
produce a \(20\times 20\times 20\) grid. The inputted \sphinxcode{\sphinxupquote{dr}}
values are rounded to produce an integer number of grid cells along
each supercell axis. Either \sphinxcode{\sphinxupquote{grid}} or \sphinxcode{\sphinxupquote{dr}} must be provided, but
not both.

\item {} 
\sphinxcode{\sphinxupquote{cell}}: When \sphinxcode{\sphinxupquote{cell}} is provided, a user\sphinxhyphen{}defined grid volume is
used instead of the global supercell. This must be provided if open
boundary conditions are used. Additionally, if \sphinxcode{\sphinxupquote{cell}} is provided,
the user must specify where the volume is located in space in
addition to its size/shape (\sphinxcode{\sphinxupquote{cell}}) using either the \sphinxcode{\sphinxupquote{corner}} or
\sphinxcode{\sphinxupquote{center}} parameters.

\item {} 
\sphinxcode{\sphinxupquote{corner}}: The grid volume is defined as
\(corner+\sum_{d=1}^3u_dcell_d\) with \(0<u_d<1\) (“cell”
refers to either the supercell or user\sphinxhyphen{}provided cell).

\item {} 
\sphinxcode{\sphinxupquote{center}}: The grid volume is defined as
\(center+\sum_{d=1}^3u_dcell_d\) with \(-1/2<u_d<1/2\)
(“cell” refers to either the supercell or user\sphinxhyphen{}provided cell).
\sphinxcode{\sphinxupquote{corner/center}} can be used to shift the grid even if \sphinxcode{\sphinxupquote{cell}} is
not specified. Simultaneous use of \sphinxcode{\sphinxupquote{corner}} and \sphinxcode{\sphinxupquote{center}} will
cause QMCPACK to abort.

\end{itemize}
\sphinxSetupCaptionForVerbatim{Spin density estimator (uniform grid).}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-25}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spindensity}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SpinDensity}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{report}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{grid}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{40} \PYG{l+m+mi}{40} \PYG{l+m+mi}{40} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{estimator}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{Spin density estimator (uniform grid centered about origin).}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-26}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spindensity}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SpinDensity}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{report}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{grid}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{l+m+mi}{20} \PYG{l+m+mi}{20} \PYG{l+m+mi}{20}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{center}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cell}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{l+m+mf}{10.0}  \PYG{l+m+mf}{0.0}  \PYG{l+m+mf}{0.0}
     \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{10.0}  \PYG{l+m+mf}{0.0}
     \PYG{l+m+mf}{0.0}  \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{10.0}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{estimator}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Pair correlation function, \protect\(g(r)\protect\)}
\label{\detokenize{hamiltonianobservable:pair-correlation-function-g-r}}
The functional form of the species\sphinxhyphen{}resolved radial pair correlation function operator is
\begin{equation}\label{equation:hamiltonianobservable:eq34}
\begin{split}g_{ss'}(r) = \frac{V}{4\pi r^2N_sN_{s'}}\sum_{i_s=1}^{N_s}\sum_{j_{s'}=1}^{N_{s'}}\delta(r-|r_{i_s}-r_{j_{s'}}|)\:,\end{split}
\end{equation}
where \(N_s\) is the number of particles of species \(s\) and
\(V\) is the supercell volume. If \(s=s'\), then the sum is
restricted so that \(i_s\ne j_s\).

In QMCPACK, an estimate of \(g_{ss'}(r)\) is obtained as a radial
histogram with a set of \(N_b\) uniform bins of width
\(\delta r\). This can be expressed analytically as
\begin{equation}\label{equation:hamiltonianobservable:eq35}
\begin{split}\tilde{g}_{ss'}(r) = \frac{V}{4\pi r^2N_sN_{s'}}\sum_{i=1}^{N_s}\sum_{j=1}^{N_{s'}}\frac{1}{\delta r}\int_{r-\delta r/2}^{r+\delta r/2}dr'\delta(r'-|r_{si}-r_{s'j}|)\:,\end{split}
\end{equation}
where the radial coordinate \(r\) is restricted to reside at the bin
centers, \(\delta r/2, 3 \delta r/2, 5 \delta r/2, \ldots\).

\sphinxcode{\sphinxupquote{estimator type=gofr}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{gofr}
&&
Must be gofr
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^o\)
&
text
&
\sphinxstyleemphasis{anything}
&
any
&
\sphinxstyleemphasis{No current function}
\\
\hline
\sphinxcode{\sphinxupquote{num\_bin}}\(^r\)
&
integer
&
\(>1\)
&
20
&
\# of histogram bins
\\
\hline
\sphinxcode{\sphinxupquote{rmax}}\(^o\)
&
real
&
\(>0\)
&
10
&
Histogram extent (Bohr)
\\
\hline
\sphinxcode{\sphinxupquote{dr}}\(^o\)
&
real
&
\(0\)
&
0.5
&
\sphinxstyleemphasis{No current function}
\\
\hline
\sphinxcode{\sphinxupquote{debug}}\(^o\)
&
boolean
&
yes/no
&
no
&
\sphinxstyleemphasis{No current function}
\\
\hline
\sphinxcode{\sphinxupquote{target}}\(^o\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
\sphinxcode{\sphinxupquote{hamiltonian.target}}
&
Quantum particles
\\
\hline
\sphinxcode{\sphinxupquote{source/sources}}\(^o\)
&
text array
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
\sphinxcode{\sphinxupquote{hamiltonian.target}}
&
Classical particles
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{num\_bin:}} This is the number of bins in each species pair radial
histogram.

\item {} 
\sphinxcode{\sphinxupquote{rmax:}} This is the maximum pair distance included in the
histogram. The uniform bin width is
\(\delta r=\texttt{rmax/num\_bin}\). If periodic boundary
conditions are used for any dimension of the simulation cell, then
the default value of \sphinxcode{\sphinxupquote{rmax}} is the simulation cell radius instead
of 10 Bohr. For open boundary conditions, the volume (\(V\)) used
is 1.0 Bohr\(^3\).

\item {} 
\sphinxcode{\sphinxupquote{source/sources:}} If unspecified, only pair correlations between
each species of quantum particle will be measured. For each classical
particleset specified by \sphinxcode{\sphinxupquote{source/sources}}, additional pair
correlations between each quantum and classical species will be
measured. Typically there is only one classical particleset (e.g.,
\sphinxcode{\sphinxupquote{source="ion0"}}), but there can be several in principle (e.g.,
\sphinxcode{\sphinxupquote{sources="ion0 ion1 ion2"}}).

\item {} 
\sphinxcode{\sphinxupquote{target:}} The default value is the preferred usage (i.e.,
\sphinxcode{\sphinxupquote{target}} does not need to be provided).

\item {} 
Data is output to the \sphinxcode{\sphinxupquote{stat.h5}} for each QMC subrun. Individual
histograms are named according to the quantum particleset and index
of the pair. For example, if the quantum particleset is named “e” and
there are two species (up and down electrons, say), then there will
be three sets of histogram data in each \sphinxcode{\sphinxupquote{stat.h5}} file named
\sphinxcode{\sphinxupquote{gofr\_e\_0\_0}}, \sphinxcode{\sphinxupquote{gofr\_e\_0\_1}}, and \sphinxcode{\sphinxupquote{gofr\_e\_1\_1}} for up\sphinxhyphen{}up,
up\sphinxhyphen{}down, and down\sphinxhyphen{}down correlations, respectively.

\end{itemize}
\sphinxSetupCaptionForVerbatim{Pair correlation function estimator element.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-27}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{gofr}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{gofr}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{num\PYGZus{}bin}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{200}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rmax}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{Pair correlation function estimator element with additional electron\sphinxhyphen{}ion correlations.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-28}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{gofr}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{gofr}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{num\PYGZus{}bin}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{200}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rmax}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Static structure factor, \protect\(S(k)\protect\)}
\label{\detokenize{hamiltonianobservable:static-structure-factor-s-k}}
Let
\(\rho^e_{\mathbf{k}}=\sum_j e^{i \mathbf{k}\cdot\mathbf{r}_j^e}\)
be the Fourier space electron density, with \(\mathbf{r}^e_j\) being
the coordinate of the j\sphinxhyphen{}th electron. \(\mathbf{k}\) is a wavevector
commensurate with the simulation cell. QMCPACK allows the user to
accumulate the static electron structure factor \(S(\mathbf{k})\) at
all commensurate \(\mathbf{k}\) such that
\(|\mathbf{k}| \leq (LR\_DIM\_CUTOFF) r_c\). \(N^e\) is the
number of electrons, \sphinxcode{\sphinxupquote{LR\_DIM\_CUTOFF}} is the optimized breakup
parameter, and \(r_c\) is the Wigner\sphinxhyphen{}Seitz radius. It is defined as
follows:
\begin{equation}\label{equation:hamiltonianobservable:eq36}
\begin{split}S(\mathbf{k}) = \frac{1}{N^e}\langle \rho^e_{-\mathbf{k}} \rho^e_{\mathbf{k}} \rangle\:.\end{split}
\end{equation}
\sphinxcode{\sphinxupquote{estimator type=sk}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
sk
&&
Must sk
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
any
&
Unique name for estimator
\\
\hline
\sphinxcode{\sphinxupquote{hdf5}}\(^o\)
&
boolean
&
yes/no
&
no
&
Output to \sphinxcode{\sphinxupquote{stat.h5}} (yes) or \sphinxcode{\sphinxupquote{scalar.dat}} (no)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name:}} This is the unique name for estimator instance. A data
structure of the same name will appear in \sphinxcode{\sphinxupquote{stat.h5}} output files.

\item {} 
\sphinxcode{\sphinxupquote{hdf5:}} If \sphinxcode{\sphinxupquote{hdf5==yes}}, output data for \(S(k)\) is directed
to the \sphinxcode{\sphinxupquote{stat.h5}} file (recommended usage). If \sphinxcode{\sphinxupquote{hdf5==no}}, the
data is instead routed to the \sphinxcode{\sphinxupquote{scalar.dat}} file, resulting in many
columns of data with headings prefixed by \sphinxcode{\sphinxupquote{name}} and postfixed by
the k\sphinxhyphen{}point index (e.g., \sphinxcode{\sphinxupquote{sk\_0 sk\_1 …sk\_1037 …}}).

\item {} 
This estimator only works in periodic boundary conditions. Its
presence in the input file is ignored otherwise.

\item {} 
This is not a species\sphinxhyphen{}resolved structure factor. Additionally, for
\(\mathbf{k}\) vectors commensurate with the unit cell,
\(S(\mathbf{k})\) will include contributions from the static
electronic density, thus meaning it will not accurately measure the
electron\sphinxhyphen{}electron density response.

\end{itemize}
\sphinxSetupCaptionForVerbatim{Static structure factor estimator element.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-29}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sk}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sk}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{hdf5}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Static structure factor, \sphinxstyleliteralintitle{\sphinxupquote{SkAll}}}
\label{\detokenize{hamiltonianobservable:static-structure-factor-skall}}
In order to compute the finite size correction to the potential energy,
records of \(\rho(\mathbf{k})\) is required. What sets \sphinxcode{\sphinxupquote{SkAll}}
apart from \sphinxcode{\sphinxupquote{sk}} is that \sphinxcode{\sphinxupquote{SkAll}} records \(\rho(\mathbf{k})\) in
addition to \(s(\mathbf{k})\).

\sphinxcode{\sphinxupquote{estimator type=SkAll}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
sk
&&
Must be sk
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
any
&
Unique name for estimator
\\
\hline
\sphinxcode{\sphinxupquote{source}}\(^r\)
&
text
&
Ion ParticleSet name
&
None
&
\sphinxtitleref{\sphinxhyphen{}}
\\
\hline
\sphinxcode{\sphinxupquote{target}}\(^r\)
&
text
&
Electron ParticleSet name
&
None
&
\sphinxtitleref{\sphinxhyphen{}}
\\
\hline
\sphinxcode{\sphinxupquote{hdf5}}\(^o\)
&
boolean
&
yes/no
&
no
&
Output to \sphinxcode{\sphinxupquote{stat.h5}} (yes) or \sphinxcode{\sphinxupquote{scalar.dat}} (no)
\\
\hline
\sphinxcode{\sphinxupquote{writeionion}}\(^o\)
&
boolean
&
yes/no
&
no
&
Writes file rhok\_IonIon.dat containing \(s(\mathbf{k})\) for the ions
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name:}} This is the unique name for estimator instance. A data
structure of the same name will appear in \sphinxcode{\sphinxupquote{stat.h5}} output files.

\item {} 
\sphinxcode{\sphinxupquote{hdf5:}} If \sphinxcode{\sphinxupquote{hdf5==yes}}, output data is directed to the
\sphinxcode{\sphinxupquote{stat.h5}} file (recommended usage). If \sphinxcode{\sphinxupquote{hdf5==no}}, the data is
instead routed to the \sphinxcode{\sphinxupquote{scalar.dat}} file, resulting in many columns
of data with headings prefixed by \sphinxcode{\sphinxupquote{rhok}} and postfixed by the
k\sphinxhyphen{}point index.

\item {} 
This estimator only works in periodic boundary conditions. Its
presence in the input file is ignored otherwise.

\item {} 
This is not a species\sphinxhyphen{}resolved structure factor. Additionally, for
\(\mathbf{k}\) vectors commensurate with the unit cell,
\(S(\mathbf{k})\) will include contributions from the static
electronic density, thus meaning it wil not accurately measure the
electron\sphinxhyphen{}electron density response.

\end{itemize}
\sphinxSetupCaptionForVerbatim{SkAll estimator element.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-30}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{skall}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SkAll}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{hdf5}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Species kinetic energy}
\label{\detokenize{hamiltonianobservable:species-kinetic-energy}}
Record species\sphinxhyphen{}resolved kinetic energy instead of the total kinetic
energy in the \sphinxcode{\sphinxupquote{Kinetic}} column of scalar.dat. \sphinxcode{\sphinxupquote{SpeciesKineticEnergy}}
is arguably the simplest estimator in QMCPACK. The implementation of
this estimator is detailed in
\sphinxcode{\sphinxupquote{manual/estimator/estimator\_implementation.pdf}}.

\sphinxcode{\sphinxupquote{estimator type=specieskinetic}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
specieskinetic
&&
Must be specieskinetic
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
any
&
Unique name for estimator
\\
\hline
\sphinxcode{\sphinxupquote{hdf5}}\(^o\)
&
boolean
&
yes/no
&
no
&
Output to \sphinxcode{\sphinxupquote{stat.h5}} (yes)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}
\sphinxSetupCaptionForVerbatim{Species kinetic energy estimator element.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-31}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{specieskinetic}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{skinetic}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{hdf5}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Lattice deviation estimator}
\label{\detokenize{hamiltonianobservable:lattice-deviation-estimator}}
Record deviation of a group of particles in one particle set (target) from a group of particles in another particle set (source).

\sphinxcode{\sphinxupquote{estimator type=latticedeviation}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
latticedeviation
&&
Must be latticedeviation
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
any
&
Unique name for estimator
\\
\hline
\sphinxcode{\sphinxupquote{hdf5}}\(^o\)
&
boolean
&
yes/no
&
no
&
Output to \sphinxcode{\sphinxupquote{stat.h5}} (yes)
\\
\hline
\sphinxcode{\sphinxupquote{per\_xyz}}\(^o\)
&
boolean
&
yes/no
&
no
&
Directionally resolved (yes)
\\
\hline
\sphinxcode{\sphinxupquote{source}}\(^r\)
&
text
&
e/ion0/…
&
no
&
source particleset
\\
\hline
\sphinxcode{\sphinxupquote{sgroup}}\(^r\)
&
text
&
u/d/…
&
no
&
source particle group
\\
\hline
\sphinxcode{\sphinxupquote{target}}\(^r\)
&
text
&
e/ion0/…
&
no
&
target particleset
\\
\hline
\sphinxcode{\sphinxupquote{tgroup}}\(^r\)
&
text
&
u/d/…
&
no
&
target particle group
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{source}}: The “reference” particleset to measure distances from;
actual reference points are determined together with \sphinxcode{\sphinxupquote{sgroup}}.

\item {} 
\sphinxcode{\sphinxupquote{sgroup}}: The “reference” particle group to measure distances from.

\item {} 
\sphinxcode{\sphinxupquote{source}}: The “target” particleset to measure distances to.

\item {} 
\sphinxcode{\sphinxupquote{sgroup}}: The “target” particle group to measure distances to. For
example, in {\hyperref[\detokenize{hamiltonianobservable:listing-32}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 32}}}} the distance from the up
electron (“u”) to the origin of the coordinate system is recorded.

\item {} 
\sphinxcode{\sphinxupquote{per\_xyz}}: Used to record direction\sphinxhyphen{}resolved distance. In
{\hyperref[\detokenize{hamiltonianobservable:listing-32}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 32}}}}, the x,y,z coordinates of the up electron
will be recorded separately if \sphinxcode{\sphinxupquote{per\_xyz=yes}}.

\item {} 
\sphinxcode{\sphinxupquote{hdf5}}: Used to record particle\sphinxhyphen{}resolved distances in the h5 file
if \sphinxcode{\sphinxupquote{gdf5=yes}}.

\end{itemize}
\sphinxSetupCaptionForVerbatim{Lattice deviation estimator element.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-32}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{particleset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{random}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{mass}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}              \PYG{o}{\PYGZgt{}}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}                    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mass}\PYG{l+s+s2}{\PYGZdq{}}                \PYG{o}{\PYGZgt{}}    \PYG{l+m+mf}{1.0}                   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{mass}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}              \PYG{o}{\PYGZgt{}}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}                    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mass}\PYG{l+s+s2}{\PYGZdq{}}                \PYG{o}{\PYGZgt{}}    \PYG{l+m+mf}{1.0}                   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{particleset}\PYG{o}{\PYGZgt{}}

\PYG{o}{\PYGZlt{}}\PYG{n}{particleset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{wf\PYGZus{}center}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{origin}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{attrib} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{position}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{datatype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{posArray}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{condition}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
             \PYG{l+m+mf}{0.00000000}        \PYG{l+m+mf}{0.00000000}        \PYG{l+m+mf}{0.00000000}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{attrib}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{particleset}\PYG{o}{\PYGZgt{}}

\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{latticedeviation}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{latdev}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{hdf5}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{per\PYGZus{}xyz}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{wf\PYGZus{}center}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{sgroup}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{origin}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{tgroup}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Energy density estimator}
\label{\detokenize{hamiltonianobservable:energy-density-estimator}}
An energy density operator, \(\hat{\mathcal{E}}_r\), satisfies
\begin{equation}\label{equation:hamiltonianobservable:eq37}
\begin{split}\int dr \hat{\mathcal{E}}_r = \hat{H},\end{split}
\end{equation}
where the integral is over all space and \(\hat{H}\) is the
Hamiltonian. In QMCPACK, the energy density is split into kinetic and potential
components
\begin{equation}\label{equation:hamiltonianobservable:eq38}
\begin{split}\hat{\mathcal{E}}_r = \hat{\mathcal{T}}_r + \hat{\mathcal{V}}_r\:,\end{split}
\end{equation}
with each component given by
\begin{equation}\label{equation:hamiltonianobservable:eq39}
\begin{split}\begin{aligned}
    \hat{\mathcal{T}}_r &=  \frac{1}{2}\sum_i\delta(r-r_i)\hat{p}_i^2 \\
    \hat{\mathcal{V}}_r &=  \sum_{i<j}\frac{\delta(r-r_i)+\delta(r-r_j)}{2}\hat{v}^{ee}(r_i,r_j)
               + \sum_{i\ell}\frac{\delta(r-r_i)+\delta(r-\tilde{r}_\ell)}{2}\hat{v}^{eI}(r_i,\tilde{r}_\ell) \nonumber\\
     &\qquad   + \sum_{\ell< m}\frac{\delta(r-\tilde{r}_\ell)+\delta(r-\tilde{r}_m)}{2}\hat{v}^{II}(\tilde{r}_\ell,\tilde{r}_m)\:.\nonumber\end{aligned}\end{split}
\end{equation}
Here, \(r_i\) and \(\tilde{r}_\ell\) represent electron and ion
positions, respectively; \(\hat{p}_i\) is a single electron momentum
operator; and \(\hat{v}^{ee}(r_i,r_j)\),
\(\hat{v}^{eI}(r_i,\tilde{r}_\ell)\), and
\(\hat{v}^{II}(\tilde{r}_\ell,\tilde{r}_m)\) are the
electron\sphinxhyphen{}electron, electron\sphinxhyphen{}ion, and ion\sphinxhyphen{}ion pair potential operators
(including nonlocal pseudopotentials, if present). This form of the
energy density is size consistent; that is, the partially integrated
energy density operators of well\sphinxhyphen{}separated atoms gives the isolated
Hamiltonians of the respective atoms. For periodic systems with
twist\sphinxhyphen{}averaged boundary conditions, the energy density is formally
correct only for either a set of supercell k\sphinxhyphen{}points that correspond to
real\sphinxhyphen{}valued wavefunctions or a k\sphinxhyphen{}point set that has inversion symmetry
around a k\sphinxhyphen{}point having a real\sphinxhyphen{}valued wavefunction. For more information
about the energy density, see \sphinxcite{hamiltonianobservable:krogel2013}.

In QMCPACK, the energy density can be accumulated on piecewise uniform 3D grids in generalized Cartesian, cylindrical, or spherical coordinates.  The energy density integrated within Voronoi volumes centered on ion positions is also available.  The total particle number density is also accumulated on the same grids by the energy density estimator for convenience so that related quantities, such as the regional energy per particle, can be computed easily.

\sphinxcode{\sphinxupquote{estimator type=EnergyDensity}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{reference\_points, spacegrid}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{EnergyDensity}
&&
Must be EnergyDensity
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&&
Unique name for estimator
\\
\hline
\sphinxcode{\sphinxupquote{dynamic}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&&
Identify electrons
\\
\hline
\sphinxcode{\sphinxupquote{static}}\(^o\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&&
Identify ions
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name:}} Must be unique. A dataset with blocked statistical data for
the energy density will appear in the \sphinxcode{\sphinxupquote{stat.h5}} files labeled as
\sphinxcode{\sphinxupquote{name}}.

\end{itemize}
\sphinxSetupCaptionForVerbatim{Energy density estimator accumulated on a \(20 \times  10 \times 10\) grid over the simulation cell.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-33}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EnergyDensity}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EDcell}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{dynamic}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{static}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{spacegrid} \PYG{n}{coord}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cartesian}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{origin} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{zero}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{axis} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{scale}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.5}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{grid}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}1 (.05) 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{axis} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{scale}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.5}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{grid}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}1 (.1) 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{axis} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{scale}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.5}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{z}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{grid}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}1 (.1) 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{spacegrid}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{estimator}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{Energy density estimator accumulated within spheres of radius 6.9 Bohr centered on the first and second atoms in the ion0 particleset.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-34}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EnergyDensity}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EDatom}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{dynamic}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{static}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{reference\PYGZus{}points} \PYG{n}{coord}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cartesian}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{r1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}
    \PYG{n}{r2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0}
    \PYG{n}{r3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{reference\PYGZus{}points}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{spacegrid} \PYG{n}{coord}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spherical}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{origin} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion01}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{axis} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{scale}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6.9}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r}\PYG{l+s+s2}{\PYGZdq{}}     \PYG{n}{grid}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{axis} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{scale}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6.9}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{phi}\PYG{l+s+s2}{\PYGZdq{}}   \PYG{n}{grid}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{axis} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{scale}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6.9}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{theta}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{grid}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{spacegrid}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{spacegrid} \PYG{n}{coord}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spherical}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{origin} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion02}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{axis} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{scale}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6.9}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r}\PYG{l+s+s2}{\PYGZdq{}}     \PYG{n}{grid}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{axis} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{scale}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6.9}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{phi}\PYG{l+s+s2}{\PYGZdq{}}   \PYG{n}{grid}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{axis} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{scale}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6.9}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{theta}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{grid}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{spacegrid}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{estimator}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{Energy density estimator accumulated within Voronoi polyhedra centered on the ions.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-35}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EnergyDensity}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EDvoronoi}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{dynamic}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{static}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{spacegrid} \PYG{n}{coord}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{voronoi}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{estimator}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{\textless{}reference\_points/\textgreater{}}} element provides a set of points for later
use in specifying the origin and coordinate axes needed to construct a
spatial histogramming grid. Several reference points on the surface of
the simulation cell (see \hyperref[\detokenize{hamiltonianobservable:table8}]{Table \ref{\detokenize{hamiltonianobservable:table8}}}), as well as the
positions of the ions (see the \sphinxcode{\sphinxupquote{energydensity.static}} attribute), are
made available by default. The reference points can be used, for
example, to construct a cylindrical grid along a bond with the origin on
the bond center.
\begin{quote}

\sphinxcode{\sphinxupquote{reference\_points}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{estimator type=EnergyDensity}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{coord}}\(^r\)
&
text
&
Cartesian/cell
&&
Specify coordinate system
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

body text: The body text is a line formatted list of points with labels
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{coord:}} If \sphinxcode{\sphinxupquote{coord=cartesian}}, labeled points are in Cartesian
(x,y,z) format in units of Bohr. If \sphinxcode{\sphinxupquote{coord=cell}}, then labeled
points are in units of the simulation cell axes.

\item {} 
\sphinxcode{\sphinxupquote{body text:}} The list of points provided in the body text are line
formatted, with four entries per line (\sphinxstyleemphasis{label} \sphinxstyleemphasis{coor1} \sphinxstyleemphasis{coor2}
\sphinxstyleemphasis{coor3}). A set of points referenced to the simulation cell is
available by default (see \hyperref[\detokenize{hamiltonianobservable:table8}]{Table \ref{\detokenize{hamiltonianobservable:table8}}}). If
\sphinxcode{\sphinxupquote{energydensity.static}} is provided, the location of each individual
ion is also available (e.g., if \sphinxcode{\sphinxupquote{energydensity.static=ion0}}, then
the location of the first atom is available with label ion01, the
second with ion02, etc.). All points can be used by label when
constructing spatial histogramming grids (see the following
\sphinxcode{\sphinxupquote{spacegrid}} element) used to collect energy densities.

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{hamiltonianobservable:table8}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{label}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{point}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{description}}
\\
\hline
\sphinxcode{\sphinxupquote{zero}}
&
0 0 0
&
Cell center
\\
\hline
\sphinxcode{\sphinxupquote{a1}}
&
\(a_1\)
&
Cell axis 1
\\
\hline
\sphinxcode{\sphinxupquote{a2}}
&
\(a_2\)
&
Cell axis 2
\\
\hline
\sphinxcode{\sphinxupquote{a3}}
&
\(a_3\)
&
Cell axis 3
\\
\hline
\sphinxcode{\sphinxupquote{f1p}}
&
\(a_1\)/2
&
Cell face 1+
\\
\hline
\sphinxcode{\sphinxupquote{f1m}}
&
\sphinxhyphen{}\(a_1\)/2
&
Cell face 1\sphinxhyphen{}
\\
\hline
\sphinxcode{\sphinxupquote{f2p}}
&
\(a_2\)/2
&
Cell face 2+
\\
\hline
\sphinxcode{\sphinxupquote{f2m}}
&
\sphinxhyphen{}\(a_2\)/2
&
Cell face 2\sphinxhyphen{}
\\
\hline
\sphinxcode{\sphinxupquote{f3p}}
&
\(a_3\)/2
&
Cell face 3+
\\
\hline
\sphinxcode{\sphinxupquote{f3m}}
&
\sphinxhyphen{}\(a_3\)/2
&
Cell face 3\sphinxhyphen{}
\\
\hline
\sphinxcode{\sphinxupquote{cppp}}
&
\((a_1+a_2+a_3)/2\)
&
Cell corner +,+,+
\\
\hline
\sphinxcode{\sphinxupquote{cppm}}
&
\((a_1+a_2-a_3)/2\)
&
Cell corner +,+,\sphinxhyphen{}
\\
\hline
\sphinxcode{\sphinxupquote{cpmp}}
&
\((a_1-a_2+a_3)/2\)
&
Cell corner +,\sphinxhyphen{},+
\\
\hline
\sphinxcode{\sphinxupquote{cmpp}}
&
\((-a_1+a_2+a_3)/2\)
&
Cell corner \sphinxhyphen{},+,+
\\
\hline
\sphinxcode{\sphinxupquote{cpmm}}
&
\((a_1-a_2-a_3)/2\)
&
Cell corner +,\sphinxhyphen{},\sphinxhyphen{}
\\
\hline
\sphinxcode{\sphinxupquote{cmpm}}
&
\((-a_1+a_2-a_3)/2\)
&
Cell corner \sphinxhyphen{},+,\sphinxhyphen{}
\\
\hline
\sphinxcode{\sphinxupquote{cmmp}}
&
\((-a_1-a_2+a_3)/2\)
&
Cell corner \sphinxhyphen{},\sphinxhyphen{},+
\\
\hline
\sphinxcode{\sphinxupquote{cmmm}}
&
\((-a_1-a_2-a_3)/2\)
&
Cell corner \sphinxhyphen{},\sphinxhyphen{},\sphinxhyphen{}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{center}Table 8 Reference points available by default. Vectors \(a_1\), \(a_2\), and \(a_3\) refer to the simulation cell axes. The representation of the cell is centered around \sphinxcode{\sphinxupquote{zero}}.
\end{center}
The \sphinxcode{\sphinxupquote{\textless{}spacegrid/\textgreater{}}} element is used to specify a spatial histogramming
grid for the energy density. Grids are constructed based on a set of,
potentially nonorthogonal, user\sphinxhyphen{}provided coordinate axes. The axes are
based on information available from \sphinxcode{\sphinxupquote{reference\_points}}. Voronoi grids
are based only on nearest neighbor distances between electrons and ions.
Any number of space grids can be provided to a single energy density
estimator.

\sphinxcode{\sphinxupquote{spacegrid}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{estimator type=EnergyDensity}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{origin, axis}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{coord}}\(^r\)
&
text
&
Cartesian
&&
Specify coordinate system
\\
\hline&&
cylindrical
&&\\
\hline&&
spherical
&&\\
\hline&&
Voronoi
&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

The \sphinxcode{\sphinxupquote{\textless{}origin/\textgreater{}}} element gives the location of the origin for a
non\sphinxhyphen{}Voronoi grid.

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{p1/p2/fraction:}} The location of the origin is set to
\sphinxcode{\sphinxupquote{p1+fraction*(p2\sphinxhyphen{}p1)}}. If only \sphinxcode{\sphinxupquote{p1}} is provided, the origin is at
\sphinxcode{\sphinxupquote{p1}}.

\end{itemize}

\sphinxcode{\sphinxupquote{origin}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{spacegrid}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{p1}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{reference\_point.label}}
&&
Select end point
\\
\hline
\sphinxcode{\sphinxupquote{p2}}\(^o\)
&
text
&
\sphinxcode{\sphinxupquote{reference\_point.label}}
&&
Select end point
\\
\hline
\sphinxcode{\sphinxupquote{fraction}}\(^o\)
&
real
&&
0
&
Interpolation fraction
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

The \sphinxcode{\sphinxupquote{\textless{}axis/\textgreater{}}} element represents a coordinate axis used to construct the, possibly curved, coordinate system for the histogramming grid.  Three \sphinxcode{\sphinxupquote{\textless{}axis/\textgreater{}}} elements must be provided to a non\sphinxhyphen{}Voronoi \sphinxcode{\sphinxupquote{\textless{}spacegrid/\textgreater{}}} element.

\sphinxcode{\sphinxupquote{axis}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{spacegrid}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{label}}\(^r\)
&
text
&
\sphinxstyleemphasis{See below}
&&
Axis/dimension label
\\
\hline
\sphinxcode{\sphinxupquote{grid}}\(^r\)
&
text
&&
“0 1”
&
Grid ranges/intervals
\\
\hline
\sphinxcode{\sphinxupquote{p1}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{reference\_point.label}}
&&
Select end point
\\
\hline
\sphinxcode{\sphinxupquote{p2}}\(^o\)
&
text
&
\sphinxcode{\sphinxupquote{reference\_point.label}}
&&
Select end point
\\
\hline
\sphinxcode{\sphinxupquote{scale}}\(^o\)
&
real
&&&
Interpolation fraction
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{label:}} The allowed set of axis labels depends on the coordinate
system (i.e., \sphinxcode{\sphinxupquote{spacegrid.coord}}). Labels are \sphinxcode{\sphinxupquote{x/y/z}} for
\sphinxcode{\sphinxupquote{coord=cartesian}}, \sphinxcode{\sphinxupquote{r/phi/z}} for \sphinxcode{\sphinxupquote{coord=cylindrical}},
\sphinxcode{\sphinxupquote{r/phi/theta}} for \sphinxcode{\sphinxupquote{coord=spherical}}.

\item {} 
\sphinxcode{\sphinxupquote{p1/p2/scale:}} The axis vector is set to \sphinxcode{\sphinxupquote{p1+scale*(p2\sphinxhyphen{}p1)}}. If
only \sphinxcode{\sphinxupquote{p1}} is provided, the axis vector is \sphinxcode{\sphinxupquote{p1}}.

\item {} 
\sphinxcode{\sphinxupquote{grid:}} The grid specifies the histogram grid along the direction
specified by \sphinxcode{\sphinxupquote{label}}. The allowed grid points fall in the range
{[}\sphinxhyphen{}1,1{]} for \sphinxcode{\sphinxupquote{label=x/y/z}} or {[}0,1{]} for \sphinxcode{\sphinxupquote{r/phi/theta}}. A grid of 10
evenly spaced points between 0 and 1 can be requested equivalently by
\sphinxcode{\sphinxupquote{grid="0 (0.1) 1"}} or \sphinxcode{\sphinxupquote{grid="0 (10) 1."}} Piecewise uniform grids
covering portions of the range are supported, e.g.,
\sphinxcode{\sphinxupquote{grid="\sphinxhyphen{}0.7 (10) 0.0 (20) 0.5."}}

\item {} 
Note that \sphinxcode{\sphinxupquote{grid}} specifies the histogram grid along the (curved)
coordinate given by \sphinxcode{\sphinxupquote{label}}. The axis specified by \sphinxcode{\sphinxupquote{p1/p2/scale}}
does not correspond one\sphinxhyphen{}to\sphinxhyphen{}one with \sphinxcode{\sphinxupquote{label}} unless \sphinxcode{\sphinxupquote{label=x/y/z}},
but the full set of axes provided defines the (sheared) space on top
of which the curved (e.g., spherical) coordinate system is built.

\end{itemize}


\subsection{One body density matrix}
\label{\detokenize{hamiltonianobservable:one-body-density-matrix}}
The N\sphinxhyphen{}body density matrix in DMC is
\(\hat{\rho}_N=\left|{\Psi_{T}}\rangle{}\langle{\Psi_{FN}}\right|\) (for VMC,
substitute \(\Psi_T\) for \(\Psi_{FN}\)). The one body reduced
density matrix (1RDM) is obtained by tracing out all particle
coordinates but one:
\begin{equation}\label{equation:hamiltonianobservable:eq40}
\begin{split}\hat{n}_1 = \sum_nTr_{R_n}\left|{\Psi_{T}}\rangle{}\langle{\Psi_{FN}}\right|\end{split}
\end{equation}
In this formula, the sum is over all electron indices and
\(Tr_{R_n}(*)\equiv\int dR_n\langle{R_n}\left|{*}\right|{R_n}\rangle\) with
\(R_n=[r_1,...,r_{n-1},r_{n+1},...,r_N]\). When the sum is
restricted over spin\sphinxhyphen{}up or spin\sphinxhyphen{}down electrons, one obtains a density
matrix for each spin species. The 1RDM computed by is partitioned in
this way.

In real space, the matrix elements of the 1RDM are
\begin{equation}\label{equation:hamiltonianobservable:eq41}
\begin{split}\begin{aligned}
   n_1(r,r') &= \langle{r}\left|{\hat{n}_1}\right|{r'}\rangle = \sum_n\int dR_n \Psi_T(r,R_n)\Psi_{FN}^*(r',R_n)\:. \end{aligned}\end{split}
\end{equation}
A more efficient and compact representation of the 1RDM is obtained by
expanding in the SPOs obtained from a Hartree\sphinxhyphen{}Fock or DFT calculation,
\(\{\phi_i\}\):
\begin{equation}\label{equation:hamiltonianobservable:eq42}
\begin{split}n_1(i,j) &= \langle{\phi_i}\left|{\hat{n}_1}\right|{\phi_j}\rangle \nonumber \\
         &= \int dR \Psi_{FN}^*(R)\Psi_{T}(R) \sum_n\int dr'_n \frac{\Psi_T(r_n',R_n)}{\Psi_T(r_n,R_n)}\phi_i(r_n')^* \phi_j(r_n)\:.\end{split}
\end{equation}
The integration over \(r'\) in \eqref{equation:hamiltonianobservable:eq42} is inefficient when one is also interested in obtaining matrices involving energetic quantities, such as the energy density matrix of \sphinxcite{hamiltonianobservable:krogel2014} or the related (and more well known) generalized Fock matrix.  For this reason, an approximation is introduced as follows:
\begin{equation}\label{equation:hamiltonianobservable:eq43}
\begin{split}\begin{aligned}
    n_1(i,j) \approx \int dR \Psi_{FN}(R)^*\Psi_T(R)  \sum_n \int dr_n' \frac{\Psi_T(r_n',R_n)^*}{\Psi_T(r_n,R_n)^*}\phi_i(r_n)^* \phi_j(r_n')\:. \end{aligned}\end{split}
\end{equation}
For VMC, FN\sphinxhyphen{}DMC, FP\sphinxhyphen{}DMC, and RN\sphinxhyphen{}DMC this formula represents an exact
sampling of the 1RDM corresponding to \(\hat{\rho}_N^\dagger\) (see
appendix A of \sphinxcite{hamiltonianobservable:krogel2014} for more detail).

\sphinxcode{\sphinxupquote{estimtor type=dm1b}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{dm1b}
&&
Must be dm1b
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&&
Unique name for estimator
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

parameters:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{basis}}\(^r\)
&
text array
&
sposet.name(s)
&&
Orbital basis
\\
\hline
\sphinxcode{\sphinxupquote{integrator}}\(^o\)
&
text
&
uniform\_grid uniform density
&
uniform\_grid
&
Integration method
\\
\hline
\sphinxcode{\sphinxupquote{evaluator}}\(^o\)
&
text
&
loop/matrix
&
loop
&
Evaluation method
\\
\hline
\sphinxcode{\sphinxupquote{scale}}\(^o\)
&
real
&
\(0<scale<1\)
&
1.0
&
Scale integration cell
\\
\hline
\sphinxcode{\sphinxupquote{center}}\(^o\)
&
real array(3)
&
\sphinxstyleemphasis{any point}
&&
Center of cell
\\
\hline
\sphinxcode{\sphinxupquote{points}}\(^o\)
&
integer
&
\(>0\)
&
10
&
Grid points in each dim
\\
\hline
\sphinxcode{\sphinxupquote{samples}}\(^o\)
&
integer
&
\(>0\)
&
10
&
MC samples
\\
\hline
\sphinxcode{\sphinxupquote{warmup}}\(^o\)
&
integer
&
\(>0\)
&
30
&
MC warmup
\\
\hline
\sphinxcode{\sphinxupquote{timestep}}\(^o\)
&
real
&
\(>0\)
&
0.5
&
MC time step
\\
\hline
\sphinxcode{\sphinxupquote{use\_drift}}\(^o\)
&
boolean
&
yes/no
&
no
&
Use drift in VMC
\\
\hline
\sphinxcode{\sphinxupquote{check\_overlap}}\(^o\)
&
boolean
&
yes/no
&
no
&
Print overlap matrix
\\
\hline
\sphinxcode{\sphinxupquote{check\_derivatives}}\(^o\)
&
boolean
&
yes/no
&
no
&
Check density derivatives
\\
\hline
\sphinxcode{\sphinxupquote{acceptance\_ratio}}\(^o\)
&
boolean
&
yes/no
&
no
&
Print accept ratio
\\
\hline
\sphinxcode{\sphinxupquote{rstats}}\(^o\)
&
boolean
&
yes/no
&
no
&
Print spatial stats
\\
\hline
\sphinxcode{\sphinxupquote{normalized}}\(^o\)
&
boolean
&
yes/no
&
yes
&
\sphinxcode{\sphinxupquote{basis}} comes norm’ed
\\
\hline
\sphinxcode{\sphinxupquote{volume\_normed}}\(^o\)
&
boolean
&
yes/no
&
yes
&
\sphinxcode{\sphinxupquote{basis}} norm is volume
\\
\hline
\sphinxcode{\sphinxupquote{energy\_matrix}}\(^o\)
&
boolean
&
yes/no
&
no
&
Energy density matrix
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name:}} Density matrix results appear in \sphinxcode{\sphinxupquote{stat.h5}} files labeled
according to \sphinxcode{\sphinxupquote{name}}.

\item {} 
\sphinxcode{\sphinxupquote{basis:}} List \sphinxcode{\sphinxupquote{sposet.name}}’s. The total set of orbitals
contained in all \sphinxcode{\sphinxupquote{sposet}}’s comprises the basis (subspace) onto
which the one body density matrix is projected. This set of orbitals
generally includes many virtual orbitals that are not occupied in a
single reference Slater determinant.

\item {} 
\sphinxcode{\sphinxupquote{integrator:}} Select the method used to perform the additional
single particle integration. Options are \sphinxcode{\sphinxupquote{uniform\_grid}} (uniform
grid of points over the cell), \sphinxcode{\sphinxupquote{uniform}} (uniform random sampling
over the cell), and \sphinxcode{\sphinxupquote{density}} (Metropolis sampling of approximate
density, \(\sum_{b\in \texttt{basis}}\left|{\phi_b}\right|^2\), is not
well tested, please check results carefully!). Depending on the
integrator selected, different subsets of the other input parameters
are active.

\item {} 
\sphinxcode{\sphinxupquote{evaluator:}} Select for\sphinxhyphen{}loop or matrix multiply implementations.
Matrix is preferred for speed. Both implementations should give the
same results, but please check as this has not been exhaustively
tested.

\item {} 
\sphinxcode{\sphinxupquote{scale:}} Resize the simulation cell by scale for use as an
integration volume (active for \sphinxcode{\sphinxupquote{integrator=uniform/uniform\_grid}}).

\item {} 
\sphinxcode{\sphinxupquote{center:}} Translate the integration volume to center at this point
(active for \sphinxcode{\sphinxupquote{integrator=uniform/ uniform\_grid}}). If \sphinxcode{\sphinxupquote{center}} is
not provided, the scaled simulation cell is used as is.

\item {} 
\sphinxcode{\sphinxupquote{points:}} Number of grid points in each dimension for
\sphinxcode{\sphinxupquote{integrator=uniform\_grid}}. For example, \sphinxcode{\sphinxupquote{points=10}} results in a
uniform \(10 \times 10 \times 10\) grid over the cell.

\item {} 
\sphinxcode{\sphinxupquote{samples:}} Sets the number of MC samples collected for each step
(active for \sphinxcode{\sphinxupquote{integrator=uniform/ density}}).

\item {} 
\sphinxcode{\sphinxupquote{warmup:}} Number of warmup Metropolis steps at the start of the run
before data collection (active for \sphinxcode{\sphinxupquote{integrator=density}}).

\item {} 
\sphinxcode{\sphinxupquote{timestep:}} Drift\sphinxhyphen{}diffusion time step used in Metropolis sampling
(active for \sphinxcode{\sphinxupquote{integrator=density}}).

\item {} 
\sphinxcode{\sphinxupquote{use\_drift:}} Enable drift in Metropolis sampling (active for
\sphinxcode{\sphinxupquote{integrator=density}}).

\item {} 
\sphinxcode{\sphinxupquote{check\_overlap:}} Print the overlap matrix (computed via simple
Riemann sums) to the log, then abort. Note that subsequent analysis
based on the 1RDM is simplest if the input orbitals are orthogonal.

\item {} 
\sphinxcode{\sphinxupquote{check\_derivatives:}} Print analytic and numerical derivatives of
the approximate (sampled) density for several sample points, then
abort.

\item {} 
\sphinxcode{\sphinxupquote{acceptance\_ratio:}} Print the acceptance ratio of the density
sampling to the log for each step.

\item {} 
\sphinxcode{\sphinxupquote{rstats:}} Print statistical information about the spatial motion of
the sampled points to the log for each step.

\item {} 
\sphinxcode{\sphinxupquote{normalized:}} Declare whether the inputted orbitals are normalized
or not. If \sphinxcode{\sphinxupquote{normalized=no}}, direct Riemann integration over a
\(200 \times 200 \times 200\) grid will be used to compute the
normalizations before use.

\item {} 
\sphinxcode{\sphinxupquote{volume\_normed:}} Declare whether the inputted orbitals are
normalized to the cell volume (default) or not (a norm of 1.0 is
assumed in this case). Currently, B\sphinxhyphen{}spline orbitals coming from QE
and HEG planewave orbitals native to QMCPACK are known to be volume
normalized.

\item {} 
\sphinxcode{\sphinxupquote{energy\_matrix:}} Accumulate the one body reduced energy density
matrix, and write it to \sphinxcode{\sphinxupquote{stat.h5}}. This matrix is not covered in
any detail here; the interested reader is referred to
\sphinxcite{hamiltonianobservable:krogel2014}.

\end{itemize}
\sphinxSetupCaptionForVerbatim{One body density matrix with uniform grid integration.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-36}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dm1b}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DensityMatrices}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{basis}\PYG{l+s+s2}{\PYGZdq{}}        \PYG{o}{\PYGZgt{}}  \PYG{n}{spo\PYGZus{}u} \PYG{n}{spo\PYGZus{}uv}  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{evaluator}\PYG{l+s+s2}{\PYGZdq{}}    \PYG{o}{\PYGZgt{}}  \PYG{n}{matrix}        \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{integrator}\PYG{l+s+s2}{\PYGZdq{}}   \PYG{o}{\PYGZgt{}}  \PYG{n}{uniform\PYGZus{}grid}  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{points}\PYG{l+s+s2}{\PYGZdq{}}       \PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{4}             \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scale}\PYG{l+s+s2}{\PYGZdq{}}        \PYG{o}{\PYGZgt{}}  \PYG{l+m+mf}{1.0}           \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{center}\PYG{l+s+s2}{\PYGZdq{}}       \PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}         \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{estimator}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{One body density matrix with uniform sampling.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-37}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dm1b}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DensityMatrices}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{basis}\PYG{l+s+s2}{\PYGZdq{}}        \PYG{o}{\PYGZgt{}}  \PYG{n}{spo\PYGZus{}u} \PYG{n}{spo\PYGZus{}uv}  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{evaluator}\PYG{l+s+s2}{\PYGZdq{}}    \PYG{o}{\PYGZgt{}}  \PYG{n}{matrix}        \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{integrator}\PYG{l+s+s2}{\PYGZdq{}}   \PYG{o}{\PYGZgt{}}  \PYG{n}{uniform}       \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{samples}\PYG{l+s+s2}{\PYGZdq{}}      \PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{64}            \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scale}\PYG{l+s+s2}{\PYGZdq{}}        \PYG{o}{\PYGZgt{}}  \PYG{l+m+mf}{1.0}           \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{center}\PYG{l+s+s2}{\PYGZdq{}}       \PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}         \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{estimator}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{One body density matrix with density sampling.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-38}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dm1b}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DensityMatrices}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{basis}\PYG{l+s+s2}{\PYGZdq{}}        \PYG{o}{\PYGZgt{}}  \PYG{n}{spo\PYGZus{}u} \PYG{n}{spo\PYGZus{}uv}  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{evaluator}\PYG{l+s+s2}{\PYGZdq{}}    \PYG{o}{\PYGZgt{}}  \PYG{n}{matrix}        \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{integrator}\PYG{l+s+s2}{\PYGZdq{}}   \PYG{o}{\PYGZgt{}}  \PYG{n}{density}       \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{samples}\PYG{l+s+s2}{\PYGZdq{}}      \PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{64}            \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}     \PYG{o}{\PYGZgt{}}  \PYG{l+m+mf}{0.5}           \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{use\PYGZus{}drift}\PYG{l+s+s2}{\PYGZdq{}}    \PYG{o}{\PYGZgt{}}  \PYG{n}{no}            \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{estimator}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{Example \sphinxcode{\sphinxupquote{sposet}} initialization for density matrix use.  Occupied and virtual orbital sets are created separately, then joined (\sphinxcode{\sphinxupquote{basis="spo\_u spo\_uv"}}).}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-39}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{sposet\PYGZus{}builder} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{../dft/pwscf\PYGZus{}output/pwscf.pwscf.h5}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{tilematrix}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1 0 0 0 1 0 0 0 1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{twistnum}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{meshfactor}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{gpu}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{precision}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{single}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{sposet} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spo\PYGZus{}u}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n}{group}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{sposet} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spo\PYGZus{}d}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n}{group}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{sposet} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spo\PYGZus{}uv}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{group}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{index\PYGZus{}min}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{index\PYGZus{}max}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{sposet\PYGZus{}builder}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{Example \sphinxcode{\sphinxupquote{sposet}} initialization for density matrix use. Density matrix orbital basis created separately (\sphinxcode{\sphinxupquote{basis="dm\_basis"}}).}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-40}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{sposet\PYGZus{}builder} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{../dft/pwscf\PYGZus{}output/pwscf.pwscf.h5}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{tilematrix}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1 0 0 0 1 0 0 0 1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{twistnum}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{meshfactor}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{gpu}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{precision}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{single}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{sposet} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spo\PYGZus{}u}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n}{group}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{sposet} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spo\PYGZus{}d}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n}{group}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{sposet} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dm\PYGZus{}basis}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{50}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{spindataset}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{sposet\PYGZus{}builder}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\section{Forward\sphinxhyphen{}Walking Estimators}
\label{\detokenize{hamiltonianobservable:forward-walking-estimators}}\label{\detokenize{hamiltonianobservable:forward-walking}}
Forward walking is a method for sampling the pure fixed\sphinxhyphen{}node
distribution \(\langle \Phi_0 | \Phi_0\rangle\). Specifically, one
multiplies each walker’s DMC mixed estimate for the observable
\(\mathcal{O}\),
\(\frac{\mathcal{O}(\mathbf{R})\Psi_T(\mathbf{R})}{\Psi_T(\mathbf{R})}\),
by the weighting factor
\(\frac{\Phi_0(\mathbf{R})}{\Psi_T(\mathbf{R})}\). As it turns out,
this weighting factor for any walker \(\mathbf{R}\) is proportional
to the total number of descendants the walker will have after a
sufficiently long projection time \(\beta\).

To forward walk on an observable, declare a generic forward\sphinxhyphen{}walking
estimator within a \sphinxcode{\sphinxupquote{\textless{}hamiltonian\textgreater{}}} block, and then specify the
observables to forward walk on and the forward\sphinxhyphen{}walking parameters. Here
is a summary.

\sphinxcode{\sphinxupquote{estimator type=ForwardWalking}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{Observable}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{ForwardWalking}
&&
Must be “ForwardWalking”
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
any
&
Unique name for estimator
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}
\end{quote}

\sphinxcode{\sphinxupquote{Observable}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{estimator, hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
any
&
Registered name of existing estimator on which to forward walk
\\
\hline
\sphinxcode{\sphinxupquote{max}}\(^r\)
&
integer
&
\(>0\)
&&
Maximum projection time in steps (\sphinxcode{\sphinxupquote{max}}\(=\beta/\tau\))
\\
\hline
\sphinxcode{\sphinxupquote{frequency}}\(^r\)
&
text
&
\(\geq 1\)
&&
Dump data only for every \sphinxcode{\sphinxupquote{frequency}}\sphinxhyphen{}th to \sphinxcode{\sphinxupquote{scalar.dat}} file
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxstylestrong{Cost}: Because histories of observables up to \sphinxcode{\sphinxupquote{max}} time steps
have to be stored, the memory cost of storing the nonforward\sphinxhyphen{}walked
observables variables should be multiplied by \(\texttt{max}\).
Although this is not an issue for items such as potential energy, it
could be prohibitive for observables such as density, forces, etc.

\item {} 
\sphinxstylestrong{Naming Convention}: Forward\sphinxhyphen{}walked observables are automatically
named \sphinxcode{\sphinxupquote{FWE\_name\_i}}, where \sphinxcode{\sphinxupquote{i}} is the forward\sphinxhyphen{}walked expectation
value at time step \sphinxcode{\sphinxupquote{i}}, and \sphinxcode{\sphinxupquote{name}} is whatever name appears in
the \sphinxcode{\sphinxupquote{\textless{}Observable\textgreater{}}} block. This is also how it will appear in the
\sphinxcode{\sphinxupquote{scalar.dat}} file.

\end{itemize}

In the following example case, QMCPACK forward walks on the potential
energy for 300 time steps and dumps the forward\sphinxhyphen{}walked value at every
time step.
\sphinxSetupCaptionForVerbatim{Forward\sphinxhyphen{}walking estimator element.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-41}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}estimator name=\PYGZdq{}fw\PYGZdq{} type=\PYGZdq{}ForwardWalking\PYGZdq{}\PYGZgt{}
    \PYGZlt{}Observable name=\PYGZdq{}LocalPotential\PYGZdq{} max=\PYGZdq{}300\PYGZdq{} frequency=\PYGZdq{}1\PYGZdq{}/\PYGZgt{}
     \PYGZlt{}!\PYGZhy{}\PYGZhy{}\PYGZhy{} Additional Observable blocks go here \PYGZhy{}\PYGZhy{}\PYGZgt{}
 \PYGZlt{}/estimator\PYGZgt{}
\end{sphinxVerbatim}


\section{“Force” estimators}
\label{\detokenize{hamiltonianobservable:force-estimators}}\label{\detokenize{hamiltonianobservable:force-est}}
QMCPACK supports force estimation by use of the Chiesa\sphinxhyphen{}Ceperly\sphinxhyphen{}Zhang
(CCZ) estimator. Currently, open and periodic boundary conditions are
supported but for all\sphinxhyphen{}electron calculations only.

Without loss of generality, the CCZ estimator for the z\sphinxhyphen{}component of the
force on an ion centered at the origin is given by the following
expression:
\begin{equation}\label{equation:hamiltonianobservable:eq44}
\begin{split}F_z = -Z \sum_{i=1}^{N_e}\frac{z_i}{r_i^3}[\theta(r_i-\mathcal{R}) + \theta(\mathcal{R}-r_i)\sum_{\ell=1}^{M}c_\ell r_i^\ell]\:.\end{split}
\end{equation}
Z is the ionic charge, \(M\) is the degree of the smoothing
polynomial, \(\mathcal{R}\) is a real\sphinxhyphen{}space cutoff of the sphere
within which the bare\sphinxhyphen{}force estimator is smoothed, and \(c_\ell\)
are predetermined coefficients. These coefficients are chosen to
minimize the weighted mean square error between the bare force estimate
and the s\sphinxhyphen{}wave filtered estimator. Specifically,
\begin{equation}\label{equation:hamiltonianobservable:eq45}
\begin{split}\chi^2 = \int_0^\mathcal{R}dr\,r^m\,[f_z(r) - \tilde{f}_z(r)]^2\:.\end{split}
\end{equation}
Here, \(m\) is the weighting exponent, \(f_z(r)\) is the
unfiltered radial force density for the z force component, and
\(\tilde{f}_z(r)\) is the smoothed polynomial function for the same
force density. The reader is invited to refer to the original paper for
a more thorough explanation of the methodology, but with the notation in
hand, QMCPACK takes the following parameters.

\sphinxcode{\sphinxupquote{estimator type=Force}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{parameter}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{mode}}\(^o\)
&
text
&
\sphinxstyleemphasis{See above}
&
bare
&
Select estimator type
\\
\hline
\sphinxcode{\sphinxupquote{lrmethod}}\(^o\)
&
text
&
ewald or srcoul
&
ewald
&
Select long\sphinxhyphen{}range potential breakup method
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
Force
&&
Must be “Force”
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^o\)
&
text
&
\sphinxstyleemphasis{Anything}
&
ForceBase
&
Unique name for this estimator
\\
\hline
\sphinxcode{\sphinxupquote{pbc}}\(^o\)
&
boolean
&
yes/no
&
yes
&
Using periodic BCs or not
\\
\hline
\sphinxcode{\sphinxupquote{addionion}}\(^o\)
&
boolean
&
yes/no
&
no
&
Add the ion\sphinxhyphen{}ion force contribution to output force estimate
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

parameters:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{rcut}}\(^o\)
&
real
&
\(>0\)
&
1.0
&
Real\sphinxhyphen{}space cutoff \(\mathcal{R}\) in bohr
\\
\hline
\sphinxcode{\sphinxupquote{nbasis}}\(^o\)
&
integer
&
\(>0\)
&
2
&
Degree of smoothing polynomial \(M\)
\\
\hline
\sphinxcode{\sphinxupquote{weightexp}}\(^o\)
&
integer
&
\(>0\)
&
2
&
\(\chi^2\) weighting exponent :math\textasciigrave{}m\textasciigrave{}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxstylestrong{Naming Convention}: The unique identifier \sphinxcode{\sphinxupquote{name}} is appended
with \sphinxcode{\sphinxupquote{name\_X\_Y}} in the \sphinxcode{\sphinxupquote{scalar.dat}} file, where \sphinxcode{\sphinxupquote{X}} is the ion
ID number and \sphinxcode{\sphinxupquote{Y}} is the component ID (an integer with x=0, y=1,
z=2). All force components for all ions are computed and dumped to
the \sphinxcode{\sphinxupquote{scalar.dat}} file.

\item {} 
\sphinxstylestrong{Long\sphinxhyphen{}range breakup}: With periodic boundary conditions, it is
important to converge the lattice sum when calculating Coulomb
contribution to the forces. As a quick test, increase the
\sphinxcode{\sphinxupquote{LR\_dim\_cutoff}} parameter until ion\sphinxhyphen{}ion forces are converged. The
Ewald method (\sphinxcode{\sphinxupquote{lrmethod}}=”ewald”) converges more slowly than
optimized method (\sphinxcode{\sphinxupquote{lrmethod}}=”srcoul”).

\item {} 
\sphinxstylestrong{Miscellaneous}: Usually, the default choice of \sphinxcode{\sphinxupquote{weightexp}} is
sufficient. Different combinations of \sphinxcode{\sphinxupquote{rcut}} and \sphinxcode{\sphinxupquote{nbasis}} should
be tested though to minimize variance and bias. There is, of course,
a tradeoff, with larger \sphinxcode{\sphinxupquote{nbasis}} and smaller \sphinxcode{\sphinxupquote{rcut}} leading to
smaller biases and larger variances.

\end{itemize}

The following is an example use case.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{simulationcell}\PYG{o}{\PYGZgt{}}
  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LR}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{\PYGZus{}dim}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{\PYGZus{}cutoff}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{20}  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{simulationcell}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{myforce}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Force}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cep}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{addionion}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{lrmethod}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{srcoul}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{rcut}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nbasis}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{4}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{weightexp}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{2}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{estimator}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}




\chapter{Quantum Monte Carlo Methods}
\label{\detokenize{methods:quantum-monte-carlo-methods}}\label{\detokenize{methods:qmcmethods}}\label{\detokenize{methods::doc}}
\sphinxcode{\sphinxupquote{qmc}} factory element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements
&
\sphinxcode{\sphinxupquote{simulation, loop}}
\\
\hline
type selector
&
\sphinxcode{\sphinxupquote{method}} attribute
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

type options:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

vmc
&
Variational Monte Carlo
\\
\hline
linear
&
Wavefunction optimization with linear method
\\
\hline
dmc
&
Diffusion Monte Carlo
\\
\hline
rmc
&
Reptation Monte Carlo
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

shared attributes:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{method}}
&
text
&
listed above
&
invalid
&
QMC driver
\\
\hline
\sphinxcode{\sphinxupquote{move}}
&
text
&
pbyp, alle
&
pbyp
&
Method used to move electrons
\\
\hline
\sphinxcode{\sphinxupquote{gpu}}
&
text
&
yes/no
&
dep.
&
Use the GPU
\\
\hline
\sphinxcode{\sphinxupquote{trace}}
&
text
&&
no
&
???
\\
\hline
\sphinxcode{\sphinxupquote{checkpoint}}
&
integer
&
\sphinxhyphen{}1, 0, n
&
\sphinxhyphen{}1
&
Checkpoint frequency
\\
\hline
\sphinxcode{\sphinxupquote{record}}
&
integer
&
n
&
0
&
Save configuration ever n steps
\\
\hline
\sphinxcode{\sphinxupquote{target}}
&
text
&&&
???
\\
\hline
\sphinxcode{\sphinxupquote{completed}}
&
text
&&&
???
\\
\hline
\sphinxcode{\sphinxupquote{append}}
&
text
&
yes/no
&
no
&
???
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{move}}: There are two ways to move electrons. The more used method
is the particle\sphinxhyphen{}by\sphinxhyphen{}particle move. In this method, only one electron
is moved for acceptance or rejection. The other method is the
all\sphinxhyphen{}electron move; namely, all the electrons are moved once for
testing acceptance or rejection.

\item {} 
\sphinxcode{\sphinxupquote{gpu}}: When the executable is compiled with CUDA, the target
computing device can be chosen by this switch. With a regular
CPU\sphinxhyphen{}only compilation, this option is not effective.

\item {} 
\sphinxcode{\sphinxupquote{checkpoint}}: This enables and disables checkpointing and
specifying the frequency of output. Possible values are:
\begin{itemize}
\item {} 
\sphinxstylestrong{{[}\sphinxhyphen{}1{]}} No checkpoint (default setting).

\item {} 
\sphinxstylestrong{{[}0{]}} Dump after the completion of a QMC section.

\item {} 
\sphinxstylestrong{{[}n{]}} Dump after every \(n\) blocks.  Also dump at the end of the run.

\end{itemize}

\end{itemize}

The particle configurations are written to a \sphinxcode{\sphinxupquote{.config.h5}} file.
\sphinxSetupCaptionForVerbatim{The following is an example of running a simulation that can be restarted.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{methods:listing-42}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dmc}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pbyp}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n}{checkpoint}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}         \PYG{l+m+mf}{0.004}  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}           \PYG{l+m+mi}{100}   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{steps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}            \PYG{l+m+mi}{400}    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

The checkpoint flag instructs QMCPACK to output walker configurations.  This also
works in VMC.  This outputs an h5 file with the name \sphinxcode{\sphinxupquote{projectid.run\sphinxhyphen{}number.config.h5}}.
Check that this file exists before attempting a restart.

To continue a run, specify the \sphinxcode{\sphinxupquote{mcwalkerset}} element before your VMC/DMC block:
\sphinxSetupCaptionForVerbatim{Restart (read walkers from previous run).}
\def\sphinxLiteralBlockLabel{\label{\detokenize{methods:listing-43}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{mcwalkerset} \PYG{n}{fileroot}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{BH.s002}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{version}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0 6}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{collected}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dmc}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pbyp}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n}{checkpoint}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}         \PYG{l+m+mf}{0.004}  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}           \PYG{l+m+mi}{100}   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{steps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}            \PYG{l+m+mi}{400}    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{BH}} is the project id, and \sphinxcode{\sphinxupquote{s002}} is the calculation number to read in the walkers from the previous run.

In the project id section, make sure that the series number is different from any existing ones to avoid overwriting them.


\section{Variational Monte Carlo}
\label{\detokenize{methods:variational-monte-carlo}}\label{\detokenize{methods:vmc}}
\sphinxcode{\sphinxupquote{vmc}} method:
\begin{quote}

parameters:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{walkers}}
&
integer
&
\(> 0\)
&
dep.
&
Number of walkers per MPI task
\\
\hline
\sphinxcode{\sphinxupquote{blocks}}
&
integer
&
\(\geq 0\)
&
1
&
Number of blocks
\\
\hline
\sphinxcode{\sphinxupquote{steps}}
&
integer
&
\(\geq 0\)
&
1
&
Number of steps per block
\\
\hline
\sphinxcode{\sphinxupquote{warmupsteps}}
&
integer
&
\(\geq 0\)
&
0
&
Number of steps for warming up
\\
\hline
\sphinxcode{\sphinxupquote{substeps}}
&
integer
&
\(\geq 0\)
&
1
&
Number of substeps per step
\\
\hline
\sphinxcode{\sphinxupquote{usedrift}}
&
text
&
yes,no
&
yes
&
Use the algorithm with drift
\\
\hline
\sphinxcode{\sphinxupquote{timestep}}
&
real
&
\(> 0\)
&
0.1
&
Time step for each electron move
\\
\hline
\sphinxcode{\sphinxupquote{samples}}
&
integer
&
\(\geq 0\)
&
0
&
Number of walker samples for DMC/optimization
\\
\hline
\sphinxcode{\sphinxupquote{stepsbetweensamples}}
&
integer
&
\(> 0\)
&
1
&
Period of sample accumulation
\\
\hline
\sphinxcode{\sphinxupquote{samplesperthread}}
&
integer
&
\(\geq 0\)
&
0
&
Number of samples per thread
\\
\hline
\sphinxcode{\sphinxupquote{storeconfigs}}
&
integer
&
all values
&
0
&
Show configurations o
\\
\hline
\sphinxcode{\sphinxupquote{blocks\_between\_recompute}}
&
integer
&
\(\geq 0\)
&
dep.
&
Wavefunction recompute frequency
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{walkers}} The number of walkers per MPI task. The initial default number of ixml\{walkers\} is one per OpenMP thread or per MPI task if threading is disabled. The number is rounded down to a multiple of the number of threads with a minimum of one per thread to ensure perfect load balancing. One walker per thread is created in the event fewer \sphinxcode{\sphinxupquote{walkers}} than threads are requested.

\item {} 
\sphinxcode{\sphinxupquote{blocks}} This parameter is universal for all the QMC
methods. The MC processes are divided into a number of
\sphinxcode{\sphinxupquote{blocks}}, each containing a number of steps. At the end of each block,
the statistics accumulated in the block are dumped into files,
e.g., \sphinxcode{\sphinxupquote{scalar.dat}}. Typically, each block should have a sufficient number of steps that the I/O at the end of each block is negligible
compared with the computational cost. Each block should not take so
long that monitoring its progress is difficult. There should be a
sufficient number of \sphinxcode{\sphinxupquote{blocks}} to perform statistical analysis.

\item {} 
\sphinxcode{\sphinxupquote{warmupsteps}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{warmupsteps}} are used only for
equilibration. Property measurements are not performed during
warm\sphinxhyphen{}up steps.

\item {} 
\sphinxcode{\sphinxupquote{steps}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{steps}} are the number of energy and other property measurements to perform per block.

\item {} 
\sphinxcode{\sphinxupquote{substeps}}  For each substep, an attempt is made to move each of the electrons once only by either particle\sphinxhyphen{}by\sphinxhyphen{}particle or an
all\sphinxhyphen{}electron move.  Because the local energy is evaluated only at
each full step and not each substep, \sphinxcode{\sphinxupquote{substeps}} are computationally cheaper
and can be used to reduce the correlation between property measurements
at a lower cost.

\item {} 
\sphinxcode{\sphinxupquote{usedrift}} The VMC is implemented in two algorithms with
or without drift. In the no\sphinxhyphen{}drift algorithm, the move of each
electron is proposed with a Gaussian distribution. The standard
deviation is chosen as the time step input. In the drift algorithm,
electrons are moved by Langevin dynamics.

\item {} 
\sphinxcode{\sphinxupquote{timestep}} The meaning of time step depends on whether or not
the drift is used. In general, larger time steps reduce the
time correlation but might also reduce the acceptance ratio,
reducing overall statistical efficiency. For VMC, typically the
acceptance ratio should be close to 50\% for an efficient
simulation.

\item {} 
\sphinxcode{\sphinxupquote{samples}} Seperate from conventional energy and other
property measurements, samples refers to storing whole electron
configurations in memory (“walker samples”) as would be needed by subsequent
wavefunction optimization or DMC steps. \sphinxstyleemphasis{A standard VMC run to
measure the energy does not need samples to be set.}
\begin{equation*}
\begin{split}\texttt{samples}=
\frac{\texttt{blocks}\cdot\texttt{steps}\cdot\texttt{walkers}}{\texttt{stepsbetweensamples}}\cdot\texttt{number of MPI tasks}\end{split}
\end{equation*}
\item {} 
\sphinxcode{\sphinxupquote{samplesperthread}} This is an alternative way to set the target amount of samples and can be useful when preparing a stored population for a subsequent DMC calculation.
\begin{equation*}
\begin{split}\texttt{samplesperthread}=
\frac{\texttt{blocks}\cdot\texttt{steps}}{\texttt{stepsbetweensamples}}\end{split}
\end{equation*}
\item {} 
\sphinxcode{\sphinxupquote{stepsbetweensamples}} Because samples generated by consecutive steps are correlated, having \sphinxcode{\sphinxupquote{stepsbetweensamples}} larger than 1 can be used to reduces that correlation. In practice, using larger substeps is cheaper than using \sphinxcode{\sphinxupquote{stepsbetweensamples}} to decorrelate samples.

\item {} 
\sphinxcode{\sphinxupquote{storeconfigs}} If \sphinxcode{\sphinxupquote{storeconfigs}} is set to a nonzero value, then electron configurations during the VMC run are saved to files.

\item {} 
\sphinxcode{\sphinxupquote{blocks\_between\_recompute}} Recompute the accuracy critical determinant part of the wavefunction
from scratch: =1 by default when using mixed precision. =0 (no
recompute) by default when not using mixed precision. Recomputing
introduces a performance penalty dependent on system size.

\end{itemize}

An example VMC section for a simple VMC run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{vmc}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pbyp}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LocalEnergy}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{hdf5}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{walkers}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}    \PYG{l+m+mi}{256} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{warmupSteps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{100} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{substeps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{5} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{20} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{steps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{100} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mf}{1.0} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{usedrift}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}   \PYG{n}{yes} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Here we set 256 \sphinxcode{\sphinxupquote{walkers}} per MPI, have a brief initial equilibration of 100 \sphinxcode{\sphinxupquote{steps}}, and then have 20 \sphinxcode{\sphinxupquote{blocks}} of 100 \sphinxcode{\sphinxupquote{steps}} with 5 \sphinxcode{\sphinxupquote{substeps}} each.

The following is an example of VMC section storing configurations (walker samples) for optimization.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{vmc}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pbyp}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{gpu}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LocalEnergy}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{hdf5}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{walkers}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}    \PYG{l+m+mi}{256} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{samples}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}    \PYG{l+m+mi}{2867200} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{stepsbetweensamples}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}    \PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{substeps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{5} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{warmupSteps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{5} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{70} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mf}{1.0} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{usedrift}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}   \PYG{n}{no} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\section{Wavefunction optimization}
\label{\detokenize{methods:wavefunction-optimization}}\label{\detokenize{methods:optimization}}
Optimizing wavefunction is critical in all kinds of real\sphinxhyphen{}space QMC calculations
because it significantly improves both the accuracy and efficiency of computation.
However, it is very difficult to directly adopt deterministic minimization approaches because of the stochastic nature of evaluating quantities with MC.
Thanks to the algorithmic breakthrough during the first decade of this century and the tremendous computer power available,
it is now feasible to optimize tens of thousands of parameters in a wavefunction for a solid or molecule.
QMCPACK has multiple optimizers implemented based on the state\sphinxhyphen{}of\sphinxhyphen{}the\sphinxhyphen{}art linear method.
We are continually improving our optimizers for robustness and friendliness and are trying to provide a single solution.
Because of the large variation of wavefunction types carrying distinct characteristics, using several optimizers might be needed in some cases.
We strongly suggested reading recommendations from the experts who maintain these optimizers.

A typical optimization block looks like the following. It starts with method=”linear” and contains three blocks of parameters.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}loop max=\PYGZdq{}10\PYGZdq{}\PYGZgt{}
 \PYGZlt{}qmc method=\PYGZdq{}linear\PYGZdq{} move=\PYGZdq{}pbyp\PYGZdq{} gpu=\PYGZdq{}yes\PYGZdq{}\PYGZgt{}
   \PYGZlt{}!\PYGZhy{}\PYGZhy{} Specify the VMC options \PYGZhy{}\PYGZhy{}\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}walkers\PYGZdq{}\PYGZgt{}              256 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}samples\PYGZdq{}\PYGZgt{}          2867200 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}stepsbetweensamples\PYGZdq{}\PYGZgt{}    1 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}substeps\PYGZdq{}\PYGZgt{}               5 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}warmupSteps\PYGZdq{}\PYGZgt{}            5 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}blocks\PYGZdq{}\PYGZgt{}                70 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}timestep\PYGZdq{}\PYGZgt{}             1.0 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}usedrift\PYGZdq{}\PYGZgt{}              no \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}estimator name=\PYGZdq{}LocalEnergy\PYGZdq{} hdf5=\PYGZdq{}no\PYGZdq{}/\PYGZgt{}
   ...
   \PYGZlt{}!\PYGZhy{}\PYGZhy{} Specify the correlated sampling options and define the cost function \PYGZhy{}\PYGZhy{}\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}minwalkers\PYGZdq{}\PYGZgt{}            0.3 \PYGZlt{}/parameter\PYGZgt{}
        \PYGZlt{}cost name=\PYGZdq{}energy\PYGZdq{}\PYGZgt{}               0.95 \PYGZlt{}/cost\PYGZgt{}
        \PYGZlt{}cost name=\PYGZdq{}unreweightedvariance\PYGZdq{}\PYGZgt{} 0.00 \PYGZlt{}/cost\PYGZgt{}
        \PYGZlt{}cost name=\PYGZdq{}reweightedvariance\PYGZdq{}\PYGZgt{}   0.05 \PYGZlt{}/cost\PYGZgt{}
   ...
   \PYGZlt{}!\PYGZhy{}\PYGZhy{} Specify the optimizer options \PYGZhy{}\PYGZhy{}\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}MinMethod\PYGZdq{}\PYGZgt{}    OneShiftOnly \PYGZlt{}/parameter\PYGZgt{}
   ...
 \PYGZlt{}/qmc\PYGZgt{}
\PYGZlt{}/loop\PYGZgt{}

\PYGZhy{}  Loop is helpful to repeatedly execute identical optimization blocks.

\PYGZhy{}  The first part is highly identical to a regular VMC block.

\PYGZhy{}  The second part is to specify the correlated sampling options and
   define the cost function.

\PYGZhy{}  The last part is used to specify the options of different optimizers,
   which can be very distinct from one to another.
\end{sphinxVerbatim}


\subsection{VMC run for the optimization}
\label{\detokenize{methods:vmc-run-for-the-optimization}}
The VMC calculation for the wavefunction optimization has a strict requirement
that \sphinxcode{\sphinxupquote{samples}} or \sphinxcode{\sphinxupquote{samplesperthread}} must be specified because of the optimizer needs for the stored \sphinxcode{\sphinxupquote{samples}}.
The input parameters of this part are identical to the VMC method.

Recommendations:
\begin{itemize}
\item {} 
Run the inclusive VMC calculation correctly and efficiently because
this takes a significant amount of time during optimization. For
example, make sure the derived \sphinxcode{\sphinxupquote{steps}} per block is 1 and use larger \sphinxcode{\sphinxupquote{substeps}} to
control the correlation between \sphinxcode{\sphinxupquote{samples}}.

\item {} 
A reasonable starting wavefunction is necessary. A lot of
optimization fails because of a bad wavefunction starting point. The
sign of a bad initial wavefunction includes but is not limited to a
very long equilibration time, low acceptance ratio, and huge
variance. The first thing to do after a failed optimization is to
check the information provided by the VMC calculation via
\sphinxcode{\sphinxupquote{*.scalar.dat files}}.

\end{itemize}


\subsection{Correlated sampling and cost function}
\label{\detokenize{methods:correlated-sampling-and-cost-function}}
After generating the samples with VMC, the derivatives of the wavefunction with respect to the parameters are computed for proposing a new set of parameters by optimizers.
And later, a correlated sampling calculation is performed to quickly evaluate values of the cost function on the old set of parameters and the new set for further decisions.
The input parameters are listed in the following table.

\sphinxcode{\sphinxupquote{linear}} method:
\begin{quote}

parameters:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{nonlocalpp}}
&
text
&
yes, no
&
no
&
include non\sphinxhyphen{}local PP energy in the cost function
\\
\hline
\sphinxcode{\sphinxupquote{minwalkers}}
&
real
&
0\textendash{}1
&
0.3
&
Lower bound of the effective weight
\\
\hline
\sphinxcode{\sphinxupquote{maxWeight}}
&
real
&
\(> 1\)
&
1e6
&
Maximum weight allowed in reweighting
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{maxWeight}} The default should be good.

\item {} 
\sphinxcode{\sphinxupquote{nonlocalpp}} The \sphinxcode{\sphinxupquote{nonlocalpp}} contribution to the local energy depends on the
wavefunction. When a new set of parameters is proposed, this
contribution needs to be updated if the cost function consists of local
energy. Fortunately, nonlocal contribution is chosen small when making a
PP for small locality error. We can ignore its change and avoid the
expensive computational cost. An implementation issue with GPU code is
that a large amount of memory is consumed with this option.

\item {} 
\sphinxcode{\sphinxupquote{minwalkers}} This is a \sphinxcode{\sphinxupquote{critical}} parameter. When the ratio of effective samples to actual number of samples in a reweighting step goes lower than \sphinxcode{\sphinxupquote{minwalkers}},
the proposed set of parameters is invalid.

\end{itemize}

The cost function consists of three components: energy, unreweighted variance, and reweighted variance.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{cost} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{energy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}                   \PYG{l+m+mf}{0.95} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{cost}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{cost} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{unreweightedvariance}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}     \PYG{l+m+mf}{0.00} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{cost}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{cost} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{reweightedvariance}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}       \PYG{l+m+mf}{0.05} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{cost}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Optimizers}
\label{\detokenize{methods:optimizers}}
QMCPACK implements a number of different optimizers each with different
priorities for accuracy, convergence, memory usage, and stability. The
optimizers can be switched among “OneShiftOnly” (default), “adaptive,”
“descent,” “hybrid,” and “quartic” (old) using the following line in the
optimization block:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MinMethod}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{n}{THE} \PYG{n}{METHOD} \PYG{n}{YOU} \PYG{n}{LIKE} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{OneShiftOnly Optimizer}
\label{\detokenize{methods:oneshiftonly-optimizer}}
The OneShiftOnly optimizer targets a fast optimization by moving parameters more aggressively. It works with OpenMP and GPU and can be considered for large systems.
This method relies on the effective weight of correlated sampling rather than the cost function value to justify a new set of parameters.
If the effective weight is larger than \sphinxcode{\sphinxupquote{minwalkers}}, the new set is taken whether or not the cost function value decreases.
If a proposed set is rejected, the standard output prints the measured ratio of effective samples to the total number of samples
and adjustment on \sphinxcode{\sphinxupquote{minwalkers}} can be made if needed.

\sphinxcode{\sphinxupquote{linear}} method:
\begin{quote}

parameters:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{shift\_i}}
&
real
&
\(> 0\)
&
0.01
&
Direct stabilizer added to the Hamiltonian matrix
\\
\hline
\sphinxcode{\sphinxupquote{shift\_s}}
&
real
&
\(> 0\)
&
1.00
&
Initial stabilizer based on the overlap matrix
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{shift\_i}} This is the direct term added to the diagonal of the Hamiltonian
matrix. It provides more stable but slower optimization with a large
value.

\item {} 
\sphinxcode{\sphinxupquote{shift\_s}} This is the initial value of the stabilizer based on the overlap
matrix added to the Hamiltonian matrix. It provides more stable but
slower optimization with a large value. The used value is
auto\sphinxhyphen{}adjusted by the optimizer.

\end{itemize}

Recommendations:
\begin{itemize}
\item {} 
Default \sphinxcode{\sphinxupquote{shift\_i}}, \sphinxcode{\sphinxupquote{shift\_s}} should be fine.

\item {} 
For hard cases, increasing \sphinxcode{\sphinxupquote{shift\_i}} (by a factor of 5 or 10) can significantly stabilize the optimization by reducing the pace towards the optimal parameter set.

\item {} 
If the VMC energy of the last optimization iterations grows significantly, increase \sphinxcode{\sphinxupquote{minwalkers}} closer to 1 and make the optimization stable.

\item {} 
If the first iterations of optimization are rejected on a reasonable initial wavefunction,
lower the \sphinxcode{\sphinxupquote{minwalkers}} value based on the measured value printed in the standard output to accept the move.

\end{itemize}

We recommended using this optimizer in two sections with a very small \sphinxcode{\sphinxupquote{minwalkers}} in the first and a large value in the second, such as the following.
In the very beginning, parameters are far away from optimal values and large changes are proposed by the optimizer.
Having a small \sphinxcode{\sphinxupquote{minwalkers}} makes it much easier to accept these changes.
When the energy gradually converges, we can have a large \sphinxcode{\sphinxupquote{minwalkers}} to avoid risky parameter sets.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}loop max=\PYGZdq{}6\PYGZdq{}\PYGZgt{}
 \PYGZlt{}qmc method=\PYGZdq{}linear\PYGZdq{} move=\PYGZdq{}pbyp\PYGZdq{} gpu=\PYGZdq{}yes\PYGZdq{}\PYGZgt{}
   \PYGZlt{}!\PYGZhy{}\PYGZhy{} Specify the VMC options \PYGZhy{}\PYGZhy{}\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}walkers\PYGZdq{}\PYGZgt{}                1 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}samples\PYGZdq{}\PYGZgt{}            10000 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}stepsbetweensamples\PYGZdq{}\PYGZgt{}    1 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}substeps\PYGZdq{}\PYGZgt{}               5 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}warmupSteps\PYGZdq{}\PYGZgt{}            5 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}blocks\PYGZdq{}\PYGZgt{}                25 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}timestep\PYGZdq{}\PYGZgt{}             1.0 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}usedrift\PYGZdq{}\PYGZgt{}              no \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}estimator name=\PYGZdq{}LocalEnergy\PYGZdq{} hdf5=\PYGZdq{}no\PYGZdq{}/\PYGZgt{}
   \PYGZlt{}!\PYGZhy{}\PYGZhy{} Specify the optimizer options \PYGZhy{}\PYGZhy{}\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}MinMethod\PYGZdq{}\PYGZgt{}    OneShiftOnly \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}minwalkers\PYGZdq{}\PYGZgt{}           1e\PYGZhy{}4 \PYGZlt{}/parameter\PYGZgt{}
 \PYGZlt{}/qmc\PYGZgt{}
\PYGZlt{}/loop\PYGZgt{}
\PYGZlt{}loop max=\PYGZdq{}12\PYGZdq{}\PYGZgt{}
 \PYGZlt{}qmc method=\PYGZdq{}linear\PYGZdq{} move=\PYGZdq{}pbyp\PYGZdq{} gpu=\PYGZdq{}yes\PYGZdq{}\PYGZgt{}
   \PYGZlt{}!\PYGZhy{}\PYGZhy{} Specify the VMC options \PYGZhy{}\PYGZhy{}\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}walkers\PYGZdq{}\PYGZgt{}                1 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}samples\PYGZdq{}\PYGZgt{}            20000 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}stepsbetweensamples\PYGZdq{}\PYGZgt{}    1 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}substeps\PYGZdq{}\PYGZgt{}               5 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}warmupSteps\PYGZdq{}\PYGZgt{}            2 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}blocks\PYGZdq{}\PYGZgt{}                50 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}timestep\PYGZdq{}\PYGZgt{}             1.0 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}usedrift\PYGZdq{}\PYGZgt{}              no \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}estimator name=\PYGZdq{}LocalEnergy\PYGZdq{} hdf5=\PYGZdq{}no\PYGZdq{}/\PYGZgt{}
   \PYGZlt{}!\PYGZhy{}\PYGZhy{} Specify the optimizer options \PYGZhy{}\PYGZhy{}\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}MinMethod\PYGZdq{}\PYGZgt{}    OneShiftOnly \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}minwalkers\PYGZdq{}\PYGZgt{}            0.5 \PYGZlt{}/parameter\PYGZgt{}
 \PYGZlt{}/qmc\PYGZgt{}
\PYGZlt{}/loop\PYGZgt{}
\end{sphinxVerbatim}

For each optimization step, you will see

\begin{sphinxVerbatim}[commandchars=\\\{\}]
The new set of parameters is valid. Updating the trial wave function!
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
The new set of parameters is not valid. Revert to the old set!
\end{sphinxVerbatim}

Occasional rejection is fine. Frequent rejection indicates potential
problems, and users should inspect the VMC calculation or change
optimization strategy. To track the progress of optimization, use the
command \sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}q ev *.scalar.dat}} to look at the VMC energy and
variance for each optimization step.


\subsection{Adaptive Organizer}
\label{\detokenize{methods:adaptive-organizer}}
The default setting of the adaptive optimizer is to construct the linear
method Hamiltonian and overlap matrices explicitly and add different
shifts to the Hamiltonian matrix as “stabilizers.” The generalized
eigenvalue problem is solved for each shift to obtain updates to the
wavefunction parameters. Then a correlated sampling is performed for
each shift’s updated wavefunction and the initial trial wavefunction
using the middle shift’s updated wavefunction as the guiding function.
The cost function for these wavefunctions is compared, and the update
corresponding to the best cost function is selected. In the next
iteration, the median magnitude of the stabilizers is set to the
magnitude that generated the best update in the current iteration, thus
adapting the magnitude of the stabilizers automatically.

When the trial wavefunction contains more than 10,000 parameters,
constructing and storing the linear method matrices could become a
memory bottleneck. To avoid explicit construction of these matrices, the
adaptive optimizer implements the block linear method (BLM) approach.
\sphinxcite{methods:zhao-2017-blocked-lm} The BLM tries to find an
approximate solution \(\vec{c}_{opt}\) to the standard LM
generalized eigenvalue problem by dividing the variable space into a
number of blocks and making intelligent estimates for which directions
within those blocks will be most important for constructing
\(\vec{c}_{opt}\), which is then obtained by solving a smaller, more
memory\sphinxhyphen{}efficient eigenproblem in the basis of these supposedly important
block\sphinxhyphen{}wise directions.

\sphinxcode{\sphinxupquote{linear}} method:
\begin{quote}

parameters:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{max\_relative\_change}}
&
real
&
\(> 0\)
&
10.0
&
Allowed change in cost function
\\
\hline
\sphinxcode{\sphinxupquote{max\_param\_change}}
&
real
&
\(> 0\)
&
0.3
&
Allowed change in wavefunction parameter
\\
\hline
\sphinxcode{\sphinxupquote{shift\_i}}
&
real
&
\(> 0\)
&
0.01
&
Initial diagonal stabilizer added to the Hamiltonian matrix
\\
\hline
\sphinxcode{\sphinxupquote{shift\_s}}
&
real
&
\(> 0\)
&
1.00
&
Initial overlap\sphinxhyphen{}based stabilizer added to the Hamiltonian matrix
\\
\hline
\sphinxcode{\sphinxupquote{target\_shift\_i}}
&
real
&
any
&
\sphinxhyphen{}1.0
&
Diagonal stabilizer value aimed for during adaptive method (disabled if \(\leq 0\))
\\
\hline
\sphinxcode{\sphinxupquote{cost\_increase\_tol}}
&
real
&
\(\geq 0\)
&
0.0
&
Tolerance for cost function increases
\\
\hline
\sphinxcode{\sphinxupquote{chase\_lowest}}
&
text
&
yes, no
&
yes
&
Chase the lowest eigenvector in iterative solver
\\
\hline
\sphinxcode{\sphinxupquote{chase\_closest}}
&
text
&
yes, no
&
no
&
Chase the eigenvector closest to initial guess
\\
\hline
\sphinxcode{\sphinxupquote{block\_lm}}
&
text
&
yes, no
&
no
&
Use BLM
\\
\hline
\sphinxcode{\sphinxupquote{blocks}}
&
integer
&
\(> 0\)
&&
Number of blocks in BLM
\\
\hline
\sphinxcode{\sphinxupquote{nolds}}
&
integer
&
\(> 0\)
&&
Number of old update vectors used in BLM
\\
\hline
\sphinxcode{\sphinxupquote{nkept}}
&
integer
&
\(> 0\)
&&
Number of eigenvectors to keep per block in BLM
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{shift\_i}} This is the initial coefficient used to scale the diagonal
stabilizer. More stable but slower optimization is expected with a
large value. The adaptive method will automatically adjust this value
after each linear method iteration.

\item {} 
\sphinxcode{\sphinxupquote{shift\_s}} This is the initial coefficient used to scale the overlap\sphinxhyphen{}based
stabilizer. More stable but slower optimization is expected with a
large value. The adaptive method will automatically adjust this value
after each linear method iteration.

\item {} 
\sphinxcode{\sphinxupquote{target\_shift\_i}} If set greater than zero, the adaptive method will choose the
update whose shift\_i value is closest to this target value so long as
the associated cost is within cost\_increase\_tol of the lowest cost.
Disable this behavior by setting target\_shift\_i to a negative number.

\item {} 
\sphinxcode{\sphinxupquote{cost\_increase\_tol}} Tolerance for cost function increases when selecting the best
shift.

\item {} 
\sphinxcode{\sphinxupquote{nblocks}} This is the number of blocks used in BLM. The amount of memory
required to store LM matrices decreases as the number of blocks
increases. But the error introduced by BLM would increase as the
number of blocks increases.

\item {} 
\sphinxcode{\sphinxupquote{nolds}} In BLM, the interblock correlation is accounted for by including a
small number of wavefunction update vectors outside the block. Larger
would include more interblock correlation and more accurate results
but also higher memory requirements.

\item {} 
\sphinxcode{\sphinxupquote{nkept}} This is the number of update directions retained from each block in
the BLM. If all directions are retained in each block, then the BLM
becomes equivalent to the standard LM. Retaining five or fewer
directions per block is often sufficient.

\end{itemize}

Recommendations:
\begin{itemize}
\item {} 
Default \sphinxcode{\sphinxupquote{shift\_i}}, \sphinxcode{\sphinxupquote{shift\_s}} should be fine.

\item {} 
When there are fewer than about 5,000 variables being optimized, the
traditional LM is preferred because it has a lower overhead than the
BLM when the number of variables is small.

\item {} 
Initial experience with the BLM suggests that a few hundred blocks
and a handful of and often provide a good balance between memory use
and accuracy. In general, using fewer blocks should be more accurate
but would require more memory.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}loop max=\PYGZdq{}15\PYGZdq{}\PYGZgt{}
 \PYGZlt{}qmc method=\PYGZdq{}linear\PYGZdq{} move=\PYGZdq{}pbyp\PYGZdq{}\PYGZgt{}
   \PYGZlt{}!\PYGZhy{}\PYGZhy{} Specify the VMC options \PYGZhy{}\PYGZhy{}\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}walkers\PYGZdq{}\PYGZgt{}                1 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}samples\PYGZdq{}\PYGZgt{}            20000 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}stepsbetweensamples\PYGZdq{}\PYGZgt{}    1 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}substeps\PYGZdq{}\PYGZgt{}               5 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}warmupSteps\PYGZdq{}\PYGZgt{}            5 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}blocks\PYGZdq{}\PYGZgt{}                50 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}timestep\PYGZdq{}\PYGZgt{}             1.0 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}usedrift\PYGZdq{}\PYGZgt{}              no \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}estimator name=\PYGZdq{}LocalEnergy\PYGZdq{} hdf5=\PYGZdq{}no\PYGZdq{}/\PYGZgt{}
   \PYGZlt{}!\PYGZhy{}\PYGZhy{} Specify the correlated sampling options and define the cost function \PYGZhy{}\PYGZhy{}\PYGZgt{}
        \PYGZlt{}cost name=\PYGZdq{}energy\PYGZdq{}\PYGZgt{}               1.00 \PYGZlt{}/cost\PYGZgt{}
        \PYGZlt{}cost name=\PYGZdq{}unreweightedvariance\PYGZdq{}\PYGZgt{} 0.00 \PYGZlt{}/cost\PYGZgt{}
        \PYGZlt{}cost name=\PYGZdq{}reweightedvariance\PYGZdq{}\PYGZgt{}   0.00 \PYGZlt{}/cost\PYGZgt{}
   \PYGZlt{}!\PYGZhy{}\PYGZhy{} Specify the optimizer options \PYGZhy{}\PYGZhy{}\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}MinMethod\PYGZdq{}\PYGZgt{}adaptive\PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}max\PYGZus{}relative\PYGZus{}cost\PYGZus{}change\PYGZdq{}\PYGZgt{}10.0\PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}shift\PYGZus{}i\PYGZdq{}\PYGZgt{} 1.00 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}shift\PYGZus{}s\PYGZdq{}\PYGZgt{} 1.00 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}max\PYGZus{}param\PYGZus{}change\PYGZdq{}\PYGZgt{} 0.3 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}chase\PYGZus{}lowest\PYGZdq{}\PYGZgt{} yes \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}chase\PYGZus{}closest\PYGZdq{}\PYGZgt{} yes \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}block\PYGZus{}lm\PYGZdq{}\PYGZgt{} no \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}!\PYGZhy{}\PYGZhy{} Specify the BLM specific options if needed
     \PYGZlt{}parameter name=\PYGZdq{}nblocks\PYGZdq{}\PYGZgt{} 100 \PYGZlt{}/parameter\PYGZgt{}
     \PYGZlt{}parameter name=\PYGZdq{}nolds\PYGZdq{}\PYGZgt{} 5 \PYGZlt{}/parameter\PYGZgt{}
     \PYGZlt{}parameter name=\PYGZdq{}nkept\PYGZdq{}\PYGZgt{} 3 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZhy{}\PYGZhy{}\PYGZgt{}
 \PYGZlt{}/qmc\PYGZgt{}
\PYGZlt{}/loop\PYGZgt{}
\end{sphinxVerbatim}

The adaptive optimizer is also able to optimize individual excited states directly. \sphinxcite{methods:zhao-2016-dir-tar}
In this case, it tries to minimize the following function:
\begin{equation*}
\begin{split}\Omega[\Psi]=\frac{\left<\Psi|\omega-H|\Psi\right>}{\left<\Psi|{\left(\omega-H\right)}^2|\Psi\right>}\:.\end{split}
\end{equation*}
The global minimum of this function corresponds to the state whose
energy lies immediately above the shift parameter \(\omega\) in the
energy spectrum. For example, if \(\omega\) were placed in between
the ground state energy and the first excited state energy and the
wavefunction ansatz was capable of a good description for the first
excited state, then the wavefunction would be optimized for the first
excited state. Note that if the ansatz is not capable of a good
description of the excited state in question, the optimization could
converge to a different state, as is known to occur in some
circumstances for traditional ground state optimizations. Note also that
the ground state can be targeted by this method by choosing
\(\omega\) to be below the ground state energy, although we should
stress that this is not the same thing as a traditional ground state
optimization and will in general give a slightly different wavefunction.
Excited state targeting requires two additional parameters, as shown in
the following table.

Excited state targeting:
\begin{quote}

parameters:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{targetExcited}}
&
text
&
yes, no
&
no
&
Whether to use the excited state targeting optimization
\\
\hline
\sphinxcode{\sphinxupquote{omega}}
&
real
&
real numbers
&
none
&
Energy shift used to target different excited states
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Excited state recommendations:
\begin{itemize}
\item {} 
Because of the finite variance in any approximate wavefunction, we
recommended setting \(\omega=\omega_0-\sigma\), where
\(\omega_0\) is placed just below the energy of the targeted
state and \(\sigma^2\) is the energy variance.

\item {} 
To obtain an unbiased excitation energy, the ground state should be
optimized with the excited state variational principle as well by
setting \sphinxcode{\sphinxupquote{omega}} below the ground state energy. Note that using the ground
state variational principle for the ground state and the excited
state variational principle for the excited state creates a bias in
favor of the ground state.

\end{itemize}


\subsection{Descent Optimizer}
\label{\detokenize{methods:descent-optimizer}}
Gradient descent algorithms are an alternative set of optimization methods to the OneShiftOnly and adaptive optimizers based on the linear method.
These methods use only first derivatives to optimize trial wave functions and convergence can be accelerated by retaining a memory of previous derivative values.
Multiple flavors of accelerated descent methods are available. They differ in details such as the schemes for adaptive adjustment of step sizes. \sphinxcite{methods:otis2019}
Descent algorithms avoid the construction of matrices that occurs in the linear method and consequently can be applied to larger sets of
optimizable parameters.
Currently, descent optimization is only available for ground state calculations.
Parameters for descent are shown in the table below.

\sphinxcode{\sphinxupquote{descent}} method:
\begin{quote}

parameters:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{flavor}}
&
text
&
RMSprop, Random, ADAM, AMSGrad
&
RMSprop
&
Particular type of descent method
\\
\hline
\sphinxcode{\sphinxupquote{Ramp\_eta}}
&
text
&
yes, no
&
no
&
Whether to gradually ramp up step sizes
\\
\hline
\sphinxcode{\sphinxupquote{Ramp\_num}}
&
integer
&
\(> 0\)
&
30
&
Number of steps over which to ramp up step size
\\
\hline
\sphinxcode{\sphinxupquote{TJF\_2Body\_eta}}
&
real
&
\(> 0\)
&
0.01
&
Step size for two body Jastrow parameters
\\
\hline
\sphinxcode{\sphinxupquote{TJF\_1Body\_eta}}
&
real
&
\(> 0\)
&
0.01
&
Step size for one body Jastrow parameters
\\
\hline
\sphinxcode{\sphinxupquote{F\_eta}}
&
real
&
\(> 0\)
&
0.001
&
Step size for number counting Jastrow F matrix parameters
\\
\hline
\sphinxcode{\sphinxupquote{Gauss\_eta}}
&
real
&
\(> 0\)
&
0.001
&
Step size for number counting Jastrow gaussian basis parameters
\\
\hline
\sphinxcode{\sphinxupquote{CI\_eta}}
&
real
&
\(> 0\)
&
0.01
&
Step size for CI parameters
\\
\hline
\sphinxcode{\sphinxupquote{Orb\_eta}}
&
real
&
\(> 0\)
&
0.001
&
Step size for orbital parameters
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information and recommendations:
\begin{itemize}
\item {} 
It is generally advantageous to set different step sizes for
different types of parameters. More nonlinear parameters such as
those for number counting Jastrow factors or orbitals typically
require smaller steps sizes than those for CI coefficients or
traditional Jastrow parameters. There are defaults for several
parameter types and a default of .001 has been chosen for all other
parameters.

\item {} 
The ability to gradually ramp up step sizes to their input values is
useful for avoiding spikes in the average local energy during early
iterations of descent optimization. This initial rise in the energy
occurs as a memory of past gradients is being built up and it may be
possible for the energy to recover without ramping if there are
enough iterations in the optimization.

\item {} 
The step sizes chosen can have a substantial influence on the quality
of the optimization and the final variational energy achieved. Larger
step sizes may be helpful if there is reason to think the descent
optimization is not reaching the minimum energy. There are also
additional hyperparameters in the descent algorithms with default
values. \sphinxcite{methods:otis2019} They seem to have limited
influence on the effectiveness of the optimization compared to step
sizes, but users can adjust them within the source code of the
descent engine if they wish.

\item {} 
The sampling effort for individual descent steps can be small
compared that for linear method iterations as shown in the example
input below. Something in the range of 10,000 to 30,000 seems
sufficient for molecules with tens of electrons. However, descent
optimizations may require anywhere from a few hundred to a few
thousand iterations.

\item {} 
In cases where a descent optimization struggles to reach the minimum
and a linear method optimization is not possible or unsatisfactory,
it may be useful to try the hybrid optimization approach described in
the next subsection.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}loop max=\PYGZdq{}100\PYGZdq{}\PYGZgt{}
   \PYGZlt{}qmc method=\PYGZdq{}linear\PYGZdq{} move=\PYGZdq{}pbyp\PYGZdq{} checkpoint=\PYGZdq{}\PYGZhy{}1\PYGZdq{} gpu=\PYGZdq{}no\PYGZdq{}\PYGZgt{}

   \PYGZlt{}!\PYGZhy{}\PYGZhy{} VMC inputs \PYGZhy{}\PYGZhy{}\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}blocks\PYGZdq{}\PYGZgt{}2000\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}steps\PYGZdq{}\PYGZgt{}1\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}samples\PYGZdq{}\PYGZgt{}20000\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}warmupsteps\PYGZdq{}\PYGZgt{}100\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}timestep\PYGZdq{}\PYGZgt{}0.05\PYGZlt{}/parameter\PYGZgt{}

    \PYGZlt{}parameter name=\PYGZdq{}MinMethod\PYGZdq{}\PYGZgt{}descent\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}estimator name=\PYGZdq{}LocalEnergy\PYGZdq{} hdf5=\PYGZdq{}no\PYGZdq{}/\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}usebuffer\PYGZdq{}\PYGZgt{}yes\PYGZlt{}/parameter\PYGZgt{}

    \PYGZlt{}estimator name=\PYGZdq{}LocalEnergy\PYGZdq{} hdf5=\PYGZdq{}no\PYGZdq{}/\PYGZgt{}

    \PYGZlt{}!\PYGZhy{}\PYGZhy{} Descent Inputs \PYGZhy{}\PYGZhy{}\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}flavor\PYGZdq{}\PYGZgt{}RMSprop\PYGZlt{}/parameter\PYGZgt{}

      \PYGZlt{}parameter name=\PYGZdq{}Ramp\PYGZus{}eta\PYGZdq{}\PYGZgt{}no\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}Ramp\PYGZus{}num\PYGZdq{}\PYGZgt{}30\PYGZlt{}/parameter\PYGZgt{}

     \PYGZlt{}parameter name=\PYGZdq{}TJF\PYGZus{}2Body\PYGZus{}eta\PYGZdq{}\PYGZgt{}.02\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}TJF\PYGZus{}1Body\PYGZus{}eta\PYGZdq{}\PYGZgt{}.02\PYGZlt{}/parameter\PYGZgt{}
     \PYGZlt{}parameter name=\PYGZdq{}F\PYGZus{}eta\PYGZdq{}\PYGZgt{}.001\PYGZlt{}/parameter\PYGZgt{}
     \PYGZlt{}parameter name=\PYGZdq{}Gauss\PYGZus{}eta\PYGZdq{}\PYGZgt{}.001\PYGZlt{}/parameter\PYGZgt{}
     \PYGZlt{}parameter name=\PYGZdq{}CI\PYGZus{}eta\PYGZdq{}\PYGZgt{}.1\PYGZlt{}/parameter\PYGZgt{}
     \PYGZlt{}parameter name=\PYGZdq{}Orb\PYGZus{}eta\PYGZdq{}\PYGZgt{}.0001\PYGZlt{}/parameter\PYGZgt{}


   \PYGZlt{}/qmc\PYGZgt{}
\PYGZlt{}/loop\PYGZgt{}
\end{sphinxVerbatim}


\subsection{Hybrid Optimizer}
\label{\detokenize{methods:hybrid-optimizer}}
Another optimization option is to use a hybrid combination of accelerated descent and blocked linear method.
It provides a means to retain the advantages of both individual methods while scaling to large numbers of parameters beyond the traditional 10,000 parameter limit of the linear method. \sphinxcite{methods:otis2019}
In a hybrid optimization, alternating sections of descent and BLM optimization are used.
Gradient descent is used to identify the previous important directions in parameter space used by the BLM, the number of which is set by the \sphinxcode{\sphinxupquote{nold}} input for the BLM.
Over the course of a section of descent, vectors of parameter differences are stored and then passed to the linear method engine after the optimization changes to the BLM.
One motivation for including sections of descent is to counteract noise in linear method updates due to uncertainties in its step direction and allow for a smoother movement to the minimum.
There are two additional parameters used in the hybrid optimization and it requires a slightly different format of input to specify the constituent methods as shown below in the example.

\sphinxcode{\sphinxupquote{descent}} method:
\begin{quote}

parameters:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{num\_updates}}
&
integer
&
\(> 0\)
&&
Number of steps for a method
\\
\hline
\sphinxcode{\sphinxupquote{Stored\_Vectors}}
&
integer
&
\(> 0\)
&
5
&
Number of vectors to transfer to BLM
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{loop} \PYG{n+nb}{max}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{203}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{linear}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pbyp}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{checkpoint}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{gpu}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Minmethod}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{n}{hybrid} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}

 \PYG{o}{\PYGZlt{}}\PYG{n}{optimizer} \PYG{n}{num\PYGZus{}updates}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{100}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}

\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1000}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{steps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{samples}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{20000}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{warmupsteps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1000}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.05}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}

     \PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LocalEnergy}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{hdf5}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}

     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Minmethod}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{n}{descent} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Stored\PYGZus{}Vectors}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{5}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flavor}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{RMSprop}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TJF\PYGZus{}2Body\PYGZus{}eta}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{o}{.}\PYG{l+m+mi}{01}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TJF\PYGZus{}1Body\PYGZus{}eta}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{o}{.}\PYG{l+m+mi}{01}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CI\PYGZus{}eta}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}

     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ramp\PYGZus{}eta}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{no}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ramp\PYGZus{}num}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{10}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{optimizer}\PYG{o}{\PYGZgt{}}

 \PYG{o}{\PYGZlt{}}\PYG{n}{optimizer} \PYG{n}{num\PYGZus{}updates}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}

     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{2000}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{steps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{samples}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1000000}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{warmupsteps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1000}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.05}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}

     \PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LocalEnergy}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{hdf5}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}

     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Minmethod}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{n}{adaptive} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max\PYGZus{}relative\PYGZus{}cost\PYGZus{}change}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{10.0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max\PYGZus{}param\PYGZus{}change}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{3}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{shift\PYGZus{}i}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.01}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{shift\PYGZus{}s}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1.00}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}

     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{block\PYGZus{}lm}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{yes}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nblocks}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{2}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nolds}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{5}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nkept}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{5}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}

 \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{optimizer}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{loop}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Additional information and recommendations:
\begin{itemize}
\item {} 
In the example above, the input for \sphinxcode{\sphinxupquote{loop}} gives the total number
of steps for the full optimization while the inputs for
\sphinxcode{\sphinxupquote{num\_updates}} specify the number of steps in the constituent
methods. For this case, the optimization would begin with 100 steps
of descent using the parameters in the first \sphinxcode{\sphinxupquote{optimizer}} block and
then switch to the BLM for 3 steps before switching back to descent
for the final 100 iterations of the total of 203.

\item {} 
The design of the hybrid method allows for more than two
\sphinxcode{\sphinxupquote{optimizer}} blocks to be used and the optimization will cycle
through the individual methods. However, the effectiveness of this in
terms of the quality of optimization results is unexplored.

\item {} 
As the descent algorithms are currently only implemented for ground
state optimizations, this hybrid combination of them with the BLM is
also restricted to the ground state for now.

\item {} 
It can be useful to follow a hybrid optimization with a section of
pure descent optimization and take an average energy over the last
few hundred iterations as the final variational energy. This approach
can achieve a lower statistical uncertainty on the energy for less
overall sampling effort compared to what a pure linear method
optimization would require.

\end{itemize}


\subsection{Quartic Optimizer}
\label{\detokenize{methods:quartic-optimizer}}
\sphinxstyleemphasis{This is an older optimizer method retained for compatibility. We
recommend starting with the newest OneShiftOnly or adaptive optimizers.}
The quartic optimizer fits a quartic polynomial to 7 values of the cost
function obtained using reweighting along the chosen direction and
determines the optimal move. This optimizer is very robust but is a bit
conservative when accepting new steps, especially when large parameters
changes are proposed.

\sphinxcode{\sphinxupquote{linear}} method:
\begin{quote}

parameters:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{bigchange}}
&
real
&
\(> 0\)
&
50.0
&
Largest parameter change allowed
\\
\hline
\sphinxcode{\sphinxupquote{alloweddifference}}
&
real
&
\(> 0\)
&
1e\sphinxhyphen{}4
&
Allowed increase in energy
\\
\hline
\sphinxcode{\sphinxupquote{exp0}}
&
real
&
any value
&
\sphinxhyphen{}16.0
&
Initial value for stabilizer
\\
\hline
\sphinxcode{\sphinxupquote{stabilizerscale}}
&
real
&
\(> 0\)
&
2.0
&
Increase in value of \sphinxcode{\sphinxupquote{exp0}} between iterations
\\
\hline
\sphinxcode{\sphinxupquote{nstabilizers}}
&
integer
&
\(> 0\)
&
3
&
Number of stabilizers to try
\\
\hline
\sphinxcode{\sphinxupquote{max\_its}}
&
integer
&
\(> 0\)
&
1
&
Number of inner loops with same samples
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{exp0}} This is the initial value for stabilizer (shift to diagonal of H).
The actual value of stabilizer is \(10^{\textrm{exp0}}\).

\end{itemize}

Recommendations:
\begin{itemize}
\item {} 
For hard cases (e.g., simultaneous optimization of long MSD and
3\sphinxhyphen{}Body J), set \sphinxcode{\sphinxupquote{exp0}} to 0 and do a single inner iteration (max its=1) per
sample of configurations.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}!\PYGZhy{}\PYGZhy{} Specify the optimizer options \PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZlt{}parameter name=\PYGZdq{}MinMethod\PYGZdq{}\PYGZgt{}quartic\PYGZlt{}/parameter\PYGZgt{}
\PYGZlt{}parameter name=\PYGZdq{}exp0\PYGZdq{}\PYGZgt{}\PYGZhy{}6\PYGZlt{}/parameter\PYGZgt{}
\PYGZlt{}parameter name=\PYGZdq{}alloweddifference\PYGZdq{}\PYGZgt{} 1.0e\PYGZhy{}4 \PYGZlt{}/parameter\PYGZgt{}
\PYGZlt{}parameter name=\PYGZdq{}nstabilizers\PYGZdq{}\PYGZgt{} 1 \PYGZlt{}/parameter\PYGZgt{}
\PYGZlt{}parameter name=\PYGZdq{}bigchange\PYGZdq{}\PYGZgt{}15.0\PYGZlt{}/parameter\PYGZgt{}
\end{sphinxVerbatim}


\subsection{General Recommendations}
\label{\detokenize{methods:general-recommendations}}\begin{itemize}
\item {} 
All electron wavefunctions are typically more difficult to optimize
than pseudopotential wavefunctions because of the importance of the
wavefunction near the nucleus.

\item {} 
Two\sphinxhyphen{}body Jastrow contributes the largest portion of correlation
energy from bare Slater determinants. Consequently, the recommended
order for optimizing wavefunction components is two\sphinxhyphen{}body, one\sphinxhyphen{}body,
three\sphinxhyphen{}body Jastrow factors and MSD coefficients.

\item {} 
For two\sphinxhyphen{}body spline Jastrows, always start from a reasonable one. The
lack of physically motivated constraints in the functional form at
large distances can cause slow convergence if starting from zero.

\item {} 
One\sphinxhyphen{}body spline Jastrow from old calculations can be a good starting
point.

\item {} 
Three\sphinxhyphen{}body polynomial Jastrow can start from zero. It is beneficial
to first optimize one\sphinxhyphen{}body and two\sphinxhyphen{}body Jastrow factors without
adding three\sphinxhyphen{}body terms in the calculation and then add the
three\sphinxhyphen{}body Jastrow and optimize all the three components together.

\end{itemize}


\subsubsection{Optimization of CI coefficients}
\label{\detokenize{methods:optimization-of-ci-coefficients}}
When storing a CI wavefunction in HDF5 format, the CI coefficients and
the \(\alpha\) and \(\beta\) components of each CI are not in
the XML input file. When optimizing the CI coefficients, they will be
stored in HDF5 format. The optimization header block will have to
specify that the new CI coefficients will be saved to HDF5 format. If
the tag is not added coefficients will not be saved.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{linear}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pbyp}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{gpu}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{hdf5}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}

\PYG{n}{The} \PYG{n}{rest} \PYG{n}{of} \PYG{n}{the} \PYG{n}{optimization} \PYG{n}{block} \PYG{n}{remains} \PYG{n}{the} \PYG{n}{same}\PYG{o}{.}
\end{sphinxVerbatim}

When running the optimization, the new coefficients will be stored in a {\color{red}\bfseries{}*}.sXXX.opt.h5 file,  where XXX coressponds to the series number. The H5 file contains only the optimized coefficients. The corresponding {\color{red}\bfseries{}*}.sXXX.opt.xml  will be updated for each optimization block as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{detlist} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1487}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DETS}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{nca}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{ncb}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{nea}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{neb}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{nstates}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{85}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{cutoff}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1e\PYGZhy{}2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{../LiH.orbs.h5}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{opt\PYGZus{}coeffs}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LiH.s001.opt.h5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

The opt\_coeffs tag will then reference where the new CI coefficients are
stored.

When restarting the run with the new optimized coeffs, you need to
specify the previous hdf5 containing the basis set, orbitals, and MSD,
as well as the new optimized coefficients. The code will read the
previous data but will rewrite the coefficients that were optimized with
the values found in the *.sXXX.opt.h5 file. Be careful to keep the pair
of optimized CI coefficients and Jastrow coefficients together to avoid
inconsistencies.


\section{Diffusion Monte Carlo}
\label{\detokenize{methods:diffusion-monte-carlo}}\label{\detokenize{methods:dmc}}
Main input parameters are given in \hyperref[\detokenize{methods:table9}]{Table \ref{\detokenize{methods:table9}}}, additional in \hyperref[\detokenize{methods:table10}]{Table \ref{\detokenize{methods:table10}}}.

\sphinxcode{\sphinxupquote{dmc}} method:

parameters:


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{methods:table9}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{targetwalkers}}
&
integer
&
\(> 0\)
&
dep.
&
Overall total number of walkers
\\
\hline
\sphinxcode{\sphinxupquote{blocks}}
&
integer
&
\(\geq 0\)
&
1
&
Number of blocks
\\
\hline
\sphinxcode{\sphinxupquote{steps}}
&
integer
&
\(\geq 0\)
&
1
&
Number of steps per block
\\
\hline
\sphinxcode{\sphinxupquote{warmupsteps}}
&
integer
&
\(\geq 0\)
&
0
&
Number of steps for warming up
\\
\hline
\sphinxcode{\sphinxupquote{timestep}}
&
real
&
\(> 0\)
&
0.1
&
Time step for each electron move
\\
\hline
\sphinxcode{\sphinxupquote{nonlocalmoves}}
&
string
&
yes, no, v0, v1, v3
&
no
&
Run with T\sphinxhyphen{}moves
\\
\hline
\sphinxcode{\sphinxupquote{branching\_cutoff\_scheme}}
&
string
&
classic/DRV/ZSGMA/YL
&
classic
&
Branch cutoff scheme
\\
\hline
\sphinxcode{\sphinxupquote{maxcpusecs}}
&
real
&
\(\geq 0\)
&
3.6e5
&
Maximum allowed walltime in seconds
\\
\hline
\sphinxcode{\sphinxupquote{blocks\_between\_recompute}}
&
integer
&
\(\geq 0\)
&
dep.
&
Wavefunction recompute frequency
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{center}Table 9 Main DMC input parameters.
\end{center}

\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{methods:table10}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{energyUpdateInterval}}
&
integer
&
\(\geq 0\)
&
0
&
Trial energy update interval
\\
\hline
\sphinxcode{\sphinxupquote{refEnergy}}
&
real
&
all values
&
dep.
&
Reference energy in atomic units
\\
\hline
\sphinxcode{\sphinxupquote{feedback}}
&
double
&
\(\geq 0\)
&
1.0
&
Population feedback on the trial energy
\\
\hline
\sphinxcode{\sphinxupquote{sigmaBound}}
&
10
&
\(\geq 0\)
&
10
&
Parameter to cutoff large weights
\\
\hline
\sphinxcode{\sphinxupquote{killnode}}
&
string
&
yes/other
&
no
&
Kill or reject walkers that cross nodes
\\
\hline
\sphinxcode{\sphinxupquote{warmupByReconfiguration}}
&
option
&
yes,no
&
0
&
Warm up with a fixed population
\\
\hline
\sphinxcode{\sphinxupquote{reconfiguration}}
&
string
&
yes/pure/other
&
no
&
Fixed population technique
\\
\hline
\sphinxcode{\sphinxupquote{branchInterval}}
&
integer
&
\(\geq 0\)
&
1
&
Branching interval
\\
\hline
\sphinxcode{\sphinxupquote{substeps}}
&
integer
&
\(\geq 0\)
&
1
&
Branching interval
\\
\hline
\sphinxcode{\sphinxupquote{MaxAge}}
&
double
&
\(\geq 0\)
&
10
&
Kill persistent walkers
\\
\hline
\sphinxcode{\sphinxupquote{MaxCopy}}
&
double
&
\(\geq 0\)
&
2
&
Limit population growth
\\
\hline
\sphinxcode{\sphinxupquote{maxDisplSq}}
&
real
&
all values
&
\sphinxhyphen{}1
&
Maximum particle move
\\
\hline
\sphinxcode{\sphinxupquote{scaleweight}}
&
string
&
yes/other
&
yes
&
Scale weights (CUDA only)
\\
\hline
\sphinxcode{\sphinxupquote{checkproperties}}
&
integer
&
\(\geq 0\)
&
100
&
Number of steps between walker updates
\\
\hline
\sphinxcode{\sphinxupquote{fastgrad}}
&
text
&
yes/other
&
yes
&
Fast gradients
\\
\hline
\sphinxcode{\sphinxupquote{storeconfigs}}
&
integer
&
all values
&
0
&
Store configurations
\\
\hline
\sphinxcode{\sphinxupquote{use\_nonblocking}}
&
string
&
yes/no
&
yes
&
Using nonblocking send/recv
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{center}Table 10 Additional DMC input parameters.
\end{center}
Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{targetwalkers}}: A DMC run can be considered a restart run or a new
run. A restart run is considered to be any method block beyond the
first one, such as when a DMC method block follows a VMC block.
Alternatively, a user reading in configurations from disk would also
considered a restart run. In the case of a restart run, the DMC
driver will use the configurations from the previous run, and this
variable will not be used. For a new run, if the number of walkers is
less than the number of threads, then the number of walkers will be
set equal to the number of threads.

\item {} 
\sphinxcode{\sphinxupquote{blocks}}: This is the number of blocks run during a DMC method
block. A block consists of a number of DMC steps (steps), after which
all the statistics accumulated in the block are written to disk.

\item {} 
\sphinxcode{\sphinxupquote{steps}}: This is the number of DMC steps in a block.

\item {} 
\sphinxcode{\sphinxupquote{warmupsteps}}: These are the steps at the beginning of a DMC run in
which the instantaneous average energy is used to update the trial
energy. During regular steps, E\(_{ref}\) is used.

\item {} 
\sphinxcode{\sphinxupquote{timestep}}: The \sphinxcode{\sphinxupquote{timestep}} determines the accuracy of the
imaginary time propagator. Generally, multiple time steps are used to
extrapolate to the infinite time step limit. A good range of time
steps in which to perform time step extrapolation will typically have
a minimum of 99\% acceptance probability for each step.

\item {} 
\sphinxcode{\sphinxupquote{checkproperties}}: When using a particle\sphinxhyphen{}by\sphinxhyphen{}particle driver, this
variable specifies how often to reset all the variables kept in the
buffer.

\item {} 
\sphinxcode{\sphinxupquote{maxcpusecs}}: The default is 100 hours. Once the specified time has
elapsed, the program will finalize the simulation even if all blocks
are not completed.

\item {} 
\sphinxcode{\sphinxupquote{energyUpdateInterval}}: The default is to update the trial energy
at every step. Otherwise the trial energy is updated every
\sphinxcode{\sphinxupquote{energyUpdateInterval}} step.

\end{itemize}
\begin{equation*}
\begin{split}E_{\text{trial}}=
\textrm{refEnergy}+\textrm{feedback}\cdot(\ln\texttt{targetWalkers}-\ln N)\:,\end{split}
\end{equation*}
where \(N\) is the current population.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{refEnergy}}: The default reference energy is taken from the VMC run
that precedes the DMC run. This value is updated to the current mean
whenever branching happens.

\item {} 
\sphinxcode{\sphinxupquote{feedback}}: This variable is used to determine how strong to react
to population fluctuations when doing population control. See the
equation in energyUpdateInterval for more details.

\item {} 
\sphinxcode{\sphinxupquote{useBareTau}}: The same time step is used whether or not a move is
rejected. The default is to use an effective time step when a move is
rejected.

\item {} 
\sphinxcode{\sphinxupquote{warmupByReconfiguration}}: Warmup DMC is done with a fixed
population.

\item {} 
\sphinxcode{\sphinxupquote{sigmaBound}}: This determines the branch cutoff to limit wild
weights based on the sigma and \sphinxcode{\sphinxupquote{sigmaBound}}.

\item {} 
\sphinxcode{\sphinxupquote{killnode}}: When running fixed\sphinxhyphen{}node, if a walker attempts to cross
a node, the move will normally be rejected. If \sphinxcode{\sphinxupquote{killnode}} = “yes,”
then walkers are destroyed when they cross a node.

\item {} 
\sphinxcode{\sphinxupquote{reconfiguration}}: If \sphinxcode{\sphinxupquote{reconfiguration}} is “yes,” then run with a
fixed walker population using the reconfiguration technique.

\item {} 
\sphinxcode{\sphinxupquote{branchInterval}}: This is the number of steps between branching.
The total number of DMC steps in a block will be
\sphinxcode{\sphinxupquote{BranchInterval}}*Steps.

\item {} 
\sphinxcode{\sphinxupquote{substeps}}: This is the same as \sphinxcode{\sphinxupquote{BranchInterval}}.

\item {} 
\sphinxcode{\sphinxupquote{nonlocalmoves}}: Evaluate pseudopotentials using one of the
nonlocal move algorithms such as T\sphinxhyphen{}moves.
\begin{itemize}
\item {} 
no(default): Imposes the locality approximation.

\item {} 
yes/v0: Implements the algorithm in the 2006 Casula
paper \sphinxcite{methods:casula2006}.

\item {} 
v1: Implements the v1 algorithm in the 2010 Casula
paper \sphinxcite{methods:casula2010}.

\item {} 
v2: Is \sphinxstylestrong{not implemented} and is \sphinxstylestrong{skipped} to avoid any confusion
with the v2 algorithm in the 2010 Casula
paper \sphinxcite{methods:casula2010}.

\item {} 
v3: (Experimental) Implements an algorithm similar to v1 but is much
faster. v1 computes the transition probability before each single
electron T\sphinxhyphen{}move selection because of the acceptance of previous
T\sphinxhyphen{}moves. v3 mostly reuses the transition probability computed during
the evaluation of nonlocal pseudopotentials for the local energy,
namely before accepting any T\sphinxhyphen{}moves, and only recomputes the
transition probability of the electrons within the same
pseudopotential region of any electrons touched by T\sphinxhyphen{}moves. This is
an approximation to v1 and results in a slightly different time step
error, but it significantly reduces the computational cost. v1 and v3
agree at zero time step. This faster algorithm is the topic of a
paper in preparation.

The v1 and v3 algorithms are size\sphinxhyphen{}consistent and are important advances over the previous v0 non\sphinxhyphen{}size\sphinxhyphen{}consistent algorithm. We highly recommend investigating the importance of size\sphinxhyphen{}consistency.

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{scaleweight}}: This is the scaling weight per Umrigar/Nightengale.
CUDA only.

\item {} 
\sphinxcode{\sphinxupquote{MaxAge}}: Set the weight of a walker to min(currentweight,0.5)
after a walker has not moved for \sphinxcode{\sphinxupquote{MaxAge}} steps. Needed if
persistent walkers appear during the course of a run.

\item {} 
\sphinxcode{\sphinxupquote{MaxCopy}}: When determining the number of copies of a walker to
branch, set the number of copies equal to min(Multiplicity,MaxCopy).

\item {} 
\sphinxcode{\sphinxupquote{fastgrad}}: This calculates gradients with either the fast version
or the full\sphinxhyphen{}ratio version.

\item {} 
\sphinxcode{\sphinxupquote{maxDisplSq}}: When running a DMC calculation with particle by
particle, this sets the maximum displacement allowed for a single
particle move. All distance displacements larger than the max are
rejected. If initialized to a negative value, it becomes equal to
Lattice(LR/rc).

\item {} 
\sphinxcode{\sphinxupquote{sigmaBound}}: This determines the branch cutoff to limit wild
weights based on the sigma and \sphinxcode{\sphinxupquote{sigmaBound}}.

\item {} 
\sphinxcode{\sphinxupquote{storeconfigs}}: If \sphinxcode{\sphinxupquote{storeconfigs}} is set to a nonzero value, then
electron configurations during the DMC run will be saved. This option
is disabled for the OpenMP version of DMC.

\item {} 
\sphinxcode{\sphinxupquote{blocks\_between\_recompute}}: See details in {\hyperref[\detokenize{methods:vmc}]{\sphinxcrossref{\DUrole{std,std-ref}{Variational Monte Carlo}}}}.

\item {} 
\sphinxcode{\sphinxupquote{branching\_cutoff\_scheme:}} Modifies how the branching factor is
computed so as to avoid divergences and stability problems near nodal
surfaces.
\begin{itemize}
\item {} 
classic (default): The implementation found in QMCPACK v3.0.0 and
earlier.
\(E_{\rm cut}=\mathrm{min}(\mathrm{max}(\sigma^2 \times \mathrm{sigmaBound},\mathrm{maxSigma}),2.5/\tau)\),
where \(\sigma^2\) is the variance and
\(\mathrm{maxSigma}\) is set to 50 during warmup
(equilibration) and 10 thereafter. \(\mathrm{sigmaBound}\) is
default to 10.

\item {} 
DRV: Implements the algorithm of DePasquale et al., Eq. 3 in
\sphinxcite{methods:depasqualereliable1988} or Eq. 9 of
\sphinxcite{methods:umrigar1993}.
\(E_{\rm cut}=2.0/\sqrt{\tau}\).

\item {} 
ZSGMA: Implements the “ZSGMA” algorithm of
\sphinxcite{methods:zenboosting2016} with \(\alpha=0.2\).
The cutoff energy is modified by a factor including the electron
count, \(E_{\rm cut}=\alpha \sqrt{N/\tau}\), which greatly
improves size consistency over Eq. 39 of
\sphinxcite{methods:umrigar1993}. See Eq. 6 in
\sphinxcite{methods:zenboosting2016} and for an application to
molecular crystals \sphinxcite{methods:zenfast2018}.

\item {} 
YL: An unpublished algorithm due to Ye Luo.
\(E_{\rm cut}=\sigma\times\mathrm{min}(\mathrm{sigmaBound},\sqrt{1/\tau})\).
This option takes into account both size consistency and
wavefunction quality via the term \(\sigma\).
\(\mathrm{sigmaBound}\) is default to 10.

\end{itemize}

\end{itemize}
\sphinxSetupCaptionForVerbatim{The following is an example of a very simple DMC section.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{methods:listing-44}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dmc}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pbyp}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{100}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{steps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{400}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.010}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{warmupsteps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{100}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

The time step should be individually adjusted for each problem.  Please refer to the theory section
on diffusion Monte Carlo.
\sphinxSetupCaptionForVerbatim{The following is an example of running a simulation that can be restarted.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{methods:listing-45}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dmc}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pbyp}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n}{checkpoint}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}         \PYG{l+m+mf}{0.004}  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}           \PYG{l+m+mi}{100}   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{steps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}            \PYG{l+m+mi}{400}    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

The checkpoint flag instructs QMCPACK to output walker configurations.
This also works in VMC. This will output an h5 file with the name
\sphinxcode{\sphinxupquote{projectid.run\sphinxhyphen{}number.config.h5}}. Check that this file exists before
attempting a restart. To read in this file for a continuation run,
specify the following:
\sphinxSetupCaptionForVerbatim{Restart (read walkers from previous run).}
\def\sphinxLiteralBlockLabel{\label{\detokenize{methods:listing-46}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{mcwalkerset} \PYG{n}{fileroot}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{BH.s002}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{version}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0 6}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{collected}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

BH is the project id, and s002 is the calculation number to read in the walkers from the previous run.

Combining VMC and DMC in a single run (wavefunction optimization can be combined in this way too) is the standard way in which QMCPACK is typically run.   There is no need to run two separate jobs since method sections can be stacked and walkers are transferred between them.
\sphinxSetupCaptionForVerbatim{Combined VMC and DMC run.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{methods:listing-47}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{vmc}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pbyp}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{100}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{steps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{4000}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{warmupsteps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{100}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{samples}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1920}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{walkers}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.5}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dmc}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pbyp}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{100}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{steps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{400}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.010}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{warmupsteps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{100}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dmc}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pbyp}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{warmupsteps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{500}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{50}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{steps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{100}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.005}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\section{Reptation Monte Carlo}
\label{\detokenize{methods:reptation-monte-carlo}}\label{\detokenize{methods:rmc}}
Like DMC, RMC is a projector\sphinxhyphen{}based method that allows sampling of the
fixed\sphinxhyphen{}node wavefunciton. However, by exploiting the path\sphinxhyphen{}integral
formulation of Schrödinger’s equation, the RMC algorithm can offer some
advantages over traditional DMC, such as sampling both the mixed and
pure fixed\sphinxhyphen{}node distributions in polynomial time, as well as not having
population fluctuations and biases. The current implementation does not
work with T\sphinxhyphen{}moves.

There are two adjustable parameters that affect the quality of the RMC
projection: imaginary projection time \(\beta\) of the sampling path
(commonly called a “reptile”) and the Trotter time step \(\tau\).
\(\beta\) must be chosen to be large enough such that
\(e^{-\beta \hat{H}}|\Psi_T\rangle \approx |\Phi_0\rangle\) for
mixed observables, and
\(e^{-\frac{\beta}{2} \hat{H}}|\Psi_T\rangle \approx |\Phi_0\rangle\)
for pure observables. The reptile is discretized into
\(M=\beta/\tau\) beads at the cost of an \(\mathcal{O}(\tau)\)
time\sphinxhyphen{}step error for observables arising from the Trotter\sphinxhyphen{}Suzuki breakup
of the short\sphinxhyphen{}time propagator.

The following table lists some of the more practical

\sphinxcode{\sphinxupquote{vmc}} method:
\begin{quote}

parameters:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{beta}}
&
real
&
\(> 0\)
&
dep.
&
Reptile project time \(\beta\)
\\
\hline
\sphinxcode{\sphinxupquote{timestep}}
&
real
&
\(> 0\)
&
0.1
&
Trotter time step \(\tau\) for each electron move
\\
\hline
\sphinxcode{\sphinxupquote{beads}}
&
int
&
\(> 0\)
&
1
&
Number of reptile beads \(M=\beta/\tau\)
\\
\hline
\sphinxcode{\sphinxupquote{blocks}}
&
integer
&
\(> 0\)
&
1
&
Number of blocks
\\
\hline
\sphinxcode{\sphinxupquote{steps}}
&
integer
&
\(\geq 0\)
&
1
&
Number of steps per block
\\
\hline
\sphinxcode{\sphinxupquote{vmcpresteps}}
&
integer
&
\(\geq 0\)
&
0
&
Propagates reptile using VMC for given number of steps
\\
\hline
\sphinxcode{\sphinxupquote{warmupsteps}}
&
integer
&
\(\geq 0\)
&
0
&
Number of steps for warming up
\\
\hline
\sphinxcode{\sphinxupquote{maxAge}}
&
integer
&
\(\geq 0\)
&
0
&
Force accept for stuck reptile if age exceeds \sphinxcode{\sphinxupquote{maxAge}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:

Because of the sampling differences between DMC ensembles of walkers and
RMC reptiles, the RMC block should contain the following estimator
declaration to ensure correct sampling:
\sphinxcode{\sphinxupquote{\textless{}estimator name="RMC" hdf5="no"\textgreater{}}}.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{beta}} or \sphinxcode{\sphinxupquote{beads}}? One or the other can be specified, and from
the Trotter time step, the code will construct an appropriately sized
reptile. If both are given, \sphinxcode{\sphinxupquote{beta}} overrides \sphinxcode{\sphinxupquote{beads}}.

\item {} 
\sphinxstylestrong{Mixed vs. pure observables?} Configurations sampled by the
endpoints of the reptile are distributed according to the mixed
distribution
\(f(\mathbf{R})=\Psi_T(\mathbf{R})\Phi_0(\mathbf{R})\). Any
observable that is computable within DMC and is dumped to the
\sphinxcode{\sphinxupquote{scalar.dat}} file will likewise be found in the \sphinxcode{\sphinxupquote{scalar.dat}} file
generated by RMC, except there will be an appended \sphinxcode{\sphinxupquote{\_m}} to alert
the user that the observable was computed on the mixed distribution.
For pure observables, care must be taken in the interpretation. If
the observable is diagonal in the position basis (in layman’s terms,
if it is entirely computable from a single electron configuration
\(\mathbf{R}\), like the potential energy), and if the observable
does not have an explicit dependence on the trial wavefunction (e.g.,
the local energy has an explicit dependence on the trial wavefunction
from the kinetic energy term), then pure estimates will be correctly
computed. These observables will be found in either the
\sphinxcode{\sphinxupquote{scalar.dat}}, where they will be appended with a \sphinxcode{\sphinxupquote{\_p}} suffix, or
in the \sphinxcode{\sphinxupquote{stat.h5}} file. No mixed estimators will be dumped to the h5
file.

\item {} 
\sphinxstylestrong{Sampling}: For pure estimators, the traces of both pure and mixed
estimates should be checked. Ergodicity is a known problem in RMC.
Because we use the bounce algorithm, it is possible for the reptile
to bounce back and forth without changing the electron coordinates of
the central beads. This might not easily show up with mixed
estimators, since these are accumulated at constantly regrown ends,
but pure estimates are accumulated on these central beads and so can
exhibit strong autocorrelations in pure estimate traces.

\item {} 
\sphinxstylestrong{Propagator}: Our implementation of RMC uses Moroni’s DMC link
action (symmetrized), with Umrigar’s scaled drift near nodes. In this
regard, the propagator is identical to the one QMCPACK uses in DMC.

\item {} 
\sphinxstylestrong{Sampling}: We use Ceperley’s bounce algorithm. \sphinxcode{\sphinxupquote{MaxAge}} is used
in case the reptile gets stuck, at which point the code forces move
acceptance, stops accumulating statistics, and requilibrates the
reptile. Very rarely will this be required. For move proposals, we
use particle\sphinxhyphen{}by\sphinxhyphen{}particle VMC a total of \(N_e\) times to generate
a new all\sphinxhyphen{}electron configuration, at which point the action is
computed and the move is either accepted or rejected.

\end{itemize}




\chapter{Output Overview}
\label{\detokenize{output_overview:output-overview}}\label{\detokenize{output_overview:id1}}\label{\detokenize{output_overview::doc}}
QMCPACK writes several output files that report information about the simulation (e.g., the physical properties such as the energy), as well as information about the computational aspects of the simulation, checkpoints, and restarts.
The types of output files generated depend on the details of a calculation. The following list is not meant to be exhaustive but rather to highlight some salient features of the more common file types. Further details can be found in the description of the estimator of interest.


\section{The .scalar.dat file}
\label{\detokenize{output_overview:the-scalar-dat-file}}\label{\detokenize{output_overview:scalardat-file}}
The most important output file is the \sphinxcode{\sphinxupquote{scalar.dat}} file. This file contains the
output of block\sphinxhyphen{}averaged properties of the system such as the local
energy and other estimators. Each line corresponds to an average over
\(N_{walkers}*N_{steps}\) samples. By default, the quantities
reported in the \sphinxcode{\sphinxupquote{scalar.dat}} file include the following:
\begin{description}
\item[{LocalEnergy}] \leavevmode
The local energy.

\item[{LocalEnergy\_sq}] \leavevmode
The local energy squared.

\item[{LocalPotential}] \leavevmode
The local potential energy.

\item[{Kinetic}] \leavevmode
The kinetic energy.

\item[{ElecElec}] \leavevmode
The electron\sphinxhyphen{}electron potential energy.

\item[{IonIon}] \leavevmode
The ion\sphinxhyphen{}ion potential energy.

\item[{LocalECP}] \leavevmode
The energy due to the pseudopotential/effective core potential.

\item[{NonLocalECP}] \leavevmode
The nonlocal energy due to the pseudopotential/effective core
potential.

\item[{MPC}] \leavevmode
The modified periodic Coulomb potential energy.

\item[{BlockWeight}] \leavevmode
The number of MC samples in the block.

\item[{BlockCPU}] \leavevmode
The number of seconds to compute the block.

\item[{AcceptRatio}] \leavevmode
The acceptance ratio.

\end{description}

QMCPACK includes a python utility, \sphinxcode{\sphinxupquote{qmca}}, that can be used to process these files. Details and examples are given in {\hyperref[\detokenize{analyzing:analyzing}]{\sphinxcrossref{\DUrole{std,std-ref}{Analyzing QMCPACK data}}}}.


\section{The .opt.xml file}
\label{\detokenize{output_overview:the-opt-xml-file}}\label{\detokenize{output_overview:optxml-file}}
This file is generated after a VMC wavefunction optimization and contains the part of the input file that lists the optimized Jastrow factors.
Conveniently, this file is already formatted such that it can easily be incorporated into a DMC input file.


\section{The .qmc.xml file}
\label{\detokenize{output_overview:the-qmc-xml-file}}\label{\detokenize{output_overview:qmc-file}}
This file contains information about the computational aspects of the simulation, for example, which parts of the code are being executed when. This file is generated only during an ensemble run in which QMCPACK runs multiple input files.


\section{The .dmc.dat file}
\label{\detokenize{output_overview:the-dmc-dat-file}}\label{\detokenize{output_overview:dmc-file}}
This file contains information similar to the \sphinxcode{\sphinxupquote{.scalar.dat}} file but also includes extra information about the details of a DMC calculation, for example, information about the walker population.
\begin{description}
\item[{Index}] \leavevmode
The block number.

\item[{LocalEnergy}] \leavevmode
The local energy.

\item[{Variance}] \leavevmode
The variance.

\item[{Weight}] \leavevmode
The number of samples in the block.

\item[{NumOfWalkers}] \leavevmode
The number of walkers times the number of steps.

\item[{AvgSentWalkers}] \leavevmode
The average number of walkers sent. During a DMC simulation, walkers
might be created or destroyed. At every step, QMCPACK will do some
load balancing to ensure that the walkers are evenly distributed
across nodes.

\item[{TrialEnergy}] \leavevmode
The trial energy. See {\hyperref[\detokenize{methods:dmc}]{\sphinxcrossref{\DUrole{std,std-ref}{Diffusion Monte Carlo}}}} for an explanation of
trial energy.

\item[{DiffEff}] \leavevmode
The diffusion efficiency.

\item[{LivingFraction}] \leavevmode
The fraction of the walker population from the previous step that
survived to the current step.

\end{description}


\section{The .bandinfo.dat file}
\label{\detokenize{output_overview:the-bandinfo-dat-file}}\label{\detokenize{output_overview:bandinfo-file}}
This file contains information from the trial wavefunction about the band structure of the system,
including the available \(k\)\sphinxhyphen{}points. This can
be helpful in constructing trial wavefunctions.


\section{Checkpoint and restart files}
\label{\detokenize{output_overview:checkpoint-and-restart-files}}\label{\detokenize{output_overview:checkpoint-files}}

\subsection{The .cont.xml file}
\label{\detokenize{output_overview:the-cont-xml-file}}
This file enables continuation of the run.  It is mostly a copy of the input XML file with the series number incremented and the \sphinxcode{\sphinxupquote{mcwalkerset}} element added to read the walkers from a config file.   The \sphinxcode{\sphinxupquote{.cont.xml}} file is always created, but other files it depends on are  present only if checkpointing is enabled.


\subsection{The .config.h5 file}
\label{\detokenize{output_overview:the-config-h5-file}}
This file contains stored walker configurations.


\subsection{The .random.h5 file}
\label{\detokenize{output_overview:the-random-h5-file}}
This file contains the state of the random number generator to allow restarts.
(Older versions used an XML file with a suffix of \sphinxcode{\sphinxupquote{.random.xml}}).


\chapter{Analyzing QMCPACK data}
\label{\detokenize{analyzing:analyzing-qmcpack-data}}\label{\detokenize{analyzing:analyzing}}\label{\detokenize{analyzing::doc}}

\section{Using the qmca tool to obtain total energies and related quantities}
\label{\detokenize{analyzing:using-the-qmca-tool-to-obtain-total-energies-and-related-quantities}}\label{\detokenize{analyzing:qmca}}
The \sphinxcode{\sphinxupquote{qmca}} tool is the primary means of analyzing scalar\sphinxhyphen{}valued data
generated by QMCPACK. Output files that contain scalar\sphinxhyphen{}valued data are
\sphinxcode{\sphinxupquote{*.scalar.dat}} and \sphinxcode{\sphinxupquote{*.dmc.dat}} (see {\hyperref[\detokenize{output_overview:output-overview}]{\sphinxcrossref{\DUrole{std,std-ref}{Output Overview}}}} for a detailed description of these files).
Quantities that are available for analysis in \sphinxcode{\sphinxupquote{*.scalar.dat}} files
include the local energy and its variance, kinetic energy, potential
energy and its components, acceptance ratio, and the average CPU time
spent per block, among others. The \sphinxcode{\sphinxupquote{*.dmc.dat}} files provide
information regarding the DMC walker population in addition to the local
energy.

Basic capabilities of \sphinxcode{\sphinxupquote{qmca}} include calculating mean values and
associated error bars, processing multiple files at once in batched
fashion, performing twist averaging, plotting mean values by series, and
plotting traces (per block or step) of the underlying data. These
capabilities are explained with accompanying examples in the following
subsections.

To use \sphinxcode{\sphinxupquote{qmca}}, installations of Python and NumPy must be present on
the local machine. For graphical plotting, the matplotlib module must
also be available.

An overview of all supported input flags to \sphinxcode{\sphinxupquote{qmca}} can be obtained by
typing \sphinxcode{\sphinxupquote{qmca}} at the command line with no other inputs (also try
\sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}x}} for a short list of examples):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}qmca
  no files provided, please see help info below

  Usage: qmca [options] [file(s)]

  Options:
    \PYGZhy{}\PYGZhy{}version             show program\PYGZsq{}s version number and exit
    \PYGZhy{}v, \PYGZhy{}\PYGZhy{}verbose         Print detailed information (default=False).
    \PYGZhy{}q QUANTITIES, \PYGZhy{}\PYGZhy{}quantities=QUANTITIES
                          Quantity or list of quantities to analyze.  See names
                          and abbreviations below (default=all).
    \PYGZhy{}u UNITS, \PYGZhy{}\PYGZhy{}units=UNITS
                          Desired energy units.  Can be Ha (Hartree), Ry
                          (Rydberg), eV (electron volts), kJ\PYGZus{}mol (k.
                          joule/mole), K (Kelvin), J (Joules) (default=Ha).
    \PYGZhy{}e EQUILIBRATION, \PYGZhy{}\PYGZhy{}equilibration=EQUILIBRATION
                          Equilibration length in blocks (default=auto).
    \PYGZhy{}a, \PYGZhy{}\PYGZhy{}average         Average over files in each series (default=False).
    \PYGZhy{}w WEIGHTS, \PYGZhy{}\PYGZhy{}weights=WEIGHTS
                          List of weights for averaging (default=None).
    \PYGZhy{}b, \PYGZhy{}\PYGZhy{}reblock         (pending) Use reblocking to calculate statistics
                          (default=False).
    \PYGZhy{}p, \PYGZhy{}\PYGZhy{}plot            Plot quantities vs. series (default=False).
    \PYGZhy{}t, \PYGZhy{}\PYGZhy{}trace           Plot a trace of quantities (default=False).
    \PYGZhy{}h, \PYGZhy{}\PYGZhy{}histogram       (pending) Plot a histogram of quantities
                          (default=False).
    \PYGZhy{}o, \PYGZhy{}\PYGZhy{}overlay         Overlay plots (default=False).
    \PYGZhy{}\PYGZhy{}legend=LEGEND       Placement of legend.  None for no legend, outside for
                          outside legend (default=upper right).
    \PYGZhy{}\PYGZhy{}noautocorr          Do not calculate autocorrelation. Warning: error bars
                          are no longer valid! (default=False).
    \PYGZhy{}\PYGZhy{}noac                Alias for \PYGZhy{}\PYGZhy{}noautocorr (default=False).
    \PYGZhy{}\PYGZhy{}sac                 Show autocorrelation of sample data (default=False).
    \PYGZhy{}\PYGZhy{}sv                  Show variance of sample data (default=False).
    \PYGZhy{}i, \PYGZhy{}\PYGZhy{}image           (pending) Save image files (default=False).
    \PYGZhy{}r, \PYGZhy{}\PYGZhy{}report          (pending) Write a report (default=False).
    \PYGZhy{}s, \PYGZhy{}\PYGZhy{}show\PYGZus{}options    Print user provided options (default=False).
    \PYGZhy{}x, \PYGZhy{}\PYGZhy{}examples        Print examples and exit (default=False).
    \PYGZhy{}\PYGZhy{}help                Print help information and exit (default=False).
    \PYGZhy{}d DESIRED\PYGZus{}ERROR, \PYGZhy{}\PYGZhy{}desired\PYGZus{}error=DESIRED\PYGZus{}ERROR
                          Show number of samples needed for desired error bar
                          (default=none).
    \PYGZhy{}n PARTICLE\PYGZus{}NUMBER, \PYGZhy{}\PYGZhy{}enlarge\PYGZus{}system=PARTICLE\PYGZus{}NUMBER
                          Show number of samples needed to maintain error bar on
                          larger system: desired particle number first, current
                          particle number second (default=none)
\end{sphinxVerbatim}


\subsection{Obtaining a statistically correct mean and error bar}
\label{\detokenize{analyzing:obtaining-a-statistically-correct-mean-and-error-bar}}\label{\detokenize{analyzing:qmca-mean-error}}
A rough guess at the mean and error bar of the local energy can be
obtained in the following way with \sphinxcode{\sphinxupquote{qmca}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s000}\PYG{o}{.}\PYG{n}{scalar}\PYG{o}{.}\PYG{n}{dat}
\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{n}{LocalEnergy}           \PYG{o}{=}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.876150} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.017688}
\end{sphinxVerbatim}

In this case the VMC energy of an 8\sphinxhyphen{}atom cell of diamond is estimated to
be \(-45.876(2)\) Hartrees (Ha). This rough guess should not be used
for production\sphinxhyphen{}level or publication\sphinxhyphen{}quality estimates.

To obtain production\sphinxhyphen{}level results, the underlying data should first be
inspected visually to ensure that all data included in the averaging can
be attributed to a distribution sharing the same mean. The first steps
of essentially any MC calculation (the “equilibration phase”) do not
belong to the equilibrium distribution and should be excluded from
estimates of the mean and its error bar.

We can plot a data trace (\sphinxcode{\sphinxupquote{\sphinxhyphen{}t}}) of the local energy in the
following way:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{0} \PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s000}\PYG{o}{.}\PYG{n}{scalar}\PYG{o}{.}\PYG{n}{dat}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{\sphinxhyphen{}e 0}} part indicates that we do not want any data
to be initially excluded from the calculation of averages.  The resulting
plot is shown in \hyperref[\detokenize{analyzing:fig4}]{Fig.\@ \ref{\detokenize{analyzing:fig4}}}.  The unphysical
equilibration period is visible on the left side of the plot.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{qmca_mean_error_trace}.png}
\caption{Trace of the VMC local energy for an 8\sphinxhyphen{}atom cell of diamond generated
with \sphinxcode{\sphinxupquote{qmca}}. The x\sphinxhyphen{}axis (“samples”) refers to the VMC block index in
this case.}\label{\detokenize{analyzing:id1}}\label{\detokenize{analyzing:fig4}}\end{figure}

Most of the data fluctuates around a well\sphinxhyphen{}defined mean (consistent
variations around a flat line).  This property is important to verify
by plotting the trace for each QMC run.

If we exclude none of the equilibration data points, we get an
erroneous estimate of \(-45.870(2)\) Ha for the local energy:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{0} \PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s000}\PYG{o}{.}\PYG{n}{scalar}\PYG{o}{.}\PYG{n}{dat}
\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{n}{LocalEnergy}           \PYG{o}{=}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.870071} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.018072}
\end{sphinxVerbatim}

The equilibration period is typically estimated by eye, though a few conservative values should be checked to ensure that the mean remains
unaffected.  In this dataset, the equilibration appears to have been
reached after 100 or so samples.  After excluding the first 100
VMC blocks from the analysis we get

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{100} \PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s000}\PYG{o}{.}\PYG{n}{scalar}\PYG{o}{.}\PYG{n}{dat}
\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{n}{LocalEnergy}           \PYG{o}{=}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.877363} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.017432}
\end{sphinxVerbatim}

This estimate (\(-45.877(2)\) Ha) differs significantly from the
\(-45.870(2)\) Ha figure obtained from the full set of data, but it
agrees with the rough estimate of \(-45.876(2)\) Ha obtained with
the abbreviated command (\sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}q e qmc.s000.scalar.dat}}). This is
because \sphinxcode{\sphinxupquote{qmca}} makes a heuristic guess at the equilibration period and
got it reasonably correct in this case. In many cases, the heuristic
guess fails and should not be relied on for quality results.

We have so far obtained a statistically correct mean. To obtain a
statistically correct error bar, it is best to include \(\sim\)100
or more statistically independent samples. An estimate of the number of
independent samples can be obtained by considering the autocorrelation
time, which is essentially a measure of the number of samples that must
be traversed before an uncorrelated/independent sample is reached. We
can get an estimate of the autocorrelation time in the following way:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{100} \PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s000}\PYG{o}{.}\PYG{n}{scalar}\PYG{o}{.}\PYG{n}{dat} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{sac}
\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{n}{LocalEnergy}           \PYG{o}{=}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.877363} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.017432}    \PYG{l+m+mf}{4.8}
\end{sphinxVerbatim}

The flag \sphinxcode{\sphinxupquote{\textendash{}sac}} stands for (s)how (a)uto(c)orrelation. In this case,
the autocorrelation estimate is \(4.8\approx 5\) samples. Since the
total run contained 800 samples and we have excluded 100 of them, we can
estimate the number of independent samples as \((800-100)/5=140\).
In this case, the error bar is expected to be estimated reasonably well.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{qmca_judge_opt}.png}
\caption{Trace of the local energy during one\sphinxhyphen{} and two\sphinxhyphen{}body Jastrow optimizations
for an 8\sphinxhyphen{}atom cell of diamond generated with \sphinxcode{\sphinxupquote{qmca}}. Data for each
optimization cycle (QMCPACK series) is separated by a vertical black
line.}\label{\detokenize{analyzing:id2}}\label{\detokenize{analyzing:fig5}}\end{figure}

Keep in mind that the error bar represents the expected range of the
mean with a certainty of only \(\sim 70\%\); i.e., it is a one sigma
error bar. The actual mean value will lie outside the range indicated by
the error bar in 1 out of every 3 runs, and in a set of 20 runs 1 value
can be expected to deviate from its estimate by twice the error bar.


\subsection{Judging wavefunction optimization}
\label{\detokenize{analyzing:judging-wavefunction-optimization}}
Wavefunction optimization is a highly nonlinear and sometimes
sensitive process.  As such, there is a risk that systematic
errors encountered at this stage of the QMC process can be propagated
into subsequent (expensive) DMC runs unless they are guarded against
with vigilance.

In this section we again consider an 8\sphinxhyphen{}atom cell of diamond but now in
the context of Jastrow optimization (one\sphinxhyphen{} and two\sphinxhyphen{}body terms). In
optimization runs it is often preferable to use a large number of
\sphinxcode{\sphinxupquote{warmupsteps}} (\(\sim 100\)) so that equilibration bias does not
propagate into the optimization process. We can check that the added
warm\sphinxhyphen{}up has had its intended effect by again checking the local energy
trace:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{*}\PYG{n}{scalar}\PYG{o}{*}
\end{sphinxVerbatim}

The resulting plot can be found in \hyperref[\detokenize{analyzing:fig5}]{Fig.\@ \ref{\detokenize{analyzing:fig5}}}. In
this case sufficient \sphinxcode{\sphinxupquote{warmupsteps}} were used to exit the equilibration
period before samples were collected and we can proceed without using
the \sphinxcode{\sphinxupquote{\sphinxhyphen{}e}} option with \sphinxcode{\sphinxupquote{qmca}}.

After inspecting the trace, we should inspect the text output from
\sphinxcode{\sphinxupquote{qmca}}, now including the total energy and its variance:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{ev} \PYG{n}{opt}\PYG{o}{*}\PYG{n}{scalar}\PYG{o}{.}\PYG{n}{dat}
                            \PYG{n}{LocalEnergy}               \PYG{n}{Variance}           \PYG{n}{ratio}
\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{44.823616} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.007430}   \PYG{l+m+mf}{7.054219} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.041998}   \PYG{l+m+mf}{0.1574}
\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{1}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.877643} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.003329}   \PYG{l+m+mf}{1.095362} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.041154}   \PYG{l+m+mf}{0.0239}
\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{2}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.883191} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.004149}   \PYG{l+m+mf}{1.077942} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.021555}   \PYG{l+m+mf}{0.0235}
\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{3}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.877524} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.003094}   \PYG{l+m+mf}{1.074047} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.010491}   \PYG{l+m+mf}{0.0234}
\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{4}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.886062} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.003750}   \PYG{l+m+mf}{1.061707} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.014459}   \PYG{l+m+mf}{0.0231}
\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{5}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.877668} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.003475}   \PYG{l+m+mf}{1.091585} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.021637}   \PYG{l+m+mf}{0.0238}
\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{6}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.877109} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.003586}   \PYG{l+m+mf}{1.069205} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.009387}   \PYG{l+m+mf}{0.0233}
\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{7}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.882563} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.004324}   \PYG{l+m+mf}{1.058771} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.008651}   \PYG{l+m+mf}{0.0231}
\end{sphinxVerbatim}

The flags \sphinxcode{\sphinxupquote{\sphinxhyphen{}q ev}} requested the energy (\sphinxcode{\sphinxupquote{e}}) and the variance
(\sphinxcode{\sphinxupquote{v}}). For this combination of quantities, a third column (\sphinxcode{\sphinxupquote{ratio}})
is printed containing the ratio of the variance and the absolute value
of the local energy. The variance/energy ratio is an intensive quantity
and is useful to inspect regardless of the system under study.
Successful optimization of molecules and solids of any size generally
result in comparable values for the variance/energy ratio.

The first line of the output (\sphinxcode{\sphinxupquote{series 0}}) corresponds to the local
energy and variance of the system without a Jastrow factor (all Jastrow
coefficients were initialized to zero in this case), reflecting the
quality of the orbitals alone. For pseudopotential systems, a
variance/energy ratio \(>0.20\) Ha generally indicates there is a
problem with the input orbitals that needs to be resolved before
performing wavefunction optimization.

The subsequent lines correspond to energies and variances of
intermediate parameterizations of the trial wavefunction during the
optimization process. The output line containing \sphinxcode{\sphinxupquote{opt series 1}}, for
example, corresponds to the trial wavefunction parameterized during the
\sphinxcode{\sphinxupquote{series 0}} step (the parameters of this wavefunction would be found in
an output file matching \sphinxcode{\sphinxupquote{*s000*opt.xml}}). The first thing to check
about the resulting optimization is again the variance/energy ratio. For
pseudopotential systems, a variance/energy ratio \(<0.03\) Ha is
consistent with a trial wavefunction of production quality, and values
of \(0.01\) Ha are rarely obtainable for standard Slater\sphinxhyphen{}Jastrow
wavefunctions. By this metric, all parameterizations obtained for
optimizations performed in series 0\sphinxhyphen{}6 are of comparable quality (note
that the quality of the wavefunction obtained during optimization series
7 is effectively unknown).

A good way to further discriminate among the parameterizations is to
plot the energy and variance as a function of series with \sphinxcode{\sphinxupquote{qmca}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{ev} \PYG{n}{opt}\PYG{o}{*}\PYG{n}{scalar}\PYG{o}{.}\PYG{n}{dat}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{\sphinxhyphen{}p}} option results in plots of means plus error bars
vs. series for all requested quantities.
The resulting plots for the local energy and variance are shown
in \hyperref[\detokenize{analyzing:fig6}]{Fig.\@ \ref{\detokenize{analyzing:fig6}}}.  In this case, the resulting energies
and variances are statistically indistinguishable for all optimization
cycles.

A good way to choose the optimal wavefunction for use in DMC is to
select the one with the lowest statistically significant energy within
the set of optimized wavefunctions with reasonable variance (e.g., among
those with a variance/energy ratio \(<0.03\) Ha). For
pseudopotential calculations, minimizing according to the total energy
is recommended to reduce locality errors in DMC.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{qmca_opt_energy}.png}\hspace*{\fill}}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{qmca_opt_variance}.png}
\caption{Energy and variance vs. optimization series for an 8\sphinxhyphen{}atom cell of
diamond as plotted by \sphinxcode{\sphinxupquote{qmca}}.}\label{\detokenize{analyzing:id3}}\label{\detokenize{analyzing:fig6}}\end{figure}


\subsection{Judging diffusion Monte Carlo runs}
\label{\detokenize{analyzing:judging-diffusion-monte-carlo-runs}}\label{\detokenize{analyzing:qmca-judge-dmc}}
Judging the quality of the DMC projection process requires more
care than is needed in VMC. To reduce bias, a small
time step is required in the approximate projector but this also
leads to slow equilibration and long autocorrelation times.
Systematic errors in the projection process can also arise from
statistical fluctuations due to pseudopotentials or from trial
wavefunctions with larger\sphinxhyphen{}than\sphinxhyphen{}necessary variance.

To illustrate the problems that can arise with respect to slow
equilibration and long autocorrelation times, we consider the 8\sphinxhyphen{}atom
diamond system with VMC (\(200\) blocks of \(160\) steps)
followed by DMC (\(400\) blocks of \(5\) steps) with a small
time step (\(0.002\) Ha\(^{-1}\)). A good first step in
assessing the quality of any DMC run is to plot the trace of the local
energy:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{0} \PYG{o}{*}\PYG{n}{scalar}\PYG{o}{*}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{qmca_short_dmc}.png}
\caption{Trace of the local energy for VMC followed by DMC with a small time step
(\(0.002\) Ha\(^{-1}\)) for an 8\sphinxhyphen{}atom cell of diamond
generated with \sphinxcode{\sphinxupquote{qmca}}.}\label{\detokenize{analyzing:id4}}\label{\detokenize{analyzing:fig7}}\end{figure}

The resulting trace plot is shown in \hyperref[\detokenize{analyzing:fig7}]{Fig.\@ \ref{\detokenize{analyzing:fig7}}}. As
always, the DMC local energy decreases exponentially away from the VMC
value, but in this case it takes a long time to do so. At least half of
the DMC run is inefficiently consumed by equilibration. If we are not
careful to inspect and remove the transient, the estimated DMC energy
will be strongly biased by the transient as shown by the horizontal red
line (estimated mean) in the figure. The autocorrelation time is also
large (\(\sim 12\) blocks):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{200} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{sac} \PYG{o}{*}\PYG{n}{s001}\PYG{o}{.}\PYG{n}{scalar}\PYG{o}{*}
\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{1}  \PYG{n}{LocalEnergy}           \PYG{o}{=}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{46.045720} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.004813}   \PYG{l+m+mf}{11.6}
\end{sphinxVerbatim}

Of the included 200 blocks, fewer than 20 contribute to the estimated error
bar, indicating that we cannot trust the reported error bar.
This can also be demonstrated directly from the data.  If we halve the number
of included samples to 100, we expect from Gaussian statistics
that the error bar will grow by a factor of \(\sqrt{2}\), but instead we
get

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{300} \PYG{o}{*}\PYG{n}{s001}\PYG{o}{.}\PYG{n}{scalar}\PYG{o}{*}
\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{1}  \PYG{n}{LocalEnergy}           \PYG{o}{=}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{46.048537} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.009280}
\end{sphinxVerbatim}

which erroneously shows an estimated increase in the error bar by a
factor of about 2. Overall, this run is simply too short to gain
meaningful information.

Consider the case in which we are interested in the cohesive energy of
diamond, and, after having performed a time step study of the cohesive
energy, we have found that the energy difference between bulk diamond
and atomic carbon converges to our required accuracy with a larger time
step of \(0.01\) Ha\(^{-1}\). In a production setting, a small
cell could be used to determine the appropriate time step, while a
larger cell would subsequently be used to obtain a converged cohesive
energy, though for purposes of demonstration we still proceed here with
the 8\sphinxhyphen{}atom cell. The new time step of \(0.01\) Ha\(^{-1}\)
will result in a shorter autocorrelation time than the smaller time step
used previously, but we would like to shorten the equilibration time
further still. This can be achieved by using a larger time step (say
\(0.02\) Ha\(^{-1}\)) in a short intermediate DMC run used to
walk down the transient. The rapidly achieved equilibrium with the
\(0.02\) Ha\(^{-1}\) time step projector will be much nearer
to the \(0.01\) Ha\(^{-1}\) time step we seek than the
original VMC equilibrium, so we can expect a shortened secondary
equilibration time in the production \(0.01\) Ha\(^{-1}\) time
step run. Note that this procedure is fully general, even if having to
deal with an even shorter time step (e.g., \(0.002\)
Ha\(^{-1}\)) for a particular problem.

We now rerun the previous example but with an intermediate DMC
calculation using \(40\) blocks of \(5\) steps with a time step
of \(0.02\) Ha\(^{-1}\), followed by a production DMC
calculation using \(400\) blocks of \(10\) steps with a time
step of \(0.01\) Ha\(^{-1}\). We again plot the local energy
trace using \sphinxcode{\sphinxupquote{qmca}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{0} \PYG{o}{*}\PYG{n}{scalar}\PYG{o}{*}
\end{sphinxVerbatim}

with the result shown in \hyperref[\detokenize{analyzing:fig8}]{Fig.\@ \ref{\detokenize{analyzing:fig8}}}.
The projection transient has been effectively contained in the
short DMC run with a larger time step.  As expected, the
production run contains only a short equilibration period.
Removing the first 20 blocks as a precaution, we obtain an estimate
of the total energy in VMC and DMC:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{ev} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{20} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{sac} \PYG{n}{qmc}\PYG{o}{.}\PYG{o}{*}\PYG{o}{.}\PYG{n}{scalar}\PYG{o}{.}\PYG{n}{dat}
                            \PYG{n}{LocalEnergy}               \PYG{n}{Variance}           \PYG{n}{ratio}
\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.881042} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.001283}    \PYG{l+m+mf}{1.0}   \PYG{l+m+mf}{1.076726} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.007013}    \PYG{l+m+mf}{1.0}   \PYG{l+m+mf}{0.0235}
\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{1}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{46.040814} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.005046}    \PYG{l+m+mf}{3.9}   \PYG{l+m+mf}{1.011303} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.016807}    \PYG{l+m+mf}{1.1}   \PYG{l+m+mf}{0.0220}
\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{2}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{46.032960} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.002077}    \PYG{l+m+mf}{5.2}   \PYG{l+m+mf}{1.014940} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.002547}    \PYG{l+m+mf}{1.0}   \PYG{l+m+mf}{0.0220}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{qmca_accel_dmc}.png}
\caption{Trace of the local energy for VMC followed by a short intermediate DMC
with a large time step (\(0.02\) Ha\(^{-1}\)) and finally a
production DMC run with a time step of \(0.01\) Ha\(^{-1}\).
Calculations were performed in an 8\sphinxhyphen{}atom cell of diamond.}\label{\detokenize{analyzing:id5}}\label{\detokenize{analyzing:fig8}}\end{figure}

Notice that the variance/energy ratio in DMC (\(0.220\) Ha) is
similar to but slightly smaller than that obtained with VMC
(\(0.235\) Ha). If the DMC variance/energy ratio is ever
significantly larger than with VMC, this is cause to be concerned about
the correctness of the DMC run. Also notice the estimated
autocorrelation time (\(\sim 5\) blocks). This leaves us with an
estimated \(\sim 76\) independent samples, though we should recall
that the autocorrelation time is also a statistical estimate that can be
improved with more data. We can gain a better estimate of the
autocorrelation time by using the \sphinxcode{\sphinxupquote{*.dmc.dat}} files, which contain
output data resolved per step rather than per block (there are
\(10\times\) more steps than blocks in this example case):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{ev} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{200} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{sac} \PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s002}\PYG{o}{.}\PYG{n}{dmc}\PYG{o}{.}\PYG{n}{dat}
                            \PYG{n}{LocalEnergy}               \PYG{n}{Variance}           \PYG{n}{ratio}
\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{2}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{46.032909} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.002068}   \PYG{l+m+mf}{31.2}   \PYG{l+m+mf}{1.015781} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.002536}    \PYG{l+m+mf}{1.4}   \PYG{l+m+mf}{0.0221}
\end{sphinxVerbatim}

This results in an estimated autocorrelation time of \(\sim 31\)
steps, or \(\sim 3\) blocks, indicating that we actually have
\(\sim 122\) independent samples, which should be sufficient to
obtain a trustworthy error bar. Our final DMC total energy is estimated
to be \(-46.0329(2)\) Ha.

Another simulation property that should be explicitly monitored
is the behavior of the DMC walker population.  Data regarding the
walker population is contained in the \sphinxcode{\sphinxupquote{*.dmc.dat}} files.
In \hyperref[\detokenize{analyzing:fig9}]{Fig.\@ \ref{\detokenize{analyzing:fig9}}} we show the trace of the DMC
walker population for the current run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{nw} \PYG{o}{*}\PYG{n}{dmc}\PYG{o}{.}\PYG{n}{dat}
\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{1}  \PYG{n}{NumOfWalkers}          \PYG{o}{=}  \PYG{l+m+mf}{2056.905405} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{8.775527}
\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{2}  \PYG{n}{NumOfWalkers}          \PYG{o}{=}  \PYG{l+m+mf}{2050.164160} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{4.954850}
\end{sphinxVerbatim}

Following a DMC run, the walker population should be checked for two
qualities: (1) that the population is sufficiently large (a number
\(>2,000\) is generally sufficient to reduce population control
bias) and (2) that the population fluctuates benignly around its
intended target value. In this case the target walker count (provided in
the input file) was \(2,048\) and we can confirm from the plot that
the population is simply fluctuating around this value. Also, from the
text output we have a dynamic population estimate of 2,050(5) walkers.
Rapid population reductions or increases—population explosions—are
indicative of problems with a run. These issues sometimes result from
using a considerably poor wavefunction (see comments regarding
variance/energy ratio in the preceding subsections). QMCPACK has
internal guards in place that prevent the population from exceeding
certain maximum and minimum bounds, so in particularly faulty runs one
might see the population “stabilize” to a constant value much larger or
smaller than the target. In such cases the cause(s) for the divergent
population behavior needs to be investigated and resolved before
proceeding further.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{qmca_pop_trace}.png}
\caption{Trace of the DMC walker population for an 8\sphinxhyphen{}atom cell of diamond
obtained with \sphinxcode{\sphinxupquote{qmca}}.}\label{\detokenize{analyzing:id6}}\label{\detokenize{analyzing:fig9}}\end{figure}


\subsection{Obtaining other quantities}
\label{\detokenize{analyzing:obtaining-other-quantities}}\label{\detokenize{analyzing:qmca-other-quantities}}
A number of other scalar\sphinxhyphen{}valued quantities are available with \sphinxcode{\sphinxupquote{qmca}}.
To obtain text output for all quantities available, simply exclude the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}q}} option used in previous examples. The following example shows
output for a DMC calculation of the 8\sphinxhyphen{}atom diamond system from the
\sphinxcode{\sphinxupquote{scalar.dat}} file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{20} \PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s002}\PYG{o}{.}\PYG{n}{scalar}\PYG{o}{.}\PYG{n}{dat}
\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{2}
  \PYG{n}{LocalEnergy}           \PYG{o}{=}          \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{46.0330} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}           \PYG{l+m+mf}{0.0021}
  \PYG{n}{Variance}              \PYG{o}{=}            \PYG{l+m+mf}{1.0149} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}           \PYG{l+m+mf}{0.0025}
  \PYG{n}{Kinetic}               \PYG{o}{=}            \PYG{l+m+mf}{33.851} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}            \PYG{l+m+mf}{0.019}
  \PYG{n}{LocalPotential}        \PYG{o}{=}           \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{79.884} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}            \PYG{l+m+mf}{0.020}
  \PYG{n}{ElecElec}              \PYG{o}{=}          \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{11.4483} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}           \PYG{l+m+mf}{0.0083}
  \PYG{n}{LocalECP}              \PYG{o}{=}           \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{22.615} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}            \PYG{l+m+mf}{0.029}
  \PYG{n}{NonLocalECP}           \PYG{o}{=}            \PYG{l+m+mf}{5.2815} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}           \PYG{l+m+mf}{0.0079}
  \PYG{n}{IonIon}                \PYG{o}{=}            \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{51.10} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}             \PYG{l+m+mf}{0.00}
  \PYG{n}{LocalEnergy\PYGZus{}sq}        \PYG{o}{=}           \PYG{l+m+mf}{2120.05} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}             \PYG{l+m+mf}{0.19}
  \PYG{n}{BlockWeight}           \PYG{o}{=}          \PYG{l+m+mf}{20514.27} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}            \PYG{l+m+mf}{48.38}
  \PYG{n}{BlockCPU}              \PYG{o}{=}            \PYG{l+m+mf}{1.4890} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}           \PYG{l+m+mf}{0.0038}
  \PYG{n}{AcceptRatio}           \PYG{o}{=}         \PYG{l+m+mf}{0.9963954} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}        \PYG{l+m+mf}{0.0000055}
  \PYG{n}{Efficiency}            \PYG{o}{=}             \PYG{l+m+mf}{71.88} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}             \PYG{l+m+mf}{0.00}
  \PYG{n}{TotalTime}             \PYG{o}{=}            \PYG{l+m+mf}{565.80} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}             \PYG{l+m+mf}{0.00}
  \PYG{n}{TotalSamples}          \PYG{o}{=}           \PYG{l+m+mi}{7795421} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}                \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

Similarly, for the \sphinxcode{\sphinxupquote{dmc.dat}} file we get

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{20} \PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s002}\PYG{o}{.}\PYG{n}{dmc}\PYG{o}{.}\PYG{n}{dat}
\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{2}
  \PYG{n}{LocalEnergy}           \PYG{o}{=}          \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{46.0329} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}           \PYG{l+m+mf}{0.0020}
  \PYG{n}{Variance}              \PYG{o}{=}            \PYG{l+m+mf}{1.0162} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}           \PYG{l+m+mf}{0.0025}
  \PYG{n}{TotalSamples}          \PYG{o}{=}           \PYG{l+m+mi}{8201275} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}                \PYG{l+m+mi}{0}
  \PYG{n}{TrialEnergy}           \PYG{o}{=}          \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{46.0343} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}           \PYG{l+m+mf}{0.0023}
  \PYG{n}{DiffEff}               \PYG{o}{=}         \PYG{l+m+mf}{0.9939150} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}        \PYG{l+m+mf}{0.0000088}
  \PYG{n}{Weight}                \PYG{o}{=}           \PYG{l+m+mf}{2050.23} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}             \PYG{l+m+mf}{4.82}
  \PYG{n}{NumOfWalkers}          \PYG{o}{=}              \PYG{l+m+mi}{2050} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}                \PYG{l+m+mi}{5}
  \PYG{n}{LivingFraction}        \PYG{o}{=}          \PYG{l+m+mf}{0.996427} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}         \PYG{l+m+mf}{0.000021}
  \PYG{n}{AvgSentWalkers}        \PYG{o}{=}            \PYG{l+m+mf}{0.2625} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}           \PYG{l+m+mf}{0.0011}
\end{sphinxVerbatim}

Any subset of desired quantities can be obtained by using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}q}}
option with either the full names of the quantities just listed

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LocalEnergy Kinetic LocalPotential}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{20} \PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s002}\PYG{o}{.}\PYG{n}{scalar}\PYG{o}{.}\PYG{n}{dat}
\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{2}
  \PYG{n}{LocalEnergy}           \PYG{o}{=}          \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{46.0330} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}           \PYG{l+m+mf}{0.0021}
  \PYG{n}{Kinetic}               \PYG{o}{=}            \PYG{l+m+mf}{33.851} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}            \PYG{l+m+mf}{0.019}
  \PYG{n}{LocalPotential}        \PYG{o}{=}           \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{79.884} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}            \PYG{l+m+mf}{0.020}
\end{sphinxVerbatim}

or with their corresponding abbreviations.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{ekp} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{20} \PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s002}\PYG{o}{.}\PYG{n}{scalar}\PYG{o}{.}\PYG{n}{dat}
\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{2}
  \PYG{n}{LocalEnergy}           \PYG{o}{=}          \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{46.0330} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}           \PYG{l+m+mf}{0.0021}
  \PYG{n}{Kinetic}               \PYG{o}{=}            \PYG{l+m+mf}{33.851} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}            \PYG{l+m+mf}{0.019}
  \PYG{n}{LocalPotential}        \PYG{o}{=}           \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{79.884} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}            \PYG{l+m+mf}{0.020}
\end{sphinxVerbatim}

Abbreviations for each quantity can be found by typing \sphinxcode{\sphinxupquote{qmca}} at the
command line with no other input. This following is a current list:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Abbreviations} \PYG{o+ow}{and} \PYG{n}{full} \PYG{n}{names} \PYG{k}{for} \PYG{n}{quantities}\PYG{p}{:}
    \PYG{n}{ar}              \PYG{o}{=} \PYG{n}{AcceptRatio}
    \PYG{n}{bc}              \PYG{o}{=} \PYG{n}{BlockCPU}
    \PYG{n}{bw}              \PYG{o}{=} \PYG{n}{BlockWeight}
    \PYG{n}{ce}              \PYG{o}{=} \PYG{n}{CorrectedEnergy}
    \PYG{n}{de}              \PYG{o}{=} \PYG{n}{DiffEff}
    \PYG{n}{e}               \PYG{o}{=} \PYG{n}{LocalEnergy}
    \PYG{n}{ee}              \PYG{o}{=} \PYG{n}{ElecElec}
    \PYG{n}{eff}             \PYG{o}{=} \PYG{n}{Efficiency}
    \PYG{n}{ii}              \PYG{o}{=} \PYG{n}{IonIon}
    \PYG{n}{k}               \PYG{o}{=} \PYG{n}{Kinetic}
    \PYG{n}{kc}              \PYG{o}{=} \PYG{n}{KEcorr}
    \PYG{n}{l}               \PYG{o}{=} \PYG{n}{LocalECP}
    \PYG{n}{le2}             \PYG{o}{=} \PYG{n}{LocalEnergy\PYGZus{}sq}
    \PYG{n}{mpc}             \PYG{o}{=} \PYG{n}{MPC}
    \PYG{n}{n}               \PYG{o}{=} \PYG{n}{NonLocalECP}
    \PYG{n}{nw}              \PYG{o}{=} \PYG{n}{NumOfWalkers}
    \PYG{n}{p}               \PYG{o}{=} \PYG{n}{LocalPotential}
    \PYG{n}{sw}              \PYG{o}{=} \PYG{n}{AvgSentWalkers}
    \PYG{n}{te}              \PYG{o}{=} \PYG{n}{TrialEnergy}
    \PYG{n}{ts}              \PYG{o}{=} \PYG{n}{TotalSamples}
    \PYG{n}{tt}              \PYG{o}{=} \PYG{n}{TotalTime}
    \PYG{n}{v}               \PYG{o}{=} \PYG{n}{Variance}
    \PYG{n}{w}               \PYG{o}{=} \PYG{n}{Weight}
\end{sphinxVerbatim}

See the output overview for \sphinxcode{\sphinxupquote{scalar.dat}}
({\hyperref[\detokenize{output_overview:scalardat-file}]{\sphinxcrossref{\DUrole{std,std-ref}{The .scalar.dat file}}}}) and \sphinxcode{\sphinxupquote{dmc.dat}}
({\hyperref[\detokenize{output_overview:dmc-file}]{\sphinxcrossref{\DUrole{std,std-ref}{The .dmc.dat file}}}}) for more information about
these quantities.  The data analysis aspects for these
quantities are essentially the same as for the local
energy as covered in the preceding subsections.
Quantities that do not belong to an equilibrium distribution
(e.g., \sphinxcode{\sphinxupquote{BlockCPU}}) are somewhat different, though they
still exhibit statistical fluctuations.


\subsection{Processing multiple files}
\label{\detokenize{analyzing:processing-multiple-files}}\label{\detokenize{analyzing:qmca-multiple-files}}
Batch file processing is a common use case for \sphinxcode{\sphinxupquote{qmca}}. If we consider
an “equation\sphinxhyphen{}of\sphinxhyphen{}state” calculation involving the 8\sphinxhyphen{}atom diamond cell we
have used so far, we might be interested in the total energy for the
various supercell volumes along the trajectory from compression to
expansion. After checking the traces
(\sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}t \sphinxhyphen{}q e scale\_*/vmc/*scalar*}}) to settle on a sensible
equilibration cutoff as discussed in the preceding subsections, we can
obtain the total energies all at once:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{ev} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{40} \PYG{n}{scale\PYGZus{}}\PYG{o}{*}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{o}{*}\PYG{n}{scalar}\PYG{o}{*}
                            \PYG{n}{LocalEnergy}               \PYG{n}{Variance}           \PYG{n}{ratio}
\PYG{n}{scale\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{80}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{44.670984} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.006051}  \PYG{l+m+mf}{2.542384} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.019902}  \PYG{l+m+mf}{0.0569}
\PYG{n}{scale\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{82}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{44.982818} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.005757}  \PYG{l+m+mf}{2.413011} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.022626}  \PYG{l+m+mf}{0.0536}
\PYG{n}{scale\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{84}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.228257} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.005374}  \PYG{l+m+mf}{2.258577} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.019322}  \PYG{l+m+mf}{0.0499}
\PYG{n}{scale\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{86}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.415842} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.005532}  \PYG{l+m+mf}{2.204980} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.052978}  \PYG{l+m+mf}{0.0486}
\PYG{n}{scale\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{88}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.570215} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.004651}  \PYG{l+m+mf}{2.061374} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.014359}  \PYG{l+m+mf}{0.0452}
\PYG{n}{scale\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{90}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.683684} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.005009}  \PYG{l+m+mf}{1.988539} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.018267}  \PYG{l+m+mf}{0.0435}
\PYG{n}{scale\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{92}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.751359} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.004928}  \PYG{l+m+mf}{1.913282} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.013998}  \PYG{l+m+mf}{0.0418}
\PYG{n}{scale\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{94}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.791622} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.005026}  \PYG{l+m+mf}{1.843704} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.014460}  \PYG{l+m+mf}{0.0403}
\PYG{n}{scale\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{96}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.809256} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.005053}  \PYG{l+m+mf}{1.829103} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.014536}  \PYG{l+m+mf}{0.0399}
\PYG{n}{scale\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{98}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.806235} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.004963}  \PYG{l+m+mf}{1.775391} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.015199}  \PYG{l+m+mf}{0.0388}
\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{00}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.783481} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.005293}  \PYG{l+m+mf}{1.726869} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.012001}  \PYG{l+m+mf}{0.0377}
\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{02}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.741655} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.005627}  \PYG{l+m+mf}{1.681776} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.011496}  \PYG{l+m+mf}{0.0368}
\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{04}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.685101} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.005353}  \PYG{l+m+mf}{1.682608} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.015423}  \PYG{l+m+mf}{0.0368}
\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{06}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.615164} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.005978}  \PYG{l+m+mf}{1.652155} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.010945}  \PYG{l+m+mf}{0.0362}
\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{08}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.543037} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.005191}  \PYG{l+m+mf}{1.646375} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.013446}  \PYG{l+m+mf}{0.0361}
\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{10}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.450976} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.004794}  \PYG{l+m+mf}{1.707649} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.048186}  \PYG{l+m+mf}{0.0376}
\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{12}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.371851} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.005103}  \PYG{l+m+mf}{1.686997} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.035920}  \PYG{l+m+mf}{0.0372}
\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{14}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.265490} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.005311}  \PYG{l+m+mf}{1.631614} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.012381}  \PYG{l+m+mf}{0.0360}
\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{16}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.161961} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.004868}  \PYG{l+m+mf}{1.656586} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.014788}  \PYG{l+m+mf}{0.0367}
\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{18}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.062579} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.005971}  \PYG{l+m+mf}{1.671998} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.019942}  \PYG{l+m+mf}{0.0371}
\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{20}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{44.960477} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.004888}  \PYG{l+m+mf}{1.651864} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.009756}  \PYG{l+m+mf}{0.0367}
\end{sphinxVerbatim}

In this case, we are using a Jastrow factor optimized only at the
equilibrium geometry (\sphinxcode{\sphinxupquote{scale\_1.00}}) but with radial cutoffs restricted
to the Wigner\sphinxhyphen{}Seitz radius of the most compressed supercell
(\sphinxcode{\sphinxupquote{scale\_0.80}}) to avoid introducing wavefunction cusps at the cell
boundary (had we tried, QMCPACK would have aborted with a warning in
this case). It is clear that this restricted Jastrow factor is not an
optimal choice because it yields variance/energy ratios between
\(0.036\) and \(0.057\) Ha. This issue is largely a result of
our undersized (8\sphinxhyphen{}atom) supercell; larger cells should always be used in
real production calculations.

Batch processing is also possible for multiple quantities.  If multiple
quantities are requested, an additional line is inserted to separate
results from different runs:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{e bc eff}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{40} \PYG{n}{scale\PYGZus{}}\PYG{o}{*}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{o}{*}\PYG{n}{scalar}\PYG{o}{*}
\PYG{n}{scale\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{80}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0}
  \PYG{n}{LocalEnergy}           \PYG{o}{=}          \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{44.6710} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}           \PYG{l+m+mf}{0.0061}
  \PYG{n}{BlockCPU}              \PYG{o}{=}           \PYG{l+m+mf}{0.02986} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}          \PYG{l+m+mf}{0.00038}
  \PYG{n}{Efficiency}            \PYG{o}{=}          \PYG{l+m+mf}{38104.00} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}             \PYG{l+m+mf}{0.00}

\PYG{n}{scale\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{82}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0}
  \PYG{n}{LocalEnergy}           \PYG{o}{=}          \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{44.9828} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}           \PYG{l+m+mf}{0.0058}
  \PYG{n}{BlockCPU}              \PYG{o}{=}           \PYG{l+m+mf}{0.02826} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}          \PYG{l+m+mf}{0.00013}
  \PYG{n}{Efficiency}            \PYG{o}{=}          \PYG{l+m+mf}{44483.91} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}             \PYG{l+m+mf}{0.00}

\PYG{n}{scale\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{84}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0}
  \PYG{n}{LocalEnergy}           \PYG{o}{=}          \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.2283} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}           \PYG{l+m+mf}{0.0054}
  \PYG{n}{BlockCPU}              \PYG{o}{=}           \PYG{l+m+mf}{0.02747} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}          \PYG{l+m+mf}{0.00030}
  \PYG{n}{Efficiency}            \PYG{o}{=}          \PYG{l+m+mf}{52525.12} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}             \PYG{l+m+mf}{0.00}

\PYG{n}{scale\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{86}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0}
  \PYG{n}{LocalEnergy}           \PYG{o}{=}          \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.4158} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}           \PYG{l+m+mf}{0.0055}
  \PYG{n}{BlockCPU}              \PYG{o}{=}           \PYG{l+m+mf}{0.02679} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}          \PYG{l+m+mf}{0.00013}
  \PYG{n}{Efficiency}            \PYG{o}{=}          \PYG{l+m+mf}{50811.55} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}             \PYG{l+m+mf}{0.00}

\PYG{n}{scale\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{88}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0}
  \PYG{n}{LocalEnergy}           \PYG{o}{=}          \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.5702} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}           \PYG{l+m+mf}{0.0047}
  \PYG{n}{BlockCPU}              \PYG{o}{=}           \PYG{l+m+mf}{0.02598} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}          \PYG{l+m+mf}{0.00015}
  \PYG{n}{Efficiency}            \PYG{o}{=}          \PYG{l+m+mf}{74148.79} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}             \PYG{l+m+mf}{0.00}

\PYG{n}{scale\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{90}\PYG{o}{/}\PYG{n}{vmc}\PYG{o}{/}\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{0}
  \PYG{n}{LocalEnergy}           \PYG{o}{=}          \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.6837} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}           \PYG{l+m+mf}{0.0050}
  \PYG{n}{BlockCPU}              \PYG{o}{=}           \PYG{l+m+mf}{0.02527} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}          \PYG{l+m+mf}{0.00011}
  \PYG{n}{Efficiency}            \PYG{o}{=}          \PYG{l+m+mf}{65714.98} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}             \PYG{l+m+mf}{0.00}

\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}


\subsection{Twist averaging}
\label{\detokenize{analyzing:twist-averaging}}\label{\detokenize{analyzing:qmca-twist-average}}
Twist averaging can be performed straightforwardly for any output
quantity listed in {\hyperref[\detokenize{analyzing:qmca-other-quantities}]{\sphinxcrossref{\DUrole{std,std-ref}{Obtaining other quantities}}}} with \sphinxcode{\sphinxupquote{qmca}}.
We illustrate these capabilities by repeating the 8\sphinxhyphen{}atom diamond DMC
runs performed in Section {\hyperref[\detokenize{analyzing:qmca-judge-dmc}]{\sphinxcrossref{\DUrole{std,std-ref}{Judging diffusion Monte Carlo runs}}}} at 8 real\sphinxhyphen{}valued
supercell twist angles (a \(2\times 2\times 2\) Monkhorst\sphinxhyphen{}Pack grid
centered at the \(\Gamma\)\sphinxhyphen{}point). Data traces for each twist can be
overlapped on the same plot:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{to} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{30 20 30}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{*}\PYG{n}{scalar}\PYG{o}{*} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{legend} \PYG{n}{outside}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{\sphinxhyphen{}o}} option requests the plots to be overlapped; otherwise,
8 separate plots would be generated.  The
equilibration input \sphinxcode{\sphinxupquote{\sphinxhyphen{}e \textquotesingle{}30 20 30\textquotesingle{}}} cuts out from
the analyzed data the first 30 blocks for series 0 (VMC),
20 blocks for series 1 (intermediate DMC), and 30 blocks for
series 2 (production DMC).  The resulting plot is shown in
\hyperref[\detokenize{analyzing:fig10}]{Fig.\@ \ref{\detokenize{analyzing:fig10}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{qmca_twist_trace_overlap}.png}
\caption{Overlapped energy traces from VMC to DMC for an 8\sphinxhyphen{}supercell diamond
obtained with \sphinxcode{\sphinxupquote{qmca}}. Data for each twist appears in a different
color.}\label{\detokenize{analyzing:id7}}\label{\detokenize{analyzing:fig10}}\end{figure}

Twist averaging is performed by providing the \sphinxcode{\sphinxupquote{\sphinxhyphen{}a}}
option.  If provided on its own, uniform weights are applied
to each twist angle.  To obtain a trace plot with twist averaging
enforced, use a command similar to the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{30 20 30}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{*}\PYG{n}{scalar}\PYG{o}{*}
\end{sphinxVerbatim}

The resulting plot is shown in \hyperref[\detokenize{analyzing:fig11}]{Fig.\@ \ref{\detokenize{analyzing:fig11}}}. As
can be seen from the trace plot, the chosen equilibration lengths are
appropriate, and we proceed to obtain the twist\sphinxhyphen{}averaged total energy
from the \sphinxcode{\sphinxupquote{scalar.dat}} files

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{ev} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{30} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{sac} \PYG{o}{*}\PYG{n}{s002}\PYG{o}{.}\PYG{n}{scalar}\PYG{o}{*}
                            \PYG{n}{LocalEnergy}               \PYG{n}{Variance}           \PYG{n}{ratio}
\PYG{n}{avg}  \PYG{n}{series} \PYG{l+m+mi}{2}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.873369} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000753}    \PYG{l+m+mf}{5.3}   \PYG{l+m+mf}{1.028751} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.001056}    \PYG{l+m+mf}{1.3}   \PYG{l+m+mf}{0.0224}
\end{sphinxVerbatim}

and also from the \sphinxcode{\sphinxupquote{dmc.dat}} files

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{ev} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{300} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{sac} \PYG{o}{*}\PYG{n}{s002}\PYG{o}{.}\PYG{n}{dmc}\PYG{o}{*}
                          \PYG{n}{LocalEnergy}               \PYG{n}{Variance}           \PYG{n}{ratio}
\PYG{n}{avg}  \PYG{n}{series} \PYG{l+m+mi}{2}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.873371} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000741}   \PYG{l+m+mf}{30.5}   \PYG{l+m+mf}{1.028843} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000972}    \PYG{l+m+mf}{1.6}   \PYG{l+m+mf}{0.0224}
\end{sphinxVerbatim}

yielding a twist\sphinxhyphen{}averaged total energy of \(-45.8733(8)\) Ha.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{qmca_twist_average_trace}.png}
\caption{Twist\sphinxhyphen{}averaged energy trace from VMC to DMC for an 8\sphinxhyphen{}supercell diamond obtained with \sphinxcode{\sphinxupquote{qmca}}.}\label{\detokenize{analyzing:id8}}\label{\detokenize{analyzing:fig11}}\end{figure}

As can be seen from \hyperref[\detokenize{analyzing:fig10}]{Fig.\@ \ref{\detokenize{analyzing:fig10}}}, some of the twist
angles are degenerate. This is seen more clearly in the text output

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{ev} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{30} \PYG{o}{*}\PYG{n}{s002}\PYG{o}{.}\PYG{n}{scalar}\PYG{o}{*}
                            \PYG{n}{LocalEnergy}               \PYG{n}{Variance}           \PYG{n}{ratio}
\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{g000}  \PYG{n}{series} \PYG{l+m+mi}{2}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.264510} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.001942}   \PYG{l+m+mf}{1.057065} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.002318}   \PYG{l+m+mf}{0.0234}
\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{g001}  \PYG{n}{series} \PYG{l+m+mi}{2}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{46.035511} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.001806}   \PYG{l+m+mf}{1.015992} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.002836}   \PYG{l+m+mf}{0.0221}
\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{g002}  \PYG{n}{series} \PYG{l+m+mi}{2}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{46.035410} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.001538}   \PYG{l+m+mf}{1.015039} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.002661}   \PYG{l+m+mf}{0.0220}
\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{g003}  \PYG{n}{series} \PYG{l+m+mi}{2}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{46.047285} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.001898}   \PYG{l+m+mf}{1.018219} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.002588}   \PYG{l+m+mf}{0.0221}
\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{g004}  \PYG{n}{series} \PYG{l+m+mi}{2}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{46.034225} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.002539}   \PYG{l+m+mf}{1.013420} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.002835}   \PYG{l+m+mf}{0.0220}
\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{g005}  \PYG{n}{series} \PYG{l+m+mi}{2}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{46.046731} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.002963}   \PYG{l+m+mf}{1.018337} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.004109}   \PYG{l+m+mf}{0.0221}
\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{g006}  \PYG{n}{series} \PYG{l+m+mi}{2}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{46.047133} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.001958}   \PYG{l+m+mf}{1.021483} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.003082}   \PYG{l+m+mf}{0.0222}
\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{g007}  \PYG{n}{series} \PYG{l+m+mi}{2}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.476146} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.002065}   \PYG{l+m+mf}{1.070456} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.003133}   \PYG{l+m+mf}{0.0235}
\end{sphinxVerbatim}

The degenerate twists grouped by set are \(\{0\}\),
\(\{1,2,4\}\), \(\{3,5,6\}\), and \(\{7\}\).

Alternatively, the run could have been performed at the four
unique (irreducible) twist angles \sphinxstyleemphasis{only}.  We will emulate this situation by
analyzing data for twists 0, 1, 3, and 7 only.  In a production setting
with irreducibly weighted twists, the run would be performed on these twists
alone; we reuse the uniform twist data for illustration purposes only.

We can use \sphinxcode{\sphinxupquote{qmca}} to perform twist averaging with different
weights applied to each twist:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{o}{\PYGZhy{}}\PYG{n}{w} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1 3 3 1}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{ev} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{30} \PYG{o}{*}\PYG{n}{g000}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{sc}\PYG{o}{*} \PYG{o}{*}\PYG{n}{g001}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{sc}\PYG{o}{*} \PYG{o}{*}\PYG{n}{g003}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{sc}\PYG{o}{*} \PYG{o}{*}\PYG{n}{g007}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{sc}\PYG{o}{*}
                            \PYG{n}{LocalEnergy}               \PYG{n}{Variance}           \PYG{n}{ratio}
\PYG{n}{avg}  \PYG{n}{series} \PYG{l+m+mi}{2}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{45.873631} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.001044}   \PYG{l+m+mf}{1.028769} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.001520}   \PYG{l+m+mf}{0.0224}
\end{sphinxVerbatim}

yielding a total energy value of \(-45.874(1)\) Ha, in agreement with the
uniform weighted twist average performed previously.

The decision of whether or not to perform irreducible weighted twist
averaging should be made on the basis of efficiency.  The relative
efficiency of irreducible vs. uniform weighted twist averaging
depends on the irreducible weights and the ratio of the lengths of
the available sampling and equilibration periods.  A formula for
the relative efficiency of these two cases is derived and discussed
in more detail in {\hyperref[\detokenize{appendices:appendix-a}]{\sphinxcrossref{\DUrole{std,std-ref}{Appendix A: Derivation of twist averaging efficiency}}}}.


\subsection{Setting output units}
\label{\detokenize{analyzing:setting-output-units}}\label{\detokenize{analyzing:qmca-output-units}}
Estimates outputted by \sphinxcode{\sphinxupquote{qmca}} are in Hartree units by default. The
output units for energetic quantities can be changed by using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}u}}
option.

Energy in Hartrees:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{\PYGZhy{}}\PYG{n}{u} \PYG{n}{Ha} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{20} \PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s002}\PYG{o}{.}\PYG{n}{scalar}\PYG{o}{.}\PYG{n}{dat}
\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{2}  \PYG{n}{LocalEnergy}           \PYG{o}{=}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{46.032960} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.002077}
\end{sphinxVerbatim}

Energy in electron volts:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{\PYGZhy{}}\PYG{n}{u} \PYG{n}{eV} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{20} \PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s002}\PYG{o}{.}\PYG{n}{scalar}\PYG{o}{.}\PYG{n}{dat}
\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{2}  \PYG{n}{LocalEnergy}           \PYG{o}{=}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1252.620565} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.056521}
\end{sphinxVerbatim}

Energy in Rydbergs:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{\PYGZhy{}}\PYG{n}{u} \PYG{n}{rydberg} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{20} \PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s002}\PYG{o}{.}\PYG{n}{scalar}\PYG{o}{.}\PYG{n}{dat}
\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{2}  \PYG{n}{LocalEnergy}           \PYG{o}{=}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{92.065919} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.004154}
\end{sphinxVerbatim}

Energy in kilojoules per mole:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{\PYGZhy{}}\PYG{n}{u} \PYG{n}{kj\PYGZus{}mol} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{20} \PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s002}\PYG{o}{.}\PYG{n}{scalar}\PYG{o}{.}\PYG{n}{dat}
\PYG{n}{qmc}  \PYG{n}{series} \PYG{l+m+mi}{2}  \PYG{n}{LocalEnergy}           \PYG{o}{=}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{120859.512998} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{5.453431}
\end{sphinxVerbatim}


\subsection{Speeding up trace plotting}
\label{\detokenize{analyzing:speeding-up-trace-plotting}}\label{\detokenize{analyzing:qmca-fast-trace-plot}}
When working with many files or files with many entries, \sphinxcode{\sphinxupquote{qmca}} might
take a long time to produce plots. The time delay is actually due to the
autocorrelation time estimate used to calculate error bars. The
calculation time for the autocorrelation scales as
\(\mathcal{O}(M^2)\), with \(M\) being the number of statistical
samples. If you are interested only in plotting traces and not in the
estimated error bars, the autocorrelation time estimation can be turned
off with the \sphinxcode{\sphinxupquote{\textendash{}noac}} option:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{20} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{noac} \PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s002}\PYG{o}{.}\PYG{n}{scalar}\PYG{o}{.}\PYG{n}{dat}
\end{sphinxVerbatim}

Note that the resulting error bars printed to the console will be
underestimated and are not meaningful. Do \sphinxstyleemphasis{not} use \sphinxcode{\sphinxupquote{\textendash{}noac}} in
conjunction with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}p}} plotting option as these plots are of no use
without meaningful error bars.


\subsection{Short usage examples}
\label{\detokenize{analyzing:short-usage-examples}}\label{\detokenize{analyzing:qmca-short-example}}
Plotting a trace of the local energy:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{*}\PYG{n}{scalar}\PYG{o}{*}
\end{sphinxVerbatim}

Applying an equilibration cutoff to VMC data (series 0):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{30} \PYG{o}{*}\PYG{n}{s000}\PYG{o}{.}\PYG{n}{scalar}\PYG{o}{*}
\end{sphinxVerbatim}

Applying the same equilibration cutoff to VMC and DMC data (series 0, 1, 2):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{20} \PYG{o}{*}\PYG{n}{scalar}\PYG{o}{*}
\end{sphinxVerbatim}

Applying different equilibration cutoffs to VMC and DMC data (series 0, 1, 2):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{30 20 40}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{*}\PYG{n}{scalar}\PYG{o}{*}
\end{sphinxVerbatim}

Obtaining the energy, variance, and variance/energy ratio for all series:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{ev} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{30} \PYG{o}{*}\PYG{n}{scalar}\PYG{o}{*}
\end{sphinxVerbatim}

Overlaying plots of mean + error bar for energy and variance for separate
two\sphinxhyphen{} and three\sphinxhyphen{}body Jastrow optimization runs:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{po} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{ev} \PYG{o}{.}\PYG{o}{/}\PYG{n}{optJ2}\PYG{o}{/}\PYG{o}{*}\PYG{n}{scalar}\PYG{o}{*} \PYG{o}{.}\PYG{o}{/}\PYG{n}{optJ3}\PYG{o}{/}\PYG{o}{*}\PYG{n}{scalar}\PYG{o}{*}
\end{sphinxVerbatim}

Obtaining the acceptance ratio:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{ar} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{30} \PYG{o}{*}\PYG{n}{scalar}\PYG{o}{*}
\end{sphinxVerbatim}

Obtaining the average DMC walker population:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{nw} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{400} \PYG{o}{*}\PYG{n}{s002}\PYG{o}{.}\PYG{n}{dmc}\PYG{o}{.}\PYG{n}{dat}
\end{sphinxVerbatim}

Obtaining the MC efficiency:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{eff} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{30} \PYG{o}{*}\PYG{n}{scalar}\PYG{o}{*}
\end{sphinxVerbatim}

Obtaining the total wall clock time per series:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{tt} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{0} \PYG{o}{*}\PYG{n}{scalar}\PYG{o}{*}
\end{sphinxVerbatim}

Obtaining the average wall clock time spent per block:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{bc} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{0} \PYG{o}{*}\PYG{n}{scalar}\PYG{o}{*}
\end{sphinxVerbatim}

Obtaining a subset of desired quantities:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{e v ar eff}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{30} \PYG{o}{*}\PYG{n}{scalar}\PYG{o}{*}
\end{sphinxVerbatim}

Obtaining all available quantities:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{30} \PYG{o}{*}\PYG{n}{scalar}\PYG{o}{*}
\end{sphinxVerbatim}

Obtaining the twist\sphinxhyphen{}averaged total energy with uniform weights:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{40} \PYG{o}{*}\PYG{n}{g}\PYG{o}{*}\PYG{n}{s002}\PYG{o}{.}\PYG{n}{scalar}\PYG{o}{.}\PYG{n}{dat}
\end{sphinxVerbatim}

Obtaining the twist\sphinxhyphen{}averaged total energy with specific weights:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{o}{\PYGZhy{}}\PYG{n}{w} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1 3 3 1}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{40} \PYG{o}{*}\PYG{n}{g}\PYG{o}{*}\PYG{n}{s002}\PYG{o}{.}\PYG{n}{scalar}\PYG{o}{.}\PYG{n}{dat}
\end{sphinxVerbatim}

Obtaining the local, kinetic, and potential energies in eV:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{ekp} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{30} \PYG{o}{\PYGZhy{}}\PYG{n}{u} \PYG{n}{eV} \PYG{o}{*}\PYG{n}{scalar}\PYG{o}{*}
\end{sphinxVerbatim}


\subsection{Production quality checklist}
\label{\detokenize{analyzing:production-quality-checklist}}\label{\detokenize{analyzing:qmca-production-checklist}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Inspect the trace plots (\sphinxcode{\sphinxupquote{\sphinxhyphen{}t}} option) for any oddities in the data.
Typical behavior is a short equilibration period followed by benign
fluctuations around a clear mean value. There should not be any large
spikes in the data. This applies to \sphinxstyleemphasis{all} runs (VMC, optimization,
DMC, etc.).

\item {} 
Remove all equilibration steps (\sphinxcode{\sphinxupquote{\sphinxhyphen{}e}} option) from the data by
inspecting the trace plot.

\item {} 
Check the quality of the orbitals (standalone Jastrow\sphinxhyphen{}less VMC or
sometimes the first \sphinxcode{\sphinxupquote{scalar}} file produced during optimization) by
inspecting the variance/energy ratio \sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}q ev *scalar*}}. For
pseudopotential systems without a Jastrow, the variance/energy ratio
should not exceed \(0.2\) Ha; otherwise, there is a problem with
the orbitals.

\item {} 
Check the quality of the optimized Jastrow factor by inspecting the
variance/energy ratio. For pseudopotential systems with a Jastrow,
the variance/energy ratio should not exceed \(0.04\) Ha for
pseudopotential systems. A good Jastrow is indicated by a
variance/energy ratio in the range of \(0.01-0.03\) Ha. A value
less than \(0.01\) Ha is difficult to achieve.

\item {} 
Confirm that the optimization has converged by plotting the energy
and variance vs. optimization series (\sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}p \sphinxhyphen{}q ev *scalar*}}). Do
not assume that optimization has converged in only a few cycles. Use
at least 10 cycles with about 100,000 samples unless you already have
experience with the system in question.

\item {} 
Optimize Jastrow factors according to energy minimization to reduce
locality errors arising from the use of nonlocal pseudopotentials in
DMC. A good approach is to optimize with a few cycles of variance
minimization followed by several cycles of energy minimization.

\item {} 
Occasionally try optimizing with more samples and/or cycles to see if
improved results are obtained.

\item {} 
If using a B\sphinxhyphen{}spline representation of the orbitals, converge the VMC
energy and variance with respect to the mesh size (controlled via
meshfactor). This is best done in the presence of any Jastrow factor
to reduce noise. Consider using the hybrid LMTO representation of the
orbitals as this can reduce both the VMC/DMC variance and the DMC
time step error, in addition to saving memory.

\item {} 
Check the variance/energy ratio of all production VMC and DMC
calculations. In all cases, the DMC ratio should be slightly less
than the VMC ratio and both should abide the preceding guidelines,
i.e., the ratio should be less than \(0.04\) Ha for
pseudopotential systems. The production ratio should also be
consistent with what is observed during wavefunction optimization.

\item {} 
Be aware of population control bias in DMC. Run with a population of
\(\sim 2,000\) or greater. Occasionally repeat a run using a
larger population to explicitly confirm that population control bias
is small.

\item {} 
Check the stability of the DMC walker population by plotting the
trace of the population size (\sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}t \sphinxhyphen{}q nw *dmc.dat}}). Verify
that the average walker population is consistent with the requested
value provided in the input.

\item {} 
In DMC, perform a time step study to obtain either (1) extrapolated
results or (2) a time step for future production where an energy
difference shows convergence (e.g., a band gap or defect formation
energy). For pseudopotential systems, converged time steps for many
systems are in the range of \(0.002-0.01\) Ha\(^{-1}\), but
the actual converged time step must be explicitly checked.

\item {} 
In periodic systems, converge the total energy with respect to the
size of the twist/k\sphinxhyphen{}point grid. Results for smaller systems can
easily be transferred to larger ones (e.g., a
\(2 \times 2 \times 2\) twist grid in a
\(2 \times 2 \times 2\) tiled cell is equivalent to a
\(1 \times 1 \times 1\) twist grid in a
\(4 \times 4 \times 4\) tiled cell).

\item {} 
In periodic systems, perform finite\sphinxhyphen{}size extrapolation including two
body corrections (needed for cohesive energy/phase stability studies)
unless it can be shown that finite\sphinxhyphen{}size effects cancel for the energy
difference in question (e.g., some defect formation energies).

\end{enumerate}


\section{Using the qmc\sphinxhyphen{}fit tool for statistical time step extrapolation and curve fitting}
\label{\detokenize{analyzing:using-the-qmc-fit-tool-for-statistical-time-step-extrapolation-and-curve-fitting}}\label{\detokenize{analyzing:qmcfit}}
The \sphinxcode{\sphinxupquote{qmc\sphinxhyphen{}fit}} tool is used to provide statistical estimates of
curve\sphinxhyphen{}fitting parameters based on QMCPACK data. Although \sphinxcode{\sphinxupquote{qmc\sphinxhyphen{}fit}}
will eventually support many types of fitted curves (e.g., Morse
potential binding curves and various equation\sphinxhyphen{}of\sphinxhyphen{}state fitting curves),
it is currently limited to estimating fitting parameters related to time
step extrapolation.


\subsection{The jackknife statistical technique}
\label{\detokenize{analyzing:the-jackknife-statistical-technique}}
The \sphinxcode{\sphinxupquote{qmc\sphinxhyphen{}fit}} tool obtains estimates of fitting parameter means and
associated error bars via the “jack\sphinxhyphen{}knife” technique. This technique is
a powerful and general tool to obtain meaningful error bars for any
quantity that is related in a nonlinear fashion to an underlying set of
statistical data. For this reason, we give a brief overview of the
jackknife technique before proceeding with usage instructions for the
\sphinxcode{\sphinxupquote{qmc\sphinxhyphen{}fit}} tool.

Consider \(N\) statistical variables \(\{x_n\}_{n=1}^N\) that
have been outputted by one or more simulation runs. If we have \(M\)
samples of each of the \(N\) variables, then the mean values of each
these variables can be estimated in the standard way, that is,
\(\bar{x}_n\approx \tfrac{1}{M}\sum_{m=1}^Mx_{nm}\).

Suppose we are interested in \(P\) statistical quantities
\(\{y_p\}_{p=1}^P\) that are related to the original \(N\)
variables by a known multidimensional function \(F\):
\begin{equation}\label{equation:analyzing:eq46}
\begin{split}\begin{aligned}
   y_1,y_2,\ldots,y_P &= F(x_1,x_2,\ldots,x_N)\quad \textrm{or} \nonumber \\
   \vec{y} &= F(\vec{x})\:.\end{aligned}\end{split}
\end{equation}
The relationship implied by \(F\) is completely general. For
example, the \(\{x_n\}\) might be elements of a matrix with
\(\{y_p\}\) being the eigenvalues, or \(F\) might be a fitting
procedure for \(N\) energies at different time steps with \(P\)
fitting parameters. An approximate guess at the mean value of
\(\vec{y}\) can be obtained by evaluating \(F\) at the mean
value of \(\vec{x}\) (i.e. \(F(\bar{x}_1\ldots\bar{x}_N)\)), but
with this approach we have no way to estimate the statistical error bar
of any \(\bar{y}_p\).

In the jackknife procedure, the statistical variability intrinsic to the
underlying data \(\{x_n\}\) is used to obtain estimates of the mean
and error bar of \(\{y_p\}\). We first construct a new set of
\(x\) statistical data by taking the average over all samples but
one:
\begin{equation}\label{equation:analyzing:eq47}
\begin{split}\tilde{x}_{nm} = \frac{1}{N-1}(N\bar{x}_n-x_{nm})\qquad m\in [1,M]\:.\end{split}
\end{equation}
The result is a distribution of approximate \(x\) mean values. These
are used to construct a distribution of approximate means for \(y\):
\begin{equation}\label{equation:analyzing:eq48}
\begin{split}\tilde{y}_{1m},\ldots,\tilde{y}_{Pm} = F(\tilde{x}_{1m},\ldots,\tilde{x}_{Nm}) \qquad m\in [1,M]\:.\end{split}
\end{equation}
Estimates for the mean and error bar of the quantities of
interest can finally be obtained using the following formulas:
\begin{equation}\label{equation:analyzing:eq49}
\begin{split}\begin{aligned}
   \bar{y}_p &= \frac{1}{M}\sum_{m=1}^M\tilde{y}_{pm}\:.  \\
   \sigma_{y_p} &= \sqrt{\frac{M-1}{M}\left(\sum_{m=1}^M\tilde{y}_{pm}^2-M\bar{y}_p^2\right)}\:.\end{aligned}\end{split}
\end{equation}

\subsection{Performing time step extrapolation}
\label{\detokenize{analyzing:performing-time-step-extrapolation}}
In this section, we use a 32\sphinxhyphen{}atom supercell of MnO as an example system
for time step extrapolation. Data for this system has been collected in
DMC using the following sequence of time steps:
\(0.04,~0.02,~0.01,~0.005,~0.0025,~0.00125\) Ha\(^{-1}\). For
a typical production pseudopotential study, time steps in the range of
\(0.02-0.002\) Ha\(^{-1}\) are usually sufficient and it is
recommended to increase the number of steps/blocks by a factor of two
when the time step is halved. To perform accurate statistical fitting,
we must first understand the equilibration and autocorrelation
properties of the inputted local energy data. After plotting the local
energy traces (\sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}t \sphinxhyphen{}q e \sphinxhyphen{}e 0 ./qmc*/*scalar*}}), it is clear that
an equilibration period of \(30\) blocks is reasonable. Approximate
autocorrelation lengths are also obtained with \sphinxcode{\sphinxupquote{qmca}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{30} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{sac} \PYG{o}{.}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{*}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{g000}\PYG{o}{.}\PYG{n}{s002}\PYG{o}{.}\PYG{n}{scalar}\PYG{o}{.}\PYG{n}{dat}
\PYG{o}{.}\PYG{o}{/}\PYG{n}{qmc\PYGZus{}tm\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{00125}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{g000} \PYG{n}{series} \PYG{l+m+mi}{2} \PYG{n}{LocalEnergy} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3848.234513} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.055754}  \PYG{l+m+mf}{1.7}
\PYG{o}{.}\PYG{o}{/}\PYG{n}{qmc\PYGZus{}tm\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{00250}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{g000} \PYG{n}{series} \PYG{l+m+mi}{2} \PYG{n}{LocalEnergy} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3848.237614} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.055432}  \PYG{l+m+mf}{2.2}
\PYG{o}{.}\PYG{o}{/}\PYG{n}{qmc\PYGZus{}tm\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{00500}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{g000} \PYG{n}{series} \PYG{l+m+mi}{2} \PYG{n}{LocalEnergy} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3848.349741} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.069729}  \PYG{l+m+mf}{2.8}
\PYG{o}{.}\PYG{o}{/}\PYG{n}{qmc\PYGZus{}tm\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{01000}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{g000} \PYG{n}{series} \PYG{l+m+mi}{2} \PYG{n}{LocalEnergy} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3848.274596} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.126407}  \PYG{l+m+mf}{3.9}
\PYG{o}{.}\PYG{o}{/}\PYG{n}{qmc\PYGZus{}tm\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{02000}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{g000} \PYG{n}{series} \PYG{l+m+mi}{2} \PYG{n}{LocalEnergy} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3848.539017} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.075740}  \PYG{l+m+mf}{2.4}
\PYG{o}{.}\PYG{o}{/}\PYG{n}{qmc\PYGZus{}tm\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{04000}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{g000} \PYG{n}{series} \PYG{l+m+mi}{2} \PYG{n}{LocalEnergy} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3848.976424} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.075305}  \PYG{l+m+mf}{1.8}
\end{sphinxVerbatim}

The autocorrelation must be removed from the data before jackknifing, so
we will reblock the data by a factor of 4.

The \sphinxcode{\sphinxupquote{qmc\sphinxhyphen{}fit}} tool can be used in the following way to obtain a linear
time step fit of the data:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmc}\PYG{o}{\PYGZhy{}}\PYG{n}{fit} \PYG{n}{ts} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{30} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0.00125 0.0025 0.005 0.01 0.02 0.04}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{.}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{*}\PYG{o}{/}\PYG{o}{*}\PYG{n}{scalar}\PYG{o}{*}
\PYG{n}{fit} \PYG{n}{function}  \PYG{p}{:} \PYG{n}{linear}
\PYG{n}{fitted} \PYG{n}{formula}\PYG{p}{:} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3848.193} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.037}\PYG{p}{)} \PYG{o}{+} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{18.95} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1.95}\PYG{p}{)}\PYG{o}{*}\PYG{n}{t}
\PYG{n}{intercept}     \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3848.193} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.037}  \PYG{n}{Ha}
\end{sphinxVerbatim}

The input arguments are as follows: \sphinxcode{\sphinxupquote{ts}} indicates we are performing a
time step fit, \sphinxcode{\sphinxupquote{\sphinxhyphen{}e 30}} is the equilibration period removed from each
set of scalar data, \sphinxcode{\sphinxupquote{\sphinxhyphen{}b 4}} indicates the data will be reblocked by a
factor of 4 (e.g., a file containing 400 entries will be block averaged
into a new set of 100 before jackknife fitting), \sphinxcode{\sphinxupquote{\sphinxhyphen{}s 2}} indicates that
the time step data begins with series 2 (scalar files matching
\sphinxcode{\sphinxupquote{*s000*}} or \sphinxcode{\sphinxupquote{*s001*}} are to be excluded), and \sphinxcode{\sphinxupquote{\sphinxhyphen{}t}} ‘0.00125 0.0025
0.005 0.01 0.02 0.04’ provides a list of time step values corresponding
to the inputted scalar files. The \sphinxcode{\sphinxupquote{\sphinxhyphen{}e}} and \sphinxcode{\sphinxupquote{\sphinxhyphen{}b}} options can receive
a list of file\sphinxhyphen{}specific values (same format as \sphinxcode{\sphinxupquote{\sphinxhyphen{}t}}) if desired. As
can be seen from the text output, the parameters for the linear fit are
printed with error bars obtained with jackknife resampling and the zero
time step “intercept” is \(-3848.19(4)\) Ha. In addition to text
output, the previous command will result in a plot of the fit with the
zero time step value shown as a red dot, as shown in the top panel of
\hyperref[\detokenize{analyzing:fig12}]{Fig.\@ \ref{\detokenize{analyzing:fig12}}}.

Different fitting functions are supported via the \sphinxcode{\sphinxupquote{\sphinxhyphen{}f}} option.
Currently supported options include \sphinxcode{\sphinxupquote{linear}} (\(a+bt\)),
\sphinxcode{\sphinxupquote{quadratic}} (\(a+bt+ct^2\)), and \sphinxcode{\sphinxupquote{sqrt}}
(\(a+b\sqrt{t}+ct\)). Results for a quadratic fit are shown
subsequently and in the bottom panel of \hyperref[\detokenize{analyzing:fig12}]{Fig.\@ \ref{\detokenize{analyzing:fig12}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{qmc}\PYG{o}{\PYGZhy{}}\PYG{n}{fit} \PYG{n}{ts} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{quadratic} \PYG{o}{\PYGZhy{}}\PYG{n}{e30} \PYG{o}{\PYGZhy{}}\PYG{n}{b4} \PYG{o}{\PYGZhy{}}\PYG{n}{s2} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0.00125 0.0025 0.005 0.01 0.02 0.04}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{.}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{*}\PYG{o}{/}\PYG{o}{*}\PYG{n}{scalar}\PYG{o}{*}
\PYG{n}{fit} \PYG{n}{function}  \PYG{p}{:} \PYG{n}{quadratic}
\PYG{n}{fitted} \PYG{n}{formula}\PYG{p}{:} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3848.245} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.047}\PYG{p}{)} \PYG{o}{+} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.25} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{8.33}\PYG{p}{)}\PYG{o}{*}\PYG{n}{t} \PYG{o}{+} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{285.00} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{202.39}\PYG{p}{)}\PYG{o}{*}\PYG{n}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}
\PYG{n}{intercept}     \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3848.245} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.047}  \PYG{n}{Ha}
\end{sphinxVerbatim}

In this case, we find a zero time step estimate of \(-3848.25(5)\)
Ha\(^{-1}\). A time step of \(0.04\) Ha\(^{-1}\) might
be on the large side to include in time step extrapolation, and it is
likely to have an outsize influence in the case of linear extrapolation.
Upon excluding this point, linear extrapolation yields a zero timestep
value of \(-3848.22(4)\) Ha\(^{-1}\). Note that quadratic
extrapolation can result in intrinsically larger uncertainty in the
extrapolated value. For example, when the \(0.04\) Ha\(^{-1}\)
point is excluded, the uncertainty grows by 50\% and we obtain an
estimated value of \(-3848.28(7)\) instead.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{qmcfit_timestep_linear}.png}\hspace*{\fill}}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{qmcfit_timestep_quadratic}.png}
\caption{Linear (top) and quadratic (bottom) time step fits to DMC data for a 32\sphinxhyphen{}atom supercell of MnO obtained with \sphinxcode{\sphinxupquote{qmc\sphinxhyphen{}fit}}.  Zero time step estimates are indicated by the red data point on the left side of either panel.}\label{\detokenize{analyzing:id9}}\label{\detokenize{analyzing:fig12}}\end{figure}


\section{Using the qdens tool to obtain electron densities}
\label{\detokenize{analyzing:using-the-qdens-tool-to-obtain-electron-densities}}\label{\detokenize{analyzing:qdens}}
The \sphinxcode{\sphinxupquote{qdens}} tool is provided to post\sphinxhyphen{}process the heavy density data
produced by QMCPACK and output the mean density (with and without
errorbars) in file formats viewable with, e.g., XCrysDen or VESTA. The
tool currently works only with the \sphinxcode{\sphinxupquote{SpinDensity}} estimator in QMCPACK.

Note: this tool is provisional and may be changed or replaced at any
time. The planned successor to this tool (\sphinxcode{\sphinxupquote{qstat}}) will expand access
to other observables and will retain at least the non\sphinxhyphen{}plotting
capabilities of \sphinxcode{\sphinxupquote{qdens}}.

To use \sphinxcode{\sphinxupquote{qdens}}, Nexus must be installed along with NumPy and H5Py. A
short list of example use cases are covered in the next section. Current
input flags are:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}qdens

Usage: qdens [options] [file(s)]

Options:
  \PYGZhy{}\PYGZhy{}version             show program\PYGZsq{}s version number and exit
  \PYGZhy{}h, \PYGZhy{}\PYGZhy{}help            Print help information and exit (default=False).
  \PYGZhy{}v, \PYGZhy{}\PYGZhy{}verbose         Print detailed information (default=False).
  \PYGZhy{}f FORMATS, \PYGZhy{}\PYGZhy{}formats=FORMATS
                        Format or list of formats for density file output.
                        Options: dat, xsf, chgcar (default=None).
  \PYGZhy{}e EQUILIBRATION, \PYGZhy{}\PYGZhy{}equilibration=EQUILIBRATION
                        Equilibration length in blocks (default=0).
  \PYGZhy{}r REBLOCK, \PYGZhy{}\PYGZhy{}reblock=REBLOCK
                        Block coarsening factor; use estimated autocorrelation
                        length (default=None).
  \PYGZhy{}a, \PYGZhy{}\PYGZhy{}average         Average over files in each series (default=False).
  \PYGZhy{}w WEIGHTS, \PYGZhy{}\PYGZhy{}weights=WEIGHTS
                        List of weights for averaging (default=None).
  \PYGZhy{}i INPUT, \PYGZhy{}\PYGZhy{}input=INPUT
                        QMCPACK input file containing structure and grid
                        information (default=None).
  \PYGZhy{}s STRUCTURE, \PYGZhy{}\PYGZhy{}structure=STRUCTURE
                        File containing atomic structure (default=None).
  \PYGZhy{}g GRID, \PYGZhy{}\PYGZhy{}grid=GRID  Density grid dimensions (default=None).
  \PYGZhy{}c CELL, \PYGZhy{}\PYGZhy{}cell=CELL  Simulation cell axes (default=None).
  \PYGZhy{}\PYGZhy{}lineplot=LINEPLOT   Produce a line plot along the selected dimension: 0,
                        1, or 2 (default=None).
  \PYGZhy{}\PYGZhy{}noplot              Do not show plots interactively (default=False).
\end{sphinxVerbatim}


\subsection{Usage examples}
\label{\detokenize{analyzing:usage-examples}}
Process a single file, excluding the first 40 blocks, and produce XSF files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qdens} \PYG{o}{\PYGZhy{}}\PYG{n}{v} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{40} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{xsf} \PYG{o}{\PYGZhy{}}\PYG{n}{i} \PYG{n}{qmc}\PYG{o}{.}\PYG{o+ow}{in}\PYG{o}{.}\PYG{n}{xml} \PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s000}\PYG{o}{.}\PYG{n}{stat}\PYG{o}{.}\PYG{n}{h5}
\end{sphinxVerbatim}

Process files for all available series:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qdens} \PYG{o}{\PYGZhy{}}\PYG{n}{v} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{40} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{xsf} \PYG{o}{\PYGZhy{}}\PYG{n}{i} \PYG{n}{qmc}\PYG{o}{.}\PYG{o+ow}{in}\PYG{o}{.}\PYG{n}{xml} \PYG{o}{*}\PYG{n}{stat}\PYG{o}{.}\PYG{n}{h5}
\end{sphinxVerbatim}

Combine groups of 10 adjacent statistical blocks together (appropriate if the
estimated autocorrelation time is about 10 blocks):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qdens} \PYG{o}{\PYGZhy{}}\PYG{n}{v} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{40} \PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{l+m+mi}{10} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{xsf} \PYG{o}{\PYGZhy{}}\PYG{n}{i} \PYG{n}{qmc}\PYG{o}{.}\PYG{o+ow}{in}\PYG{o}{.}\PYG{n}{xml} \PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s000}\PYG{o}{.}\PYG{n}{stat}\PYG{o}{.}\PYG{n}{h5}
\end{sphinxVerbatim}

Apply different equilibration lengths and reblocking factors to each
series (below is appropriate if there are three series, e.g. \sphinxcode{\sphinxupquote{s000}},
\sphinxcode{\sphinxupquote{s001}}, and \sphinxcode{\sphinxupquote{s002}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qdens} \PYG{o}{\PYGZhy{}}\PYG{n}{v} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{20 20 40}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4 4 8}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{xsf} \PYG{o}{\PYGZhy{}}\PYG{n}{i} \PYG{n}{qmc}\PYG{o}{.}\PYG{o+ow}{in}\PYG{o}{.}\PYG{n}{xml} \PYG{o}{*}\PYG{n}{stat}\PYG{o}{.}\PYG{n}{h5}
\end{sphinxVerbatim}

Produce twist averaged densities (also works with multiple series and reblocking):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qdens} \PYG{o}{\PYGZhy{}}\PYG{n}{v} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mi}{40} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{xsf} \PYG{o}{\PYGZhy{}}\PYG{n}{i} \PYG{n}{qmc}\PYG{o}{.}\PYG{n}{g000}\PYG{o}{.}\PYG{n}{twistnum\PYGZus{}0}\PYG{o}{.}\PYG{o+ow}{in}\PYG{o}{.}\PYG{n}{xml} \PYG{n}{qmc}\PYG{o}{.}\PYG{n}{g}\PYG{o}{*}\PYG{o}{.}\PYG{n}{s000}\PYG{o}{.}\PYG{n}{stat}\PYG{o}{.}\PYG{n}{h5}
\end{sphinxVerbatim}

Twist averaging with arbitrary weights can be performed via the \sphinxcode{\sphinxupquote{\sphinxhyphen{}w}}
option in a fashion identical to \sphinxcode{\sphinxupquote{qmca}}.


\subsection{Files produced}
\label{\detokenize{analyzing:files-produced}}
Look for files with names and extensions similar to:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s000}\PYG{o}{.}\PYG{n}{SpinDensity\PYGZus{}u}\PYG{o}{.}\PYG{n}{xsf}
\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s000}\PYG{o}{.}\PYG{n}{SpinDensity\PYGZus{}u}\PYG{o}{\PYGZhy{}}\PYG{n}{err}\PYG{o}{.}\PYG{n}{xsf}
\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s000}\PYG{o}{.}\PYG{n}{SpinDensity\PYGZus{}u}\PYG{o}{+}\PYG{n}{err}\PYG{o}{.}\PYG{n}{xsf}

\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s000}\PYG{o}{.}\PYG{n}{SpinDensity\PYGZus{}d}\PYG{o}{.}\PYG{n}{xsf}
\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s000}\PYG{o}{.}\PYG{n}{SpinDensity\PYGZus{}d}\PYG{o}{\PYGZhy{}}\PYG{n}{err}\PYG{o}{.}\PYG{n}{xsf}
\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s000}\PYG{o}{.}\PYG{n}{SpinDensity\PYGZus{}d}\PYG{o}{+}\PYG{n}{err}\PYG{o}{.}\PYG{n}{xsf}

\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s000}\PYG{o}{.}\PYG{n}{SpinDensity\PYGZus{}u}\PYG{o}{+}\PYG{n}{d}\PYG{o}{.}\PYG{n}{xsf}
\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s000}\PYG{o}{.}\PYG{n}{SpinDensity\PYGZus{}u}\PYG{o}{+}\PYG{n}{d}\PYG{o}{\PYGZhy{}}\PYG{n}{err}\PYG{o}{.}\PYG{n}{xsf}
\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s000}\PYG{o}{.}\PYG{n}{SpinDensity\PYGZus{}u}\PYG{o}{+}\PYG{n}{d}\PYG{o}{+}\PYG{n}{err}\PYG{o}{.}\PYG{n}{xsf}

\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s000}\PYG{o}{.}\PYG{n}{SpinDensity\PYGZus{}u}\PYG{o}{\PYGZhy{}}\PYG{n}{d}\PYG{o}{.}\PYG{n}{xsf}
\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s000}\PYG{o}{.}\PYG{n}{SpinDensity\PYGZus{}u}\PYG{o}{\PYGZhy{}}\PYG{n}{d}\PYG{o}{\PYGZhy{}}\PYG{n}{err}\PYG{o}{.}\PYG{n}{xsf}
\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{s000}\PYG{o}{.}\PYG{n}{SpinDensity\PYGZus{}u}\PYG{o}{\PYGZhy{}}\PYG{n}{d}\PYG{o}{+}\PYG{n}{err}\PYG{o}{.}\PYG{n}{xsf}
\end{sphinxVerbatim}

Files postfixed with \sphinxcode{\sphinxupquote{u}} relate to the up electron density, \sphinxcode{\sphinxupquote{d}} to
down, \sphinxcode{\sphinxupquote{u+d}} to the total charge density, and \sphinxcode{\sphinxupquote{u\sphinxhyphen{}d}} to the difference
between up and down electron densities.

Files without \sphinxcode{\sphinxupquote{err}} in the name contain only the mean, whereas files
with \sphinxcode{\sphinxupquote{+err}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}err}} in the name contain the mean plus/minus the
estimated error bar. Please use caution in interpreting the error bars
as their accuracy depends crucially on a correct estimation of the
autocorrelation time by the user (see \sphinxcode{\sphinxupquote{\sphinxhyphen{}r}} option) and having a
sufficient number of blocks remaining following any reblocking.

When twist averaging, the group tag (e.g. \sphinxcode{\sphinxupquote{g000}} or similar) will be
replaced with \sphinxcode{\sphinxupquote{avg}} in the names of the outputted files.


\chapter{Periodic LCAO for Solids}
\label{\detokenize{LCAO:periodic-lcao-for-solids}}\label{\detokenize{LCAO:lcao}}\label{\detokenize{LCAO::doc}}

\section{Introduction}
\label{\detokenize{LCAO:introduction}}
QMCPACK implements the linear combination of atomic orbitals (LCAO) and Gaussian
basis sets in periodic boundary conditions. This method uses orders of
magnitude less memory than the real\sphinxhyphen{}space spline wavefunction. Although
the spline scheme enables very fast evaluation of the wavefunction, it might
require too much on\sphinxhyphen{}node memory for a large complex cell. The periodic
Gaussian evaluation provides a fallback that will definitely fit in
available memory but at significantly increased computational
expense. Well\sphinxhyphen{}designed Gaussian basis sets should be used to accurately
represent the wavefunction, typically
including both diffuse and high angular momentum functions.

The current implementation is not highly optimized for efficiency but can handle real and complex trial wavefunctions generated by PySCF \sphinxcite{additional_tools:sun2018}, but other codes such as
Crystal can be interfaced on request. Supercell tiling is handled outside QMCPACK through a proper PySCF input generated by Nexus and the Supercell geometry and coefficients of the molecular orbotals are constructed in the converter provided by QMCPACK. This is different from the plane wave/spline route where the tiling is provided in QMCPACK.

LCAO schemes use physical considerations to construct a highly
efficient basis set compared with plane waves. Typically only a few tens
of basis functions per atom are required compared with thousands of
plane waves. Many forms of LCAO schemes exist and are being
implemented in QMCPACK. The details of the already\sphinxhyphen{}implemented methods
are described in the following section.

\sphinxstylestrong{GTOs}: The Gaussian basis functions follow a radial\sphinxhyphen{}angular decomposition of
\begin{equation}\label{equation:LCAO:eq50}
\begin{split}   \phi (\mathbf{r} )=R_{l}(r)Y_{lm}(\theta ,\phi )\:,\end{split}
\end{equation}
where \(Y_{{lm}}(\theta ,\phi )\) is a spherical harmonic, \(l\)
and \(m\) are the angular momentum and its \(z\) component, and
\(r, \theta, \phi\) are spherical coordinates. In practice, they are
atom centered and the \(l\) expansion typically includes 1\textendash{}3
additional channels compared with the formally occupied states of the
atom (e.g., 4\textendash{}6 for a nickel atom with occupied \(s\), \(p\),
and \(d\) electron shells.

The evaluation of GTOs within PBC differs slightly from evaluating GTOs
in open boundary conditions (OBCs). The orbitals are evaluated at a
distance \(r\) in the primitive cell (similar to OBC), and then the
contributions of the periodic images are added by evaluating the orbital
at a distance \(r+T\), where T is a translation of the cell lattice
vector. This requires loops over the periodic images until the
contributions are orbitals \(\Phi\). In the current implementation,
the number of periodic images is an input parameter named \sphinxcode{\sphinxupquote{PBCimages}},
which takes three integers corresponding to the number of periodic
images along the supercell axes (X, Y and Z axes for a cubic cell). By
default these parameters are set to \sphinxcode{\sphinxupquote{PBCimages= 5 5 5}}, but they
\sphinxstylestrong{require manual convergence checks}. Convergence checks can be
performed by checking the total energy convergence with respect to
\sphinxcode{\sphinxupquote{PBCimages}}, similar to checks performed for plane wave cutoff energy
and B\sphinxhyphen{}spline grids. Use of diffuse Gaussians might require these
parameters to be increased, while sharply localized Gaussians might
permit a decrease. The cost of evaluating the wavefunction increases
sharply as \sphinxcode{\sphinxupquote{PBCimages}} is increased. This input parameter will be
replaced by a tolerance factor and numerical screening in the future.


\section{Generating and using periodic Gaussian\sphinxhyphen{}type wavefunctions using PySCF}
\label{\detokenize{LCAO:generating-and-using-periodic-gaussian-type-wavefunctions-using-pyscf}}
Similar to any QMC calculation, using periodic GTOs requires the
generation of a periodic trial wavefunction. QMCPACK is currently
interfaced to PySCF, which is a multipurpose electronic structure
written mainly in Python with key numerical functionality implemented
via optimized C and C++ libraries \sphinxcite{additional_tools:sun2018}. Such a
wavefunction can be generated according to the following example for a
\(2 \times 1 \times 1\) supercell using tiling (kpoints) and a
supertwist shifted away from \(\Gamma\), leading to a complex
wavefunction.
\sphinxSetupCaptionForVerbatim{Example PySCF input for single k\sphinxhyphen{}point calculation for a \(2 \times 1 \times 1\) carbon supercell.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{LCAO:listing-48}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}! /usr/bin/env python3}
\PYG{k+kn}{import} \PYG{n+nn}{numpy}
\PYG{k+kn}{import} \PYG{n+nn}{h5py}
\PYG{k+kn}{from} \PYG{n+nn}{pyscf}\PYG{n+nn}{.}\PYG{n+nn}{pbc} \PYG{k+kn}{import} \PYG{n}{gto}\PYG{p}{,} \PYG{n}{scf}\PYG{p}{,} \PYG{n}{dft}\PYG{p}{,} \PYG{n}{df}
\PYG{k+kn}{from} \PYG{n+nn}{pyscf}\PYG{n+nn}{.}\PYG{n+nn}{pbc} \PYG{k+kn}{import} \PYG{n}{df}

\PYG{n}{cell} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{Cell}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{cell}\PYG{o}{.}\PYG{n}{a}             \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{         3.37316115       3.37316115       0.00000000}
\PYG{l+s+s1}{         0.00000000       3.37316115       3.37316115}
\PYG{l+s+s1}{         3.37316115       0.00000000       3.37316115}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{cell}\PYG{o}{.}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{   C        0.00000000       0.00000000       0.00000000}
\PYG{l+s+s1}{   C        1.686580575      1.686580575      1.686580575}
\PYG{l+s+s1}{            }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{cell}\PYG{o}{.}\PYG{n}{basis}         \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bfd\PYGZhy{}vdz}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{cell}\PYG{o}{.}\PYG{n}{ecp}           \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bfd}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{cell}\PYG{o}{.}\PYG{n}{unit}          \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{cell}\PYG{o}{.}\PYG{n}{drop\PYGZus{}exponent} \PYG{o}{=} \PYG{l+m+mf}{0.1}
\PYG{n}{cell}\PYG{o}{.}\PYG{n}{verbose}       \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{cell}\PYG{o}{.}\PYG{n}{charge}        \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{cell}\PYG{o}{.}\PYG{n}{spin}          \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{cell}\PYG{o}{.}\PYG{n}{build}\PYG{p}{(}\PYG{p}{)}


\PYG{n}{sp\PYGZus{}twist}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.07761248}\PYG{p}{,} \PYG{l+m+mf}{0.07761248}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.07761248}\PYG{p}{]}

\PYG{n}{kmesh}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{kpts}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[} \PYG{l+m+mf}{0.07761248}\PYG{p}{,}  \PYG{l+m+mf}{0.07761248}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.07761248}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[} \PYG{l+m+mf}{0.54328733}\PYG{p}{,}  \PYG{l+m+mf}{0.54328733}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.54328733}\PYG{p}{]}\PYG{p}{]}


\PYG{n}{mf} \PYG{o}{=} \PYG{n}{scf}\PYG{o}{.}\PYG{n}{KRHF}\PYG{p}{(}\PYG{n}{cell}\PYG{p}{,}\PYG{n}{kpts}\PYG{p}{)}
\PYG{n}{mf}\PYG{o}{.}\PYG{n}{exxdiv} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ewald}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{mf}\PYG{o}{.}\PYG{n}{max\PYGZus{}cycle} \PYG{o}{=} \PYG{l+m+mi}{200}

\PYG{n}{e\PYGZus{}scf}\PYG{o}{=}\PYG{n}{mf}\PYG{o}{.}\PYG{n}{kernel}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{ener} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{e\PYGZus{}scf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ener}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{e\PYGZus{}scf}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{e\PYGZus{}scf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{e\PYGZus{}scf}\PYG{p}{)}
\PYG{n}{ener}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{title}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C\PYGZus{}diamond\PYGZhy{}tiled\PYGZhy{}cplx}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k+kn}{from} \PYG{n+nn}{PyscfToQmcpack} \PYG{k+kn}{import} \PYG{n}{savetoqmcpack}
\PYG{n}{savetoqmcpack}\PYG{p}{(}\PYG{n}{cell}\PYG{p}{,}\PYG{n}{mf}\PYG{p}{,}\PYG{n}{title}\PYG{o}{=}\PYG{n}{title}\PYG{p}{,}\PYG{n}{kmesh}\PYG{o}{=}\PYG{n}{kmesh}\PYG{p}{,}\PYG{n}{kpts}\PYG{o}{=}\PYG{n}{kpts}\PYG{p}{,}\PYG{n}{sp\PYGZus{}twist}\PYG{o}{=}\PYG{n}{sp\PYGZus{}twist}\PYG{p}{)}
\end{sphinxVerbatim}

Note that the last three lines of the file

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{title}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C\PYGZus{}diamond\PYGZhy{}tiled\PYGZhy{}cplx}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k+kn}{from} \PYG{n+nn}{PyscfToQmcpack} \PYG{k+kn}{import} \PYG{n}{savetoqmcpack}
\PYG{n}{savetoqmcpack}\PYG{p}{(}\PYG{n}{cell}\PYG{p}{,}\PYG{n}{mf}\PYG{p}{,}\PYG{n}{title}\PYG{o}{=}\PYG{n}{title}\PYG{p}{,}\PYG{n}{kmesh}\PYG{o}{=}\PYG{n}{kmesh}\PYG{p}{,}\PYG{n}{kpts}\PYG{o}{=}\PYG{n}{kpts}\PYG{p}{,}\PYG{n}{sp\PYGZus{}twist}\PYG{o}{=}\PYG{n}{sp\PYGZus{}twist}\PYG{p}{)}
\end{sphinxVerbatim}

contain the title (name of the HDF5 to be used in QMCPACK) and the call
to the converter. The title variable will be the name of the HDF5 file
where all the data needed by QMCPACK will be stored. The function
\sphinxstyleemphasis{savetoqmcpack} will be called at the end of the calculation and will
generate the HDF5 similarly to the nonperiodic PySCF calculation in
{\hyperref[\detokenize{additional_tools:convert4qmc}]{\sphinxcrossref{\DUrole{std,std-ref}{convert4qmc}}}}. The function is distributed
with QMCPACK and is located in the qmcpack/src/QMCTools directory under
the name \sphinxstyleemphasis{PyscfToQmcpack.py}. Note that you need to specify the
supertwist coordinates that was used with the provided kpoints. The
supertwist must match the coordinates of the K\sphinxhyphen{}points otherwise the
phase factor for the atomic orbital will be incorrect and incorrect
results will be obtained. (For more details on how to generate tiling
with PySCF and Nexus, refer to the Nexus guide or the 2019 QMCPACK
Workshop material available on github:
\sphinxurl{https://github.com/QMCPACK/qmcpack\_workshop\_2019} under
\sphinxstylestrong{qmcpack\_workshop\_2019/day2\_nexus/pyscf/04\_pyscf\_diamond\_hf\_qmc/}

For the converter in the script to be called properly, you need
to specify the path to the file in your PYTHONPATH such as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
export PYTHONPATH=QMCPACK\PYGZus{}PATH/src/QMCTools:\PYGZdl{}PYTHONPATH
\end{sphinxVerbatim}

To generate QMCPACK input files, you will need to run \sphinxcode{\sphinxupquote{convert4qmc}} exactly as specified in {\hyperref[\detokenize{additional_tools:convert4qmc}]{\sphinxcrossref{\DUrole{std,std-ref}{convert4qmc}}}} for both cases:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{convert4qmc} \PYG{o}{\PYGZhy{}}\PYG{n}{pyscf} \PYG{n}{C\PYGZus{}diamond}\PYG{o}{\PYGZhy{}}\PYG{n}{tiled}\PYG{o}{\PYGZhy{}}\PYG{n}{cplx}
\end{sphinxVerbatim}

This tool can be used with any option described in convert4qmc. Since
the HDF5 contains all the information needed, there is no need to
specify any other specific tag for periodicity. A supercell at
\(\Gamma\)\sphinxhyphen{}point or using multiple k\sphinxhyphen{}points will work without
further modification.

Running convert4qmc will generate 3 input files:
\sphinxSetupCaptionForVerbatim{C\_diamond\sphinxhyphen{}tiled\sphinxhyphen{}cplx.structure.xml. This file contains the geometry of the system.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{LCAO:listing-49}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}?xml version=\PYGZdq{}1.0\PYGZdq{}?\PYGZgt{}
\PYGZlt{}qmcsystem\PYGZgt{}
  \PYGZlt{}simulationcell\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}lattice\PYGZdq{}\PYGZgt{}
  6.74632230000000e+00  6.74632230000000e+00  0.00000000000000e+00
  0.00000000000000e+00  3.37316115000000e+00  3.37316115000000e+00
  3.37316115000000e+00  0.00000000000000e+00  3.37316115000000e+00
\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}bconds\PYGZdq{}\PYGZgt{}p p p\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}LR\PYGZus{}dim\PYGZus{}cutoff\PYGZdq{}\PYGZgt{}15\PYGZlt{}/parameter\PYGZgt{}
  \PYGZlt{}/simulationcell\PYGZgt{}
  \PYGZlt{}particleset name=\PYGZdq{}ion0\PYGZdq{} size=\PYGZdq{}4\PYGZdq{}\PYGZgt{}
    \PYGZlt{}group name=\PYGZdq{}C\PYGZdq{}\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}charge\PYGZdq{}\PYGZgt{}4\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}valence\PYGZdq{}\PYGZgt{}4\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}atomicnumber\PYGZdq{}\PYGZgt{}6\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}/group\PYGZgt{}
    \PYGZlt{}attrib name=\PYGZdq{}position\PYGZdq{} datatype=\PYGZdq{}posArray\PYGZdq{}\PYGZgt{}
  0.0000000000e+00  0.0000000000e+00  0.0000000000e+00
  1.6865805750e+00  1.6865805750e+00  1.6865805750e+00
  3.3731611500e+00  3.3731611500e+00  0.0000000000e+00
  5.0597417250e+00  5.0597417250e+00  1.6865805750e+00
\PYGZlt{}/attrib\PYGZgt{}
    \PYGZlt{}attrib name=\PYGZdq{}ionid\PYGZdq{} datatype=\PYGZdq{}stringArray\PYGZdq{}\PYGZgt{}
 C C C C
\PYGZlt{}/attrib\PYGZgt{}
  \PYGZlt{}/particleset\PYGZgt{}
  \PYGZlt{}particleset name=\PYGZdq{}e\PYGZdq{} random=\PYGZdq{}yes\PYGZdq{} randomsrc=\PYGZdq{}ion0\PYGZdq{}\PYGZgt{}
    \PYGZlt{}group name=\PYGZdq{}u\PYGZdq{} size=\PYGZdq{}8\PYGZdq{}\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}charge\PYGZdq{}\PYGZgt{}\PYGZhy{}1\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}/group\PYGZgt{}
    \PYGZlt{}group name=\PYGZdq{}d\PYGZdq{} size=\PYGZdq{}8\PYGZdq{}\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}charge\PYGZdq{}\PYGZgt{}\PYGZhy{}1\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}/group\PYGZgt{}
  \PYGZlt{}/particleset\PYGZgt{}
\PYGZlt{}/qmcsystem\PYGZgt{}
\end{sphinxVerbatim}

As one can see, for both examples, the two\sphinxhyphen{}atom primitive cell has been
expanded to contain four atoms in a \(2 \times 1 \times 1\) carbon
cell.
\sphinxSetupCaptionForVerbatim{C\_diamond\sphinxhyphen{}tiled\sphinxhyphen{}cplx.wfj.xml. This file contains the trial wavefunction.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{LCAO:listing-50}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}?xml version=\PYGZdq{}1.0\PYGZdq{}?\PYGZgt{}
\PYGZlt{}qmcsystem\PYGZgt{}
  \PYGZlt{}wavefunction name=\PYGZdq{}psi0\PYGZdq{} target=\PYGZdq{}e\PYGZdq{}\PYGZgt{}
    \PYGZlt{}determinantset type=\PYGZdq{}MolecularOrbital\PYGZdq{} name=\PYGZdq{}LCAOBSet\PYGZdq{} source=\PYGZdq{}ion0\PYGZdq{} transform=\PYGZdq{}yes\PYGZdq{} twist=\PYGZdq{}0.07761248  0.07761248  \PYGZhy{}0.07761248\PYGZdq{} href=\PYGZdq{}C\PYGZus{}diamond\PYGZhy{}tiled\PYGZhy{}cplx.h5\PYGZdq{} PBCimages=\PYGZdq{}8  8  8\PYGZdq{}\PYGZgt{}
      \PYGZlt{}slaterdeterminant\PYGZgt{}
        \PYGZlt{}determinant id=\PYGZdq{}updet\PYGZdq{} size=\PYGZdq{}8\PYGZdq{}\PYGZgt{}
          \PYGZlt{}occupation mode=\PYGZdq{}ground\PYGZdq{}/\PYGZgt{}
          \PYGZlt{}coefficient size=\PYGZdq{}52\PYGZdq{} spindataset=\PYGZdq{}0\PYGZdq{}/\PYGZgt{}
        \PYGZlt{}/determinant\PYGZgt{}
        \PYGZlt{}determinant id=\PYGZdq{}downdet\PYGZdq{} size=\PYGZdq{}8\PYGZdq{}\PYGZgt{}
          \PYGZlt{}occupation mode=\PYGZdq{}ground\PYGZdq{}/\PYGZgt{}
          \PYGZlt{}coefficient size=\PYGZdq{}52\PYGZdq{} spindataset=\PYGZdq{}0\PYGZdq{}/\PYGZgt{}
        \PYGZlt{}/determinant\PYGZgt{}

      \PYGZlt{}/slaterdeterminant\PYGZgt{}
    \PYGZlt{}/determinantset\PYGZgt{}
    \PYGZlt{}jastrow name=\PYGZdq{}J2\PYGZdq{} type=\PYGZdq{}Two\PYGZhy{}Body\PYGZdq{} function=\PYGZdq{}Bspline\PYGZdq{} print=\PYGZdq{}yes\PYGZdq{}\PYGZgt{}
      \PYGZlt{}correlation size=\PYGZdq{}10\PYGZdq{} speciesA=\PYGZdq{}u\PYGZdq{} speciesB=\PYGZdq{}u\PYGZdq{}\PYGZgt{}
        \PYGZlt{}coefficients id=\PYGZdq{}uu\PYGZdq{} type=\PYGZdq{}Array\PYGZdq{}\PYGZgt{} 0 0 0 0 0 0 0 0 0 0\PYGZlt{}/coefficients\PYGZgt{}
      \PYGZlt{}/correlation\PYGZgt{}
      \PYGZlt{}correlation size=\PYGZdq{}10\PYGZdq{} speciesA=\PYGZdq{}u\PYGZdq{} speciesB=\PYGZdq{}d\PYGZdq{}\PYGZgt{}
        \PYGZlt{}coefficients id=\PYGZdq{}ud\PYGZdq{} type=\PYGZdq{}Array\PYGZdq{}\PYGZgt{} 0 0 0 0 0 0 0 0 0 0\PYGZlt{}/coefficients\PYGZgt{}
      \PYGZlt{}/correlation\PYGZgt{}
    \PYGZlt{}/jastrow\PYGZgt{}
    \PYGZlt{}jastrow name=\PYGZdq{}J1\PYGZdq{} type=\PYGZdq{}One\PYGZhy{}Body\PYGZdq{} function=\PYGZdq{}Bspline\PYGZdq{} source=\PYGZdq{}ion0\PYGZdq{} print=\PYGZdq{}yes\PYGZdq{}\PYGZgt{}
      \PYGZlt{}correlation size=\PYGZdq{}10\PYGZdq{} cusp=\PYGZdq{}0\PYGZdq{} elementType=\PYGZdq{}C\PYGZdq{}\PYGZgt{}
        \PYGZlt{}coefficients id=\PYGZdq{}eC\PYGZdq{} type=\PYGZdq{}Array\PYGZdq{}\PYGZgt{} 0 0 0 0 0 0 0 0 0 0\PYGZlt{}/coefficients\PYGZgt{}
      \PYGZlt{}/correlation\PYGZgt{}
    \PYGZlt{}/jastrow\PYGZgt{}
  \PYGZlt{}/wavefunction\PYGZgt{}
\PYGZlt{}/qmcsystem\PYGZgt{}
\end{sphinxVerbatim}

This file contains information related to the trial wavefunction. It is identical to the input file from an OBC calculation to the exception of the following tags:

{\color{red}\bfseries{}*}.wfj.xml specific tags:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{tag}
&\sphinxstyletheadfamily 
\sphinxstylestrong{tag type}
&\sphinxstyletheadfamily 
\sphinxstylestrong{default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{description}
\\
\hline
\sphinxcode{\sphinxupquote{twist}}
&
3 doubles
&
(0 0 0)
&
Coordinate of the twist to compute
\\
\hline
\sphinxcode{\sphinxupquote{href}}
&
string
&
default
&
Name of the HDF5 file generated by PySCF and used for convert4qmc
\\
\hline
\sphinxcode{\sphinxupquote{PBCimages}}
&
3 Integer
&
8 8 8
&
Number of periodic images to evaluate the orbitals
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Other files containing QMC methods (such as optimization, VMC, and DMC blocks) will be generated and will behave in a similar fashion regardless of the type of SPO in the trial wavefunction.




\chapter{Selected Configuration Interaction}
\label{\detokenize{sCI:selected-configuration-interaction}}\label{\detokenize{sCI:sci}}\label{\detokenize{sCI::doc}}
A direct path towards improving the accuracy of a QMC calculation is
through a better trial wavefunction.  Although using a multireference
wavefunction can be straightforward in theory, in actual practice
methods such as CASSCF are not always intuitive and often require
being an expert in either the method or the code generating the
wavefunction.  An alternative is to use a selected configuration of
interaction method (selected CI) such as CIPSI (configuration
interaction using a perturbative selection done iteratively). This
provides a direct route to systematically improving the wavefunction.


\section{Theoretical background}
\label{\detokenize{sCI:theoretical-background}}
The principle behind selected CI is rather simple and was first published in 1955 by R. K. Nesbet \sphinxcite{sCI:nesbet1955}. The first calculations on atoms were performed by Diner, Malrieu, and Claverie \sphinxcite{sCI:diner1967} in 1967 and became computationally viable for larger molecules in 2013 by Caffarel et al. \sphinxcite{sCI:caffarel2013}.

As described by Caffarel et al. in \sphinxcite{sCI:caffarel2013},
multideterminantal expansions of the ground\sphinxhyphen{}state wavefunction
\(\Psi_T\) are written as a linear combination of Slater determinants
\begin{equation}\label{equation:sCI:eq51}
\begin{split}\sum_k c_k \sum_q d_{k,q}D_{k,q\uparrow } (r^{\uparrow})D_{k,q\downarrow}(r^{\downarrow})\:,\end{split}
\end{equation}
where each determinant corresponds to a given occupation by the
\(N_{\alpha}\) and \(N_{\beta}\) electrons of
\(N=N_{\alpha}+N_{\beta}\) orbitals among a set of M spin\sphinxhyphen{}orbitals
\(\{\phi_1,.,\phi_M\}\) (restricted case). When no symmetries are
considered, the maximum number of such determinants is
\begin{equation}\label{equation:sCI:eq52}
\begin{split}\begin{aligned}
\left(
\begin{array}{c} M \hspace{1.5mm} \\ N_{\alpha}  \end{array}
\right).
\left(
\begin{array}{c} M \hspace{1.5mm} \\ N_{\beta}  \end{array}
\right),\end{aligned}\end{split}
\end{equation}
a number that grows factorially with M and N. The best representation of the exact wavefunction in the determinantal basis is the full configuration interaction (FCI) wavefunction written as
\begin{equation}\label{equation:sCI:eq53}
\begin{split}|{\Psi_0}\rangle=\sum_{i} c_{i}|{D_i}\rangle\:,\end{split}
\end{equation}
where \(c_i\) are the ground\sphinxhyphen{}state coefficients obtained by
diagonalizing the matrix, \(H_{ij}=\langle{D_i}|H|{D_j}\rangle\), within the
full orthonormalized set \(\langle{D_i}||{D_j}\rangle=\delta_{ij}\) of
determinants \(|{D_i}\rangle\). CIPSI provides a convenient method to
build up to this full wavefunction with a single criteria.

A CIPSI wavefunction is built iteratively starting from a reference
wavefunction, usually Hartree\sphinxhyphen{}Fock or CASSCF, by adding all single and
double excitations and then iteratively selecting relevant
determinants according to some criteria. Detailed iterative steps can
be found in the reference by Caffarel et al. and references
within \sphinxcite{sCI:caffarel2013}, \sphinxcite{sCI:scemama2016}, \sphinxcite{sCI:scemama2018} and \sphinxcite{sCI:garniron2017-2} and
are summarized as follows:
\begin{itemize}
\item {} 
Step 1: Define a reference wavefunction:

\end{itemize}
\begin{equation}\label{equation:sCI:eq54}
\begin{split}\begin{gathered}
       \begin{aligned}
         |{\Psi}\rangle&=\sum_{i\in D} c_i|{i}\rangle \,         \,
         &E_{var}&= \frac{\langle{\Psi}|\hat{H}|{\Psi}\rangle}{\langle{\Psi}||{\Psi}\rangle}.
       \end{aligned}
     \end{gathered}\end{split}
\end{equation}\begin{itemize}
\item {} 
Step 2: Generate external determinants \(|{\alpha}\rangle\):
New determinants are added by generating all single and double
excitations from determinants \(i \in D\) such as:

\end{itemize}
\begin{equation}\label{equation:sCI:eq55}
\begin{split}\langle{\Psi_0^{(n)}}|H|{D_{i_c}}\rangle\neq 0\:.\end{split}
\end{equation}\begin{itemize}
\item {} 
Step 3: Evaluate the second\sphinxhyphen{}order perturbative contribution to each determinant \(|{\alpha}\rangle\):

\end{itemize}
\begin{equation}\label{equation:sCI:eq56}
\begin{split}\Delta E=\frac{\langle{\Psi}|\hat{H}|{\alpha}\rangle\langle{\alpha}|\hat{H}|{\Psi}\rangle}{E_{var}-\langle{\alpha}|\hat{H}|{\alpha}\rangle}\:.\end{split}
\end{equation}\begin{itemize}
\item {} 
Step 4: Select the determinants with the largest contributions and add them to the Hamiltonian.

\item {} 
Step 5: Diagonalize the Hamiltonian within the new added determinants and update the wavefunction and the the value of \(E_{var}\).

\item {} 
Step 6: Iterate until reaching convergence.

\end{itemize}

Repeating this process leads to a multireference trial wavefunction of high quality that can be used in QMC.
\begin{equation}\label{equation:sCI:eq57}
\begin{split}\Psi_T(r)=e^{J(r)}\sum_k c_k \sum_q d_{k,q}D_{k,q\uparrow } (r^{\uparrow})D_{k,q\downarrow}(r^{\downarrow})\:.\end{split}
\end{equation}
The linear coefficients \(c_k\) are then optimized with the presence
of the Jastrow function.

Note the following:
\begin{itemize}
\item {} 
When all determinants \(|{\alpha}\rangle\) are selected, the full
configuration interaction result is obtained.

\item {} 
CIPSI can be seen as a deterministic counterpart of FCIQMC.

\item {} 
In practice, any wavefunction method can be made multireference with
CIPSI. For instance, a multireference coupled cluster (MRCC) with
CIPSI is implemented in QP. \sphinxcite{sCI:garniron2017-1}

\item {} 
At any time, with CIPSI selection,
\(E_{PT_2}=\sum_\alpha \Delta E_\alpha\) estimates the distance
to the FCI solution.

\end{itemize}


\subsection{CIPSI wavefunction interface}
\label{\detokenize{sCI:cipsi-wavefunction-interface}}\label{\detokenize{sCI:cipsi}}
The CIPSI method is implemented in the QP code:cite:\sphinxtitleref{QP} developed by the Caffarel group. Once the trial wavefunction is generated, QP is able to produce output readable by the QMCPACK converter as described in {\hyperref[\detokenize{additional_tools:convert4qmc}]{\sphinxcrossref{\DUrole{std,std-ref}{convert4qmc}}}}. QP can be installed with multiple plugins for different levels of theory in quantum chemistry. When installing the “QMC” plugin, QP can save the wavefunction in a format readable by the QMCPACK converter.

In the following we use the \(C_2O_2H_3N\) molecule
(\hyperref[\detokenize{sCI:fig13}]{Fig.\@ \ref{\detokenize{sCI:fig13}}}) as an example of how to run a multireference
calculation with CIPSI as a trial wavefunction for . The choice of this
molecule is motivated by its multireference nature. Although the
molecule remains small enough for CCSD(T) calculations with aug\sphinxhyphen{}cc\sphinxhyphen{}pVTZ
basis set, the D1 diagnostic shows a very high value for
\(C_2O_2H_3N\), suggesting a multireference character. Therefore, an
accurate reference for the system is not available, and it becomes
difficult to trust the quality of a single\sphinxhyphen{}determinant wavefunction even
when using the DFT\sphinxhyphen{}B3LYP exchange and correlation functional. Therefore,
in the following, we show an example of how to systematically improve
the nodal surface by increasing the number of determinants in the trial
wavefunction.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=200\sphinxpxdimen]{{Reactant}.jpg}
\caption{\(C_2O_2H_3N\) molecule.}\label{\detokenize{sCI:id11}}\label{\detokenize{sCI:fig13}}\end{figure}

The following steps show how to run from Hartree\sphinxhyphen{}Fock to selected CI using QP, convert the wavefunction to a QMCPACK trial wavefunction, and analyze the result.
\begin{itemize}
\item {} 
Step 1: Generate the QP input file.
QP takes for input an XYZ file containing the geometry of the molecule such as:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline

8
&&&\\
\hline
C2O2H3N
&&&\\
\hline
C
&
1.067070
&
\sphinxhyphen{}0.370798
&
0.020324
\\
\hline
C
&
\sphinxhyphen{}1.115770
&
\sphinxhyphen{}0.239135
&
0.081860
\\
\hline
O
&
\sphinxhyphen{}0.537581
&
1.047619
&
\sphinxhyphen{}0.091020
\\
\hline
N
&
0.879629
&
0.882518
&
0.046830
\\
\hline
H
&
\sphinxhyphen{}1.525096
&
\sphinxhyphen{}0.354103
&
1.092299
\\
\hline
H
&
\sphinxhyphen{}1.868807
&
\sphinxhyphen{}0.416543
&
\sphinxhyphen{}0.683862
\\
\hline
H
&
2.035229
&
\sphinxhyphen{}0.841662
&
0.053363
\\
\hline
O
&
\sphinxhyphen{}0.025736
&
\sphinxhyphen{}1.160835
&
\sphinxhyphen{}0.084319
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The input file is generated through the following command line:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qp\PYGZus{}create\PYGZus{}ezfio\PYGZus{}from\PYGZus{}xyz} \PYG{n}{C2O2H3N}\PYG{o}{.}\PYG{n}{xyz} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{n}{cc}\PYG{o}{\PYGZhy{}}\PYG{n}{pvtz}
\end{sphinxVerbatim}

This means that we will be simulating the molecule in all electrons
within the cc\sphinxhyphen{}pVTZ basis set. Other options are, of course, possible
such as using ECPs, different spin multiplicities, etc. For more
details, see the QP tutorial at
\sphinxurl{https://github.com/LCPQ/quantum\_package/wiki/Tutorial}.

A directory called \sphinxcode{\sphinxupquote{C2O2H3N.ezfio}} is created and contains all the
relevant data to run the SCF Hartree\sphinxhyphen{}Fock calculation. Note that because
of the large size of molecular orbitals (MOs) (220), it is preferable to
run QP in parallel. QP parallelization is based on a master/slave
process that allows a master node to manage the work load between
multiple MPI processes through the LibZMQ library. In practice, the run
is submitted to one master node and is then submitted to as many nodes
as necessary to speed up the calculations. If a slave node dies before
the end of its task, the master node will resubmit the workload to
another available node. If more nodes are added at any time during the
simulation, the master node will use them to reduce the time to
solution.

\item {} 
Step 2: Run Hartree\sphinxhyphen{}Fock.
To save the integrals on disk and avoid recomputing them later, edit
the \sphinxcode{\sphinxupquote{ezfio}} directory with the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qp\PYGZus{}edit} \PYG{n}{C2O2H3N}\PYG{o}{.}\PYG{n}{ezfio}
\end{sphinxVerbatim}

This will generate a temporary file showing all the contents of the
simulation and opens an editor to allow modification of their values.
Look for \sphinxcode{\sphinxupquote{disk\_access\_ao\_integrals}} and modify its value from \sphinxcode{\sphinxupquote{None}}
to \sphinxcode{\sphinxupquote{Write}}.

To run a simulation with QP, use the binary texttt\{qp\_run\} with the desired level of theory, in this case Hartree\sphinxhyphen{}Fock (SCF).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{np} \PYG{l+m+mi}{1} \PYG{n}{qp\PYGZus{}run} \PYG{n}{SCF} \PYG{n}{C2O2H3N}\PYG{o}{.}\PYG{n}{ezfio} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZgt{}} \PYG{n}{C2O2H3N}\PYG{o}{\PYGZhy{}}\PYG{n}{SCF}\PYG{o}{.}\PYG{n}{out}
\end{sphinxVerbatim}

If run in serial, the evaluation of the integrals and the Hamiltonian diagonalization would take a substantial amount of computer time. We recommend adding a few more slave nodes to help speed up the calculation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{np} \PYG{l+m+mi}{20} \PYG{n}{qp\PYGZus{}run} \PYG{o}{\PYGZhy{}}\PYG{n}{slave} \PYG{n}{qp\PYGZus{}ao\PYGZus{}ints} \PYG{n}{C2O2H3N}\PYG{o}{.}\PYG{n}{ezfio} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZgt{}} \PYG{n}{C2O2H3N}\PYG{o}{\PYGZhy{}}\PYG{n}{SCF}\PYG{o}{\PYGZhy{}}\PYG{n}{Slave}\PYG{o}{.}\PYG{n}{out}
\end{sphinxVerbatim}

The total Hartree\sphinxhyphen{}Fock energy of the system in cc\sphinxhyphen{}pVTZ is
\sphinxstyleemphasis{:math:\textasciigrave{}E\_\{HF\}=\sphinxhyphen{}283.0992\textasciigrave{}}Ha.

\item {} 
Step 3: Freeze core electrons. To avoid making excitation from the core electrons, freeze the core electrons and do only the excitations from the valence electrons.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qp\PYGZus{}set\PYGZus{}frozen\PYGZus{}core}\PYG{o}{.}\PYG{n}{py} \PYG{n}{C2O2H3N}\PYG{o}{.}\PYG{n}{ezfio}
\end{sphinxVerbatim}

This will will automatically freeze the orbitals from 1 to 5, leaving the remaining orbitals active.

\item {} 
Step 4: Transform atomic orbitals (AOs) to MOs.
This step is the most costly, especially given that its implementation in QP is serial. We recommend completing it in a separate run and on one node.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qp\PYGZus{}run} \PYG{n}{four\PYGZus{}idx\PYGZus{}transform} \PYG{n}{C2O2H3N}\PYG{o}{.}\PYG{n}{ezfio}
\end{sphinxVerbatim}

The MO integrals are now saved on disk, and unless the orbitals are changed, they will not be recomputed.

\item {} 
Step 5: CIPSI
At this point the wavefunction is ready for the selected CI. By default,
QP has two convergence criteria: the number of determinants (set by
default to 1M) or the value of PT2 (set by default to
\(1.10^{-4}\)Ha). For this molecule, the total number of
determinants in the FCI space is \(2.07e+88\) determinants. Although
this number is completely out of range of what is possible to compute,
we will set the limit of determinants in QP to 5M determinants and see
whether the nodal surface of the wavefunction is converged enough for
the DMC. At this point it is important to remember that the main value
of CIPSI compared with other selected CI methods, is that the value of
PT2 is evaluated directly at each step, giving a good estimate of the
error to the FCI energy. This allows us to conclude that when the E+PT2
energy is converged, the nodal surface is also probably converged.
Similar to the SCF runs, FCI runs have to be submitted in parallel with
a master/slave process:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{np} \PYG{l+m+mi}{1} \PYG{n}{qp\PYGZus{}run} \PYG{n}{fci\PYGZus{}zmq} \PYG{n}{C2O2H3N}\PYG{o}{.}\PYG{n}{ezfio} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZgt{}} \PYG{n}{C2O2H3N}\PYG{o}{\PYGZhy{}}\PYG{n}{FCI}\PYG{o}{.}\PYG{n}{out}
\PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{np} \PYG{l+m+mi}{199} \PYG{n}{qp\PYGZus{}run} \PYG{o}{\PYGZhy{}}\PYG{n}{slave} \PYG{n}{selection\PYGZus{}davidson\PYGZus{}slave} \PYG{n}{C2O2H3N}\PYG{o}{.}\PYG{n}{ezfio}\PYGZbs{}\PYGZbs{}
\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZgt{}} \PYG{n}{C2O2H3N}\PYG{o}{\PYGZhy{}}\PYG{n}{FCI}\PYG{o}{\PYGZhy{}}\PYG{n}{Slave}\PYG{o}{.}\PYG{n}{out}
\end{sphinxVerbatim}

\item {} 
Step 6 (optional): Natural orbitals
Although this step is optional, it is important to note that using natural orbitals instead of Hartree\sphinxhyphen{}Fock orbitals will always improve the quality of the wavefunction and the nodal surface by reducing the number of needed determinants for the same accuracy. When a full convergence to the FCI limit is attainable, this step will not lead to any change in the energy but will only reduce the total number of determinants. However, if a full convergence is not possible, this step can significantly increase the accuracy of the calculation at the same number of determinants.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qp\PYGZus{}run} \PYG{n}{save\PYGZus{}natorb} \PYG{n}{C2O2H3N}\PYG{o}{.}\PYG{n}{ezfio}
\end{sphinxVerbatim}

At this point, the orbitals are modified, a new
AO \(\rightarrow\)MO transformation is required, and steps 3 and
4 need to be run again.

\item {} 
Step 7: Analyze the CIPSI results.
\hyperref[\detokenize{sCI:fig14}]{Fig.\@ \ref{\detokenize{sCI:fig14}}} shows the evolution of the variational energy and the energy corrected with PT2 as a function of the number of determinants up to 4M determinants. Although it is clear that the raw variational energy is far from being converged, the Energy + PT2 appears converged around 0.4M determinants.

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{CIPSI}.jpg}
\caption{Evolution of the variational energy and the Energy + PT2 as a function
of the number of determinants for the \(C_2O_2H_3N\) molecule.}\label{\detokenize{sCI:id12}}\label{\detokenize{sCI:fig14}}\end{figure}
\begin{itemize}
\item {} 
Step 8: Truncate the number of determinants.
Although using all the 4M determinants from CIPSI always guarantees that
all important determinants are kept in the wavefunction, practically,
such a large number of determinants would make any QMC calculation
prohibitively expensive because the cost of evaluating a determinant in
DMC grows as \(\sqrt[]{N_{det}}\), where \(N_{det}\) is the
number of determinants in the trial wavefunction. To truncate the number
of determinants, we follow the method described by Scemama et
al. \sphinxcite{sCI:scemama2018} where the wavefunction is truncated
by independently removing spin\sphinxhyphen{}up and spin\sphinxhyphen{}down determinants whose
contribution to the norm of the wavefunction is below a user\sphinxhyphen{}defined
threshold, \(\epsilon\). For this step, we choose to truncate the
determinants whose coefficients are below, \(1.10^{-3}\),
\(1.10^{-4}\), \(1.10^{-5}\), and \(1.10^{-6}\), translating
to 239, 44539, 541380, and 908128 determinants, respectively.

To  truncate the determinants in QP, edit the \sphinxcode{\sphinxupquote{ezfio}} file as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qp\PYGZus{}edit} \PYG{n}{C2O2H3N}\PYG{o}{.}\PYG{n}{ezfio}
\end{sphinxVerbatim}

Then look for \sphinxcode{\sphinxupquote{ci\textbackslash{}\_threshold}} and modify the value according to the desired threshold. Use the following run to truncate the determinants:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qp\PYGZus{}run} \PYG{n}{truncate\PYGZus{}wf\PYGZus{}spin} \PYG{n}{C2O2H3N}\PYG{o}{.}\PYG{n}{ezfio}
\end{sphinxVerbatim}

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{sCI:table11}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Method
&\sphinxstyletheadfamily 
N\_det
&\sphinxstyletheadfamily 
Energy
\\
\hline
Hartree\sphinxhyphen{}Fock
&
1
&
\sphinxhyphen{}281.6729
\\
\hline
Natural orbitals
&
1
&
\sphinxhyphen{}281.6735
\\
\hline
E\_Variational
&
438,753
&
\sphinxhyphen{}282.2951
\\
\hline
E\_Variational
&
4,068,271
&
\sphinxhyphen{}282.4882
\\
\hline
E+PT2
&
438,753
&
\sphinxhyphen{}282.6809
\\
\hline
E+PT2
&
4,068,271
&
\sphinxhyphen{}282.6805
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{center}\hyperref[\detokenize{sCI:table11}]{Table \ref{\detokenize{sCI:table11}}} Energies of \(C_2O_2H_3N\) using orbitals from
Hartree\sphinxhyphen{}Fock, natural orbitals, and 0.4M and 4M determinants
\end{center}\begin{itemize}
\item {} 
Save the wavefunction for QMCPACK.
The wavefunction in QP is now ready to be converted to QMCPACK format.
Save the wavefunction into QMCPACK format and then convert the wavefunction using the \sphinxcode{\sphinxupquote{convert4qmc}} tool.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qp\PYGZus{}run} \PYG{n}{save\PYGZus{}for\PYGZus{}qmcpack} \PYG{n}{C2O2H3N}\PYG{o}{.}\PYG{n}{ezfio} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZgt{}} \PYG{n}{C2O2H3N}\PYG{o}{.}\PYG{n}{dump}
\PYG{n}{convert4qmc} \PYG{o}{\PYGZhy{}}\PYG{n}{QP} \PYG{n}{C2O2H3N}\PYG{o}{.}\PYG{n}{dump} \PYG{o}{\PYGZhy{}}\PYG{n}{addCusp} \PYG{o}{\PYGZhy{}}\PYG{n}{production}
\end{sphinxVerbatim}

Since we are running all\sphinxhyphen{}electron calculations, orbitals in QMC need
to be corrected for the electron\sphinxhyphen{}nuclearcusp condition.  This is done
by adding the option \sphinxcode{\sphinxupquote{\sphinxhyphen{}addCusp}} to \sphinxcode{\sphinxupquote{convert4qmc}}, which
adds a tag forcing QMCPACK to run the correction or read them from a
file if pre\sphinxhyphen{}computed. When running multiple DMC runs with different
truncation thresholds, only the number of determinants is varied and
the orbitals remain unchanged from one calculation to another and the
cusp correction needs to be run only once.

\item {} 
Step 10: Run QMCPACK.
At this point, running a multideterminant DMC becomes identical to running a regular DMC with QMCPACK;
After correcting the orbitals for the cusp, optimize the Jastrow functions and then run the DMC. It is important, however, to note a few items:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{(}{)}%
\item {} 
QMCPACK allows reoptimization of the coefficients of the
determinants during the Jastrow optimization step. Although this has
proven to lower the energy significantly when the number of
determinants is below 10k, a large number of determinants from CIPSI
is often too large to optimize conveniently. Keeping the coefficients
of the determinants from CIPSI unoptimized is an alternative strategy.

\item {} 
The large determinant expansion and the Jastrows are both trying
to recover the missing correlations from the system. When optimizing
the Jastrows, we recommend first optimizing J1 and J2 without the J3,
and then with the added J3. Trying to initially optimize J1, J2, and J3
at the same time could lead to numerical instabilities.

\item {} 
The parameters of the Jastrow function will need to be optimized
for each truncation scheme and usually cannot be reused efficiently
from one truncation scheme to another.

\end{enumerate}

\item {} 
Step 11: Analyze the DMC results from QMCPACK.
From \hyperref[\detokenize{sCI:table12}]{Table \ref{\detokenize{sCI:table12}}}, we can see that increasing the number
of determinants from 0.5M to almost 1M keeps the energy
within error bars and does not improve the quality of the nodal
surface. We can conclude that the DMC energy is converged at 0.54M
determinants. Note that this number of determinants
also corresponds to the convergence of E+PT2 in CIPSI calculations,
confirming for this case that the convergence of the nodal surface can
follow the convergence of E+PT2 instead of the more difficult
variational energy.

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{sCI:table12}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
N\_det
&\sphinxstyletheadfamily 
DMC
&\sphinxstyletheadfamily 
CISPI
\\
\hline
1
&
\sphinxhyphen{}283.0696 (6)
&
\sphinxhyphen{}283.0063
\\
\hline
239
&
\sphinxhyphen{}283.0730 (9)
&
\sphinxhyphen{}282.9063
\\
\hline
44,539
&
\sphinxhyphen{}283.078 (1)
&
\sphinxhyphen{}282.7339
\\
\hline
541,380
&
\sphinxhyphen{}283.088 (1)
&
\sphinxhyphen{}282.6772
\\
\hline
908,128
&
\sphinxhyphen{}283.089 (1)
&
\sphinxhyphen{}282.6775
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{center}Table 12 DMC Energies and CIPSI(E+PT2) of \(C_2O_2H_3N\) in
function of the number of determinants in the trial wavefunction.
\end{center}
As mentioned in previous sections, DMC is variational relative to the
exact nodal surface. A nodal surface is “better” if it lowers DMC
energy. To assess the quality of the nodal surface from CIPSI, we
compare these DMC results to other single\sphinxhyphen{}determinant calculations from
multiple nodal surfaces and theories. \hyperref[\detokenize{sCI:fig15}]{Fig.\@ \ref{\detokenize{sCI:fig15}}} shows
the energy of the \(C_2O_2H_3N\) molecule as a function of different
single\sphinxhyphen{}determinant trial wavefunctions with an aug\sphinxhyphen{}cc\sphinxhyphen{}pVTZ basis set,
including Hartree\sphinxhyphen{}Fock, DFT\sphinxhyphen{}PBE, and hybrid functionals B3LYP and PBE0.
The last four points in the plot show the systematic improvement of the
nodal surface as a function of the number of determinants.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{DMC-Multidet}.jpg}
\caption{DMC energy of the \(C_2O_2H_3N\) molecule as a function of different
single\sphinxhyphen{}determinant trial wavefunctions with aug\sphinxhyphen{}ccp\sphinxhyphen{}VTZ basis set using
nodal surfaces from Hartree\sphinxhyphen{}Fock, DFT\sphinxhyphen{}PBE, and DFT with hybrid
functionals PBE0 and P3LYP. As indicated, the CIPSI trial wavefunction
contains 239, 44539, 514380, and 908128 determinants (D).}\label{\detokenize{sCI:id13}}\label{\detokenize{sCI:fig15}}\end{figure}

When the DMC\sphinxhyphen{}CIPSI energy is converged with respect to the number of
determinants, its nodal surface is still lower than the best SD\sphinxhyphen{}DMC
(B3LYP) by 6(1) mHa. When compared with CCSD(T) with the same basis set,
\(E_{CCSD(T)}\) is 4 mHa higher than DMC\sphinxhyphen{}CIPSI and 2 mHa lower than
DMC\sphinxhyphen{}B3LYP. Although 6 (1) mHa can seem very small, it is important to
remember that CCSD(T) cannot correctly describe multireference systems;
therefore, it is impossible to assess the correctness of the
single\sphinxhyphen{}determinant\textendash{}DMC result, making CIPSI\sphinxhyphen{}DMC calculations an ideal
benchmark tool for multireference systems.




\chapter{Auxiliary\sphinxhyphen{}Field Quantum Monte Carlo}
\label{\detokenize{afqmc:auxiliary-field-quantum-monte-carlo}}\label{\detokenize{afqmc:afqmc}}\label{\detokenize{afqmc::doc}}
The AFQMC method is an orbital\sphinxhyphen{}space formulation of the imaginary\sphinxhyphen{}time propagation algorithm. We refer the reader to one of the review articles on the method \sphinxcite{afqmc:afqmc-review}\sphinxcite{afqmc:physrevlett-90-136401}\sphinxcite{afqmc:physreve-70-056702} for a detailed description of the algorithm. It uses the Hubbard\sphinxhyphen{}Stratonovich transformation to express the imaginary\sphinxhyphen{}time propagator, which is inherently a 2\sphinxhyphen{}body operator, as an integral over 1\sphinxhyphen{}body propagators, which can be efficiently applied to an arbitrary Slater determinant. This transformation allows us to represent the interacting many\sphinxhyphen{}body system as an average over a noninteracting system (e.g., Slater determinants) in a time\sphinxhyphen{}dependent fluctuating external field (the Auxiliary fields). The walkers in this case represent nonorthogonal Slater determinants, whose time average represents the desired quantum state. QMCPACK currently implements the phaseless AFQMC algorithm of Zhang and Krakauer \sphinxcite{afqmc:physrevlett-90-136401}, where a trial wavefunction is used to project the simulation to the real axis, controlling the fermionic sign problem at the expense of a bias. This approximation is similar in spirit to the fixed\sphinxhyphen{}node approximation in real\sphinxhyphen{}space DMC but applied in the Hilbert space where the AFQMC random walk occurs.


\section{Theoretical Background}
\label{\detokenize{afqmc:theoretical-background}}
… coming soon …


\section{Input}
\label{\detokenize{afqmc:input}}
The input for an AFQMC calculation is fundamentally different to the
input for other real\sphinxhyphen{}space algorithms in QMCPACK. The main source of
input comes from the Hamiltonian matrix elements in an appropriate
single particle basis. This must be evaluated by an external code and
saved in a format that QMCPACK can read. More details about file formats
follow. The input file has six basic xml\sphinxhyphen{}blocks: \sphinxcode{\sphinxupquote{AFQMCInfo}},
\sphinxcode{\sphinxupquote{Hamiltonian}}, \sphinxcode{\sphinxupquote{Wavefunction}}, \sphinxcode{\sphinxupquote{WalkerSet}}, \sphinxcode{\sphinxupquote{Propagator}}, and
\sphinxcode{\sphinxupquote{execute}}. The first five define input structures required for various
types of calculations. The \sphinxcode{\sphinxupquote{execute}} block represents actual
calculations and takes as input the other blocks. Nonexecution blocks
are parsed first, followed by a second pass where execution blocks are
parsed (and executed) in order. {\hyperref[\detokenize{afqmc:listing-51}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 51}}}} shows an example of a
minimal input file for an AFQMC calculation.
\hyperref[\detokenize{afqmc:table13}]{Table \ref{\detokenize{afqmc:table13}}} shows a brief description of the most
important parameters in the calculation. All xml sections contain a
“name” argument used to identify the resulting object within QMCPACK.
For example, in the example, multiple Hamiltonian objects with different
names can be defined. The one actually used in the calculation is the
one passed to “execute” as ham.
\sphinxSetupCaptionForVerbatim{Sample input file for AFQMC.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{afqmc:listing-51}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}?xml version=\PYGZdq{}1.0\PYGZdq{}?\PYGZgt{}
\PYGZlt{}simulation method=\PYGZdq{}afqmc\PYGZdq{}\PYGZgt{}
  \PYGZlt{}project id=\PYGZdq{}Carbon\PYGZdq{} series=\PYGZdq{}0\PYGZdq{}/\PYGZgt{}

  \PYGZlt{}AFQMCInfo name=\PYGZdq{}info0\PYGZdq{}\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}NMO\PYGZdq{}\PYGZgt{}32\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}NAEA\PYGZdq{}\PYGZgt{}16\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}NAEB\PYGZdq{}\PYGZgt{}16\PYGZlt{}/parameter\PYGZgt{}
  \PYGZlt{}/AFQMCInfo\PYGZgt{}

  \PYGZlt{}Hamiltonian name=\PYGZdq{}ham0\PYGZdq{} info=\PYGZdq{}info0\PYGZdq{}\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}filename\PYGZdq{}\PYGZgt{}../fcidump.h5\PYGZlt{}/parameter\PYGZgt{}
  \PYGZlt{}/Hamiltonian\PYGZgt{}

  \PYGZlt{}Wavefunction name=\PYGZdq{}wfn0\PYGZdq{} type=\PYGZdq{}MSD\PYGZdq{} info=\PYGZdq{}info0\PYGZdq{}\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}filetype\PYGZdq{}\PYGZgt{}ascii\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}filename\PYGZdq{}\PYGZgt{}wfn.dat\PYGZlt{}/parameter\PYGZgt{}
  \PYGZlt{}/Wavefunction\PYGZgt{}

  \PYGZlt{}WalkerSet name=\PYGZdq{}wset0\PYGZdq{}\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}walker\PYGZus{}type\PYGZdq{}\PYGZgt{}closed\PYGZlt{}/parameter\PYGZgt{}
  \PYGZlt{}/WalkerSet\PYGZgt{}

  \PYGZlt{}Propagator name=\PYGZdq{}prop0\PYGZdq{} info=\PYGZdq{}info0\PYGZdq{}\PYGZgt{}
  \PYGZlt{}/Propagator\PYGZgt{}

  \PYGZlt{}execute wset=\PYGZdq{}wset0\PYGZdq{} ham=\PYGZdq{}ham0\PYGZdq{} wfn=\PYGZdq{}wfn0\PYGZdq{} prop=\PYGZdq{}prop0\PYGZdq{} info=\PYGZdq{}info0\PYGZdq{}\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}timestep\PYGZdq{}\PYGZgt{}0.005\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}blocks\PYGZdq{}\PYGZgt{}10000\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}nWalkers\PYGZdq{}\PYGZgt{}20\PYGZlt{}/parameter\PYGZgt{}
  \PYGZlt{}/execute\PYGZgt{}

\PYGZlt{}/simulation\PYGZgt{}
\end{sphinxVerbatim}

The following list includes all input sections for AFQMC calculations, along with a detailed explanation of accepted parameters. Since the code is under active development, the list of parameters and their interpretation might change in the future.

\sphinxcode{\sphinxupquote{AFQMCInfo}}: Input block that defines basic information about the
calculation. It is passed to all other input blocks to propagate the
basic information: \sphinxcode{\sphinxupquote{\textless{}AFQMCInfo name="info0"\textgreater{}}}
\begin{itemize}
\item {} 
\sphinxstylestrong{NMO}. Number of molecular orbitals, i.e., number of states in the
single particle basis.

\item {} 
\sphinxstylestrong{NAEA}. Number of active electrons\sphinxhyphen{}alpha, i.e., number of spin\sphinxhyphen{}up
electrons.

\item {} 
\sphinxstylestrong{NAEB}. Number of active electrons\sphinxhyphen{}beta, i.e., number of spin\sphinxhyphen{}down
electrons.

\end{itemize}

\sphinxcode{\sphinxupquote{Hamiltonian}}: Controls the object that reads, stores, and manages the
\sphinxcode{\sphinxupquote{hamiltonian}}.
\sphinxcode{\sphinxupquote{\textless{}Hamiltonian name="ham0" type="SparseGeneral" info="info0"\textgreater{}}}
\begin{itemize}
\item {} 
\sphinxstylestrong{filename}. Name of file with the \sphinxcode{\sphinxupquote{Hamiltonian}}. This is a
required parameter.

\item {} 
\sphinxstylestrong{cutoff\_1bar}. Cutoff applied to integrals during reading. Any term
in the Hamiltonian smaller than this value is set to zero. (For
filetype=“hdf5”, the cutoff is applied only to the 2\sphinxhyphen{}electron
integrals). Default: 1e\sphinxhyphen{}8

\item {} 
\sphinxstylestrong{cutoff\_decomposition}. Cutoff used to stop the iterative cycle in
the generation of the Cholesky decomposition of the 2\sphinxhyphen{}electron
integrals. The generation of Cholesky vectors is stopped when the
maximum error in the diagonal reaches this value. In case of an
eigenvalue factorization, this becomes the cutoff applied to the
eigenvalues. Only eigenvalues above this value are kept. Default:
1e\sphinxhyphen{}6

\item {} 
\sphinxstylestrong{nblocks}. This parameter controls the distribution of the
2\sphinxhyphen{}electron integrals among processors. In the default behavior
(nblocks=1), all nodes contain the entire list of integrals. If
nblocks \(>\) 1, the of nodes in the calculation will be split in
nblocks groups. Each node in a given group contains the same subset
of integrals and subsequently operates on this subset during any
further operation that requires the hamiltonian. The maximum number
of groups is NMO. Currently only works for filetype=“hdf5” and the
file must contain integrals. Not yet implemented for input
hamiltonians in the form of Cholesky vectors or for ASCII input.
Coming soon! Default: No distribution

\item {} 
\sphinxstylestrong{printEig}. If “yes”, prints additional information during the
Cholesky decomposition. Default: no

\item {} 
\sphinxstylestrong{fix\_2eint}. If this is set to “yes”, orbital pairs that are
found not to be positive definite are ignored in the generation of
the Cholesky factorization. This is necessary if the 2\sphinxhyphen{}electron
integrals are not positive definite because of round\sphinxhyphen{}off errors in
their generation. Default: no

\end{itemize}

\sphinxcode{\sphinxupquote{Wavefunction}}: controls the object that manages the trial
wavefunctions. This block expects a list of xml\sphinxhyphen{}blocks defining actual
trial wavefunctions for various roles.
\sphinxcode{\sphinxupquote{\textless{}Wavefunction name="wfn0" type="MSD/PHMSD" info="info0"\textgreater{}}}
\begin{itemize}
\item {} 
\sphinxstylestrong{filename}. Name of file with wavefunction information.

\item {} 
\sphinxstylestrong{cutoff}. cutoff applied to the terms in the calculation of the
local energy. Only terms in the Hamiltonian above this cutoff are
included in the evaluation of the energy. Default: 1e\sphinxhyphen{}6

\item {} 
\sphinxstylestrong{nnodes}. Defines the parallelization of the local energy
evaluation and the distribution of the \sphinxcode{\sphinxupquote{Hamiltonian}} matrix (not to
be confused with the list of 2\sphinxhyphen{}electron integrals managed by
\sphinxcode{\sphinxupquote{Hamiltonian}}. These are not the same.) If nnodes \(>\) 1, the
nodes in the simulation are split into groups of nnodes, each group
works collectively in the evaluation of the local energy of their
walkers. This helps distribute the effort involved in the evaluation
of the local energy among the nodes in the group, but also
distributes the memory associated with the wavefunction among the
nodes in the group. Default: No distribution

\item {} 
\sphinxstylestrong{ndet}. Number of determinants to read from file. Default: Read all
determinants.

\item {} 
\sphinxstylestrong{cutoff}. For sparse hamiltoniants, this defines the cutoff applied
to the half\sphinxhyphen{}rotated 2\sphinxhyphen{}electron integrals. Default: 0.0

\item {} 
\sphinxstylestrong{nbatch}. This turns on(\textgreater{}=1)/off(==0) batched calculation of
density matrices and overlaps. \sphinxhyphen{}1 means all the walkers in the batch.
Default: 0 (CPU) / \sphinxhyphen{}1 (GPU)

\item {} 
\sphinxstylestrong{nbatch\_qr}. This turns on(\textgreater{}=1)/off(==0) batched QR calculation. \sphinxhyphen{}1
means all the walkers in the batch. Default: 0 (CPU) / \sphinxhyphen{}1 (GPU)

\end{itemize}

\sphinxcode{\sphinxupquote{WalkerSet}}: Controls the object that handles the set of walkers.
\sphinxcode{\sphinxupquote{\textless{}WalkerSet name="wset0"\textgreater{}}}
\begin{itemize}
\item {} 
\sphinxstylestrong{walker\_type}. Type of walker set: closed or collinear. Default:
collinear

\item {} 
\sphinxstylestrong{pop\_control}. Population control algorithm. Options: “simple”:
Uses a simple branching scheme with a fluctuating population. Walkers
with weight above max\_weight are split into multiple walkers of
weight reset\_weight. Walkers with weight below min\_weight are killed
with probability (weight/min\_weight); “pair”: Fixed\sphinxhyphen{}population
branching algorithm, based on QWalk’s branching algorithm. Pairs of
walkers with weight above/below max\_weight/min\_weight are combined
into 2 walkers with weights equal to \((w_1+w_2)/2\). The
probability of replicating walker w1 (larger weight) occurs with
probability \(w_1/(w_1+w_2)\), otherwise walker w2 (lower weight)
is replicated; “comb”: Fixed\sphinxhyphen{}population branching algorithm based on
the Comb method. Will be available in the next release. Default:
“pair”

\item {} 
\sphinxstylestrong{min\_weight}. Weight at which walkers are possibly killed (with
probability weight/min\_weight). Default: 0.05

\item {} 
\sphinxstylestrong{max\_weight}. Weight at which walkers are replicated. Default: 4.0

\item {} 
\sphinxstylestrong{reset\_weight}. Weight to which replicated walkers are reset to.
Default: 1.0

\end{itemize}

\sphinxcode{\sphinxupquote{Propagator}}: Controls the object that manages the propagators.
\sphinxcode{\sphinxupquote{\textless{}Propagator name="prop0" info="info0"\textgreater{}}}
\begin{itemize}
\item {} 
\sphinxstylestrong{cutoff}. Cutoff applied to Cholesky vectors. Elements of the
Cholesky vectors below this value are set to zero. Only meaningful
with sparse hamiltonians. Default: 1e\sphinxhyphen{}6

\item {} 
\sphinxstylestrong{substractMF}. If “yes”, apply mean\sphinxhyphen{}field subtraction based on the
ImpSamp trial wavefunction. Must set to “no” to turn it off. Default:
yes

\item {} 
\sphinxstylestrong{vbias\_bound}. Upper bound applied to the vias potential.
Components of the vias potential above this value are truncated
there. The bound is currently applied to
\(\sqrt{\tau} v_{bias}\), so a larger value must be used as
either the time step or the fluctuations increase (e.g. from running
a larger system or using a poor trial wavefunction). Default: 3.0

\item {} 
\sphinxstylestrong{apply\_constrain}. If “yes”, apply the phaseless constrain to the
walker propagation. Currently, setting this to “no” produces unknown
behavior, since free propagation algorithm has not been tested.
Default: yes

\item {} 
\sphinxstylestrong{hybrid}. If “yes”, use hybrid propagation algorithm. This
propagation scheme doesn’t use the local energy during propagation,
leading to significant speed ups when its evaluation cost is high.
The local energy of the ImpSamp trial wavefunction is never
evaluated. To obtain energy estimates in this case, you must define
an Estimator xml\sphinxhyphen{}block with the \sphinxcode{\sphinxupquote{Wavefunction}} block. The local
energy of this trial wavefunction is evaluated and printed. It is
possible to use a previously defined trial wavefunction in the
Estimator block, just set its “name” argument to the name of a
previously defined wavefunction. In this case, the same object is
used for both roles. Default: no

\item {} 
\sphinxstylestrong{nnodes}. Controls the parallel propagation algorithm. If nnodes
\(>\) 1, the nodes in the simulation are split into groups of
nnodes nodes, each group working collectively to propagate their
walkers. Default: 1 (Serial algorithm)

\item {} 
\sphinxstylestrong{nbatch}. This turns on(\textgreater{}=1)/off(==0) batched calculation of
density matrices and overlaps. \sphinxhyphen{}1 means all the walkers in the batch.
Default: 0 (CPU) / \sphinxhyphen{}1 (GPU)

\item {} 
\sphinxstylestrong{nbatch\_qr}. This turns on(\textgreater{}=1)/off(==0) batched QR
calculation. \sphinxhyphen{}1 means all the walkers in the batch. Default: 0 (CPU)
/ \sphinxhyphen{}1 (GPU)

\end{itemize}

\sphinxcode{\sphinxupquote{execute}}: Defines an execution region.
\sphinxcode{\sphinxupquote{\textless{}execute wset="wset0" ham="ham0" wfn="wfn0" prop="prop0" info="info0"\textgreater{}}}
\begin{itemize}
\item {} 
\sphinxstylestrong{nWalkers}. Initial number of walkers per core group (see
ncores). This sets the number of walkers for a given gorup of
“ncores” on a node; the total number of walkers in the simulation
depends on the total number of nodes and on the total number of
cores on a node in the following way:
\(\#_walkers_total = nWalkers * \#_nodes * \#_cores_total / ncores\).
Default: 5

\item {} 
\sphinxstylestrong{timestep}. Time step in 1/a.u.
Default: 0.01

\item {} 
\sphinxstylestrong{blocks}. Number of blocks. Slow operations occur once per block
(e.g., write to file, slow observables, checkpoints),
Default: 100

\item {} 
\sphinxstylestrong{step}. Number of steps within a block. Operations that occur at
the step level include load balance, orthogonalization, branching,
etc.
Default: 1

\item {} 
\sphinxstylestrong{substep}. Number of substeps within a step. Only walker
propagation occurs in a substep.
Default: 1

\item {} 
\sphinxstylestrong{ortho}. Number of steps between orthogonalization. Default: 1

\item {} 
\sphinxstylestrong{ncores}. Number of nodes in a task group. This number defines the
number of cores on a node that share the parallel work associated
with a distributed task. This number is used in the \sphinxcode{\sphinxupquote{Wavefunction}}
and \sphinxcode{\sphinxupquote{Propagator}} task groups. The walker sets are shares by the
ncores on a given node in the task group.

\item {} 
\sphinxstylestrong{checkpoint}. Number of blocks between checkpoint files are
generated. If a value smaller than 1 is given, no file is generated.
If \sphinxstylestrong{hdf\_write\_file} is not set, a default name is used. \sphinxstylestrong{Default:
0}

\item {} 
\sphinxstylestrong{hdf\_write\_file}. If set (and checkpoint\textgreater{}0), a checkpoint file with
this name will be written.

\item {} 
\sphinxstylestrong{hdf\_read\_file}. If set, the simulation will be restarted from
the given file.

\end{itemize}

Within the \sphinxcode{\sphinxupquote{Estimators}} xml block has an argument \sphinxstylestrong{name}: the type
of estimator we want to measure. Currently available estimators include:
“basic”, “energy”, “mixed\_one\_rdm”, and “back\_propagation”.

The basic estimator has the following optional parameters:
\begin{itemize}
\item {} 
\sphinxstylestrong{timers}. print timing information. Default: true

\end{itemize}

The back\_propagation estimator has the following parameters:
\begin{itemize}
\item {} 
\sphinxstylestrong{ortho}. Number of back\sphinxhyphen{}propagation steps between
orthogonalization. Default: 10

\item {} 
\sphinxstylestrong{nsteps}. Maximum number of back\sphinxhyphen{}propagation steps. Default: 10

\item {} 
\sphinxstylestrong{naverages}. Number of back propagation calculations to perform.
The number of steps will be chosed equally distributed in the range
0,nsteps. Default: 1

\item {} 
\sphinxstylestrong{block\_size}. Number of blocks to use in the internal average of
the back propagated estimator. This is used to block data and reduce
the size of the output. Default: 1

\item {} 
\sphinxstylestrong{nskip}. Number of blocks to skip at the start of the calculation
for equilibration purposes. Default: 0

\end{itemize}


\section{File formats}
\label{\detokenize{afqmc:file-formats}}
QMCPACK offers three factorization approaches which are appropriate in different settings. The most generic approach implemented
is based on the modified\sphinxhyphen{}Cholesky
factorization \sphinxcite{afqmc:beebecholesky1977}\sphinxcite{afqmc:kochcholesky2003}\sphinxcite{afqmc:aquilantemolcas2009}\sphinxcite{afqmc:purwantoca2011}\sphinxcite{afqmc:purwantodownfolding2013} of the ERI
tensor:
\begin{equation}\label{equation:afqmc:eq58}
\begin{split}v_{pqrs} = V_{(pr),(sq)} \approx \sum_n^{N_\mathrm{chol}} L_{pr,n} L^{*}_{sq,n},\end{split}
\end{equation}
where the sum is truncated at \(N_{\mathrm{chol}} = x_c M\),
\(x_c\) is typically between \(5\) and \(10\), \(M\) is
the number of basis functions and we have assumed that the
single\sphinxhyphen{}particle orbitals are in general complex. The storage requirement
is thus naively \(\mathcal{O}(M^3)\). Note we follow the usual
definition of \(v_{pqrs} = \langle pq | rs \rangle = (pr|qs)\). With
this form of factorization QMCPACK allows for the integrals to be stored
in either dense or sparse format.

The dense case is the simplest and is only implemented for Hamiltonians
with \sphinxstyleemphasis{real} integrals (and basis functions, i.e. not the homegeneous
electron gas which has complex orbitals but real integrals). The file
format is given as follows:
\sphinxSetupCaptionForVerbatim{Sample Dense Cholesky QMCPACK Hamtiltonian.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{afqmc:listing-52}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} h5dump \PYGZhy{}n afqmc.h5
HDF5 \PYGZdq{}afqmc.h5\PYGZdq{} \PYGZob{}
    FILE\PYGZus{}CONTENTS \PYGZob{}
        group      /
        group      /Hamiltonian
        group      /Hamiltonian/DenseFactorized
        dataset    /Hamiltonian/DenseFactorized/L
        dataset    /Hamiltonian/dims
        dataset    /Hamiltonian/hcore
        dataset    /Hamiltonian/Energies
    \PYGZcb{}
\PYGZcb{}
\end{sphinxVerbatim}

where the datasets are given by the following
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/DenseFactorized/L}} Contains the \([M^2,N_\mathrm{nchol}]\) dimensional matrix
representatation of \(L_{pr,n}\).

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/dims}} Descriptor array of length 8 containing
\([0,0,0,M,N_\alpha,N_\beta,0,N_\mathrm{nchol}]\). Note that
\(N_\alpha\) and \(N_\beta\) are somewhat redundant and will
be read from the input file and wavefunction. This allows for the
Hamiltonian to be used with different (potentially spin polarized)
wavefunctions.

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/hcore}} Contains the \([M,M]\) dimensional one\sphinxhyphen{}body Hamiltonian matrix
elements \(h_{pq}\).

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/Energies}} Array containing \([E_{II}, E_{\mathrm{core}}]\).
\(E_{II}\) should contain ion\sphinxhyphen{}ion repulsion energy and any
additional constant terms which have to be added to the total energy.
\(E_{\mathrm{core}}\) is deprecated and not used.

\end{itemize}

Typically the Cholesky matrix is sparse, particularly if written in the
non\sphinxhyphen{}orthogonal AO basis (not currently supported in QMCPACK). In this
case only a small number of non\sphinxhyphen{}zero elements (denoted \(nnz\)
below) need to be stored which can reduce the memory overhead
considerably. Internally QMCPACK stores this matrix in the CSR format,
and the HDF5 file format is reflective of this. For large systems and,
more generally when running in parallel, it is convenient to chunk the
writing/reading of the Cholesky matrix into blocks of size
\([M^2,\frac{N_{\mathrm{chol}}}{N_{\mathrm{blocks}}}]\) (if
interpreted as a dense array). This is achieved by writing these blocks
to different data sets in the file. For the sparse case the Hamtiltonian
file format is given as follows:
\sphinxSetupCaptionForVerbatim{Sample Sparse Cholesky QMCPACK Hamtiltonian.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{afqmc:listing-53}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} h5dump \PYGZhy{}n afqmc.h5
HDF5 \PYGZdq{}afqmc.h5\PYGZdq{} \PYGZob{}
    FILE\PYGZus{}CONTENTS \PYGZob{}
        group      /
        group      /Hamiltonian
        group      /Hamiltonian/Factorized
        dataset    /Hamiltonian/Factorized/block\PYGZus{}sizes
        dataset    /Hamiltonian/Factorized/index\PYGZus{}0
        dataset    /Hamiltonian/Factorized/vals\PYGZus{}0
        dataset    /Hamiltonian/ComplexIntegrals
        dataset    /Hamiltonian/dims
        dataset    /Hamiltonian/hcore
        dataset    /Hamiltonian/Energies
    \PYGZcb{}
\PYGZcb{}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/Factorized/block\_sizes}} Contains the number of elements in each block of the sparse
representation of the Cholesky matrix \(L_{pr,n}\). In this case
there is 1 block.

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/Factorized/index\_0}} \([2\times nnz]\) dimensional array, containing the indices of
the non\sphinxhyphen{}zero values of \(L_{ik,n}\). The row indices are stored
in the even entries, and the column indices in the odd entries.

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/Factorized/vals\_0}} \([nnz]\) length array containing non\sphinxhyphen{}zero values of
\(L_{pr,n}\) for chunk 0.

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/dims}} Descriptor array of length 8 containing
\([0,nnz,N_{\mathrm{block}},M,N_\alpha,N_\beta,0,N_\mathrm{nchol}]\).

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/ComplexIntegrals}} Length 1 array that specifies if integrals are complex valued. 1
for complex integrals, 0 for real integrals.

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/hcore}} Contains the \([M,M]\) dimensional one\sphinxhyphen{}body Hamiltonian matrix
elements \(h_{pq}\). Due to its small size this is written as a
dense 2D\sphinxhyphen{}array.

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/Energies}} Array containing \([E_{II}, E_{\mathrm{core}}]\).
\(E_{II}\) should contain ion\sphinxhyphen{}ion repulsion energy and any
additional constant terms which have to be added to the total energy.
\(E_{\mathrm{core}}\) is deprecated and not used.

\end{itemize}

To reduce the memory overhead of storing the three\sphinxhyphen{}index tensor we recently adapted the
tensor\sphinxhyphen{}hypercontraction \sphinxcite{afqmc:hohensteinthci2012}\sphinxcite{afqmc:parrishthcii2012}\sphinxcite{afqmc:hohensteinthciii2012} (THC) approach for use in AFQMCcite\{MaloneISDF2019\}. Within the THC approach we
can approximate the orbital products entering the ERIs as
\begin{equation}\label{equation:afqmc:eq59}
\begin{split}\varphi^{*}_p(\mathbf{r})\varphi_r(\mathbf{r}) \approx \sum_\mu^{N_\mu} \zeta_\mu(\mathbf{r}) \varphi^*_p(\mathbf{r}_\mu)\varphi_r(\mathbf{r}_\mu),\end{split}
\end{equation}
where \(\varphi_p(\mathbf{r})\) are the one\sphinxhyphen{}electron orbitals and
\(\mathbf{r}_\mu\) are a set of specially selected interpolating
points, \(\zeta_\mu(\mathbf{r})\) are a set of interpolating vectors
and \(N_\mu = x_\mu M\). We can then write the ERI tensor as a
product of rank\sphinxhyphen{}2 tensors
\begin{equation}\label{equation:afqmc:eq60}
\begin{split}v_{pqrs} \approx \sum_{\mu\nu} \varphi^{*}_p(\mathbf{r}_\mu)\varphi_r(\mathbf{r}_\mu) M_{\mu\nu} \varphi^{*}_q(\mathbf{r}_\nu)\varphi_s(\mathbf{r}_\nu),\end{split}
\end{equation}
where
\begin{equation}\label{equation:afqmc:eq61}
\begin{split}M_{\mu\nu} = \int d\mathbf{r}d\mathbf{r}' \zeta_\mu(\mathbf{r})\frac{1}{|\mathbf{r}-\mathbf{r}'|}\zeta^{*}_\nu(\mathbf{r}').\end{split}
\end{equation}
We also require the half\sphinxhyphen{}rotated versions of these quantities which live
on a different set of \(\tilde{N}_\mu\) interpolating points
\(\tilde{\mathbf{r}}_\mu\) (see \sphinxcite{afqmc:maloneisdf2019}). The file format for THC
factorization is as follows:
\sphinxSetupCaptionForVerbatim{Sample Sparse Cholesky QMCPACK Hamtiltonian.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{afqmc:listing-54}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} h5dump \PYGZhy{}n afqmc.h5
HDF5 \PYGZdq{}afqmc.h5\PYGZdq{} \PYGZob{}
    FILE\PYGZus{}CONTENTS \PYGZob{}
        group      /
        group      /Hamiltonian
        group      /Hamiltonian/THC
        dataset    /Hamiltonian/THC/Luv
        dataset    /Hamiltonian/THC/Orbitals
        dataset    /Hamiltonian/THC/HalfTransformedMuv
        dataset    /Hamiltonian/THC/HalfTransformedFullOrbitals
        dataset    /Hamiltonian/THC/HalfTransformedOccOrbitals
        dataset    /Hamiltonian/THC/dims
        dataset    /Hamiltonian/ComplexIntegrals
        dataset    /Hamiltonian/dims
        dataset    /Hamiltonian/hcore
        dataset    /Hamiltonian/Energies
    \PYGZcb{}
\PYGZcb{}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/THC/Luv}} Cholesky factorization of the \(M_{\mu\nu}\) matrix given in \eqref{equation:afqmc:eq61}.

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/THC/Orbitals}} \([M,N_\mu]\) dimensional array of orbitals evaluated at chosen
interpolating points \(\varphi_i(\mathbf{r}_\mu)\).

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/THC/HalfTransformedMuv}} \([\tilde{N}_\mu,\tilde{N}_\mu]\) dimensional array containing
half\sphinxhyphen{}transformed \(\tilde{M}_{\mu\nu}\).

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/THC/HalfTransformedFullOrbitals}} \([M,\tilde{N}_\mu]\) dimensional array containing orbital set
computed at half\sphinxhyphen{}transformed interpolating points
\(\varphi_i(\tilde{\mathbf{r}}_\mu)\).

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/THC/HalfTransformedOccOrbitals}} \([N_\alpha+N_\beta,\tilde{N}_\mu]\) dimensional array
containing half\sphinxhyphen{}rotated orbital set computed at half\sphinxhyphen{}transformed
interpolating points
\(\varphi_a(\tilde{\mathbf{r}}_\mu) = \sum_{p} A_{pa}^* \varphi_{p}(\tilde{\mathbf{r}}_\mu)\),
where \(\mathbf{A}\) is the Slater\sphinxhyphen{}Matrix of the (currently
single\sphinxhyphen{}determinant) trial wavefunction.

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/THC/dims}} Descriptor array containing \([M, N_\mu, \tilde{N}_\mu]\).

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/ComplexIntegrals}} Length 1 array that specifies if integrals are complex valued. 1
for complex integrals, 0 for real integrals.

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/dims}} Descriptor array of length 8 containing
\([0,0,0,M,N_\alpha,N_\beta,0,0]\).

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/hcore}} Contains the \([M,M]\) dimensional one\sphinxhyphen{}body Hamiltonian matrix
elements \(h_{ij}\).

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/Energies}} Array containing \([E_{II}, E_{\mathrm{core}}]\).
\(E_{II}\) should contain ion\sphinxhyphen{}ion repulsion energy and any
additional constant terms which have to be added to the total energy
(such as the electron\sphinxhyphen{}electron interaction Madelung contribution of
\(\frac{1}{2} N \xi )\). \(E_{\mathrm{core}}\) is deprecated
and not used.

\end{itemize}

Finally, we have implemented an explicitly \(k\)\sphinxhyphen{}point dependent factorization for periodic systems \sphinxcite{afqmc:mottakpoint2019}\sphinxcite{afqmc:malonegpu2020}
\begin{equation}\label{equation:afqmc:eq62}
\begin{split}v_{pqrs} = \sum_{\substack{n\textbf{Q}\textbf{k}\textbf{k}' \\ pqrs\sigma\sigma'}} L^{\textbf{Q},\textbf{k}}_{pr,n} {L^{\textbf{Q},\textbf{k}'}_{sq,n}}^{*}\end{split}
\end{equation}
where \(\textbf{k}\), \(\textbf{k}'\) and \(\textbf{Q}\) are
vectors in the first Brillouin zone. The one\sphinxhyphen{}body Hamiltonian is block
diagonal in \(\textbf{k}\) and in \eqref{equation:afqmc:eq62} we have used
momentum conservation
\((\textbf{k}_p - \textbf{k}_r + \textbf{k}_q - \textbf{k}_s) = \textbf{G}\)
with \(\textbf{G}\) being some vector in the reciprocal lattice of
the simulation cell. The convention for the Cholesky matrix
\(L^{\textbf{Q},\textbf{k}}_{pr,\gamma}\) is as follows:
\(\textbf{k}_r = \textbf{k}_p - \textbf{Q}\), so the vector
\(\textbf{k}\) labels the \sphinxstyleemphasis{k}\sphinxhyphen{}point of the first band index,
\(\textit{p}\), while the \sphinxstyleemphasis{k}\sphinxhyphen{}point vector of the second band index,
\(\textit{r}\), is given by \(\textbf{k} - \textbf{Q}\).
Electron repulsion integrals at different \(\textbf{Q}\) vectors are
zero by symmetry, resulting in a reduction in the number of required
\(\mathbf{Q}\) vectors. For certain \(\textbf{Q}\) vectors that
satisfy \(\textbf{Q} \ne -\textbf{Q}\) (this is not satisfied at the
origin and at high symmetry points on the edge of the 1BZ), we have
\({L^{\textbf{Q},\textbf{k}}_{sq,\gamma}}^{*} = {L^{-\textbf{Q},\textbf{k}-\textbf{Q}}_{qs,\gamma}}\),
which requires us to store Cholesky vectors for either one of the
\((\textbf{Q},-\textbf{Q})\) pair, but not both.

In what follows let \(m_{\mathbf{k}}\) denote the number of basis
functions for basis functions of a given \(k\)\sphinxhyphen{}point (these can in
principle differ for different \(k\)\sphinxhyphen{}points due to linear
dependencies), \(n^{\alpha}_{\mathbf{k}}\) the number of
\(\alpha\) electrons in a given \(k\)\sphinxhyphen{}point and
\(n_{\mathrm{chol}}^{\mathbf{Q}_n}\) the number of Cholesky vectors
for momentum transfer \(\mathbf{Q}_n\). The file format for this
factorization is as follows (for a \(2\times2\times2\)
\(k\)\sphinxhyphen{}point mesh, for denser meshes generally there will be far
fewer symmetry inequivalent momentum transfer vectors than there are
\(k\)\sphinxhyphen{}points):
\sphinxSetupCaptionForVerbatim{Sample Dense \(k\)\sphinxhyphen{}point dependent Cholesky QMCPACK Hamtiltonian.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{afqmc:listing-55}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} h5dump \PYGZhy{}n afqmc.h5
HDF5 \PYGZdq{}afqmc.h5\PYGZdq{} \PYGZob{}
    FILE\PYGZus{}CONTENTS \PYGZob{}
        group      /
        group      /Hamiltonian
        group      /Hamiltonian/KPFactorized
        dataset    /Hamiltonian/KPFactorized/L0
        dataset    /Hamiltonian/KPFactorized/L1
        dataset    /Hamiltonian/KPFactorized/L2
        dataset    /Hamiltonian/KPFactorized/L3
        dataset    /Hamiltonian/KPFactorized/L4
        dataset    /Hamiltonian/KPFactorized/L5
        dataset    /Hamiltonian/KPFactorized/L6
        dataset    /Hamiltonian/KPFactorized/L7
        dataset    /Hamiltonian/NCholPerKP
        dataset    /Hamiltonian/MinusK
        dataset    /Hamiltonian/NMOPerKP
        dataset    /Hamiltonian/QKTok2
        dataset    /Hamiltonian/H1\PYGZus{}kp0
        dataset    /Hamiltonian/H1\PYGZus{}kp1
        dataset    /Hamiltonian/H1\PYGZus{}kp2
        dataset    /Hamiltonian/H1\PYGZus{}kp3
        dataset    /Hamiltonian/H1\PYGZus{}kp4
        dataset    /Hamiltonian/H1\PYGZus{}kp5
        dataset    /Hamiltonian/H1\PYGZus{}kp6
        dataset    /Hamiltonian/H1\PYGZus{}kp7
        dataset    /Hamiltonian/ComplexIntegrals
        dataset    /Hamiltonian/KPoints
        dataset    /Hamiltonian/dims
        dataset    /Hamiltonian/Energies
    \PYGZcb{}
\PYGZcb{}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/KPFactorized/L{[}n{]}}} This series of datasets store elements of the Cholesky tensors
\(L[\mathbf{Q}_n,\mathbf{k},pr,n]\). Each data set is of
dimension
\([N_k,m_{\mathbf{k}}\times m_{\mathbf{k}'},n^{\mathbf{Q}_n}_\mathrm{chol}]\),
where, again, \(k\) is the \(k\)\sphinxhyphen{}point associated with basis
function \(p\), the \(k\)\sphinxhyphen{}point of basis function \(r\)
is defined via the mapping \sphinxcode{\sphinxupquote{QKtok2}}.

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/NCholPerKP}} \(N_k\) length array giving number of Cholesky vectors per
\(k\)\sphinxhyphen{}point.

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/MinusK}}: \(N_k\) length array mapping a
\(k\)\sphinxhyphen{}point to its inverse: \(\mathbf{k}_i+\)\sphinxcode{\sphinxupquote{MinusK{[}i{]}}}
\(= \mathbf{0} \mod \mathbf{G}\).

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/NMOPerKP}}: \(N_k\) length array listing number of
basis functions per \(k\)\sphinxhyphen{}point.

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/QKTok2}}: \([N_k,N_k]\) dimensional array.
\sphinxcode{\sphinxupquote{QKtok2{[}i,j{]}}} yields the \(k\) point index satisfying
\(\mathbf{k}=\mathbf{Q}_i-\mathbf{k}_j+\mathbf{G}\).

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/dims}}: Descriptor array of length 8 containing
\([0,0,0,M,N_\alpha,N_\beta,0,0]\).

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/H1\_kp{[}n{]}}} Contains the \([m_{\mathbf{k}_n},m_{\mathbf{k}_n}]\)
dimensional one\sphinxhyphen{}body Hamiltonian matrix elements
\(h_{(\mathbf{k}_{n}p)(\mathbf{k}_{n}q)}\).

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/ComplexIntegrals}} Length 1 array that specifies if integrals are complex valued. 1
for complex integrals, 0 for real integrals.

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/KPoints}} \([N_k,3]\) Dimensional array containing \(k\)\sphinxhyphen{}points used to
sample Brillouin zone.

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/dims}} Descriptor array of length 8 containing
\([0,0,N_k,M,N_\alpha,N_\beta,0,N_\mathrm{nchol}]\). Note that
\(M\) is the total number of basis functions, i.e.
\(M=\sum_\mathbf{k} m_\mathbf{k}\), and likewise for the number
of electrons.

\item {} 
\sphinxcode{\sphinxupquote{/Hamiltonian/Energies}} Array containing \([E_{II}, E_{\mathrm{core}}]\).
\(E_{II}\) should contain ion\sphinxhyphen{}ion repulsion energy and any
additional constant terms which have to be added to the total energy
(such as the electron\sphinxhyphen{}electron interaction Madelung contribution of
\(\frac{1}{2} N \xi )\). \(E_{\mathrm{core}}\) is deprecated
and not used.

\end{itemize}

Complex integrals should be written as an array with an additional dimension, e.g., a 1D array should be written as a 2D array with \sphinxcode{\sphinxupquote{array\_hdf5{[}:,0{]}=real(1d\_array)}} and \sphinxcode{\sphinxupquote{array\_hdf5{[}:,1{]}=imag(1d\_array)}}. The functions \sphinxcode{\sphinxupquote{afqmctools.utils.misc.from\_qmcpack\_complex}} and \sphinxcode{\sphinxupquote{afqmctools.utils.misc.to\_qmcpack\_complex}} can be used to transform qmcpack format to complex valued numpy arrays of the appropriate shape and vice versa.

Finally, if using external tools to generate this file format, we provide a sanity checker script in \sphinxcode{\sphinxupquote{utils/afqmctools/bin/test\_afqmc\_input.py}} which will raise errors if the format does not conform to what is being used internally.


\section{Advice/Useful Information}
\label{\detokenize{afqmc:advice-useful-information}}
AFQMC calculations are computationally expensive and require some care to obtain reasonable performance.
The following is a growing list of useful advice for new users, followed by a sample input for a large calculation.
\begin{itemize}
\item {} 
Generate Cholesky\sphinxhyphen{}decomposed integrals with external codes instead of
the 2\sphinxhyphen{}electron integrals directly. The generation of the Cholesky
factorization is faster and consumes less memory.

\item {} 
Use the hybrid algorithm for walker propagation. Set steps/substeps
to adequate values to reduce the number of energy evaluations. This
is essential when using large multideterminant expansions.

\item {} 
Adjust cutoffs in the wavefunction and propagator bloxks until
desired accuracy is reached. The cost of the calculation will depend
on these cutoffs.

\item {} 
Adjust ncores/nWalkers to obtain better efficiency. Larger nWalkers
will lead to more efficient linear algebra operations but will
increase the time per step. Larger ncores will reduce the time per
step but will reduce efficiency because of inefficiencies in the
parallel implementation. For large calculations, values between 6\textendash{}12
for both quantities should be reasonable, depending on architecture.

\end{itemize}
\sphinxSetupCaptionForVerbatim{Example of sections of an AFQMC input file for a large calculation.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{afqmc:listing-56}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

  \PYG{o}{\PYGZlt{}}\PYG{n}{Hamiltonian} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ham0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SparseGeneral}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{info}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{info0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{filename}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{fcidump}\PYG{o}{.}\PYG{n}{h5}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cutoff\PYGZus{}1bar}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cutoff\PYGZus{}decomposition}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Hamiltonian}\PYG{o}{\PYGZgt{}}

  \PYG{o}{\PYGZlt{}}\PYG{n}{Wavefunction} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{wfn0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MSD}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{info}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{info0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{filetype}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ascii}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{filename}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{wfn}\PYG{o}{.}\PYG{n}{dat}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Wavefunction}\PYG{o}{\PYGZgt{}}

  \PYG{o}{\PYGZlt{}}\PYG{n}{WalkerSet} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{wset0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{walker\PYGZus{}type}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{closed}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{WalkerSet}\PYG{o}{\PYGZgt{}}

  \PYG{o}{\PYGZlt{}}\PYG{n}{Propagator} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{prop0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{info}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{info0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hybrid}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{yes}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Propagator}\PYG{o}{\PYGZgt{}}

  \PYG{o}{\PYGZlt{}}\PYG{n}{execute} \PYG{n}{wset}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{wset0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{ham}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ham0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{wfn}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{wfn0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{prop}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{prop0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{info}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{info0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ncores}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{8}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.01}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{10000}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{steps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{10}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{substeps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{5}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nWalkers}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{8}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ortho}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{5}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{execute}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\section{Using PySCF to generate integrals for AFQMC}
\label{\detokenize{afqmc:using-pyscf-to-generate-integrals-for-afqmc}}\label{\detokenize{afqmc:pyscf}}
PySCF (\sphinxurl{https://github.com/sunqm/pyscf}) is a collection of electronic structure programs powered by Python. It is the recommended program for the generation of input for AFQMC calculations in QMCPACK. We refer the reader to the documentation of the code (\sphinxurl{http://sunqm.github.io/pyscf/}) for a detailed description of the features and the functionality of the code. While the notes below are not meant to replace a detailed study of the PySCF documentation, these notes describe useful knowledge and tips in the use of pyscf for the generation of input for QMCPACK.

For molecular systems or periodic calculations at the Gamma point, PySCF provides a routine that generates the integral file in Molpro’s FCIDUMP format, which contains all the information needed to run AFQMC with a single determinant trial wave\sphinxhyphen{}function. Below is an example using this routine to generate the FCIDUMP file for an 8\sphinxhyphen{}atom unit cell of carbon in the diamond structure with HF orbitals. For a detailed description, see PySCF’s documentation.
\sphinxSetupCaptionForVerbatim{Simple example showing how to generate FCIDUMP files with PySCF}
\def\sphinxLiteralBlockLabel{\label{\detokenize{afqmc:listing-57}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy}
\PYG{k+kn}{from} \PYG{n+nn}{pyscf}\PYG{n+nn}{.}\PYG{n+nn}{tools} \PYG{k+kn}{import} \PYG{n}{fcidump}
\PYG{k+kn}{from} \PYG{n+nn}{pyscf}\PYG{n+nn}{.}\PYG{n+nn}{pbc} \PYG{k+kn}{import} \PYG{n}{gto}\PYG{p}{,} \PYG{n}{scf}\PYG{p}{,} \PYG{n}{tools}

\PYG{n}{cell} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{Cell}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{cell}\PYG{o}{.}\PYG{n}{a} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{  3.5668 0 0}
\PYG{l+s+s1}{  0 3.5668 0}
\PYG{l+s+s1}{  0 0 3.5668}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{cell}\PYG{o}{.}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{  C 0. 0. 0.}
\PYG{l+s+s1}{  C 0.8917 0.8917 0.8917}
\PYG{l+s+s1}{  C 1.7834 1.7834 0.}
\PYG{l+s+s1}{  C 2.6751 2.6751 0.8917}
\PYG{l+s+s1}{  C 1.7834 0. 1.7834}
\PYG{l+s+s1}{  C 2.6751 0.8917 2.6751}
\PYG{l+s+s1}{  C 0. 1.7834 1.7834}
\PYG{l+s+s1}{  C 0.8917 2.6751 2.6751}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{cell}\PYG{o}{.}\PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gth\PYGZhy{}szv}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{cell}\PYG{o}{.}\PYG{n}{pseudo} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gth\PYGZhy{}pade}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{cell}\PYG{o}{.}\PYG{n}{gs} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{3} \PYG{c+c1}{\PYGZsh{} for testing purposes, must be increased for converged results}
\PYG{n}{cell}\PYG{o}{.}\PYG{n}{verbose} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{n}{cell}\PYG{o}{.}\PYG{n}{build}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{mf} \PYG{o}{=} \PYG{n}{scf}\PYG{o}{.}\PYG{n}{RHF}\PYG{p}{(}\PYG{n}{cell}\PYG{p}{)}
\PYG{n}{ehf} \PYG{o}{=} \PYG{n}{mf}\PYG{o}{.}\PYG{n}{kernel}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HF energy (per unit cell) = }\PYG{l+s+si}{\PYGZpc{}.17g}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{ehf}\PYG{p}{)}

\PYG{n}{c} \PYG{o}{=} \PYG{n}{mf}\PYG{o}{.}\PYG{n}{mo\PYGZus{}coeff}
\PYG{n}{h1e} \PYG{o}{=} \PYG{n}{reduce}\PYG{p}{(}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{,} \PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{T}\PYG{p}{,} \PYG{n}{mf}\PYG{o}{.}\PYG{n}{get\PYGZus{}hcore}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{eri} \PYG{o}{=} \PYG{n}{mf}\PYG{o}{.}\PYG{n}{with\PYGZus{}df}\PYG{o}{.}\PYG{n}{ao2mo}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,}\PYG{n}{compact}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} nuclear energy + electronic ewald}
\PYG{n}{e0} \PYG{o}{=} \PYG{n}{cell}\PYG{o}{.}\PYG{n}{energy\PYGZus{}nuc}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{n}{tools}\PYG{o}{.}\PYG{n}{pbc}\PYG{o}{.}\PYG{n}{madelung}\PYG{p}{(}\PYG{n}{cell}\PYG{p}{,} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{cell}\PYG{o}{.}\PYG{n}{nelectron} \PYG{o}{*} \PYG{o}{\PYGZhy{}}\PYG{o}{.}\PYG{l+m+mi}{5}
\PYG{n}{fcidump}\PYG{o}{.}\PYG{n}{from\PYGZus{}integrals}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fcidump.dat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{h1e}\PYG{p}{,} \PYG{n}{eri}\PYG{p}{,} \PYG{n}{c}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cell}\PYG{o}{.}\PYG{n}{nelectron}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}8}\PYG{p}{,} \PYG{n}{nuc}\PYG{o}{=}\PYG{n}{e0}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{center}\sphinxcode{\sphinxupquote{afqmc}} method
\end{center}
parameters in \sphinxcode{\sphinxupquote{AFQMCInfo}}


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{afqmc:table13}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{NMO}}
&
integer
&
\(\geq  0\)
&
no
&
Number of molecular orbitals
\\
\hline
\sphinxcode{\sphinxupquote{NAEA}}
&
integer
&
\(\geq  0\)
&
no
&
Number of active electrons of spin\sphinxhyphen{}up
\\
\hline
\sphinxcode{\sphinxupquote{NAEB}}
&
integer
&
\(\geq  0\)
&
no
&
Number of active electrons of spin\sphinxhyphen{}down
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

parameters in \sphinxcode{\sphinxupquote{Hamiltonian}}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{info}}
&
argument
&&&
Name of \sphinxcode{\sphinxupquote{AFQMCInfo}} block
\\
\hline
\sphinxcode{\sphinxupquote{filename}}
&
string
&&
no
&
Name of file with the hamiltonian
\\
\hline
\sphinxcode{\sphinxupquote{filetype}}
&
string
&
hdf5
&
yes
&
Native HDF5\sphinxhyphen{}based format of QMCPACK
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

parameters in \sphinxcode{\sphinxupquote{Wavefunction}}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{info}}
&
argument
&&&
name of \sphinxcode{\sphinxupquote{AFQMCInfo}} block
\\
\hline
\sphinxcode{\sphinxupquote{type}}
&
argument
&
MSD, PHMSD
&
no
&
Linear combination of (assumed non\sphinxhyphen{}orthogonal) Slater determinants
\\
\hline
\sphinxcode{\sphinxupquote{filetype}}
&
string
&
ascii, hdf5
&
no
&
CI\sphinxhyphen{}type multi\sphinxhyphen{}determinant wave function
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

parameters in \sphinxcode{\sphinxupquote{WalkerSet}}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{walker\_type}}
&
string
&
collinear
&
yes
&
Request a collinear walker set.
\\
\hline&&
closed
&
no
&
Request a closed shell (doubly\sphinxhyphen{}occupied) walker set.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

parameters in \sphinxcode{\sphinxupquote{Propagator}}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}
&
argument
&
afqmc
&
afqmc
&
Type of propagator
\\
\hline
\sphinxcode{\sphinxupquote{info}}
&
argument
&&&
Name of \sphinxcode{\sphinxupquote{AFQMCInfo}} block
\\
\hline
\sphinxcode{\sphinxupquote{hybrid}}
&
string
&
yes
&&
Use hybrid propagation algorithm.
\\
\hline&&
no
&&
Use local energy based propagation algorithm.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

parameters in \sphinxcode{\sphinxupquote{execute}}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{wset}}
&
argument
&&&\\
\hline
\sphinxcode{\sphinxupquote{ham}}
&
argument
&&&\\
\hline
\sphinxcode{\sphinxupquote{wfn}}
&
argument
&&&\\
\hline
\sphinxcode{\sphinxupquote{prop}}
&
argument
&&&\\
\hline
\sphinxcode{\sphinxupquote{info}}
&
argument
&&&
Name of \sphinxcode{\sphinxupquote{AFQMCInfo}} block
\\
\hline
\sphinxcode{\sphinxupquote{nWalkers}}
&
integer
&
\(\geq 0\)
&
5
&
Initial number of walkers per task group
\\
\hline
\sphinxcode{\sphinxupquote{timestep}}
&
real
&
\(> 0\)
&
0.01
&
Time step in 1/a.u.
\\
\hline
\sphinxcode{\sphinxupquote{blocks}}
&
integer
&
\(\geq 0\)
&
100
&
Number of blocks
\\
\hline
\sphinxcode{\sphinxupquote{step}}
&
integer
&
\(> 0\)
&
1
&
Number of steps within a block
\\
\hline
\sphinxcode{\sphinxupquote{substep}}
&
integer
&
\(> 0\)
&
1
&
Number of substeps within a step
\\
\hline
\sphinxcode{\sphinxupquote{ortho}}
&
integer
&
\(> 0\)
&
1
&
Number of steps between walker orthogonalization.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}




\chapter{Examples}
\label{\detokenize{examples:examples}}\label{\detokenize{examples:id1}}\label{\detokenize{examples::doc}}
\sphinxstylestrong{WARNING: THESE EXAMPLES ARE NOT CONVERGED! YOU MUST CONVERGE
PARAMETERS (SIMULATION CELL SIZE, JASTROW PARAMETER NUMBER/CUTOFF, TWIST
NUMBER, DMC TIME STEP, DFT PLANE WAVE CUTOFF, DFT K\sphinxhyphen{}POINT MESH, ETC.)
FOR REAL CALCUATIONS!}

The following examples should run in serial on a modern workstation in a few hours.


\section{Using QMCPACK directly}
\label{\detokenize{examples:using-qmcpack-directly}}
In \sphinxcode{\sphinxupquote{examples/molecules}} are the following examples.
Each directory also contains a \sphinxcode{\sphinxupquote{README}} file with more details.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Directory
&
Description
\\
\hline
\sphinxcode{\sphinxupquote{H20}}
&
H2O molecule from GAMESS orbitals
\\
\hline
\sphinxcode{\sphinxupquote{He}}
&
Helium atom with simple wavefunctions
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Using Nexus}
\label{\detokenize{examples:using-nexus}}
For more information about Nexus, see the User Guide in \sphinxcode{\sphinxupquote{nexus/documentation}}.

For Python to find the Nexus library, the PYTHONPATH environment variable should be set to \sphinxcode{\sphinxupquote{\textless{}QMCPACK source\textgreater{}/nexus/library}}.
For these examples to work properly, the executables for QE and QMCPACK either
need to be on the path, or the paths in the script should be adjusted.

These examples can be found under the \sphinxcode{\sphinxupquote{nexus/examples/qmcpack}} directory.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Directory
&
Description
\\
\hline
\sphinxcode{\sphinxupquote{diamond}}
&
Bulk diamond with VMC
\\
\hline
\sphinxcode{\sphinxupquote{graphene}}
&
Graphene sheet with DMC
\\
\hline
\sphinxcode{\sphinxupquote{c20}}
&
C20 cage molecule
\\
\hline
\sphinxcode{\sphinxupquote{oxygen\_dimer}}
&
Binding curve for O\(_2\) molecule
\\
\hline
\sphinxcode{\sphinxupquote{H2O}}
&
H\(_2\)O molecule with QE orbitals
\\
\hline
\sphinxcode{\sphinxupquote{LiH}}
&
LiH crystal with QE orbitals
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\chapter{Lab 1: MC Statistical Analysis}
\label{\detokenize{lab_qmc_statistics:lab-1-mc-statistical-analysis}}\label{\detokenize{lab_qmc_statistics:lab-qmc-statistics}}\label{\detokenize{lab_qmc_statistics::doc}}

\section{Topics covered in this lab}
\label{\detokenize{lab_qmc_statistics:topics-covered-in-this-lab}}
This lab focuses on the basics of analyzing data from MC calculations.
In this lab, participants will use data from VMC calculations of a
simple 1\sphinxhyphen{}electron system with an analytically soluble system (the ground
state of the hydrogen atom) to understand how to interpret an MC
situation. Most of these analyses will also carry over to DMC
simulations. Topics covered include:
\begin{itemize}
\item {} 
Averaging MC variables

\item {} 
The statisical error bar of mean values

\item {} 
The effects of autocorrelation and variance on the error bar

\item {} 
The relationship between MC time step and autocorrelation

\item {} 
The use of blocking to reduce autocorrelation

\item {} 
The significance of the acceptance ratio

\item {} 
The significance of the sample size

\item {} 
How to determine whether an MC run was successful

\item {} 
The relationship between wavefunction quality and variance

\item {} 
Gauging the efficiency of MC runs

\item {} 
The cost of scaling up to larger system sizes

\end{itemize}


\section{Lab directories and files}
\label{\detokenize{lab_qmc_statistics:lab-directories-and-files}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
labs/lab1\PYGZus{}qmc\PYGZus{}statistics/
│
├── atom                              \PYGZhy{} H atom VMC calculation
│   ├── H.s000.scalar.dat                \PYGZhy{} H atom VMC data
│   └── H.xml                            \PYGZhy{} H atom VMC input file
│
├── autocorrelation                   \PYGZhy{} varying autocorrelation
│   ├── H.dat                            \PYGZhy{} data for gnuplot
│   ├── H.plt                            \PYGZhy{} gnuplot for time step vs. E\PYGZus{}L, tau\PYGZus{}c
│   ├── H.s000.scalar.dat                \PYGZhy{} H atom VMC data: time step = 10
│   ├── H.s001.scalar.dat                \PYGZhy{} H atom VMC data: time step =  5
│   ├── H.s002.scalar.dat                \PYGZhy{} H atom VMC data: time step =  2
│   ├── H.s003.scalar.dat                \PYGZhy{} H atom VMC data: time step =  1
│   ├── H.s004.scalar.dat                \PYGZhy{} H atom VMC data: time step =  0.5
│   ├── H.s005.scalar.dat                \PYGZhy{} H atom VMC data: time step =  0.2
│   ├── H.s006.scalar.dat                \PYGZhy{} H atom VMC data: time step =  0.1
│   ├── H.s007.scalar.dat                \PYGZhy{} H atom VMC data: time step =  0.05
│   ├── H.s008.scalar.dat                \PYGZhy{} H atom VMC data: time step =  0.02
│   ├── H.s009.scalar.dat                \PYGZhy{} H atom VMC data: time step =  0.01
│   ├── H.s010.scalar.dat                \PYGZhy{} H atom VMC data: time step =  0.005
│   ├── H.s011.scalar.dat                \PYGZhy{} H atom VMC data: time step =  0.002
│   ├── H.s012.scalar.dat                \PYGZhy{} H atom VMC data: time step =  0.001
│   ├── H.s013.scalar.dat                \PYGZhy{} H atom VMC data: time step =  0.0005
│   ├── H.s014.scalar.dat                \PYGZhy{} H atom VMC data: time step =  0.0002
│   ├── H.s015.scalar.dat                \PYGZhy{} H atom VMC data: time step =  0.0001
│   └── H.xml                            \PYGZhy{} H atom VMC input file
│
├── average                            \PYGZhy{} Python scripts for average/std. dev.
│   ├── average.py                         \PYGZhy{} average five E\PYGZus{}L from H atom VMC
│   ├── stddev2.py                         \PYGZhy{} standard deviation using (E\PYGZus{}L)\PYGZca{}2
│   └── stddev.py                          \PYGZhy{} standard deviation around the mean
│
├── basis                              \PYGZhy{} varying basis set for orbitals
│   ├── H\PYGZus{}\PYGZus{}exact.s000.scalar.dat           \PYGZhy{} H atom VMC data using STO basis
│   ├── H\PYGZus{}STO\PYGZhy{}2G.s000.scalar.dat           \PYGZhy{} H atom VMC data using STO\PYGZhy{}2G basis
│   ├── H\PYGZus{}STO\PYGZhy{}3G.s000.scalar.dat           \PYGZhy{} H atom VMC data using STO\PYGZhy{}3G basis
│   └── H\PYGZus{}STO\PYGZhy{}6G.s000.scalar.dat           \PYGZhy{} H atom VMC data using STO\PYGZhy{}6G basis
│
├── blocking                           \PYGZhy{} varying block/step ratio
│   ├── H.dat                              \PYGZhy{} data for gnuplot
│   ├── H.plt                              \PYGZhy{} gnuplot for N\PYGZus{}block vs. E, tau\PYGZus{}c
│   ├── H.s000.scalar.dat                  \PYGZhy{} H atom VMC data 50000:1 blocks:steps
│   ├── H.s001.scalar.dat                  \PYGZhy{} \PYGZdq{}  \PYGZdq{}    \PYGZdq{}    \PYGZdq{}  25000:2 blocks:steps
│   ├── H.s002.scalar.dat                  \PYGZhy{} \PYGZdq{}  \PYGZdq{}    \PYGZdq{}    \PYGZdq{}  12500:4 blocks:steps
│   ├── H.s003.scalar.dat                  \PYGZhy{} \PYGZdq{}  \PYGZdq{}    \PYGZdq{}    \PYGZdq{}  6250: 8 blocks:steps
│   ├── H.s004.scalar.dat                  \PYGZhy{} \PYGZdq{}  \PYGZdq{}    \PYGZdq{}    \PYGZdq{}  3125:16 blocks:steps
│   ├── H.s005.scalar.dat                  \PYGZhy{} \PYGZdq{}  \PYGZdq{}    \PYGZdq{}    \PYGZdq{}  2500:20 blocks:steps
│   ├── H.s006.scalar.dat                  \PYGZhy{} \PYGZdq{}  \PYGZdq{}    \PYGZdq{}    \PYGZdq{}  1250:40 blocks:steps
│   ├── H.s007.scalar.dat                  \PYGZhy{} \PYGZdq{}  \PYGZdq{}    \PYGZdq{}    \PYGZdq{}  1000:50 blocks:steps
│   ├── H.s008.scalar.dat                  \PYGZhy{} \PYGZdq{}  \PYGZdq{}    \PYGZdq{}    \PYGZdq{}  500:100 blocks:steps
│   ├── H.s009.scalar.dat                  \PYGZhy{} \PYGZdq{}  \PYGZdq{}    \PYGZdq{}    \PYGZdq{}  250:200 blocks:steps
│   ├── H.s010.scalar.dat                  \PYGZhy{} \PYGZdq{}  \PYGZdq{}    \PYGZdq{}    \PYGZdq{}  125:400 blocks:steps
│   ├── H.s011.scalar.dat                  \PYGZhy{} \PYGZdq{}  \PYGZdq{}    \PYGZdq{}    \PYGZdq{}  100:500 blocks:steps
│   ├── H.s012.scalar.dat                  \PYGZhy{} \PYGZdq{}  \PYGZdq{}    \PYGZdq{}    \PYGZdq{}  50:1000 blocks:steps
│   ├── H.s013.scalar.dat                  \PYGZhy{} \PYGZdq{}  \PYGZdq{}    \PYGZdq{}    \PYGZdq{}  40:1250 blocks:steps
│   ├── H.s014.scalar.dat                  \PYGZhy{} \PYGZdq{}  \PYGZdq{}    \PYGZdq{}    \PYGZdq{}  20:2500 blocks:steps
│   ├── H.s015.scalar.dat                  \PYGZhy{} \PYGZdq{}  \PYGZdq{}    \PYGZdq{}    \PYGZdq{}  10:5000 blocks:steps
│   └── H.xml                             \PYGZhy{} H atom VMC input file
│
├── blocks                             \PYGZhy{}  varying total number of blocks
│   ├── H.dat                             \PYGZhy{} data for gnuplot
│   ├── H.plt                             \PYGZhy{} gnuplot for N\PYGZus{}block vs. E
│   ├── H.s000.scalar.dat                 \PYGZhy{} H atom VMC data    500 blocks
│   ├── H.s001.scalar.dat                 \PYGZhy{} \PYGZdq{}  \PYGZdq{}    \PYGZdq{}    \PYGZdq{}    2000 blocks
│   ├── H.s002.scalar.dat                 \PYGZhy{} \PYGZdq{}  \PYGZdq{}    \PYGZdq{}    \PYGZdq{}    8000 blocks
│   ├── H.s003.scalar.dat                 \PYGZhy{} \PYGZdq{}  \PYGZdq{}    \PYGZdq{}    \PYGZdq{}   32000 blocks
│   ├── H.s004.scalar.dat                 \PYGZhy{} \PYGZdq{}  \PYGZdq{}    \PYGZdq{}    \PYGZdq{}  128000 blocks
│   └── H.xml                             \PYGZhy{} H atom VMC input file
│
├── dimer                          \PYGZhy{} comparing no and simple Jastrow factor
│   ├── H2\PYGZus{}STO\PYGZus{}\PYGZus{}\PYGZus{}no\PYGZus{}jastrow.s000.scalar.dat \PYGZhy{} H dimer VMC data without Jastrow
│   └── H2\PYGZus{}STO\PYGZus{}with\PYGZus{}jastrow.s000.scalar.dat \PYGZhy{} H dimer VMC data with Jastrow
│
├──  docs                               \PYGZhy{} documentation
│   ├──  Lab\PYGZus{}1\PYGZus{}MC\PYGZus{}Analysis.pdf             \PYGZhy{} this document
│   └──  Lab\PYGZus{}1\PYGZus{}Slides.pdf                  \PYGZhy{} slides presented in the lab
│
├── nodes                              \PYGZhy{} varying number of computing nodes
│   ├──  H.dat                             \PYGZhy{} data for gnuplot
│   ├──  H.plt                             \PYGZhy{} gnuplot for N\PYGZus{}node vs. E
│   ├──  H.s000.scalar.dat                 \PYGZhy{} H atom VMC data with  32 nodes
│   ├──  H.s001.scalar.dat                 \PYGZhy{} H atom VMC data with 128 nodes
│   └──  H.s002.scalar.dat                 \PYGZhy{} H atom VMC data with 512 nodes
│
├── problematic                        \PYGZhy{} problematic VMC run
│   └──  H.s000.scalar.dat                 \PYGZhy{} H atom VMC data with a problem
│
└── size                                \PYGZhy{} scaling with number of particles
    ├──  01\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}H.s000.scalar.dat       \PYGZhy{} H atom VMC data
    ├──  02\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}H2.s000.scalar.dat       \PYGZhy{} H dimer \PYGZdq{}   \PYGZdq{}
    ├──  06\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}C.s000.scalar.dat       \PYGZhy{} C atom  \PYGZdq{}   \PYGZdq{}
    ├──  10\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}CH4.s000.scalar.dat       \PYGZhy{} methane \PYGZdq{}   \PYGZdq{}
    ├──  12\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}C2.s000.scalar.dat       \PYGZhy{} C dimer \PYGZdq{}   \PYGZdq{}
    ├──  16\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}C2H4.s000.scalar.dat       \PYGZhy{} ethene  \PYGZdq{}
    ├──  18\PYGZus{}\PYGZus{}\PYGZus{}CH4CH4.s000.scalar.dat       \PYGZhy{} methane dimer VMC data
    ├──  32\PYGZus{}C2H4C2H4.s000.scalar.dat       \PYGZhy{} ethene dimer   \PYGZdq{}   \PYGZdq{}
    ├──  nelectron\PYGZus{}tcpu.dat                \PYGZhy{} data for gnuplot
    └──  Nelectron\PYGZus{}tCPU.plt                \PYGZhy{} gnuplot for N\PYGZus{}elec vs. t\PYGZus{}CPU
\end{sphinxVerbatim}


\section{Atomic units}
\label{\detokenize{lab_qmc_statistics:atomic-units}}
QMCPACK operates in Ha atomic units to reduce the number of factors in
the Schrödinger equation. Thus, the unit of length is the bohr (5.291772
\(\times 10^{-11}\) m = 0.529177 Å); the unit of energy is the Ha
(4.359744 \(\times 10^{-18}\) J = 27.211385 eV). The energy of the
ground state of the hydrogen atom in these units is \sphinxhyphen{}0.5 Ha.


\section{Reviewing statistics}
\label{\detokenize{lab_qmc_statistics:reviewing-statistics}}\label{\detokenize{lab_qmc_statistics:review}}
We will practice taking the average (mean) and standard deviation of
some MC data by hand to review the basic definitions.

Enter Python’s command line by typing \sphinxcode{\sphinxupquote{python {[}Enter{]}}}. You will see a
prompt “\textgreater{}\textgreater{}\textgreater{}.”

The mean of a dataset is given by:
\begin{equation}\label{equation:lab_qmc_statistics:eq63}
\begin{split}\overline{x} = \frac{1}{N}\sum_{i=1}^{N} x_i\:.\end{split}
\end{equation}
To calculate the average of five local energies from an MC calculation
of the ground state of an electron in the hydrogen atom, input (truncate
at the thousandths place if you cannot copy and paste; script versions
are also available in the \sphinxcode{\sphinxupquote{average}} directory):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}
\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.45298911858}\PYG{p}{)} \PYG{o}{+}
\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.45481953564}\PYG{p}{)} \PYG{o}{+}
\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.48066105923}\PYG{p}{)} \PYG{o}{+}
\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.47316713469}\PYG{p}{)} \PYG{o}{+}
\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.46204733302}\PYG{p}{)}
\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{5.}
\end{sphinxVerbatim}

Then, press \sphinxcode{\sphinxupquote{{[}Enter{]}}} to get:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{(}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.45298911858}\PYG{p}{)} \PYG{o}{+} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.45481953564}\PYG{p}{)} \PYG{o}{+} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.48066105923}\PYG{p}{)} \PYG{o}{+}
\PYG{g+go}{(\PYGZhy{}0.47316713469) + (\PYGZhy{}0.4620473302))/5.}
\PYG{g+go}{\PYGZhy{}0.46473683566800006}
\end{sphinxVerbatim}

To understand the significance of the mean, we also need the standard deviation
around the mean of the data (also called the error bar), given by:
\begin{equation}\label{equation:lab_qmc_statistics:eq64}
\begin{split}\sigma = \sqrt{\frac{1}{N(N-1)}\sum_{i=1}^{N} ({x_i} - \overline{x})^2}\:.\end{split}
\end{equation}
To calculate the standard deviation around the mean (\sphinxhyphen{}0.464736835668) of these
five data points, put in:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(} \PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mf}{5.}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{5.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}
\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.45298911858}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.464736835668}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYGZbs{}\PYGZbs{}
\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.45481953564}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.464736835668}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+}
\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.48066105923}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.464736835668}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+}
\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.47316713469}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.464736835668}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+}
\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.46204733302}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.464736835668}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{p}{)}
\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{0.5}
\end{sphinxVerbatim}

Then, press \sphinxcode{\sphinxupquote{{[}Enter{]}}} to get:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{(} \PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mf}{5.}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{5.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.45298911858}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.464736835668}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+}
\PYG{g+go}{(\PYGZhy{}0.45481953564\PYGZhy{}(\PYGZhy{}0.464736835668))**2 + (\PYGZhy{}0.48066105923\PYGZhy{}(\PYGZhy{}0.464736835668))**2 +}
\PYG{g+go}{(\PYGZhy{}0.47316713469\PYGZhy{}(\PYGZhy{}0.464736835668))**2 + (\PYGZhy{}0.46204733302\PYGZhy{}(\PYGZhy{}0.464736835668))**2}
\PYG{g+go}{) )**0.5}
\PYG{g+go}{0.0053303187464332066}
\end{sphinxVerbatim}

Thus, we might report this data as having a value \sphinxhyphen{}0.465 +/\sphinxhyphen{} 0.005 Ha.
This calculation of the standard deviation assumes that the average for this
data is fixed, but we can continually add MC samples to the data, so it
is better to use an estimate of the error bar that does not rely on the overall
average.  Such an estimate is given by:
\begin{equation}\label{equation:lab_qmc_statistics:eq65}
\begin{split}\tilde{\sigma} = \sqrt{\frac{1}{N-1}\sum_{i=1}^{N} \left[{(x^2)}_i - ({x_i})^2\right]}\:.\end{split}
\end{equation}
To calculate the standard deviation with this formula, input the following,
which includes the square of the local energy calculated with each
corresponding local energy:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(} \PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mf}{5.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}
\PYG{p}{(}\PYG{l+m+mf}{0.60984565298}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.45298911858}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}\PYGZbs{}
\PYG{p}{(}\PYG{l+m+mf}{0.61641291630}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.45481953564}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+}
\PYG{p}{(}\PYG{l+m+mf}{1.35860151160}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.48066105923}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}\PYGZbs{}
\PYG{p}{(}\PYG{l+m+mf}{0.78720769003}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.47316713469}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+}
\PYG{p}{(}\PYG{l+m+mf}{0.56393677687}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.46204733302}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{)}
\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{0.5}
\end{sphinxVerbatim}

and press \sphinxcode{\sphinxupquote{{[}Enter{]}}} to get:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mf}{5.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{0.60984565298}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.45298911858}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{+}
\PYG{g+go}{(0.61641291630\PYGZhy{}(\PYGZhy{}0.45481953564)**2)+(1.35860151160\PYGZhy{}(\PYGZhy{}0.48066105923)**2)+}
\PYG{g+go}{(0.78720769003\PYGZhy{}(\PYGZhy{}0.47316713469)**2)+(0.56393677687\PYGZhy{}(\PYGZhy{}0.46204733302)**2))}
\PYG{g+go}{)**0.5}
\PYG{g+go}{0.84491636672906634}
\end{sphinxVerbatim}

This much larger standard deviation, acknowledging that the mean of this
small data set is not the average in the limit of infinite sampling,
more accurately reports the value of the local energy as \sphinxhyphen{}0.5 +/\sphinxhyphen{} 0.8
Ha.

Type \sphinxcode{\sphinxupquote{quit()}} and press \sphinxcode{\sphinxupquote{{[}Enter{]}}} to exit the Python command line.


\section{Inspecting MC Data}
\label{\detokenize{lab_qmc_statistics:inspecting-mc-data}}\label{\detokenize{lab_qmc_statistics:inspect-data}}
QMCPACK outputs data from MC calculations into files ending in
\sphinxcode{\sphinxupquote{scalar.dat}}. Several quantities are calculated and written for each
block of MC steps in successive columns to the right of the step index.

Change directories to \sphinxcode{\sphinxupquote{atom}}, and open the file ending in
\sphinxcode{\sphinxupquote{scalar.dat}} with a text editor (e.g., \sphinxstylestrong{vi *.scalar.dat} or \sphinxstylestrong{emacs
*.scalar.dat}. If possible, adjust the terminal so that lines do not
wrap. The data will begin as follows (broken into three groups to fit on
this page):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}   index    LocalEnergy         LocalEnergy\PYGZus{}sq      LocalPotential     ...}
         \PYG{l+m+mi}{0}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.5298911858e\PYGZhy{}01}    \PYG{l+m+mf}{6.0984565298e\PYGZhy{}01}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.1708693521e+00}
         \PYG{l+m+mi}{1}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.5481953564e\PYGZhy{}01}    \PYG{l+m+mf}{6.1641291630e\PYGZhy{}01}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.1863425644e+00}
         \PYG{l+m+mi}{2}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.8066105923e\PYGZhy{}01}    \PYG{l+m+mf}{1.3586015116e+00}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.1766446209e+00}
         \PYG{l+m+mi}{3}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.7316713469e\PYGZhy{}01}    \PYG{l+m+mf}{7.8720769003e\PYGZhy{}01}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.1799481122e+00}
         \PYG{l+m+mi}{4}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.6204733302e\PYGZhy{}01}    \PYG{l+m+mf}{5.6393677687e\PYGZhy{}01}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.1619244081e+00}
         \PYG{l+m+mi}{5}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.4313854290e\PYGZhy{}01}    \PYG{l+m+mf}{6.0831516179e\PYGZhy{}01}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.2064503041e+00}
         \PYG{l+m+mi}{6}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.5064926960e\PYGZhy{}01}    \PYG{l+m+mf}{5.9891422196e\PYGZhy{}01}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.1521370176e+00}
         \PYG{l+m+mi}{7}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.5687452611e\PYGZhy{}01}    \PYG{l+m+mf}{5.8139614676e\PYGZhy{}01}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.1423627617e+00}
         \PYG{l+m+mi}{8}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.5018503739e\PYGZhy{}01}    \PYG{l+m+mf}{8.4147849706e\PYGZhy{}01}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.1842075439e+00}
         \PYG{l+m+mi}{9}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.3862013841e\PYGZhy{}01}    \PYG{l+m+mf}{5.5477715836e\PYGZhy{}01}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.2080979177e+00}
\end{sphinxVerbatim}

The first line begins with a \#, indicating that this line does not
contain MC data but rather the labels of the columns. After a blank
line, the remaining lines consist of the MC data. The first column,
labeled index, is an integer indicating which block of MC data is on
that line. The second column contains the quantity usually of greatest
interest from the simulation: the local energy. Since this simulation
did not use the exact ground state wavefunction, it does not produce
\sphinxhyphen{}0.5 Ha as the local energy although the value lies within about 10\%.
The value of the local energy fluctuates from block to block, and the
closer the trial wavefunction is to the ground state the smaller these
fluctuations will be. The next column contains an important ingredient
in estimating the error in the MC average—the square of the local
energy—found by evaluating the square of the Hamiltonian.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}   \PYG{n}{Kinetic}             \PYG{n}{Coulomb}             \PYG{n}{BlockWeight}        \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
       \PYG{l+m+mf}{7.1788023352e\PYGZhy{}01}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.1708693521e+00}    \PYG{l+m+mf}{1.2800000000e+04}
       \PYG{l+m+mf}{7.3152302871e\PYGZhy{}01}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.1863425644e+00}    \PYG{l+m+mf}{1.2800000000e+04}
       \PYG{l+m+mf}{6.9598356165e\PYGZhy{}01}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.1766446209e+00}    \PYG{l+m+mf}{1.2800000000e+04}
       \PYG{l+m+mf}{7.0678097751e\PYGZhy{}01}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.1799481122e+00}    \PYG{l+m+mf}{1.2800000000e+04}
       \PYG{l+m+mf}{6.9987707508e\PYGZhy{}01}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.1619244081e+00}    \PYG{l+m+mf}{1.2800000000e+04}
       \PYG{l+m+mf}{7.6331176120e\PYGZhy{}01}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.2064503041e+00}    \PYG{l+m+mf}{1.2800000000e+04}
       \PYG{l+m+mf}{7.0148774798e\PYGZhy{}01}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.1521370176e+00}    \PYG{l+m+mf}{1.2800000000e+04}
       \PYG{l+m+mf}{6.8548823555e\PYGZhy{}01}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.1423627617e+00}    \PYG{l+m+mf}{1.2800000000e+04}
       \PYG{l+m+mf}{7.3402250655e\PYGZhy{}01}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.1842075439e+00}    \PYG{l+m+mf}{1.2800000000e+04}
       \PYG{l+m+mf}{7.6947777925e\PYGZhy{}01}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.2080979177e+00}    \PYG{l+m+mf}{1.2800000000e+04}
\end{sphinxVerbatim}

The fourth column from the left consists of the values of the local potential
energy.  In this simulation, it is identical to the Coulomb potential
(contained in the sixth column) because the one electron in the simulation has
only the potential energy coming from its interaction with the nucleus.  In
many\sphinxhyphen{}electron simulations, the local potential energy contains contributions
from the electron\sphinxhyphen{}electron Coulomb interactions and the nuclear potential or
pseudopotential.  The fifth column contains the local kinetic energy value for
each MC block, obtained from the Laplacian of the wavefunction.  The sixth
column shows the local Coulomb interaction energy.  The seventh column displays
the weight each line of data has in the average (the weights are identical in
this simulation).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}    \PYG{n}{BlockCPU}            \PYG{n}{AcceptRatio}
       \PYG{l+m+mf}{6.0178991748e\PYGZhy{}03}    \PYG{l+m+mf}{9.8515625000e\PYGZhy{}01}
       \PYG{l+m+mf}{5.8323097461e\PYGZhy{}03}    \PYG{l+m+mf}{9.8562500000e\PYGZhy{}01}
       \PYG{l+m+mf}{5.8213412744e\PYGZhy{}03}    \PYG{l+m+mf}{9.8531250000e\PYGZhy{}01}
       \PYG{l+m+mf}{5.8330412549e\PYGZhy{}03}    \PYG{l+m+mf}{9.8828125000e\PYGZhy{}01}
       \PYG{l+m+mf}{5.8108362256e\PYGZhy{}03}    \PYG{l+m+mf}{9.8625000000e\PYGZhy{}01}
       \PYG{l+m+mf}{5.8254170264e\PYGZhy{}03}    \PYG{l+m+mf}{9.8625000000e\PYGZhy{}01}
       \PYG{l+m+mf}{5.8314813086e\PYGZhy{}03}    \PYG{l+m+mf}{9.8679687500e\PYGZhy{}01}
       \PYG{l+m+mf}{5.8258469971e\PYGZhy{}03}    \PYG{l+m+mf}{9.8726562500e\PYGZhy{}01}
       \PYG{l+m+mf}{5.8158433545e\PYGZhy{}03}    \PYG{l+m+mf}{9.8468750000e\PYGZhy{}01}
       \PYG{l+m+mf}{5.7959401123e\PYGZhy{}03}    \PYG{l+m+mf}{9.8539062500e\PYGZhy{}01}
\end{sphinxVerbatim}

The eighth column shows the CPU time (in seconds) to calculate the data
in that line. The ninth column from the left contains the acceptance
ratio (1 being full acceptance) for MC steps in that line’s data. Other
than the block weight, all quantities vary from line to line.

Exit the text editor (\sphinxstylestrong{{[}Esc{]} :q! {[}Enter{]}} in vi, \sphinxstylestrong{{[}Ctrl{]}\sphinxhyphen{}x {[}Ctrl{]}\sphinxhyphen{}c}
in emacs).


\section{Averaging quantities in the MC data}
\label{\detokenize{lab_qmc_statistics:averaging-quantities-in-the-mc-data}}\label{\detokenize{lab_qmc_statistics:averaging}}
QMCPACK includes the qmca Python tool to average quantities in the
\sphinxcode{\sphinxupquote{scalar.dat}} file (and also the \sphinxcode{\sphinxupquote{dmc.dat}} file of DMC simulations).
Without any flags, qmca will output the average of each column with a
quantity in the \sphinxcode{\sphinxupquote{scalar.dat}} file as follows.

Execute qmca by \sphinxcode{\sphinxupquote{qmca *.scalar.dat}}, which for this data outputs:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{H}  \PYG{n}{series} \PYG{l+m+mi}{0}
\PYG{n}{LocalEnergy}           \PYG{o}{=}          \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.45446} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}          \PYG{l+m+mf}{0.00057}
\PYG{n}{Variance}              \PYG{o}{=}             \PYG{l+m+mf}{0.529} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}            \PYG{l+m+mf}{0.018}
\PYG{n}{Kinetic}               \PYG{o}{=}            \PYG{l+m+mf}{0.7366} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}           \PYG{l+m+mf}{0.0020}
\PYG{n}{LocalPotential}        \PYG{o}{=}           \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.1910} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}           \PYG{l+m+mf}{0.0016}
\PYG{n}{Coulomb}               \PYG{o}{=}           \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.1910} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}           \PYG{l+m+mf}{0.0016}
\PYG{n}{LocalEnergy\PYGZus{}sq}        \PYG{o}{=}             \PYG{l+m+mf}{0.736} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}            \PYG{l+m+mf}{0.018}
\PYG{n}{BlockWeight}           \PYG{o}{=}    \PYG{l+m+mf}{12800.00000000} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}       \PYG{l+m+mf}{0.00000000}
\PYG{n}{BlockCPU}              \PYG{o}{=}        \PYG{l+m+mf}{0.00582002} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}       \PYG{l+m+mf}{0.00000067}
\PYG{n}{AcceptRatio}           \PYG{o}{=}          \PYG{l+m+mf}{0.985508} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}         \PYG{l+m+mf}{0.000048}
\PYG{n}{Efficiency}            \PYG{o}{=}        \PYG{l+m+mf}{0.00000000} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}}       \PYG{l+m+mf}{0.00000000}
\end{sphinxVerbatim}

After one blank, qmca prints the title of the subsequent data, gleaned
from the data file name. In this case, \sphinxcode{\sphinxupquote{H.s000.scalar.dat}} became “H
series 0.” Everything before the first “\sphinxcode{\sphinxupquote{.s}}” will be interpreted as
the title, and the number between “\sphinxcode{\sphinxupquote{.s}}” and the next “.” will be
interpreted as the series number.

The first column under the title is the name of each quantity qmca
averaged. The column to the right of the equal signs contains the
average for the quantity of that line, and the column to the right of
the plus\sphinxhyphen{}slash\sphinxhyphen{}minus is the statistical error bar on the quantity. All
quantities calculated from MC simulations have and must be reported with
a statistical error bar!

Two new quantities not present in the \sphinxcode{\sphinxupquote{scalar.dat}} file are computed
by qmca from the data—variance and efficiency. We will look at these
later in this lab.

To view only one value, \sphinxstylestrong{qmca} takes the \sphinxstylestrong{\sphinxhyphen{}q (quantity)} flag. For
example, the output of \sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}q LocalEnergy *.scalar.dat}} in this
directory produces a single line of output:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{H}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{n}{LocalEnergy} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.454460} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000568}
\end{sphinxVerbatim}

Type \sphinxcode{\sphinxupquote{qmca \textendash{}help}} to see the list of all quantities and their
abbreviations.


\section{Evaluating MC simulation quality}
\label{\detokenize{lab_qmc_statistics:evaluating-mc-simulation-quality}}
There are several aspects of a MC simulation to consider in deciding how well
it went.  Besides the deviation of the average from an expected value (if there
is one), the stability of the simulation in its sampling, the autocorrelation
between MC steps, the value of the acceptance ratio (accepted steps over total
proposed steps), and the variance in the local energy all indicate the quality
of an MC simulation.  We will look at these one by one.


\subsection{Tracing MC quantities}
\label{\detokenize{lab_qmc_statistics:tracing-mc-quantities}}
Visualizing the evolution of MC quantities over the course of the
simulation by a \sphinxstyleemphasis{trace} offers a quick picture of whether the random
walk had the expected behavior. qmca plots traces with the \sphinxhyphen{}t flag.

Type \sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}q e \sphinxhyphen{}t H.s000.scalar.dat}}, which produces a graph of the
trace of the local energy:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{lab_qmc_statistics_tracing1}.png}\hspace*{\fill}}

The solid black line connects the values of the local energy at each MC
block (labeled “samples”). The average value is marked with a
horizontal, solid red line. One standard deviation above and below the
average are marked with horizontal, dashed red lines.

The solid black line connects the values of the local energy at each MC
block (labeled “samples”). The average value is marked with a
horizontal, solid red line. One standard deviation above and below the
average are marked with horizontal, dashed red lines.

The trace of this run is largely centered on the average with no
large\sphinxhyphen{}scale oscillations or major shifts, indicating a good\sphinxhyphen{}quality MC
run.

Try tracing the kinetic and potential energies, seeing that their
behavior is comparable with the total local energy.

Change to directory \sphinxcode{\sphinxupquote{problematic}} and type
\sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}q e \sphinxhyphen{}t H.s000.scalar.dat}} to produce this graph:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{lab_qmc_statistics_tracing2}.png}\hspace*{\fill}}

Here, the local energy samples cluster around the expected \sphinxhyphen{}0.5 Ha for the
first 150 samples or so and then begin to oscillate more wildly and increase
erratically toward 0, indicating a poor\sphinxhyphen{}quality MC run.

Again, trace the kinetic and potential energies in this run and see how their
behavior compares with the total local energy.


\subsection{Blocking away autocorrelation}
\label{\detokenize{lab_qmc_statistics:blocking-away-autocorrelation}}
\sphinxstyleemphasis{Autocorrelation} occurs when a given MC step biases subsequent MC
steps, leading to samples that are not statistically independent. We
must take this autocorrelation into account to obtain accurate
statistics. qmca outputs autocorrelation when given the \textendash{}sac flag.

Change to directory \sphinxcode{\sphinxupquote{autocorrelation}} and type
\sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}q e \sphinxhyphen{}\sphinxhyphen{}sac H.s000.scalar.dat}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{H}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{n}{LocalEnergy} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.454982} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000430}    \PYG{l+m+mf}{1.0}
\end{sphinxVerbatim}

The value after the error bar on the quantity is the autocorrelation
(1.0 in this case).

Proposing too small a step in configuration space, the MC \sphinxstyleemphasis{time step},
can lead to autocorrelation since the new samples will be in the
neighborhood of previous samples. Type \sphinxcode{\sphinxupquote{grep timestep H.xml}} to see
the varying time step values in this QMCPACK input file (\sphinxcode{\sphinxupquote{H.xml}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{10}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{5}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{2}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.5}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.2}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.05}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.02}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.01}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.005}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.002}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.001}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.0005}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.0002}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.0001}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Generally, as the time step decreases, the autocorrelation will increase
(caveat: very large time steps will also have increasing
autocorrelation). To see this, type \sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}q e \sphinxhyphen{}\sphinxhyphen{}sac *.scalar.dat}} to
see the energies and autocorrelation times, then plot with gnuplot by
inputting \sphinxcode{\sphinxupquote{gnuplot H.plt}}:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{lab_qmc_statistics_blocking1}.png}\hspace*{\fill}}

The error bar also increases with the autocorrelation.

Press \sphinxcode{\sphinxupquote{q {[}Enter{]}}} to quit gnuplot.

To get around the bias of autocorrelation, we group the MC steps into
blocks, take the average of the data in the steps of each block, and
then finally average the averages in all the blocks. QMCPACK outputs the
block averages as each line in the \sphinxcode{\sphinxupquote{scalar.dat}} file. (For DMC
simulations, in addition to the \sphinxcode{\sphinxupquote{scalar.dat}}, QMCPACK outputs the
quantities at each step to the \sphinxcode{\sphinxupquote{dmc.dat}} file, which permits
reblocking the data differently from the specification in the input
file.)

Change directories to \sphinxcode{\sphinxupquote{blocking}}. Here we look at the time step of the
last dataset in the \sphinxcode{\sphinxupquote{autocorrelation}} directory. Verify this by typing
\sphinxcode{\sphinxupquote{grep timestep H.xml}} to see that all values are set to 0.001. Now to
see how we will vary the blocking, type \sphinxcode{\sphinxupquote{grep \sphinxhyphen{}A1 blocks H.xml}}. The
parameter “steps” indicates the number of steps per block, and the
parameter “blocks” gives the number of blocks. For this comparison, the
total number of MC steps (equal to the product of “steps” and “blocks”)
is fixed at 50,000. Now check the effect of blocking on
autocorrelation—type \sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}q e \sphinxhyphen{}\sphinxhyphen{}sac *scalar.dat}} to see the data and
\sphinxcode{\sphinxupquote{gnuplot H.plt}} to visualize the data:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{lab_qmc_statistics_blocking2}.png}\hspace*{\fill}}

The greatest number of steps per block produces the smallest
autocorrelation time. The larger number of blocks over which to average
at small step\sphinxhyphen{}per\sphinxhyphen{}block number masks the corresponding increase in error
bar with increasing autocorrelation.

Press \sphinxcode{\sphinxupquote{q {[}Enter{]}}} to quit gnuplot.


\subsection{Balancing autocorrelation and acceptance ratio}
\label{\detokenize{lab_qmc_statistics:balancing-autocorrelation-and-acceptance-ratio}}
Adjusting the time step value also affects the ratio of accepted steps to
proposed steps.  Stepping nearby in configuration space implies that the
probability distribution is similar and thus more likely to result in an
accepted move.  Keeping the acceptance ratio high means the algorithm is
efficiently exploring configuration space and not sticking at particular
configurations.  Return to the \sphinxcode{\sphinxupquote{autocorrelation}} directory.  Refresh your
memory on the time steps in this set of simulations by \sphinxcode{\sphinxupquote{grep timestep
H.xml}}. Then, type \sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}q ar *scalar.dat}} to see the acceptance ratio
as it varies with decreasing time step:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{H}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{n}{AcceptRatio} \PYG{o}{=} \PYG{l+m+mf}{0.047646} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000206}
\PYG{n}{H}  \PYG{n}{series} \PYG{l+m+mi}{1}  \PYG{n}{AcceptRatio} \PYG{o}{=} \PYG{l+m+mf}{0.125361} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000308}
\PYG{n}{H}  \PYG{n}{series} \PYG{l+m+mi}{2}  \PYG{n}{AcceptRatio} \PYG{o}{=} \PYG{l+m+mf}{0.328590} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000340}
\PYG{n}{H}  \PYG{n}{series} \PYG{l+m+mi}{3}  \PYG{n}{AcceptRatio} \PYG{o}{=} \PYG{l+m+mf}{0.535708} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000313}
\PYG{n}{H}  \PYG{n}{series} \PYG{l+m+mi}{4}  \PYG{n}{AcceptRatio} \PYG{o}{=} \PYG{l+m+mf}{0.732537} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000234}
\PYG{n}{H}  \PYG{n}{series} \PYG{l+m+mi}{5}  \PYG{n}{AcceptRatio} \PYG{o}{=} \PYG{l+m+mf}{0.903498} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000156}
\PYG{n}{H}  \PYG{n}{series} \PYG{l+m+mi}{6}  \PYG{n}{AcceptRatio} \PYG{o}{=} \PYG{l+m+mf}{0.961506} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000083}
\PYG{n}{H}  \PYG{n}{series} \PYG{l+m+mi}{7}  \PYG{n}{AcceptRatio} \PYG{o}{=} \PYG{l+m+mf}{0.985499} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000051}
\PYG{n}{H}  \PYG{n}{series} \PYG{l+m+mi}{8}  \PYG{n}{AcceptRatio} \PYG{o}{=} \PYG{l+m+mf}{0.996251} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000025}
\PYG{n}{H}  \PYG{n}{series} \PYG{l+m+mi}{9}  \PYG{n}{AcceptRatio} \PYG{o}{=} \PYG{l+m+mf}{0.998638} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000014}
\PYG{n}{H}  \PYG{n}{series} \PYG{l+m+mi}{10}  \PYG{n}{AcceptRatio} \PYG{o}{=} \PYG{l+m+mf}{0.999515} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000009}
\PYG{n}{H}  \PYG{n}{series} \PYG{l+m+mi}{11}  \PYG{n}{AcceptRatio} \PYG{o}{=} \PYG{l+m+mf}{0.999884} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000004}
\PYG{n}{H}  \PYG{n}{series} \PYG{l+m+mi}{12}  \PYG{n}{AcceptRatio} \PYG{o}{=} \PYG{l+m+mf}{0.999958} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000003}
\PYG{n}{H}  \PYG{n}{series} \PYG{l+m+mi}{13}  \PYG{n}{AcceptRatio} \PYG{o}{=} \PYG{l+m+mf}{0.999986} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000002}
\PYG{n}{H}  \PYG{n}{series} \PYG{l+m+mi}{14}  \PYG{n}{AcceptRatio} \PYG{o}{=} \PYG{l+m+mf}{0.999995} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000001}
\PYG{n}{H}  \PYG{n}{series} \PYG{l+m+mi}{15}  \PYG{n}{AcceptRatio} \PYG{o}{=} \PYG{l+m+mf}{0.999999} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000000}
\end{sphinxVerbatim}

By series 8 (time step = 0.02), the acceptance ratio is in excess of
99\%.

Considering the increase in autocorrelation and subsequent increase in
error bar as time step decreases, it is important to choose a time step
that trades off appropriately between acceptance ratio and
autocorrelation. In this example, a time step of 0.02 occupies a spot
where the acceptance ratio is high (99.6\%) and autocorrelation is not
appreciably larger than the minimum value (1.4 vs. 1.0).


\subsection{Considering variance}
\label{\detokenize{lab_qmc_statistics:considering-variance}}
Besides autocorrelation, the dominant contributor to the error bar is
the \sphinxstyleemphasis{variance} in the local energy. The variance measures the
fluctuations around the average local energy, and, as the fluctuations
go to zero, the wavefunction reaches an exact eigenstate of the
Hamiltonian. qmca calculates this from the local energy and local energy
squared columns of the \sphinxcode{\sphinxupquote{scalar.dat}}.

Type \sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}q v H.s009.scalar.dat}} to calculate the variance on the
run with time step balancing autocorrelation and acceptance ratio:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{H}  \PYG{n}{series} \PYG{l+m+mi}{9}  \PYG{n}{Variance} \PYG{o}{=} \PYG{l+m+mf}{0.513570} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.010589}
\end{sphinxVerbatim}

Just as the total energy does not tell us much by itself, neither does
the variance. However, comparing the ratio of the variance with the
energy indicates how the magnitude of the fluctuations compares with the
energy itself. Type \sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}q ev H.s009.scalar.dat}} to calculate the
energy and variance on the run side by side with the ratio:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
                    \PYG{n}{LocalEnergy}               \PYG{n}{Variance}        \PYG{n}{ratio}
\PYG{n}{H}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.454460} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000568}   \PYG{l+m+mf}{0.529496} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.018445}   \PYG{l+m+mf}{1.1651}
\end{sphinxVerbatim}

The very high ration of 1.1651 indicates the square of the fluctuations is on
average larger than the value itself.  In the next section, we will approach
ways to improve the variance that subsequent labs will build on.


\section{Reducing statistical error bars}
\label{\detokenize{lab_qmc_statistics:reducing-statistical-error-bars}}

\subsection{Increasing MC sampling}
\label{\detokenize{lab_qmc_statistics:increasing-mc-sampling}}
Increasing the number of MC samples in a dataset reduces the error bar
as the inverse of the square root of the number of samples. There are
two ways to increase the number of MC samples in a simulation: (1)
running more samples in parallel and (2) increasing the number of blocks
(with fixed number of steps per block, this increases the total number
of MC steps).

To see the effect of running more samples in parallel, change to the
directory \sphinxcode{\sphinxupquote{nodes}}. The series here increases the number of nodes by
factors of four from 32 to 128 to 512. Type \sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}q ev *scalar.dat}}
and note the change in the error bar on the local energy as the number
of nodes. Visualize this with \sphinxstylestrong{gnuplot H.plt}:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{lab_qmc_statistics_nodes}.png}\hspace*{\fill}}

Increasing the number of blocks, unlike running in parallel, increases
the total CPU time of the simulation.

Press \sphinxcode{\sphinxupquote{q {[}Enter{]}}} to quit gnuplot.

To see the effect of increasing the block number, change to the
directory \sphinxcode{\sphinxupquote{blocks}}. To see how we will vary the number of blocks, type
\sphinxcode{\sphinxupquote{grep \sphinxhyphen{}A1 blocks H.xml}}. The number of steps remains fixed, thus
increasing the total number of samples. Visualize the tradeoff by
inputting \sphinxcode{\sphinxupquote{gnuplot H.plt}}:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{lab_qmc_statistics_blocks}.png}\hspace*{\fill}}

Press \sphinxcode{\sphinxupquote{q {[}Enter{]}}} to quit gnuplot.


\subsection{Improving the basis sets}
\label{\detokenize{lab_qmc_statistics:improving-the-basis-sets}}
In all of the previous examples, we are using the sum of two Gaussian
functions (STO\sphinxhyphen{}2G) to approximate what should be a simple decaying
exponential for the wavefunction of the ground state of the hydrogen
atom. The sum of multiple copies of a function varying each copy’s width
and amplitude with coefficients is called a \sphinxstyleemphasis{basis set}. As we add
Gaussians to the basis set, the approximation improves, the variance
goes toward zero, and the energy goes to \sphinxhyphen{}0.5 Ha. In nearly every other
case, the exact function is unknown, and we add basis functions until
the total energy does not change within some threshold.

Change to the directory \sphinxcode{\sphinxupquote{basis}} and look at the total energy and
variance as we change the wavefunction by typing \sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}q ev H\_}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
                          \PYG{n}{LocalEnergy}               \PYG{n}{Variance}        \PYG{n}{ratio}
\PYG{n}{H\PYGZus{}STO}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{n}{G}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.454460} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000568}   \PYG{l+m+mf}{0.529496} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.018445}   \PYG{l+m+mf}{1.1651}
\PYG{n}{H\PYGZus{}STO}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{n}{G}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.465386} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000502}   \PYG{l+m+mf}{0.410491} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.010051}   \PYG{l+m+mf}{0.8820}
\PYG{n}{H\PYGZus{}STO}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}\PYG{n}{G}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.471332} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000491}   \PYG{l+m+mf}{0.213919} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.012954}   \PYG{l+m+mf}{0.4539}
\PYG{n}{H\PYGZus{}\PYGZus{}exact}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.500000} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000000}   \PYG{l+m+mf}{0.000000} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000000}   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0000}
\end{sphinxVerbatim}

qmca also puts out the ratio of the variance to the local energy in a
column to the right of the variance error bar. A typical high\sphinxhyphen{}quality
value for this ratio is lower than 0.1 or so—none of these few\sphinxhyphen{}Gaussian
wavefunctions satisfy that rule of thumb.

Use qmca to plot the trace of the local energy, kinetic energy, and
potential energy of H\_\_exact. The total energy is constantly \sphinxhyphen{}0.5 Ha
even though the kinetic and potential energies fluctuate from
configuration to configuration.


\subsection{Adding a Jastrow factor}
\label{\detokenize{lab_qmc_statistics:adding-a-jastrow-factor}}
Another route to reducing the variance is the introduction of a Jastrow
factor to account for electron\sphinxhyphen{}electron correlation (not the statistical
autocorrelation of MC steps but the physical avoidance that electrons
have of one another). To do this, we will switch to the hydrogen dimer
with the exact ground state wavefunction of the atom (STO basis)—this
will not be exact for the dimer. The ground state energy of the hydrogen
dimer is \sphinxhyphen{}1.174 Ha.

Change directories to \sphinxcode{\sphinxupquote{dimer}} and put in \sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}q ev *scalar.dat}} to
see the result of adding a simple, one\sphinxhyphen{}parameter Jastrow to the STO
basis for the hydrogen dimer at experimental bond length:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
                                \PYG{n}{LocalEnergy}               \PYG{n}{Variance}
\PYG{n}{H2\PYGZus{}STO\PYGZus{}\PYGZus{}\PYGZus{}no\PYGZus{}jastrow}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.876548} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.005313}   \PYG{l+m+mf}{0.473526} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.014910}
\PYG{n}{H2\PYGZus{}STO\PYGZus{}with\PYGZus{}jastrow}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.912763} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.004470}   \PYG{l+m+mf}{0.279651} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.016405}
\end{sphinxVerbatim}

The energy reduces by 0.044 +/\sphinxhyphen{} 0.006 HA and the variance by 0.19 +/\sphinxhyphen{}
0.02. This is still 20\% above the ground state energy, and subsequent
labs will cover how to improve on this with improved forms of the
wavefunction that capture more of the physics.


\section{Scaling to larger numbers of electrons}
\label{\detokenize{lab_qmc_statistics:scaling-to-larger-numbers-of-electrons}}

\subsection{Calculating the efficiency}
\label{\detokenize{lab_qmc_statistics:calculating-the-efficiency}}
The inverse of the product of CPU time and the variance measures the
\sphinxstyleemphasis{efficiency} of an MC calculation. Use qmca to calculate efficiency by
typing \sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}q eff *scalar.dat}} to see the efficiency of these two
H \(_2\) calculations:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{H2\PYGZus{}STO\PYGZus{}\PYGZus{}\PYGZus{}no\PYGZus{}jastrow}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{n}{Efficiency} \PYG{o}{=} \PYG{l+m+mf}{16698.725453} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000000}
\PYG{n}{H2\PYGZus{}STO\PYGZus{}with\PYGZus{}jastrow}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{n}{Efficiency} \PYG{o}{=} \PYG{l+m+mf}{52912.365609} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000000}
\end{sphinxVerbatim}

The Jastrow factor increased the efficiency in these calculations by a factor
of three, largely through the reduction in variance (check the average block
CPU time to verify this claim).


\subsection{Scaling up}
\label{\detokenize{lab_qmc_statistics:scaling-up}}
To see how MC scales with increasing particle number, change directories
to \sphinxcode{\sphinxupquote{size}}. Here are the data from runs of increasing numbers of
electrons for H, H\(_2\), C, CH\(_4\), C\(_2\),
C\(_2\)H\(_4\), (CH\(_4\))\(_2\), and
(C\(_2\)H\(_4\))\(_2\) using the STO\sphinxhyphen{}6G basis set
for the orbitals of the Slater determinant. The file names begin with
the number of electrons simulated for those data.

Use \sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}q bc *scalar.dat}} to see that the CPU time per block
increases with the number of electrons in the simulation; then plot the
total CPU time of the simulation by \sphinxstylestrong{gnuplot Nelectron\_tCPU.plt}:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{lab_qmc_statistics_scaling}.png}\hspace*{\fill}}

The green pluses represent the CPU time per block at each electron
number. The red line is a quadratic fit to those data. For a fixed basis
set size, we expect the time to scale quadratically up to 1,000s of
electrons, at which point a cubic scaling term may become dominant.
Knowing the scaling allows you to roughly project the calculation time
for a larger number of electrons.

Press \sphinxcode{\sphinxupquote{q {[}Enter{]}}} to quit gnuplot.

This is not the whole story, however. The variance of the energy also
increases with a fixed basis set as the number of particles increases at
a faster rate than the energy decreases. To see this, type
\sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}q ev *scalar.dat}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
            \PYG{n}{LocalEnergy}               \PYG{n}{Variance}
\PYG{l+m+mi}{01}\PYG{n}{\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}H}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.471352} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000493}      \PYG{l+m+mf}{0.213020} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.012950}
\PYG{l+m+mi}{02}\PYG{n}{\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}H2}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.898875} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000998}      \PYG{l+m+mf}{0.545717} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.009980}
\PYG{l+m+mi}{06}\PYG{n}{\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}C}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{37.608586} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.020453}   \PYG{l+m+mf}{184.322000} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{45.481193}
\PYG{l+m+mi}{10}\PYG{n}{\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}CH4}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{38.821513} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.022740}   \PYG{l+m+mf}{169.797871} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{24.765674}
\PYG{l+m+mi}{12}\PYG{n}{\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}C2}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{72.302390} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.037691}   \PYG{l+m+mf}{491.416711} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{106.090103}
\PYG{l+m+mi}{16}\PYG{n}{\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}C2H4}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{75.488701} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.042919}   \PYG{l+m+mf}{404.218115} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{60.196642}
\PYG{l+m+mi}{18}\PYG{n}{\PYGZus{}\PYGZus{}\PYGZus{}CH4CH4}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{58.459857} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.039309}   \PYG{l+m+mf}{498.579645} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{92.480126}
\PYG{l+m+mi}{32}\PYG{n}{\PYGZus{}C2H4C2H4}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{91.567283} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.048392}   \PYG{l+m+mf}{632.114026} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{69.637760}
\end{sphinxVerbatim}

The increase in variance is not uniform, but the general trend is upward with a
fixed wavefunction form and basis set.  Subsequent labs will address how to
improve the wavefunction to keep the variance manageable.


\chapter{Lab 2: QMC Basics}
\label{\detokenize{lab_qmc_basics:lab-2-qmc-basics}}\label{\detokenize{lab_qmc_basics:lab-qmc-basics}}\label{\detokenize{lab_qmc_basics::doc}}

\section{Topics covered in this lab}
\label{\detokenize{lab_qmc_basics:topics-covered-in-this-lab}}
This lab focuses on the basics of performing quality QMC calculations.
As an example, participants test an oxygen pseudopotential within DMC by
calculating atomic and dimer properties, a common step prior to
production runs. Topics covered include:
\begin{itemize}
\item {} 
Converting pseudopotentials into QMCPACK’s FSATOM format

\item {} 
Generating orbitals with QE

\item {} 
Converting orbitals into QMCPACK’s ESHDF format with pw2qmcpack

\item {} 
Optimizing Jastrow factors with QMCPACK

\item {} 
Removing DMC time step errors via extrapolation

\item {} 
Automating QMC workflows with Nexus

\item {} 
Testing pseudopotentials for accuracy

\end{itemize}


\section{Lab outline}
\label{\detokenize{lab_qmc_basics:lab-outline}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Download and conversion of oxygen atom pseudopotential

\item {} 
DMC time step study of the neutral oxygen atom
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
DFT orbital generation with QE

\item {} 
Orbital conversion with

\item {} 
Optimization of Jastrow correlation factor with QMCPACK

\item {} 
DMC run with multiple time steps

\end{enumerate}

\item {} 
DMC time step study of the first ionization potential of oxygen
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
Repetition of a\sphinxhyphen{}d above for ionized oxygen atom

\end{enumerate}

\item {} 
Automated DMC calculations of the oxygen dimer binding curve

\end{enumerate}


\section{Lab directories and files}
\label{\detokenize{lab_qmc_basics:lab-directories-and-files}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZpc{}
labs/lab2\PYGZus{}qmc\PYGZus{}basics/
│
├── oxygen\PYGZus{}atom           \PYGZhy{} oxygen atom calculations
│   ├── O.q0.dft.in          \PYGZhy{} Quantum ESPRESSO input for DFT run
│   ├── O.q0.p2q.in          \PYGZhy{} pw2qmcpack.x input for orbital conversion run
│   ├── O.q0.opt.in.xml      \PYGZhy{} QMCPACK input for Jastrow optimization run
│   ├── O.q0.dmc.in.xml      \PYGZhy{} QMCPACK input file for neutral O DMC
│   ├── ip\PYGZus{}conv.py           \PYGZhy{} tool to fit oxygen IP vs timestep
│   └── reference            \PYGZhy{} directory w/ completed runs
│
├── oxygen\PYGZus{}dimer          \PYGZhy{} oxygen dimer calculations
│   ├── dimer\PYGZus{}fit.py         \PYGZhy{} tool to fit dimer binding curve
│   ├── O\PYGZus{}dimer.py           \PYGZhy{} automation script for dimer calculations
│   ├── pseudopotentials     \PYGZhy{} directory for pseudopotentials
│   └── reference            \PYGZhy{} directory w/ completed runs
│
└── your\PYGZus{}system           \PYGZhy{} performing calculations for an arbitrary system (yours)
    ├── example.py           \PYGZhy{} example nexus file for periodic diamond
    ├── pseudopotentials     \PYGZhy{} directory containing C pseudopotentials
    └── reference            \PYGZhy{} directory w/ completed runs
\end{sphinxVerbatim}


\section{Obtaining and converting a pseudopotential for oxygen}
\label{\detokenize{lab_qmc_basics:obtaining-and-converting-a-pseudopotential-for-oxygen}}\label{\detokenize{lab_qmc_basics:lqb-pseudo}}
First enter the \sphinxcode{\sphinxupquote{oxygen\_atom}} directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{labs}\PYG{o}{/}\PYG{n}{lab2\PYGZus{}qmc\PYGZus{}basics}\PYG{o}{/}\PYG{n}{oxygen\PYGZus{}atom}\PYG{o}{/}
\end{sphinxVerbatim}

Throughout the rest of the lab, locations are specified with respect to \sphinxcode{\sphinxupquote{labs/lab2\_qmc\_basics}} (e.g., \sphinxcode{\sphinxupquote{oxygen\_atom}}).

We use a potential from the Burkatzki\sphinxhyphen{}Filippi\sphinxhyphen{}Dolg pseudopotential database.
Although the full database is available in QMCPACK distribution (\sphinxcode{\sphinxupquote{trunk/pseudopotentials/BFD/}}),
we use a BFD pseudopotential to illustrate the process of converting and testing an
external potential for use with QMCPACK.   To obtain the pseudopotential, go to
\sphinxurl{http://www.burkatzki.com/pseudos/index.2.html}
and click on the “Select Pseudopotential” button.  Next click on oxygen in the
periodic table.  Click on the empty circle next to “V5Z” (a large Gaussian
basis set) and click on “Next.”  Select the Gamess format and click on
“Retrive Potential.”  Helpful information about the pseudopotential will be
displayed.  The desired portion is at the bottom (the last 7 lines).  Copy
this text into the editor of your choice (e.g., \sphinxcode{\sphinxupquote{emacs}} or \sphinxcode{\sphinxupquote{vi}})
and save it as \sphinxcode{\sphinxupquote{O.BFD.gamess}}
(be sure to include a new line at the end of the file).  To transform the
pseudopotential into the FSATOM XML format used by QMCPACK, use the \sphinxcode{\sphinxupquote{ppconvert}}
tool:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ppconvert} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{gamess\PYGZus{}pot} \PYG{n}{O}\PYG{o}{.}\PYG{n}{BFD}\PYG{o}{.}\PYG{n}{gamess} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{s\PYGZus{}ref} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1s(2)2p(4)}\PYG{l+s+s2}{\PYGZdq{}} \PYGZbs{}
 \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{p\PYGZus{}ref} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1s(2)2p(4)}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{d\PYGZus{}ref} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1s(2)2p(4)}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{xml} \PYG{n}{O}\PYG{o}{.}\PYG{n}{BFD}\PYG{o}{.}\PYG{n}{xml}
\end{sphinxVerbatim}

Observe the notation used to describe the reference valence configuration for this helium\sphinxhyphen{}core PP: \sphinxcode{\sphinxupquote{1s(2)2p(4)}}.  The \sphinxcode{\sphinxupquote{ppconvert}} tool uses the following convention for the valence states: the first \$s\$ state is labeled \sphinxcode{\sphinxupquote{1s}} (\sphinxcode{\sphinxupquote{1s}}, \sphinxcode{\sphinxupquote{2s}}, \sphinxcode{\sphinxupquote{3s}}, \(\ldots\)), the first \(p\) state is labeled \sphinxcode{\sphinxupquote{2p}} (\sphinxcode{\sphinxupquote{2p}}, \sphinxcode{\sphinxupquote{3p}}, \(\ldots\)), and the first \(d\) state is labeled \sphinxcode{\sphinxupquote{3d}} (\sphinxcode{\sphinxupquote{3d}}, \sphinxcode{\sphinxupquote{4d}}, \(\ldots\)). Copy the resulting xml file into the \sphinxcode{\sphinxupquote{oxygen\_atom}} directory.

Note: The command to convert the PP into QE’s UPF format is similar (both formats are required):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ppconvert} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{gamess\PYGZus{}pot} \PYG{n}{O}\PYG{o}{.}\PYG{n}{BFD}\PYG{o}{.}\PYG{n}{gamess} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{s\PYGZus{}ref} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1s(2)2p(4)}\PYG{l+s+s2}{\PYGZdq{}} \PYGZbs{}
 \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{p\PYGZus{}ref} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1s(2)2p(4)}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{d\PYGZus{}ref} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1s(2)2p(4)}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{log\PYGZus{}grid} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{upf} \PYG{n}{O}\PYG{o}{.}\PYG{n}{BFD}\PYG{o}{.}\PYG{n}{upf}
\end{sphinxVerbatim}

For reference, the text of \sphinxcode{\sphinxupquote{O.BFD.gamess}} should be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{O}\PYG{o}{\PYGZhy{}}\PYG{n}{QMC} \PYG{n}{GEN} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{3}
\PYG{l+m+mf}{6.00000000} \PYG{l+m+mi}{1} \PYG{l+m+mf}{9.29793903}
\PYG{l+m+mf}{55.78763416} \PYG{l+m+mi}{3} \PYG{l+m+mf}{8.86492204}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{38.81978498} \PYG{l+m+mi}{2} \PYG{l+m+mf}{8.62925665}
\PYG{l+m+mi}{1}
\PYG{l+m+mf}{38.41914135} \PYG{l+m+mi}{2} \PYG{l+m+mf}{8.71924452}
\end{sphinxVerbatim}

The full QMCPACK pseudopotential is also included in \sphinxcode{\sphinxupquote{oxygen\_atom/reference/O.BFD.*}}.


\section{DFT with QE to obtain the orbital part of the wavefunction}
\label{\detokenize{lab_qmc_basics:dft-with-qe-to-obtain-the-orbital-part-of-the-wavefunction}}\label{\detokenize{lab_qmc_basics:lqb-dft}}
With the pseudopotential in hand, the next step toward a QMC calculation is to obtain the
Fermionic part of the wavefunction, in this case a single Slater determinant constructed
from DFT\sphinxhyphen{}LDA orbitals for a neutral oxygen atom.  If you had trouble with the pseudopotential conversion
step, preconverted pseudopotential files are located in the \sphinxcode{\sphinxupquote{oxygen\_atom/reference}} directory.

QE input for the DFT\sphinxhyphen{}LDA ground state of the neutral oxygen atom can be found in \sphinxcode{\sphinxupquote{O.q0.dft.in}}
and also in {\hyperref[\detokenize{lab_qmc_basics:listing-58}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 58}}}}.  Setting \sphinxcode{\sphinxupquote{wf\_collect=.true.}} instructs QE to write the
orbitals to disk at the end of the run. Option \sphinxcode{\sphinxupquote{wf\_collect=.true.}} could be a potential problem
in large simulations; therefore, we recommend avoiding it and using the converter pw2qmcpack in parallel
(see details in {\hyperref[\detokenize{additional_tools:pw2qmcpack}]{\sphinxcrossref{\DUrole{std,std-ref}{pw2qmcpack.x}}}}).
Note that the plane\sphinxhyphen{}wave energy cutoff has been set to a reasonable value of 300 Ry here (\sphinxcode{\sphinxupquote{ecutwfc=300}}).
This value depends on the pseudopotentials used, and, in general,
should be selected by running DFT \(\rightarrow\) (orbital conversion) \(\rightarrow\) VMC with
increasing energy cutoffs until the lowest VMC total energy and variance is reached.
\sphinxSetupCaptionForVerbatim{QE input file for the neutral oxygen atom (\sphinxcode{\sphinxupquote{O.q0.dft.in}})}
\def\sphinxLiteralBlockLabel{\label{\detokenize{lab_qmc_basics:listing-58}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZam{}}\PYG{n}{CONTROL}
   \PYG{n}{calculation}       \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scf}\PYG{l+s+s1}{\PYGZsq{}}
   \PYG{n}{restart\PYGZus{}mode}      \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{from\PYGZus{}scratch}\PYG{l+s+s1}{\PYGZsq{}}
   \PYG{n}{prefix}            \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O.q0}\PYG{l+s+s1}{\PYGZsq{}}
   \PYG{n}{outdir}            \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./}\PYG{l+s+s1}{\PYGZsq{}}
   \PYG{n}{pseudo\PYGZus{}dir}        \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./}\PYG{l+s+s1}{\PYGZsq{}}
   \PYG{n}{disk\PYGZus{}io}           \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{low}\PYG{l+s+s1}{\PYGZsq{}}
   \PYG{n}{wf\PYGZus{}collect}        \PYG{o}{=} \PYG{o}{.}\PYG{n}{true}\PYG{o}{.}
\PYG{o}{/}

\PYG{o}{\PYGZam{}}\PYG{n}{SYSTEM}
   \PYG{n}{celldm}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}         \PYG{o}{=} \PYG{l+m+mf}{1.0}
   \PYG{n}{ibrav}             \PYG{o}{=} \PYG{l+m+mi}{0}
   \PYG{n}{nat}               \PYG{o}{=} \PYG{l+m+mi}{1}
   \PYG{n}{ntyp}              \PYG{o}{=} \PYG{l+m+mi}{1}
   \PYG{n}{nspin}             \PYG{o}{=} \PYG{l+m+mi}{2}
   \PYG{n}{tot\PYGZus{}charge}        \PYG{o}{=} \PYG{l+m+mi}{0}
   \PYG{n}{tot\PYGZus{}magnetization} \PYG{o}{=} \PYG{l+m+mi}{2}
   \PYG{n}{input\PYGZus{}dft}         \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lda}\PYG{l+s+s1}{\PYGZsq{}}
   \PYG{n}{ecutwfc}           \PYG{o}{=} \PYG{l+m+mi}{300}
   \PYG{n}{ecutrho}           \PYG{o}{=} \PYG{l+m+mi}{1200}
   \PYG{n}{nosym}             \PYG{o}{=} \PYG{o}{.}\PYG{n}{true}\PYG{o}{.}
   \PYG{n}{occupations}       \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{smearing}\PYG{l+s+s1}{\PYGZsq{}}
   \PYG{n}{smearing}          \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fermi\PYGZhy{}dirac}\PYG{l+s+s1}{\PYGZsq{}}
   \PYG{n}{degauss}           \PYG{o}{=} \PYG{l+m+mf}{0.0001}
\PYG{o}{/}

\PYG{o}{\PYGZam{}}\PYG{n}{ELECTRONS}
   \PYG{n}{diagonalization}   \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{david}\PYG{l+s+s1}{\PYGZsq{}}
   \PYG{n}{mixing\PYGZus{}mode}       \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{plain}\PYG{l+s+s1}{\PYGZsq{}}
   \PYG{n}{mixing\PYGZus{}beta}       \PYG{o}{=} \PYG{l+m+mf}{0.7}
   \PYG{n}{conv\PYGZus{}thr}          \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}08}
   \PYG{n}{electron\PYGZus{}maxstep}  \PYG{o}{=} \PYG{l+m+mi}{1000}
\PYG{o}{/}


\PYG{n}{ATOMIC\PYGZus{}SPECIES}
   \PYG{n}{O}  \PYG{l+m+mf}{15.999} \PYG{n}{O}\PYG{o}{.}\PYG{n}{BFD}\PYG{o}{.}\PYG{n}{upf}

\PYG{n}{ATOMIC\PYGZus{}POSITIONS} \PYG{n}{alat}
   \PYG{n}{O}     \PYG{l+m+mf}{9.44863067}       \PYG{l+m+mf}{9.44863161}       \PYG{l+m+mf}{9.44863255}

\PYG{n}{K\PYGZus{}POINTS} \PYG{n}{automatic}
   \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}

\PYG{n}{CELL\PYGZus{}PARAMETERS} \PYG{n}{cubic}
        \PYG{l+m+mf}{18.89726133}       \PYG{l+m+mf}{0.00000000}       \PYG{l+m+mf}{0.00000000}
         \PYG{l+m+mf}{0.00000000}      \PYG{l+m+mf}{18.89726133}       \PYG{l+m+mf}{0.00000000}
         \PYG{l+m+mf}{0.00000000}       \PYG{l+m+mf}{0.00000000}      \PYG{l+m+mf}{18.89726133}
\end{sphinxVerbatim}

Run QE by typing

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{np} \PYG{l+m+mi}{4} \PYG{n}{pw}\PYG{o}{.}\PYG{n}{x} \PYG{o}{\PYGZhy{}}\PYG{n+nb}{input} \PYG{n}{O}\PYG{o}{.}\PYG{n}{q0}\PYG{o}{.}\PYG{n}{dft}\PYG{o}{.}\PYG{o+ow}{in} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{n}{O}\PYG{o}{.}\PYG{n}{q0}\PYG{o}{.}\PYG{n}{dft}\PYG{o}{.}\PYG{n}{out}\PYG{o}{\PYGZam{}}
\end{sphinxVerbatim}

The DFT run should take a few minutes to complete.  If desired, you can track the progress of the DFT run by typing “\sphinxcode{\sphinxupquote{tail \sphinxhyphen{}f O.q0.dft.out}}.” Once finished, you should check the LDA total energy in \sphinxcode{\sphinxupquote{O.q0.dft.out}}  by typing  “\sphinxcode{\sphinxupquote{grep \textquotesingle{}!  \textquotesingle{} O.q0.dft.out}}.”  The result should be close to

\begin{sphinxVerbatim}[commandchars=\\\{\}]
!    total energy              =     \PYGZhy{}31.57553905 Ry
\end{sphinxVerbatim}

The orbitals have been written in a format native to QE in the \sphinxcode{\sphinxupquote{O.q0.save}} directory.  We will convert them into the ESHDF format expected by QMCPACK by using the \sphinxcode{\sphinxupquote{pw2qmcpack.x}} tool.  The input for \sphinxcode{\sphinxupquote{pw2qmcpack.x}} can be found in the file \sphinxcode{\sphinxupquote{O.q0.p2q.in}} and also in {\hyperref[\detokenize{lab_qmc_basics:listing-59}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 59}}}}.
\sphinxSetupCaptionForVerbatim{\sphinxcode{\sphinxupquote{pw2qmcpack.x}} input file for orbital conversion (\sphinxcode{\sphinxupquote{O.q0.p2q.in}})}
\def\sphinxLiteralBlockLabel{\label{\detokenize{lab_qmc_basics:listing-59}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZam{}}\PYG{n}{inputpp}
  \PYG{n}{prefix}     \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O.q0}\PYG{l+s+s1}{\PYGZsq{}}
  \PYG{n}{outdir}     \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./}\PYG{l+s+s1}{\PYGZsq{}}
  \PYG{n}{write\PYGZus{}psir} \PYG{o}{=} \PYG{o}{.}\PYG{n}{false}\PYG{o}{.}
\PYG{o}{/}
\end{sphinxVerbatim}

Perform the orbital conversion now by typing the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{np} \PYG{l+m+mi}{1} \PYG{n}{pw2qmcpack}\PYG{o}{.}\PYG{n}{x}\PYG{o}{\PYGZlt{}}\PYG{n}{O}\PYG{o}{.}\PYG{n}{q0}\PYG{o}{.}\PYG{n}{p2q}\PYG{o}{.}\PYG{o+ow}{in}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{n}{O}\PYG{o}{.}\PYG{n}{q0}\PYG{o}{.}\PYG{n}{p2q}\PYG{o}{.}\PYG{n}{out}\PYG{o}{\PYGZam{}}
\end{sphinxVerbatim}

Upon completion of the run, a new file should be present containing the orbitals for QMCPACK: \sphinxcode{\sphinxupquote{O.q0.pwscf.h5}}.  Template XML files for particle (\sphinxcode{\sphinxupquote{O.q0.ptcl.xml}}) and wavefunction (\sphinxcode{\sphinxupquote{O.q0.wfs.xml}}) inputs to QMCPACK should also be present.


\section{Optimization with QMCPACK to obtain the correlated part of the wavefunction}
\label{\detokenize{lab_qmc_basics:optimization-with-qmcpack-to-obtain-the-correlated-part-of-the-wavefunction}}\label{\detokenize{lab_qmc_basics:optimization-walkthrough}}
The wavefunction we have obtained to this point corresponds to a noninteracting Hamiltonian.  Once the Coulomb pair potential is switched on between particles, it is known analytically that the exact wavefunction has cusps whenever two particles meet spatially and, in general, the electrons become correlated.  This is represented in the wavefunction by introducing a Jastrow factor containing at least pair correlations:
\begin{equation}\label{equation:lab_qmc_basics:eq66}
\begin{split}\Psi_{Slater-Jastrow}=e^{-J}\Psi_{Slater}\end{split}
\end{equation}\begin{equation}\label{equation:lab_qmc_basics:eq67}
\begin{split}J = \sum_{\sigma\sigma'}\sum_{i<j}u^{\sigma\sigma'}_2(|r_i-r_j|) + \sum_\sigma\sum_{iI}u^{\sigma I}_1(|r_i-r_I|)\:.\end{split}
\end{equation}
Here \(\sigma\) is a spin variable while \(r_i\) and \(r_I\)
represent electron and ion coordinates, respectively. The introduction
of \(J\) into the wavefunction is similar to F12 methods in quantum
chemistry, though it has been present in essentially all QMC studies
since the first applications the method (circa 1965).

How are the functions \(u_2^{\sigma\sigma'}\) and
\(u_1^{\sigma}\) obtained? Generally, they are approximated by
analytical functions with several unknown parameters that are determined
by minimizing the energy or variance directly within VMC. This is
effective because the energy and variance reach a global minimum only
for the true ground state wavefunction
(\(\textrm{Energy}=E\equiv\langle{\Psi}|{\hat{H}}|{\Psi}\rangle\),
\(\textrm{Variance}=V\equiv\langle{\Psi}|{(\hat{H}-E)^2}|{\Psi}\rangle\)).
For this exercise, we will focus on minimizing the variance.

First, we need to update the template particle and wavefunction information in \sphinxcode{\sphinxupquote{O.q0.ptcl.xml}} and \sphinxcode{\sphinxupquote{O.q0.wfs.xml}}.  We want to simulate the O atom in open boundary conditions (the default is periodic).  To do this, open \sphinxcode{\sphinxupquote{\textasciigrave{}O.q0.ptcl.xml}} with your favorite text editor (e.g., \sphinxcode{\sphinxupquote{emacs}} or \sphinxcode{\sphinxupquote{vi}}) and replace

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bconds}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{n}{p} \PYG{n}{p} \PYG{n}{p}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LR\PYGZus{}dim\PYGZus{}cutoff}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{l+m+mi}{15}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bconds}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{n}{n} \PYG{n}{n} \PYG{n}{n}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Next we will select Jastrow factors appropriate for an atom.  In open boundary conditions, the B\sphinxhyphen{}spline Jastrow correlation functions should cut off to zero at some distance away from the atom.  Open \sphinxcode{\sphinxupquote{O.q0.wfs.xml}} and add the following cutoffs (\sphinxcode{\sphinxupquote{rcut}} in Bohr radii) to the correlation factors:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{speciesA}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{speciesB}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{speciesA}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{speciesB}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{O}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{5.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

These terms correspond to
\(u_2^{\uparrow\uparrow}/u_2^{\downarrow\downarrow}\),
\(u_2^{\uparrow\downarrow}\), and
\(u_1^{\uparrow O}/u_1^{\downarrow O}\), respectively. In each case,
the correlation function (\(u_*\)) is represented by piecewise
continuous cubic B\sphinxhyphen{}splines. Each correlation function has eight
parameters, which are just the values of \(u\) on a uniformly spaced
grid up to \sphinxcode{\sphinxupquote{rcut}}. Initially the parameters (\sphinxcode{\sphinxupquote{coefficients}}) are set
to zero:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{speciesA}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{speciesB}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{uu}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
     \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Finally, we need to assemble particle, wavefunction, and pseudopotential information into the main QMCPACK input file (\sphinxcode{\sphinxupquote{O.q0.opt.in.xml}}) and specify inputs for the Jastrow optimization process.  Open \sphinxcode{\sphinxupquote{O.q0.opt.in.xml}} and write in the location of the particle, wavefunction, and pseudopotential files (“\sphinxcode{\sphinxupquote{\textless{}!\sphinxhyphen{}\sphinxhyphen{} ... \sphinxhyphen{}\sphinxhyphen{}\textgreater{}}}” are comments):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
...
\PYGZlt{}!\PYGZhy{}\PYGZhy{} include simulationcell and particle information from pw2qmcpqack \PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZlt{}include href=\PYGZdq{}O.q0.ptcl.xml\PYGZdq{}/\PYGZgt{}
...
\PYGZlt{}!\PYGZhy{}\PYGZhy{} include wavefunction information from pw2qmcpqack \PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZlt{}include href=\PYGZdq{}O.q0.wfs.xml\PYGZdq{}/\PYGZgt{}
...
\PYGZlt{}!\PYGZhy{}\PYGZhy{} O pseudopotential read from \PYGZdq{}O.BFD.xml\PYGZdq{} \PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZlt{}pseudo elementType=\PYGZdq{}O\PYGZdq{} href=\PYGZdq{}O.BFD.xml\PYGZdq{}/\PYGZgt{}
...
\end{sphinxVerbatim}

The relevant portion of the input describing the linear optimization process is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{loop} \PYG{n+nb}{max}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MAX}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{linear}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pbyp}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{checkpoint}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{cost} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{energy}\PYG{l+s+s2}{\PYGZdq{}}              \PYG{o}{\PYGZgt{}}  \PYG{n}{ECOST}    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{cost}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{cost} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{unreweightedvariance}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{n}{UVCOST}   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{cost}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{cost} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{reweightedvariance}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{o}{\PYGZgt{}}  \PYG{n}{RVCOST}   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{cost}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}       \PYG{o}{\PYGZgt{}}  \PYG{n}{TS}       \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{samples}\PYG{l+s+s2}{\PYGZdq{}}        \PYG{o}{\PYGZgt{}}  \PYG{n}{SAMPLES}  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{warmupSteps}\PYG{l+s+s2}{\PYGZdq{}}    \PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{50}       \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}         \PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{200}      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{subSteps}\PYG{l+s+s2}{\PYGZdq{}}       \PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{1}        \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nonlocalpp}\PYG{l+s+s2}{\PYGZdq{}}     \PYG{o}{\PYGZgt{}}  \PYG{n}{yes}      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{useBuffer}\PYG{l+s+s2}{\PYGZdq{}}      \PYG{o}{\PYGZgt{}}  \PYG{n}{yes}      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{loop}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

An explanation of each input variable follows.  The remaining variables control specialized internal details of the linear optimization algorithm.  The meaning of these inputs is beyond the scope of this lab, and reasonable results are often obtained keeping these values fixed.
\begin{description}
\item[{energy}] \leavevmode
Fraction of trial energy in the cost function.

\item[{unreweightedvariance}] \leavevmode
Fraction of unreweighted trial variance in the cost function.
Neglecting the weights can be more robust.

\item[{reweightedvariance}] \leavevmode
Fraction of trial variance (including the full weights) in the cost
function.

\item[{timestep}] \leavevmode
Time step of the VMC random walk, determines spatial distance moved
by each electron during MC steps. Should be chosen such that the
acceptance ratio of MC moves is around 50\% (30\textendash{}70\% is often
acceptable). Reasonable values are often between 0.2 and 0.6
\(\textrm{Ha}^{-1}\).

\item[{samples}] \leavevmode
Total number of MC samples collected for optimization; determines
statistical error bar of cost function. It is often efficient to
start with a modest number of samples (50k) and then increase as
needed. More samples may be required if the wavefunction contains a
large number of variational parameters. MUST be be a multiple of the
number of threads/cores.

\item[{warmupSteps}] \leavevmode
Number of MC steps discarded as a warmup or equilibration period of
the random walk. If this is too small, it will bias the optimization
procedure.

\item[{blocks}] \leavevmode
Number of average energy values written to output files. Should be
greater than 200 for meaningful statistical analysis of output data
(e.g., via \sphinxcode{\sphinxupquote{qmca}}).

\item[{subSteps}] \leavevmode
Number of MC steps in between energy evaluations. Each energy
evaluation is expensive, so taking a few steps to decorrelate between
measurements can be more efficient. Will be less efficient with many
substeps.

\item[{nonlocalpp,useBuffer}] \leavevmode
If \sphinxcode{\sphinxupquote{nonlocalpp="no,"}} then the nonlocal part of the pseudopotential
is not included when computing the cost function. If
\sphinxcode{\sphinxupquote{useBuffer="yes,"}} then temporary data is stored to speed up
nonlocal pseudopotential evaluation at the expense of memory
consumption.

\item[{loop max}] \leavevmode
Number of times to repeat the optimization. Using the resulting
wavefunction from the previous optimization in the next one improves
the results. Typical choices range between 8 and 16.

\end{description}

The cost function defines the quantity to be minimized during
optimization. The three components of the cost function, energy,
unreweighted variance, and reweighted variance should sum to one.
Dedicating 100\% of the cost function to unreweighted variance is often a
good choice. Another common choice is to try 90/10 or 80/20 mixtures of
reweighted variance and energy. Using 100\% energy minimization is
desirable for reducing DMC pseudopotential localization errors, but the
optimization process is less stable and should be attempted only after
first performing several cycles of, for example, variance minimization
(the entire \sphinxcode{\sphinxupquote{loop}} section can be duplicated with a different cost
function each time).

Replace \sphinxcode{\sphinxupquote{MAX}}, \sphinxcode{\sphinxupquote{EVCOST}}, \sphinxcode{\sphinxupquote{UVCOST}}, \sphinxcode{\sphinxupquote{RVCOST}}, \sphinxcode{\sphinxupquote{TS}}, and \sphinxcode{\sphinxupquote{SAMPLES}} in the \sphinxcode{\sphinxupquote{loop}} with appropriate starting values in the \sphinxcode{\sphinxupquote{O.q0.opt.in.xml}} input file.  Perform the optimization run by typing

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{np} \PYG{l+m+mi}{4} \PYG{n}{qmcpack} \PYG{n}{O}\PYG{o}{.}\PYG{n}{q0}\PYG{o}{.}\PYG{n}{opt}\PYG{o}{.}\PYG{o+ow}{in}\PYG{o}{.}\PYG{n}{xml} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{n}{O}\PYG{o}{.}\PYG{n}{q0}\PYG{o}{.}\PYG{n}{opt}\PYG{o}{.}\PYG{n}{out}\PYG{o}{\PYGZam{}}
\end{sphinxVerbatim}

The run should take only a few minutes for reasonable values of loop \sphinxcode{\sphinxupquote{max}} and \sphinxcode{\sphinxupquote{samples}}.

The log file output will appear in \sphinxcode{\sphinxupquote{O.q0.opt.out}}.  The beginning of each linear optimization will be marked with text similar to

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{=}
  \PYG{n}{Start} \PYG{n}{QMCFixedSampleLinearOptimize}
  \PYG{n}{File} \PYG{n}{Root} \PYG{n}{O}\PYG{o}{.}\PYG{n}{q0}\PYG{o}{.}\PYG{n}{opt}\PYG{o}{.}\PYG{n}{s011} \PYG{n}{append} \PYG{o}{=} \PYG{n}{no}
\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{=}
\end{sphinxVerbatim}

At the end of each optimization section the change in cost function, new values for the Jastrow parameters, and elapsed wall clock time are reported:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{OldCost}\PYG{p}{:} \PYG{l+m+mf}{7.0598901869e\PYGZhy{}01} \PYG{n}{NewCost}\PYG{p}{:} \PYG{l+m+mf}{7.0592576381e\PYGZhy{}01} \PYG{n}{Delta} \PYG{n}{Cost}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.3254886314e\PYGZhy{}05}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
 \PYG{o}{\PYGZlt{}}\PYG{n}{optVariables} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{O.q0.opt.s011.opt.xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{n}{uu\PYGZus{}0} \PYG{l+m+mf}{6.9392504232e\PYGZhy{}01} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{0}
\PYG{n}{uu\PYGZus{}1} \PYG{l+m+mf}{4.9690781460e\PYGZhy{}01} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{1}
\PYG{n}{uu\PYGZus{}2} \PYG{l+m+mf}{4.0934542375e\PYGZhy{}01} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{2}
\PYG{n}{uu\PYGZus{}3} \PYG{l+m+mf}{3.7875640157e\PYGZhy{}01} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{3}
\PYG{n}{uu\PYGZus{}4} \PYG{l+m+mf}{3.7308380014e\PYGZhy{}01} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{4}
\PYG{n}{uu\PYGZus{}5} \PYG{l+m+mf}{3.5419786809e\PYGZhy{}01} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{5}
\PYG{n}{uu\PYGZus{}6} \PYG{l+m+mf}{4.3139019377e\PYGZhy{}01} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{6}
\PYG{n}{uu\PYGZus{}7} \PYG{l+m+mf}{1.9344371667e\PYGZhy{}01} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{7}
\PYG{n}{ud\PYGZus{}0} \PYG{l+m+mf}{3.9219009713e\PYGZhy{}01} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{8}
\PYG{n}{ud\PYGZus{}1} \PYG{l+m+mf}{1.2352664647e\PYGZhy{}01} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{9}
\PYG{n}{ud\PYGZus{}2} \PYG{l+m+mf}{4.4048945133e\PYGZhy{}02} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{10}
\PYG{n}{ud\PYGZus{}3} \PYG{l+m+mf}{2.1415676741e\PYGZhy{}02} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{11}
\PYG{n}{ud\PYGZus{}4} \PYG{l+m+mf}{1.5201803731e\PYGZhy{}02} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{12}
\PYG{n}{ud\PYGZus{}5} \PYG{l+m+mf}{2.3708169445e\PYGZhy{}02} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{13}
\PYG{n}{ud\PYGZus{}6} \PYG{l+m+mf}{3.4279064930e\PYGZhy{}02} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{14}
\PYG{n}{ud\PYGZus{}7} \PYG{l+m+mf}{4.3334583596e\PYGZhy{}02} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{15}
\PYG{n}{eO\PYGZus{}0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.8490123937e\PYGZhy{}01} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{16}
\PYG{n}{eO\PYGZus{}1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.6726618338e\PYGZhy{}01} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{17}
\PYG{n}{eO\PYGZus{}2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.8753453838e\PYGZhy{}01} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{18}
\PYG{n}{eO\PYGZus{}3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.0913993774e\PYGZhy{}01} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{19}
\PYG{n}{eO\PYGZus{}4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.7901872177e\PYGZhy{}01} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{20}
\PYG{n}{eO\PYGZus{}5} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{8.6199000697e\PYGZhy{}02} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{21}
\PYG{n}{eO\PYGZus{}6} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.0601160841e\PYGZhy{}02} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{22}
\PYG{n}{eO\PYGZus{}7} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.1358075061e\PYGZhy{}03} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}  \PYG{n}{ON} \PYG{l+m+mi}{23}
 \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{optVariables}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
 \PYG{n}{QMC} \PYG{n}{Execution} \PYG{n}{time} \PYG{o}{=} \PYG{l+m+mf}{2.8218972974e+01} \PYG{n}{secs}
\end{sphinxVerbatim}

The cost function should decrease during each linear optimization (\sphinxcode{\sphinxupquote{Delta cost \textless{} 0}}).  Try “\sphinxcode{\sphinxupquote{grep OldCost *opt.out.}}”  You should see something like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{OldCost}\PYG{p}{:} \PYG{l+m+mf}{1.2655186572e+00} \PYG{n}{NewCost}\PYG{p}{:} \PYG{l+m+mf}{7.2443875597e\PYGZhy{}01} \PYG{n}{Delta} \PYG{n}{Cost}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.4107990118e\PYGZhy{}01}
\PYG{n}{OldCost}\PYG{p}{:} \PYG{l+m+mf}{7.2229830632e\PYGZhy{}01} \PYG{n}{NewCost}\PYG{p}{:} \PYG{l+m+mf}{6.9833678217e\PYGZhy{}01} \PYG{n}{Delta} \PYG{n}{Cost}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.3961524143e\PYGZhy{}02}
\PYG{n}{OldCost}\PYG{p}{:} \PYG{l+m+mf}{8.0649629434e\PYGZhy{}01} \PYG{n}{NewCost}\PYG{p}{:} \PYG{l+m+mf}{8.0551871147e\PYGZhy{}01} \PYG{n}{Delta} \PYG{n}{Cost}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{9.7758287036e\PYGZhy{}04}
\PYG{n}{OldCost}\PYG{p}{:} \PYG{l+m+mf}{6.6821241388e\PYGZhy{}01} \PYG{n}{NewCost}\PYG{p}{:} \PYG{l+m+mf}{6.6797703487e\PYGZhy{}01} \PYG{n}{Delta} \PYG{n}{Cost}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.3537901148e\PYGZhy{}04}
\PYG{n}{OldCost}\PYG{p}{:} \PYG{l+m+mf}{7.0106275099e\PYGZhy{}01} \PYG{n}{NewCost}\PYG{p}{:} \PYG{l+m+mf}{7.0078055426e\PYGZhy{}01} \PYG{n}{Delta} \PYG{n}{Cost}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.8219672877e\PYGZhy{}04}
\PYG{n}{OldCost}\PYG{p}{:} \PYG{l+m+mf}{6.9538522411e\PYGZhy{}01} \PYG{n}{NewCost}\PYG{p}{:} \PYG{l+m+mf}{6.9419186712e\PYGZhy{}01} \PYG{n}{Delta} \PYG{n}{Cost}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.1933569922e\PYGZhy{}03}
\PYG{n}{OldCost}\PYG{p}{:} \PYG{l+m+mf}{6.7709626744e\PYGZhy{}01} \PYG{n}{NewCost}\PYG{p}{:} \PYG{l+m+mf}{6.7501251165e\PYGZhy{}01} \PYG{n}{Delta} \PYG{n}{Cost}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0837557922e\PYGZhy{}03}
\PYG{n}{OldCost}\PYG{p}{:} \PYG{l+m+mf}{6.6659923822e\PYGZhy{}01} \PYG{n}{NewCost}\PYG{p}{:} \PYG{l+m+mf}{6.6651737755e\PYGZhy{}01} \PYG{n}{Delta} \PYG{n}{Cost}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{8.1860671682e\PYGZhy{}05}
\PYG{n}{OldCost}\PYG{p}{:} \PYG{l+m+mf}{7.7828995609e\PYGZhy{}01} \PYG{n}{NewCost}\PYG{p}{:} \PYG{l+m+mf}{7.7735482525e\PYGZhy{}01} \PYG{n}{Delta} \PYG{n}{Cost}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{9.3513083900e\PYGZhy{}04}
\PYG{n}{OldCost}\PYG{p}{:} \PYG{l+m+mf}{7.2717974404e\PYGZhy{}01} \PYG{n}{NewCost}\PYG{p}{:} \PYG{l+m+mf}{7.2715201115e\PYGZhy{}01} \PYG{n}{Delta} \PYG{n}{Cost}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.7732880747e\PYGZhy{}05}
\PYG{n}{OldCost}\PYG{p}{:} \PYG{l+m+mf}{6.9400639873e\PYGZhy{}01} \PYG{n}{NewCost}\PYG{p}{:} \PYG{l+m+mf}{6.9257183689e\PYGZhy{}01} \PYG{n}{Delta} \PYG{n}{Cost}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.4345618444e\PYGZhy{}03}
\PYG{n}{OldCost}\PYG{p}{:} \PYG{l+m+mf}{7.0598901869e\PYGZhy{}01} \PYG{n}{NewCost}\PYG{p}{:} \PYG{l+m+mf}{7.0592576381e\PYGZhy{}01} \PYG{n}{Delta} \PYG{n}{Cost}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.3254886314e\PYGZhy{}05}
\end{sphinxVerbatim}

Blocked averages of energy data, including the kinetic energy and components of the potential energy, are written to \sphinxcode{\sphinxupquote{scalar.dat}} files.  The first is named “\sphinxcode{\sphinxupquote{O.q0.opt.s000.scalar.dat}},” with a series number of zero (\sphinxcode{\sphinxupquote{s000}}).  In the end there will be \sphinxcode{\sphinxupquote{MAX}} of them, one for each series.

When the job has finished, use the \sphinxcode{\sphinxupquote{qmca}} tool to assess the effectiveness of the optimization process.  To look at just the total energy and the variance, type “\sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}q ev O.q0.opt*scalar*}}.”  This will print the energy, variance, and the variance/energy ratio in Hartree units:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
                  \PYG{n}{LocalEnergy}               \PYG{n}{Variance}           \PYG{n}{ratio}
\PYG{n}{O}\PYG{o}{.}\PYG{n}{q0}\PYG{o}{.}\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{15.739585} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.007656}   \PYG{l+m+mf}{0.887412} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.010728}   \PYG{l+m+mf}{0.0564}
\PYG{n}{O}\PYG{o}{.}\PYG{n}{q0}\PYG{o}{.}\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{1}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{15.848347} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.004089}   \PYG{l+m+mf}{0.318490} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.006404}   \PYG{l+m+mf}{0.0201}
\PYG{n}{O}\PYG{o}{.}\PYG{n}{q0}\PYG{o}{.}\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{2}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{15.867494} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.004831}   \PYG{l+m+mf}{0.292309} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.007786}   \PYG{l+m+mf}{0.0184}
\PYG{n}{O}\PYG{o}{.}\PYG{n}{q0}\PYG{o}{.}\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{3}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{15.871508} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.003025}   \PYG{l+m+mf}{0.275364} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.006045}   \PYG{l+m+mf}{0.0173}
\PYG{n}{O}\PYG{o}{.}\PYG{n}{q0}\PYG{o}{.}\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{4}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{15.865512} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.002997}   \PYG{l+m+mf}{0.278056} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.006523}   \PYG{l+m+mf}{0.0175}
\PYG{n}{O}\PYG{o}{.}\PYG{n}{q0}\PYG{o}{.}\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{5}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{15.864967} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.002733}   \PYG{l+m+mf}{0.278065} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.004413}   \PYG{l+m+mf}{0.0175}
\PYG{n}{O}\PYG{o}{.}\PYG{n}{q0}\PYG{o}{.}\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{6}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{15.869644} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.002949}   \PYG{l+m+mf}{0.273497} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.006141}   \PYG{l+m+mf}{0.0172}
\PYG{n}{O}\PYG{o}{.}\PYG{n}{q0}\PYG{o}{.}\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{7}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{15.868397} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.003838}   \PYG{l+m+mf}{0.285451} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.007570}   \PYG{l+m+mf}{0.0180}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

Plots of the data can also be obtained with the “\sphinxcode{\sphinxupquote{\sphinxhyphen{}p}}” option
(“\sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}p \sphinxhyphen{}q ev O.q0.opt*scalar*}}”).

Identify which optimization series is the “best” according to your cost function.  It is likely that multiple series are similar in quality.  Note the \sphinxcode{\sphinxupquote{opt.xml}} file corresponding to this series.  This file contains the final value of the optimized Jastrow parameters to be used in the DMC calculations of the next section of the lab.

\sphinxstylestrong{Questions and Exercises}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
What is the acceptance ratio of your optimization runs? (use
“texttqmca \sphinxhyphen{}q ar O.q0.opt*scalar*”) Do you expect the MC sampling to
be efficient?

\item {} 
How do you know when the optimization process has converged?

\item {} 
(optional) Optimization is sometimes sensitive to initial guesses of
the parameters. If you have time, try varying the initial parameters,
including the cutoff radius (\sphinxcode{\sphinxupquote{rcut}}) of the Jastrow factors
(remember to change \sphinxcode{\sphinxupquote{id}} in the \sphinxcode{\sphinxupquote{\textless{}project/\textgreater{}}} element). Do you
arrive at a similar set of final Jastrow parameters? What is the
lowest variance you are able to achieve?

\end{enumerate}


\section{DMC timestep extrapolation I: neutral oxygen atom}
\label{\detokenize{lab_qmc_basics:dmc-timestep-extrapolation-i-neutral-oxygen-atom}}
The DMC algorithm contains two biases in addition to the fixed node and pseudopotential approximations that are important to control: time step and population control bias.  In this section we focus on estimating and removing time step bias from DMC calculations.  The essential fact to remember is that the bias vanishes as the time step goes to zero, while the needed computer time increases inversely with the time step.

In the same directory you used to perform wavefunction optimization (\sphinxcode{\sphinxupquote{oxygen\_atom}}) you will find a sample DMC input file for the neutral oxygen atom named \sphinxcode{\sphinxupquote{O.q0.dmc.in.xml}}.  Open this file in a text editor and note the differences from the optimization case.  Wavefunction information is no longer included from \sphinxcode{\sphinxupquote{pw2qmcpack}} but instead should come from the optimization run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}!\PYGZhy{}\PYGZhy{} OPT\PYGZus{}XML is from optimization, e.g. O.q0.opt.s008.opt.xml \PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZlt{}include href=\PYGZdq{}OPT\PYGZus{}XML\PYGZdq{}/\PYGZgt{}
\end{sphinxVerbatim}

Replace “\sphinxcode{\sphinxupquote{OPT\_XML}}” with the \sphinxcode{\sphinxupquote{opt.xml}} file corresponding to the best Jastrow parameters you found in the last section (this is a file name similar to \sphinxcode{\sphinxupquote{O.q0.opt.s008.opt.xml}}).

The QMC calculation section at the bottom is also different.  The linear optimization blocks have been replaced with XML describing a VMC run followed by DMC.  Descriptions of the input keywords follow.
\begin{description}
\item[{timestep}] \leavevmode
Time step of the VMC/DMC random walk. In VMC choose a time step
corresponding to an acceptance ratio of about 50\%. In DMC the
acceptance ratio is often above 99\%.

\item[{warmupSteps}] \leavevmode
Number of MC steps discarded as a warmup or equilibration period of
the random walk.

\item[{steps}] \leavevmode
Number of MC steps per block. Physical quantities, such as the total
energy, are averaged over walkers and steps.

\item[{blocks}] \leavevmode
Number of blocks. This is also the number of average energy values
written to output files. The number should be greater than 200 for
meaningful statistical analysis of output data (e.g., via \sphinxcode{\sphinxupquote{qmca}}).
The total number of MC steps each walker takes is
\sphinxcode{\sphinxupquote{blocks}}\(\times\)\sphinxcode{\sphinxupquote{steps}}.

\item[{samples}] \leavevmode
VMC only. This is the number of walkers used in subsequent DMC runs.
Each DMC walker is initialized with electron positions sampled from
the VMC random walk.

\item[{nonlocalmoves}] \leavevmode
DMC only. If yes/no, use the locality approximation/T\sphinxhyphen{}moves for
nonlocal pseudopotentials. T\sphinxhyphen{}moves generally improve the stability of
the algorithm and restore the variational principle for small systems
(T\sphinxhyphen{}moves version 1).

\end{description}

The purpose of the VMC run is to provide initial electron positions for each DMC walker.  Setting \(\texttt{walkers}=1\) in the VMC block ensures there will be only one VMC walker per execution thread.  There will be a total of 4 VMC walkers in this case (see \sphinxcode{\sphinxupquote{O.q0.dmc.qsub.in}}).  We want the electron positions used to initialize the DMC walkers to be decorrelated from one another.  A VMC walker will often decorrelate from its current position after propagating for a few Ha \(^{-1}\) in imaginary time (in general, this is system dependent).  This leads to a rough rule of thumb for choosing \sphinxcode{\sphinxupquote{blocks}} and \sphinxcode{\sphinxupquote{steps}} for the VMC run (\(\texttt{vwalkers}=4\) here):
\begin{equation}\label{equation:lab_qmc_basics:eq68}
\begin{split}\begin{aligned}
   \texttt{VBLOCKS}\times\texttt{VSTEPS} \ge \frac{\texttt{DWALKERS}}{\texttt{VWALKERS}} \frac{5~\textrm{Ha}^{-1}}{\texttt{VTIMESTEP}}\end{aligned}\end{split}
\end{equation}
Fill in the VMC XML block with appropriate values for these parameters.
There should be more than one DMC walker per thread and enough walkers
in total to avoid population control bias. The general rule of thumb is
to have more than \(\sim 2,000\) walkers, although the dependence of
the total energy on population size should be explicitly checked from
time to time.

To study time step bias, we will perform a sequence of DMC runs over a
range of time steps (\(0.1\) Ha\(^{-1}\) is too large, and
time steps below \(0.002\) Ha\(^{-1}\) are probably too
small). A common approach is to select a fairly large time step to begin
with and then decrease the time step by a factor of two in each
subsequent DMC run. The total amount of imaginary time the walker
population propagates should be the same for each run. A simple way to
accomplish this is to choose input parameters in the following way
\begin{equation}\label{equation:lab_qmc_basics:eq69}
\begin{split} \begin{aligned}
   \texttt{timestep}_{n}    &= \texttt{timestep}_{n-1}/2\nonumber\\
   \texttt{warmupSteps}_{n} &= \texttt{warmupSteps}_{n-1}\times 2\nonumber\\
   \texttt{blocks}_{n}      &= \texttt{blocks}_{n-1}\nonumber\\
   \texttt{steps}_{n}       &= \texttt{steps}_{n-1}\times 2\end{aligned}\end{split}
\end{equation}
Each DMC run will require about twice as much computer time as the one
preceding it. Note that the number of blocks is kept fixed for uniform
statistical analysis.
\(\texttt{blocks}\times\texttt{steps}\times\texttt{timestep}\sim 60~\mathrm{Ha}^{-1}\)
is sufficient for this system.

Choose an initial DMC time step and create a sequence of \(N\) time steps according to \eqref{equation:lab_qmc_basics:eq69}.  Make \(N\) copies of the DMC XML block in the input file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dmc}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pbyp}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{warmupSteps}\PYG{l+s+s2}{\PYGZdq{}}         \PYG{o}{\PYGZgt{}}    \PYG{n}{DWARMUP}         \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}              \PYG{o}{\PYGZgt{}}    \PYG{n}{DBLOCKS}         \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{steps}\PYG{l+s+s2}{\PYGZdq{}}               \PYG{o}{\PYGZgt{}}    \PYG{n}{DSTEPS}          \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}            \PYG{o}{\PYGZgt{}}    \PYG{n}{DTIMESTEP}       \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nonlocalmoves}\PYG{l+s+s2}{\PYGZdq{}}       \PYG{o}{\PYGZgt{}}    \PYG{n}{yes}             \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Fill in \sphinxcode{\sphinxupquote{DWARMUP}}, \sphinxcode{\sphinxupquote{DBLOCKS}}, \sphinxcode{\sphinxupquote{DSTEPS}}, and \sphinxcode{\sphinxupquote{DTIMESTEP}} for each DMC run according to \eqref{equation:lab_qmc_basics:eq69}.  Start the DMC time step extrapolation run by typing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{np} \PYG{l+m+mi}{4} \PYG{n}{qmcpack} \PYG{n}{O}\PYG{o}{.}\PYG{n}{q0}\PYG{o}{.}\PYG{n}{dmc}\PYG{o}{.}\PYG{o+ow}{in}\PYG{o}{.}\PYG{n}{xml} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{n}{O}\PYG{o}{.}\PYG{n}{q0}\PYG{o}{.}\PYG{n}{dmc}\PYG{o}{.}\PYG{n}{out}\PYG{o}{\PYGZam{}}
\end{sphinxVerbatim}

The run should take only a few minutes to complete.

QMCPACK will create files prefixed with \sphinxcode{\sphinxupquote{O.q0.dmc}}.  The log file is \sphinxcode{\sphinxupquote{O.q0.dmc.out}}.  As before, block\sphinxhyphen{}averaged data is written to \sphinxcode{\sphinxupquote{scalar.dat}} files.  In addition, DMC runs produce \sphinxcode{\sphinxupquote{dmc.dat}} files, which contain energy data averaged only over the walker population (one line per DMC step).  The \sphinxcode{\sphinxupquote{dmc.dat}} files also provide a record of the walker population at each step.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{lab_qmc_basics_timestep_conv}.jpg}
\caption{Linear fit to DMC timestep data from \sphinxcode{\sphinxupquote{PlotTstepConv.pl}}.}\label{\detokenize{lab_qmc_basics:id3}}\label{\detokenize{lab_qmc_basics:fig16}}\end{figure}

Use the \sphinxcode{\sphinxupquote{PlotTstepConv.pl}} to obtain a linear fit to the time step data (type “\sphinxcode{\sphinxupquote{PlotTstepConv.pl O.q0.dmc.in.xml 40}}”).  You should see a plot similar to \hyperref[\detokenize{lab_qmc_basics:fig16}]{Fig.\@ \ref{\detokenize{lab_qmc_basics:fig16}}}.  The tail end of the text output displays the parameters for the linear fit.  The “\sphinxcode{\sphinxupquote{a}}” parameter is the total energy extrapolated to zero time step in Hartree units.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{Final} \PYG{n+nb}{set} \PYG{n}{of} \PYG{n}{parameters}            \PYG{n}{Asymptotic} \PYG{n}{Standard} \PYG{n}{Error}
\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{=}            \PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}

\PYG{n}{a}               \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{15.8925}         \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.0007442}    \PYG{p}{(}\PYG{l+m+mf}{0.004683}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{b}               \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0457479}       \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.0422}       \PYG{p}{(}\PYG{l+m+mf}{92.24}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxstylestrong{Questions and Exercises}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
What is the \(\tau\rightarrow 0\) extrapolated value for the
total energy?

\item {} 
What is the maximum time step you should use if you want to calculate
the total energy to an accuracy of \(0.05\) eV? For convenience,
\(1~\textrm{Ha}=27.2113846~\textrm{eV}\).

\item {} 
What is the acceptance ratio for this (bias \(<0.05\) eV) run?
Does it follow the rule of thumb for sensible DMC (acceptance ratio
\(>99\)\%) ?

\item {} 
Check the fluctuations in the walker population
(\sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}t \sphinxhyphen{}q nw O.q0.dmc*dmc.dat \textendash{}noac}}). Does the population seem
to be stable?

\item {} 
(Optional) Study population control bias for the oxygen atom. Select
a few population sizes. Copy \sphinxcode{\sphinxupquote{O.q0.dmc.in.xml}} to a new file and
remove all but one DMC run (select a single time step). Make one copy
of the new file for each population, set “textttsamples,” and choose
a unique \sphinxcode{\sphinxupquote{id}} in \sphinxcode{\sphinxupquote{\textless{}project/\textgreater{}}}. Use \sphinxcode{\sphinxupquote{qmca}} to study the
dependence of the DMC total energy on the walker population. How
large is the bias compared with time step error? What bias is
incurred by following the “rule of thumb” of a couple thousand
walkers? Will population control bias generally be an issue for
production runs on modern parallel machines?

\end{enumerate}


\section{DMC time step extrapolation II: oxygen atom ionization potential}
\label{\detokenize{lab_qmc_basics:dmc-time-step-extrapolation-ii-oxygen-atom-ionization-potential}}
In this section, we will repeat the calculations of the previous two
sections (optimization, time step extrapolation) for the \(+1\)
charge state of the oxygen atom. Comparing the resulting first
ionization potential (IP) with experimental data will complete our first
test of the BFD oxygen pseudopotential. In actual practice, higher IPs
could also be tested before performing production runs.

Obtaining the time step extrapolated DMC total energy for ionized oxygen
should take much less (human) time than for the neutral case. For
convenience, the necessary steps are summarized as follows.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Obtain DFT orbitals with QE.

\end{enumerate}
\begin{quote}
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{(}{)}%
\item {} 
Copy the DFT input (\sphinxcode{\sphinxupquote{O.q0.dft.in}}) to \sphinxcode{\sphinxupquote{O.q1.dft.in}}

\item {} 
Edit \sphinxcode{\sphinxupquote{O.q1.dft.in}} to match the +1 charge state of the oxygen atom.

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{prefix}            \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O.q1}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{tot\PYGZus{}charge}        \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{tot\PYGZus{}magnetization} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{(}{)}%
\setcounter{enumi}{2}
\item {} 
Perform the DFT run: \sphinxcode{\sphinxupquote{mpirun \sphinxhyphen{}np 4 pw.x \sphinxhyphen{}input O.q1.dft.in \textgreater{}\&O.q1.dft.out\&}}

\end{enumerate}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Convert the orbitals to ESHDF format.

\end{enumerate}
\begin{quote}
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{(}{)}%
\item {} 
Copy the pw2qmcpack input (\sphinxcode{\sphinxupquote{O.q0.p2q.in}}) to \sphinxcode{\sphinxupquote{O.q1.p2q.in}}

\item {} 
Edit \sphinxcode{\sphinxupquote{O.q1.p2q.in}} to match the file prefix used in DFT.

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{prefix} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O.q1}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{(}{)}%
\setcounter{enumi}{2}
\item {} 
Perform the orbital conversion run: \sphinxcode{\sphinxupquote{mpirun \sphinxhyphen{}np 1 pw2qmcpack.x\textless{}O.q1.p2q.in\textgreater{}\&O.q1.p2q.out\&}}

\end{enumerate}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Optimize the Jastrow factor with QMCPACK.

\end{enumerate}
\begin{quote}
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{(}{)}%
\item {} 
Copy the optimization input (\sphinxcode{\sphinxupquote{O.q0.opt.in.xml}}) to \sphinxcode{\sphinxupquote{O.q1.opt.in.xml}}

\item {} 
Edit \sphinxcode{\sphinxupquote{O.q1.opt.in.xml}} to match the file prefix used in DFT.

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{project} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{O.q1.opt}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{series}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{include} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{O.q1.ptcl.xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{include} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{O.q1.wfs.xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{(}{)}%
\setcounter{enumi}{2}
\item {} 
Edit the particle XML file (\sphinxcode{\sphinxupquote{O.q1.ptcl.xml}}) to have open boundary conditions.

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bconds}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{n}{n} \PYG{n}{n} \PYG{n}{n}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{(}{)}%
\setcounter{enumi}{3}
\item {} 
Add cutoffs to the Jastrow factors in the wavefunction XML file (\sphinxcode{\sphinxupquote{O.q1.wfs.xml}})

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{speciesA}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{speciesB}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{speciesA}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{speciesB}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{O}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{5.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{(}{)}%
\setcounter{enumi}{4}
\item {} 
Perform the Jastrow optimization run: \sphinxcode{\sphinxupquote{mpirun \sphinxhyphen{}np 4 qmcpack O.q1.opt.in.xml \textgreater{}\&O.q1.opt.out\&}}

\item {} 
Identify the optimal set of parameters with \sphinxcode{\sphinxupquote{qmca}} (\sphinxcode{\sphinxupquote{{[}your opt.xml{]}}}).

\end{enumerate}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
DMC time step study with QMCPACK

\end{enumerate}
\begin{quote}
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{(}{)}%
\item {} 
Copy the DMC input (\sphinxcode{\sphinxupquote{O.q0.dmc.in.xml}}) to \sphinxcode{\sphinxupquote{O.q1.dmc.in.xml}}

\item {} 
Edit \sphinxcode{\sphinxupquote{O.q1.dmc.in.xml}} to use the DFT prefix and the optimal Jastrow.

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{project} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{O.q1.dmc}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{series}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{include} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{O.q1.ptcl.xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{include} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{[your opt.xml]}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{(}{)}%
\setcounter{enumi}{2}
\item {} 
Perform the DMC run: \sphinxcode{\sphinxupquote{mpirun \sphinxhyphen{}np 4 qmcpack O.q1.dmc.in.xml \textgreater{}\&O.q1.dmc.out\&}}

\item {} 
Obtain the DMC total energy extrapolated to zero time step with \sphinxcode{\sphinxupquote{PlotTstepConv.pl}}.

\end{enumerate}
\end{quote}

The aforementioned process, which excludes additional steps for orbital generation and conversion, can become tedious to perform by hand in production settings where many calculations are often required.  For this reason, automation tools are introduced for calculations involving the oxygen dimer in {\hyperref[\detokenize{lab_qmc_basics:dimer-automation}]{\sphinxcrossref{\DUrole{std,std-ref}{Automated binding curve of the oxygen dimer}}}} of the lab.

\sphinxstylestrong{Questions and Exercises}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
What is the \(\tau\rightarrow 0\) extrapolated DMC value for the
first ionization potential of oxygen?

\item {} 
How does the extrapolated value compare with the experimental IP? Go
to \sphinxurl{http://physics.nist.gov/PhysRefData/ASD/ionEnergy.html} and enter
“\sphinxcode{\sphinxupquote{O I}}” in the box labeled “\sphinxcode{\sphinxupquote{Spectra}}” and click on the
“\sphinxcode{\sphinxupquote{Retrieve Data}}” button.

\item {} 
What can we conclude about the accuracy of the pseudopotential? What
factors complicate this assessment?

\item {} 
Explore the sensitivity of the IP to the choice of time step. Type \sphinxcode{\sphinxupquote{./ip\_conv.py}} to
view three time step extrapolation plots: two for the \(q=0,\)
one for total energies, and one for the IP. Is the IP more, less, or
similarly sensitive to time step than the total energy?

\item {} 
What is the maximum time step you should use if you want to calculate
the ionization potential to an accuracy of \(0.05\) eV? What
factor of CPU time is saved by assessing time step convergence on the
IP (a total energy difference) vs. a single total energy?

\item {} 
Are the acceptance ratio and population fluctuations reasonable for
the \(q=1\) calculations?

\end{enumerate}


\section{DMC workflow automation with Nexus}
\label{\detokenize{lab_qmc_basics:dmc-workflow-automation-with-nexus}}
Production QMC projects are often composed of many similar workflows.  The simplest of these is a single DMC calculation involving four different compute jobs:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Orbital generation via QE or GAMESS.

\item {} 
Conversion of orbital data via \sphinxcode{\sphinxupquote{pw2qmcpack.x}} or \sphinxcode{\sphinxupquote{convert4qmc}}.

\item {} 
Optimization of Jastrow factors via QMCPACK.

\item {} 
DMC calculation via QMCPACK.

\end{enumerate}

Simulation workflows quickly become more complex with increasing costs in terms of human time for the researcher.  Automation tools can decrease both human time and error if used well.

The set of automation tools we will be using is known as Nexus \sphinxcite{lab_qmc_basics:krogel2016nexus}, which is distributed with QMCPACK.  Nexus is capable of generating input files, submitting and monitoring compute jobs, passing data between simulations (relaxed structures, orbital files, optimized Jastrow parameters, etc.), and data analysis.  The user interface to Nexus is through a set of functions defined in the Python programming language.  User scripts that execute simple workflows resemble input files and do not require programming experience.  More complex workflows require only basic programming constructs (e.g. for loops and if statements).  Nexus input files/scripts should be easier to navigate than QMCPACK input files and more efficient than submitting all the jobs by hand.

Nexus is driven by simple user\sphinxhyphen{}defined scripts that resemble keyword\sphinxhyphen{}driven input files.  An example Nexus input file that performs a single VMC calculation (with pregenerated orbitals) follows.  Take a moment to read it over and especially note the comments (prefixed with “\sphinxcode{\sphinxupquote{\textbackslash{}\#}}”) explaining most of the contents.  If the input syntax is unclear you may want to consult portions of {\hyperref[\detokenize{lab_qmc_basics:python-basics}]{\sphinxcrossref{\DUrole{std,std-ref}{Appendix A: Basic Python constructs}}}}, which gives a condensed summary of Python constructs.  An additional example and details about the inner workings of Nexus can be found in the reference publication \sphinxcite{lab_qmc_basics:krogel2016nexus}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}! /usr/bin/env python3}

\PYG{c+c1}{\PYGZsh{} import Nexus functions}
\PYG{k+kn}{from} \PYG{n+nn}{nexus} \PYG{k+kn}{import} \PYG{n}{settings}\PYG{p}{,}\PYG{n}{job}\PYG{p}{,}\PYG{n}{get\PYGZus{}machine}\PYG{p}{,}\PYG{n}{run\PYGZus{}project}
\PYG{k+kn}{from} \PYG{n+nn}{nexus} \PYG{k+kn}{import} \PYG{n}{generate\PYGZus{}physical\PYGZus{}system}
\PYG{k+kn}{from} \PYG{n+nn}{nexus} \PYG{k+kn}{import} \PYG{n}{generate\PYGZus{}qmcpack}\PYG{p}{,}\PYG{n}{vmc}

\PYG{n}{settings}\PYG{p}{(}                             \PYG{c+c1}{\PYGZsh{} Nexus settings}
    \PYG{n}{pseudo\PYGZus{}dir}    \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./pseudopotentials}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} location of PP files}
    \PYG{n}{runs}          \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}                   \PYG{c+c1}{\PYGZsh{} root directory for simulations}
    \PYG{n}{results}       \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}                   \PYG{c+c1}{\PYGZsh{} root directory for simulation results}
    \PYG{n}{status\PYGZus{}only}   \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,}                    \PYG{c+c1}{\PYGZsh{} show simulation status, then exit}
    \PYG{n}{generate\PYGZus{}only} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,}                    \PYG{c+c1}{\PYGZsh{} generate input files, then exit}
    \PYG{n}{sleep}         \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,}                    \PYG{c+c1}{\PYGZsh{} seconds between checks on sim. progress}
    \PYG{n}{machine}       \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ws4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}                \PYG{c+c1}{\PYGZsh{} workstation with 4 cores}
    \PYG{p}{)}

\PYG{n}{qmcjob} \PYG{o}{=} \PYG{n}{job}\PYG{p}{(}                         \PYG{c+c1}{\PYGZsh{} specify job parameters}
    \PYG{n}{cores}   \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{,}                          \PYG{c+c1}{\PYGZsh{} use 4 MPI tasks}
    \PYG{n}{threads} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,}                          \PYG{c+c1}{\PYGZsh{} 1 OpenMP thread per node}
    \PYG{n}{app}     \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{qmcpack}\PYG{l+s+s1}{\PYGZsq{}}                   \PYG{c+c1}{\PYGZsh{} use QMCPACK executable (assumed in PATH)}
    \PYG{p}{)}

\PYG{n}{qmc\PYGZus{}calcs} \PYG{o}{=} \PYG{p}{[}                         \PYG{c+c1}{\PYGZsh{} list QMC calculation methods}
    \PYG{n}{vmc}\PYG{p}{(}                                  \PYG{c+c1}{\PYGZsh{}   VMC}
        \PYG{n}{walkers}     \PYG{o}{=}   \PYG{l+m+mi}{1}\PYG{p}{,}                \PYG{c+c1}{\PYGZsh{}     1 walker}
        \PYG{n}{warmupsteps} \PYG{o}{=}  \PYG{l+m+mi}{50}\PYG{p}{,}                \PYG{c+c1}{\PYGZsh{}    50 MC steps for warmup}
        \PYG{n}{blocks}      \PYG{o}{=} \PYG{l+m+mi}{200}\PYG{p}{,}                \PYG{c+c1}{\PYGZsh{}   200 blocks}
        \PYG{n}{steps}       \PYG{o}{=}  \PYG{l+m+mi}{10}\PYG{p}{,}                \PYG{c+c1}{\PYGZsh{}    10 steps per block}
        \PYG{n}{timestep}    \PYG{o}{=}  \PYG{o}{.}\PYG{l+m+mi}{4}                 \PYG{c+c1}{\PYGZsh{}   0.4 1/Ha timestep}
        \PYG{p}{)}\PYG{p}{]}

\PYG{n}{dimer} \PYG{o}{=} \PYG{n}{generate\PYGZus{}physical\PYGZus{}system}\PYG{p}{(}     \PYG{c+c1}{\PYGZsh{} make a dimer system}
    \PYG{n+nb}{type}       \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dimer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}                 \PYG{c+c1}{\PYGZsh{} system type is dimer}
    \PYG{n}{dimer}      \PYG{o}{=} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}               \PYG{c+c1}{\PYGZsh{} dimer is two oxygen atoms}
    \PYG{n}{separation} \PYG{o}{=} \PYG{l+m+mf}{1.2074}\PYG{p}{,}                  \PYG{c+c1}{\PYGZsh{} separated by 1.2074 Angstrom}
    \PYG{n}{Lbox}       \PYG{o}{=} \PYG{l+m+mf}{15.0}\PYG{p}{,}                    \PYG{c+c1}{\PYGZsh{} simulation box is 15 Angstrom}
    \PYG{n}{units}      \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}                     \PYG{c+c1}{\PYGZsh{} Angstrom is dist. unit}
    \PYG{n}{net\PYGZus{}spin}   \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,}                       \PYG{c+c1}{\PYGZsh{} nup\PYGZhy{}ndown is 2}
    \PYG{n}{O}          \PYG{o}{=} \PYG{l+m+mi}{6}                        \PYG{c+c1}{\PYGZsh{} pseudo\PYGZhy{}oxygen has 6 valence el.}
    \PYG{p}{)}

\PYG{n}{qmc} \PYG{o}{=} \PYG{n}{generate\PYGZus{}qmcpack}\PYG{p}{(}                \PYG{c+c1}{\PYGZsh{} make a qmcpack simulation}
    \PYG{n}{identifier}   \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{example}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}             \PYG{c+c1}{\PYGZsh{} prefix files with \PYGZsq{}example\PYGZsq{}}
    \PYG{n}{path}         \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scale\PYGZus{}1.0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}           \PYG{c+c1}{\PYGZsh{} run in ./scale\PYGZus{}1.0 directory}
    \PYG{n}{system}       \PYG{o}{=} \PYG{n}{dimer}\PYG{p}{,}                 \PYG{c+c1}{\PYGZsh{} run the dimer system}
    \PYG{n}{job}          \PYG{o}{=} \PYG{n}{qmcjob}\PYG{p}{,}                \PYG{c+c1}{\PYGZsh{} set job parameters}
    \PYG{n}{input\PYGZus{}type}   \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{basic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}               \PYG{c+c1}{\PYGZsh{} basic qmcpack inputs given below}
    \PYG{n}{pseudos}      \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O.BFD.xml}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}         \PYG{c+c1}{\PYGZsh{} list of PP\PYGZsq{}s to use}
    \PYG{n}{orbitals\PYGZus{}h5}  \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O2.pwscf.h5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}         \PYG{c+c1}{\PYGZsh{} file with orbitals from DFT}
    \PYG{n}{bconds}       \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nnn}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}                 \PYG{c+c1}{\PYGZsh{} open boundary conditions}
    \PYG{n}{jastrows}     \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}\PYG{p}{,}                    \PYG{c+c1}{\PYGZsh{} no jastrow factors}
    \PYG{n}{calculations} \PYG{o}{=} \PYG{n}{qmc\PYGZus{}calcs}              \PYG{c+c1}{\PYGZsh{} QMC calculations to perform}
    \PYG{p}{)}

\PYG{n}{run\PYGZus{}project}\PYG{p}{(}\PYG{n}{qmc}\PYG{p}{)}                       \PYG{c+c1}{\PYGZsh{} write input file and submit job}
\end{sphinxVerbatim}


\section{Automated binding curve of the oxygen dimer}
\label{\detokenize{lab_qmc_basics:automated-binding-curve-of-the-oxygen-dimer}}\label{\detokenize{lab_qmc_basics:dimer-automation}}
In this section we will use Nexus to calculate the DMC total energy of the oxygen dimer over a series of bond lengths.  The equilibrium bond length and binding energy of the dimer will be determined by performing a polynomial fit to the data (Morse potential fits should be preferred in production tests).  Comparing these values with corresponding experimental data provides a second test of the BFD pseudopotential for oxygen.

Enter the \sphinxcode{\sphinxupquote{oxygen\_dimer}} directory.  Copy your BFD pseudopotential from the atom runs into \sphinxcode{\sphinxupquote{oxygen\_dimer/pseudopotentials}} (be sure to move both files: \sphinxcode{\sphinxupquote{.upf}} and \sphinxcode{\sphinxupquote{.xml}}).  Open \sphinxcode{\sphinxupquote{O\_dimer.py}} with a text editor.  The overall format is similar to the example file shown in the last section. The main difference is that a full workflow of runs (DFT orbital generation, orbital conversion, optimization and DMC) are being performed rather than a single VMC run.

As in the example in the last section, the oxygen dimer is generated with the \sphinxcode{\sphinxupquote{generate\_physical\_
system}} function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dimer} \PYG{o}{=} \PYG{n}{generate\PYGZus{}physical\PYGZus{}system}\PYG{p}{(}
    \PYG{n+nb}{type}       \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dimer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{dimer}      \PYG{o}{=} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{separation} \PYG{o}{=} \PYG{l+m+mf}{1.2074}\PYG{o}{*}\PYG{n}{scale}\PYG{p}{,}
    \PYG{n}{Lbox}       \PYG{o}{=} \PYG{l+m+mf}{10.0}\PYG{p}{,}
    \PYG{n}{units}      \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{net\PYGZus{}spin}   \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,}
    \PYG{n}{O}          \PYG{o}{=} \PYG{l+m+mi}{6}
    \PYG{p}{)}
\end{sphinxVerbatim}

Similar syntax can be used to generate crystal structures or to specify systems with arbitrary atomic configurations and simulation cells.  Notice that a “\sphinxcode{\sphinxupquote{scale}}” variable has been introduced to stretch or compress the dimer.

Next, objects representing a QE (PWSCF) run and subsequent orbital conversion step are constructed with respective \sphinxcode{\sphinxupquote{generate\_*}} functions:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dft} \PYG{o}{=} \PYG{n}{generate\PYGZus{}pwscf}\PYG{p}{(}
    \PYG{n}{identifier}   \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dft}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{n}{input\PYGZus{}dft}    \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lda}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{p}{)}
\PYG{n}{sims}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{dft}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} describe orbital conversion run}
\PYG{n}{p2q} \PYG{o}{=} \PYG{n}{generate\PYGZus{}pw2qmcpack}\PYG{p}{(}
    \PYG{n}{identifier}   \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{p2q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{n}{dependencies} \PYG{o}{=} \PYG{p}{(}\PYG{n}{dft}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orbitals}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{)}
\PYG{n}{sims}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{p2q}\PYG{p}{)}
\end{sphinxVerbatim}

Note the \sphinxcode{\sphinxupquote{dependencies}} keyword.  This keyword is used to construct workflows out of otherwise separate runs.  In this case, the dependency indicates that the orbital conversion run must wait for the DFT to finish before starting.

Objects representing QMCPACK simulations are then constructed with the \sphinxcode{\sphinxupquote{generate\_qmcpack}} function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{opt} \PYG{o}{=} \PYG{n}{generate\PYGZus{}qmcpack}\PYG{p}{(}
    \PYG{n}{identifier}   \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{opt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{n}{jastrows}     \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{J1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bspline}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mf}{5.0}\PYG{p}{)}\PYG{p}{,}
                    \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{J2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bspline}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mf}{10.0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{calculations} \PYG{o}{=} \PYG{p}{[}
        \PYG{n}{loop}\PYG{p}{(}\PYG{n+nb}{max}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{,}
             \PYG{n}{qmc}\PYG{o}{=}\PYG{n}{linear}\PYG{p}{(}
                \PYG{n}{energy}               \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{,}
                \PYG{n}{unreweightedvariance} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{,}
                \PYG{n}{reweightedvariance}   \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{,}
                \PYG{n}{timestep}             \PYG{o}{=} \PYG{l+m+mf}{0.3}\PYG{p}{,}
                \PYG{n}{samples}              \PYG{o}{=} \PYG{l+m+mi}{61440}\PYG{p}{,}
                \PYG{n}{warmupsteps}          \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{,}
                \PYG{n}{blocks}               \PYG{o}{=} \PYG{l+m+mi}{200}\PYG{p}{,}
                \PYG{n}{substeps}             \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,}
                \PYG{n}{nonlocalpp}           \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{,}
                \PYG{n}{usebuffer}            \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{,}
                \PYG{n}{walkers}              \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,}
                \PYG{n}{minwalkers}           \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{,}
                \PYG{n}{maxweight}            \PYG{o}{=} \PYG{l+m+mf}{1e9}\PYG{p}{,}
                \PYG{n}{usedrift}             \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{,}
                \PYG{n}{minmethod}            \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{quartic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{n}{beta}                 \PYG{o}{=} \PYG{l+m+mf}{0.025}\PYG{p}{,}
                \PYG{n}{exp0}                 \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{16}\PYG{p}{,}
                \PYG{n}{bigchange}            \PYG{o}{=} \PYG{l+m+mf}{15.0}\PYG{p}{,}
                \PYG{n}{alloweddifference}    \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}4}\PYG{p}{,}
                \PYG{n}{stepsize}             \PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{,}
                \PYG{n}{stabilizerscale}      \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{,}
                \PYG{n}{nstabilizers}         \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,}
                \PYG{p}{)}
             \PYG{p}{)}
        \PYG{p}{]}\PYG{p}{,}
    \PYG{n}{dependencies} \PYG{o}{=} \PYG{p}{(}\PYG{n}{p2q}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orbitals}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{)}
\PYG{n}{sims}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{opt}\PYG{p}{)}

\PYG{n}{qmc} \PYG{o}{=} \PYG{n}{generate\PYGZus{}qmcpack}\PYG{p}{(}
    \PYG{n}{identifier}   \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{qmc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{n}{jastrows}     \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{calculations} \PYG{o}{=} \PYG{p}{[}
        \PYG{n}{vmc}\PYG{p}{(}
            \PYG{n}{walkers}     \PYG{o}{=}   \PYG{l+m+mi}{1}\PYG{p}{,}
            \PYG{n}{warmupsteps} \PYG{o}{=}  \PYG{l+m+mi}{30}\PYG{p}{,}
            \PYG{n}{blocks}      \PYG{o}{=}  \PYG{l+m+mi}{20}\PYG{p}{,}
            \PYG{n}{steps}       \PYG{o}{=}  \PYG{l+m+mi}{10}\PYG{p}{,}
            \PYG{n}{substeps}    \PYG{o}{=}   \PYG{l+m+mi}{2}\PYG{p}{,}
            \PYG{n}{timestep}    \PYG{o}{=}  \PYG{o}{.}\PYG{l+m+mi}{4}\PYG{p}{,}
            \PYG{n}{samples}     \PYG{o}{=} \PYG{l+m+mi}{2048}
            \PYG{p}{)}\PYG{p}{,}
        \PYG{n}{dmc}\PYG{p}{(}
            \PYG{n}{warmupsteps}   \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{,}
            \PYG{n}{blocks}        \PYG{o}{=} \PYG{l+m+mi}{400}\PYG{p}{,}
            \PYG{n}{steps}         \PYG{o}{=}  \PYG{l+m+mi}{32}\PYG{p}{,}
            \PYG{n}{timestep}      \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{,}
            \PYG{n}{nonlocalmoves} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{,}
            \PYG{p}{)}
        \PYG{p}{]}\PYG{p}{,}
    \PYG{n}{dependencies} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{n}{p2q}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orbitals}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n}{opt}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{jastrow}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{)}
\PYG{n}{sims}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{qmc}\PYG{p}{)}
\end{sphinxVerbatim}

Shared details such as the run directory, job, pseudopotentials, and orbital file have been omitted (\sphinxcode{\sphinxupquote{...}}).  The “\sphinxcode{\sphinxupquote{opt}}” run will optimize a 1\sphinxhyphen{}body B\sphinxhyphen{}spline Jastrow with 8 knots having a cutoff of 5.0 Bohr and a B\sphinxhyphen{}spline Jastrow (for up\sphinxhyphen{}up and up\sphinxhyphen{}down correlations) with 8 knots and cutoffs of 10.0 Bohr.  The Jastrow list for the DMC run is empty, and the previous use of \sphinxcode{\sphinxupquote{dependencies}} indicates that the DMC run depends on the optimization run for the Jastrow factor.  Nexus will submit the “\sphinxcode{\sphinxupquote{opt}}” run first, and upon completion it will scan the output, select the optimal set of parameters, pass the Jastrow information to the “\sphinxcode{\sphinxupquote{qmc}}” run, and then submit the DMC job.  Independent job workflows are submitted in parallel when permitted.  No input files are written or job submissions made until the “\sphinxcode{\sphinxupquote{run\_project}}” function is reached:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{run\PYGZus{}project}\PYG{p}{(}\PYG{n}{sims}\PYG{p}{)}
\end{sphinxVerbatim}

All of the simulation objects have been collected into a list (\sphinxcode{\sphinxupquote{sims}}) for submission.

As written, \sphinxcode{\sphinxupquote{O\_dimer.py}} will perform calculations only at the equilibrium separation distance of 1.2074 \{AA\} since the list of scaling factors (representing stretching or compressing the dimer)  contains only one value (\sphinxcode{\sphinxupquote{scales = {[}1.00{]}}}).  Modify the file now to perform DMC calculations across a range of separation distances with each DMC run using the Jastrow factor optimized at the equilibrium separation distance.  Specifically, you will want to change the list of scaling factors to include both compression (\sphinxcode{\sphinxupquote{scale\textless{}1.0}}) and stretch (\sphinxcode{\sphinxupquote{scale\textgreater{}1.0}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{scales} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.00}\PYG{p}{,}\PYG{l+m+mf}{0.90}\PYG{p}{,}\PYG{l+m+mf}{0.95}\PYG{p}{,}\PYG{l+m+mf}{1.05}\PYG{p}{,}\PYG{l+m+mf}{1.10}\PYG{p}{]}
\end{sphinxVerbatim}

Note that “\sphinxcode{\sphinxupquote{1.00}}” is left in front because we are going to optimize the Jastrow factor first at the equilibrium separation and reuse this Jastrow factor for all other separation distances.  This procedure is used because it can reduce variations in localization errors (due to pseudopotentials in DMC) along the binding curve.

Change the \sphinxcode{\sphinxupquote{status\_only}} parameter in the “\sphinxcode{\sphinxupquote{settings}}” function to \sphinxcode{\sphinxupquote{1}} and type “\sphinxcode{\sphinxupquote{./O\_dimer.py}}” at the command line.  This will print the status of all simulations:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Project} \PYG{n}{starting}
  \PYG{n}{checking} \PYG{k}{for} \PYG{n}{file} \PYG{n}{collisions}
  \PYG{n}{loading} \PYG{n}{cascade} \PYG{n}{images}
    \PYG{n}{cascade} \PYG{l+m+mi}{0} \PYG{n}{checking} \PYG{o+ow}{in}
    \PYG{n}{cascade} \PYG{l+m+mi}{10} \PYG{n}{checking} \PYG{o+ow}{in}
    \PYG{n}{cascade} \PYG{l+m+mi}{4} \PYG{n}{checking} \PYG{o+ow}{in}
    \PYG{n}{cascade} \PYG{l+m+mi}{13} \PYG{n}{checking} \PYG{o+ow}{in}
    \PYG{n}{cascade} \PYG{l+m+mi}{7} \PYG{n}{checking} \PYG{o+ow}{in}
  \PYG{n}{checking} \PYG{n}{cascade} \PYG{n}{dependencies}
    \PYG{n+nb}{all} \PYG{n}{simulation} \PYG{n}{dependencies} \PYG{n}{satisfied}

  \PYG{n}{cascade} \PYG{n}{status}
    \PYG{n}{setup}\PYG{p}{,} \PYG{n}{sent\PYGZus{}files}\PYG{p}{,} \PYG{n}{submitted}\PYG{p}{,} \PYG{n}{finished}\PYG{p}{,} \PYG{n}{got\PYGZus{}output}\PYG{p}{,} \PYG{n}{analyzed}
    \PYG{l+m+mi}{000000}  \PYG{n}{dft}     \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0}
    \PYG{l+m+mi}{000000}  \PYG{n}{p2q}     \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0}
    \PYG{l+m+mi}{000000}  \PYG{n}{opt}     \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0}
    \PYG{l+m+mi}{000000}  \PYG{n}{qmc}     \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0}
    \PYG{l+m+mi}{000000}  \PYG{n}{dft}     \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{9}
    \PYG{l+m+mi}{000000}  \PYG{n}{p2q}     \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{9}
    \PYG{l+m+mi}{000000}  \PYG{n}{qmc}     \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{9}
    \PYG{l+m+mi}{000000}  \PYG{n}{dft}     \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{95}
    \PYG{l+m+mi}{000000}  \PYG{n}{p2q}     \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{95}
    \PYG{l+m+mi}{000000}  \PYG{n}{qmc}     \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}0}\PYG{o}{.}\PYG{l+m+mi}{95}
    \PYG{l+m+mi}{000000}  \PYG{n}{dft}     \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{05}
    \PYG{l+m+mi}{000000}  \PYG{n}{p2q}     \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{05}
    \PYG{l+m+mi}{000000}  \PYG{n}{qmc}     \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{05}
    \PYG{l+m+mi}{000000}  \PYG{n}{dft}     \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{1}
    \PYG{l+m+mi}{000000}  \PYG{n}{p2q}     \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{1}
    \PYG{l+m+mi}{000000}  \PYG{n}{qmc}     \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{1}
    \PYG{n}{setup}\PYG{p}{,} \PYG{n}{sent\PYGZus{}files}\PYG{p}{,} \PYG{n}{submitted}\PYG{p}{,} \PYG{n}{finished}\PYG{p}{,} \PYG{n}{got\PYGZus{}output}\PYG{p}{,} \PYG{n}{analyzed}
\end{sphinxVerbatim}

In this case, five simulation “cascades” (workflows) have been identified, each one starting and ending with “\sphinxcode{\sphinxupquote{dft}}” and “\sphinxcode{\sphinxupquote{qmc}}” runs, respectively.  The six status flags \sphinxcode{\sphinxupquote{setup}}, \sphinxcode{\sphinxupquote{sent\_files}}, \sphinxcode{\sphinxupquote{submitted}}, \sphinxcode{\sphinxupquote{finished}}, \sphinxcode{\sphinxupquote{got\_output}}, \sphinxcode{\sphinxupquote{analyzed}}) each shows \sphinxcode{\sphinxupquote{0}}, indicating that no work has been done yet.

Now change “\sphinxcode{\sphinxupquote{status\_only}}” back to \sphinxcode{\sphinxupquote{0}}, set “\sphinxcode{\sphinxupquote{generate\_only}}” to \sphinxcode{\sphinxupquote{1}}, and run \sphinxcode{\sphinxupquote{O\_dimer.py}} again.  This will perform a dry run of all simulations.  The dry run should finish in about 20 seconds:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Project} \PYG{n}{starting}
  \PYG{n}{checking} \PYG{k}{for} \PYG{n}{file} \PYG{n}{collisions}
  \PYG{n}{loading} \PYG{n}{cascade} \PYG{n}{images}
    \PYG{n}{cascade} \PYG{l+m+mi}{0} \PYG{n}{checking} \PYG{o+ow}{in}
    \PYG{n}{cascade} \PYG{l+m+mi}{10} \PYG{n}{checking} \PYG{o+ow}{in}
    \PYG{n}{cascade} \PYG{l+m+mi}{4} \PYG{n}{checking} \PYG{o+ow}{in}
    \PYG{n}{cascade} \PYG{l+m+mi}{13} \PYG{n}{checking} \PYG{o+ow}{in}
    \PYG{n}{cascade} \PYG{l+m+mi}{7} \PYG{n}{checking} \PYG{o+ow}{in}
  \PYG{n}{checking} \PYG{n}{cascade} \PYG{n}{dependencies}
    \PYG{n+nb}{all} \PYG{n}{simulation} \PYG{n}{dependencies} \PYG{n}{satisfied}

  \PYG{n}{starting} \PYG{n}{runs}\PYG{p}{:}
  \PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}
  \PYG{n}{poll} \PYG{l+m+mi}{0}  \PYG{n}{memory} \PYG{l+m+mf}{91.03} \PYG{n}{MB}
    \PYG{n}{Entering} \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0}
      \PYG{n}{writing} \PYG{n+nb}{input} \PYG{n}{files}  \PYG{l+m+mi}{0} \PYG{n}{dft}
    \PYG{n}{Entering} \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0}
      \PYG{n}{sending} \PYG{n}{required} \PYG{n}{files}  \PYG{l+m+mi}{0} \PYG{n}{dft}
      \PYG{n}{submitting} \PYG{n}{job}  \PYG{l+m+mi}{0} \PYG{n}{dft}
  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
  \PYG{n}{poll} \PYG{l+m+mi}{1}  \PYG{n}{memory} \PYG{l+m+mf}{91.10} \PYG{n}{MB}
  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{n}{Entering} \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0}
      \PYG{n}{Would} \PYG{n}{have} \PYG{n}{executed}\PYG{p}{:}
        \PYG{n}{export} \PYG{n}{OMP\PYGZus{}NUM\PYGZus{}THREADS}\PYG{o}{=}\PYG{l+m+mi}{1}
        \PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{np} \PYG{l+m+mi}{4} \PYG{n}{pw}\PYG{o}{.}\PYG{n}{x} \PYG{o}{\PYGZhy{}}\PYG{n+nb}{input} \PYG{n}{dft}\PYG{o}{.}\PYG{o+ow}{in}

  \PYG{n}{poll} \PYG{l+m+mi}{2}  \PYG{n}{memory} \PYG{l+m+mf}{91.10} \PYG{n}{MB}
    \PYG{n}{Entering} \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0}
      \PYG{n}{copying} \PYG{n}{results}  \PYG{l+m+mi}{0} \PYG{n}{dft}
    \PYG{n}{Entering} \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0}
      \PYG{n}{analyzing}  \PYG{l+m+mi}{0} \PYG{n}{dft}
  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
  \PYG{n}{poll} \PYG{l+m+mi}{3}  \PYG{n}{memory} \PYG{l+m+mf}{91.10} \PYG{n}{MB}
    \PYG{n}{Entering} \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
      \PYG{n}{writing} \PYG{n+nb}{input} \PYG{n}{files}  \PYG{l+m+mi}{1} \PYG{n}{p2q}
    \PYG{n}{Entering} \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
      \PYG{n}{sending} \PYG{n}{required} \PYG{n}{files}  \PYG{l+m+mi}{1} \PYG{n}{p2q}
      \PYG{n}{submitting} \PYG{n}{job}  \PYG{l+m+mi}{1} \PYG{n}{p2q}
  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{n}{Entering} \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
      \PYG{n}{Would} \PYG{n}{have} \PYG{n}{executed}\PYG{p}{:}
        \PYG{n}{export} \PYG{n}{OMP\PYGZus{}NUM\PYGZus{}THREADS}\PYG{o}{=}\PYG{l+m+mi}{1}
        \PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{np} \PYG{l+m+mi}{1} \PYG{n}{pw2qmcpack}\PYG{o}{.}\PYG{n}{x}\PYG{o}{\PYGZlt{}}\PYG{n}{p2q}\PYG{o}{.}\PYG{o+ow}{in}

  \PYG{n}{poll} \PYG{l+m+mi}{4}  \PYG{n}{memory} \PYG{l+m+mf}{91.10} \PYG{n}{MB}
    \PYG{n}{Entering} \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
      \PYG{n}{copying} \PYG{n}{results}  \PYG{l+m+mi}{1} \PYG{n}{p2q}
    \PYG{n}{Entering} \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
      \PYG{n}{analyzing}  \PYG{l+m+mi}{1} \PYG{n}{p2q}
  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
  \PYG{n}{poll} \PYG{l+m+mi}{5}  \PYG{n}{memory} \PYG{l+m+mf}{91.10} \PYG{n}{MB}
    \PYG{n}{Entering} \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0} \PYG{l+m+mi}{2}
      \PYG{n}{writing} \PYG{n+nb}{input} \PYG{n}{files}  \PYG{l+m+mi}{2} \PYG{n}{opt}
    \PYG{n}{Entering} \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0} \PYG{l+m+mi}{2}
      \PYG{n}{sending} \PYG{n}{required} \PYG{n}{files}  \PYG{l+m+mi}{2} \PYG{n}{opt}
      \PYG{n}{submitting} \PYG{n}{job}  \PYG{l+m+mi}{2} \PYG{n}{opt}
  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{n}{Entering} \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0} \PYG{l+m+mi}{2}
      \PYG{n}{Would} \PYG{n}{have} \PYG{n}{executed}\PYG{p}{:}
        \PYG{n}{export} \PYG{n}{OMP\PYGZus{}NUM\PYGZus{}THREADS}\PYG{o}{=}\PYG{l+m+mi}{1}
        \PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{np} \PYG{l+m+mi}{4} \PYG{n}{qmcpack} \PYG{n}{opt}\PYG{o}{.}\PYG{o+ow}{in}\PYG{o}{.}\PYG{n}{xml}

  \PYG{n}{poll} \PYG{l+m+mi}{6}  \PYG{n}{memory} \PYG{l+m+mf}{91.16} \PYG{n}{MB}
    \PYG{n}{Entering} \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0} \PYG{l+m+mi}{2}
      \PYG{n}{copying} \PYG{n}{results}  \PYG{l+m+mi}{2} \PYG{n}{opt}
    \PYG{n}{Entering} \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0} \PYG{l+m+mi}{2}
      \PYG{n}{analyzing}  \PYG{l+m+mi}{2} \PYG{n}{opt}
  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
  \PYG{n}{poll} \PYG{l+m+mi}{7}  \PYG{n}{memory} \PYG{l+m+mf}{93.00} \PYG{n}{MB}
    \PYG{n}{Entering} \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0} \PYG{l+m+mi}{3}
      \PYG{n}{writing} \PYG{n+nb}{input} \PYG{n}{files}  \PYG{l+m+mi}{3} \PYG{n}{qmc}
    \PYG{n}{Entering} \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0} \PYG{l+m+mi}{3}
      \PYG{n}{sending} \PYG{n}{required} \PYG{n}{files}  \PYG{l+m+mi}{3} \PYG{n}{qmc}
      \PYG{n}{submitting} \PYG{n}{job}  \PYG{l+m+mi}{3} \PYG{n}{qmc}
  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{n}{Entering} \PYG{o}{.}\PYG{o}{/}\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0} \PYG{l+m+mi}{3}
      \PYG{n}{Would} \PYG{n}{have} \PYG{n}{executed}\PYG{p}{:}
        \PYG{n}{export} \PYG{n}{OMP\PYGZus{}NUM\PYGZus{}THREADS}\PYG{o}{=}\PYG{l+m+mi}{1}
        \PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{np} \PYG{l+m+mi}{4} \PYG{n}{qmcpack} \PYG{n}{qmc}\PYG{o}{.}\PYG{o+ow}{in}\PYG{o}{.}\PYG{n}{xml}
  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
  \PYG{n}{poll} \PYG{l+m+mi}{17}  \PYG{n}{memory} \PYG{l+m+mf}{93.06} \PYG{n}{MB}
\PYG{n}{Project} \PYG{n}{finished}
\end{sphinxVerbatim}

Nexus polls the simulation status every 3 seconds and sleeps in between.
The “\sphinxcode{\sphinxupquote{scale\_}}” directories should now contain several files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{scale\PYGZus{}1}\PYG{o}{.}\PYG{l+m+mi}{0}
   \PYG{n}{dft}\PYG{o}{.}\PYG{o+ow}{in}
   \PYG{n}{O}\PYG{o}{.}\PYG{n}{BFD}\PYG{o}{.}\PYG{n}{upf}
   \PYG{n}{O}\PYG{o}{.}\PYG{n}{BFD}\PYG{o}{.}\PYG{n}{xml}
   \PYG{n}{opt}\PYG{o}{.}\PYG{o+ow}{in}\PYG{o}{.}\PYG{n}{xml}
   \PYG{n}{p2q}\PYG{o}{.}\PYG{o+ow}{in}
   \PYG{n}{pwscf\PYGZus{}output}
   \PYG{n}{qmc}\PYG{o}{.}\PYG{o+ow}{in}\PYG{o}{.}\PYG{n}{xml}
   \PYG{n}{sim\PYGZus{}dft}\PYG{o}{/}
       \PYG{n}{analyzer}\PYG{o}{.}\PYG{n}{p}
       \PYG{n+nb}{input}\PYG{o}{.}\PYG{n}{p}
       \PYG{n}{sim}\PYG{o}{.}\PYG{n}{p}
   \PYG{n}{sim\PYGZus{}opt}\PYG{o}{/}
       \PYG{n}{analyzer}\PYG{o}{.}\PYG{n}{p}
       \PYG{n+nb}{input}\PYG{o}{.}\PYG{n}{p}
       \PYG{n}{sim}\PYG{o}{.}\PYG{n}{p}
   \PYG{n}{sim\PYGZus{}p2q}\PYG{o}{/}
       \PYG{n}{analyzer}\PYG{o}{.}\PYG{n}{p}
       \PYG{n+nb}{input}\PYG{o}{.}\PYG{n}{p}
       \PYG{n}{sim}\PYG{o}{.}\PYG{n}{p}
   \PYG{n}{sim\PYGZus{}qmc}\PYG{o}{/}
       \PYG{n}{analyzer}\PYG{o}{.}\PYG{n}{p}
       \PYG{n+nb}{input}\PYG{o}{.}\PYG{n}{p}
       \PYG{n}{sim}\PYG{o}{.}\PYG{n}{p}
\end{sphinxVerbatim}

Take a minute to inspect the generated input (\sphinxcode{\sphinxupquote{dft.in}}, \sphinxcode{\sphinxupquote{p2q.in}}, \sphinxcode{\sphinxupquote{opt.in.xml}}, \sphinxcode{\sphinxupquote{qmc.in.xml}}). The pseudopotential files (\sphinxcode{\sphinxupquote{O.BFD.upf}} and \sphinxcode{\sphinxupquote{O.BFD.xml}}) have been copied into each local directory. Four additional directories have been created: \sphinxcode{\sphinxupquote{sim\_dft}},  \sphinxcode{\sphinxupquote{sim\_p2q}}, \sphinxcode{\sphinxupquote{sim\_opt}} and \sphinxcode{\sphinxupquote{sim\_qmc}}.  The \sphinxcode{\sphinxupquote{sim.p}} files in each directory contain the current status of each simulation.  If you run \sphinxcode{\sphinxupquote{O\_dimer.py}} again, it should not attempt to rerun any of the simulations:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Project} \PYG{n}{starting}
  \PYG{n}{checking} \PYG{k}{for} \PYG{n}{file} \PYG{n}{collisions}
  \PYG{n}{loading} \PYG{n}{cascade} \PYG{n}{images}
    \PYG{n}{cascade} \PYG{l+m+mi}{0} \PYG{n}{checking} \PYG{o+ow}{in}
    \PYG{n}{cascade} \PYG{l+m+mi}{10} \PYG{n}{checking} \PYG{o+ow}{in}
    \PYG{n}{cascade} \PYG{l+m+mi}{4} \PYG{n}{checking} \PYG{o+ow}{in}
    \PYG{n}{cascade} \PYG{l+m+mi}{13} \PYG{n}{checking} \PYG{o+ow}{in}
    \PYG{n}{cascade} \PYG{l+m+mi}{7} \PYG{n}{checking} \PYG{o+ow}{in}
  \PYG{n}{checking} \PYG{n}{cascade} \PYG{n}{dependencies}
    \PYG{n+nb}{all} \PYG{n}{simulation} \PYG{n}{dependencies} \PYG{n}{satisfied}

  \PYG{n}{starting} \PYG{n}{runs}\PYG{p}{:}
  \PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}\PYG{o}{\PYGZti{}}
  \PYG{n}{poll} \PYG{l+m+mi}{0}  \PYG{n}{memory} \PYG{l+m+mf}{64.25} \PYG{n}{MB}
\PYG{n}{Project} \PYG{n}{finished}
\end{sphinxVerbatim}

This way you can continue to add to the \sphinxcode{\sphinxupquote{O\_dimer.py}} file (e.g., adding more separation distances) without worrying about duplicate job submissions.

Now submit the jobs in the dimer workflow.  Reset the state of the simulations by removing the \sphinxcode{\sphinxupquote{sim.p}} files (“\sphinxcode{\sphinxupquote{rm ./scale*/sim*/sim.p}}”), set “\sphinxcode{\sphinxupquote{generate\_only}}” to \sphinxcode{\sphinxupquote{0}}, and rerun \sphinxcode{\sphinxupquote{O\_dimer.py}}.  It should take about 20 minutes for all the jobs to complete.  You may wish to open another terminal to monitor the progress of the individual jobs while the current terminal runs \sphinxcode{\sphinxupquote{O\_dimer.py}} in the foreground.  You can begin the following first exercise once the optimization job completes.

\sphinxstylestrong{Questions and Exercises}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Evaluate the quality of the optimization at \sphinxcode{\sphinxupquote{scale=1.0}} using the \sphinxcode{\sphinxupquote{qmca}} tool. Did the
optimization succeed? How does the variance compare with the neutral
oxygen atom? Is the wavefunction of similar quality to the atomic
case?

\item {} 
Evaluate the traces of the local energy and the DMC walker population
for each separation distance with the \sphinxcode{\sphinxupquote{qmca}} tool. Are there any anomalies
in the runs? Is the acceptance ratio reasonable? Is the wavefunction
of similar quality across all separation distances?

\item {} 
Use the \sphinxcode{\sphinxupquote{dimer\_fit.py}} tool located in \sphinxcode{\sphinxupquote{oxygen\_dimer}} to fit the oxygen dimer binding curve. To get
the binding energy of the dimer, we will need the DMC energy of the
atom. Before performing the fit, answer: What DMC time step should be
used for the oxygen atom results? The tool accepts three arguments
(\sphinxcode{\sphinxupquote{./dimer\_fit.py P N E Eerr}}), \sphinxcode{\sphinxupquote{P}} is the prefix of the DMC input files (should be “\sphinxcode{\sphinxupquote{qmc}}” at this point), \sphinxcode{\sphinxupquote{N}}
is the order of the fit (use 2 to start),\textasciigrave{}\textasciigrave{}E\textasciigrave{}\textasciigrave{} and \sphinxcode{\sphinxupquote{Eerr}} are your DMC total
energy and error bar, respectively, for the oxygen atom (in electron
volts). A plot of the dimer data will be displayed, and text output
will show the DMC equilibrium bond length and binding energy as well
as experimental values. How accurately does your fit to the DMC data
reproduce the experimental values? What factors affect the accuracy
of your results?

\item {} 
Refit your data with a fourth\sphinxhyphen{}order polynomial. How do your
predictions change with a fourth\sphinxhyphen{}order fit? Is a fourth\sphinxhyphen{}order fit
appropriate for the available data?

\item {} 
Add new “\sphinxcode{\sphinxupquote{scale}}” values to the list in \sphinxcode{\sphinxupquote{O\_dimer.py}} that interpolate between the original
set (e.g., expand to ). Perform the DMC calculations and redo the
fits. How accurately does your fit to the DMC data reproduce the
experimental values? Should this pseudopotential be used in
production calculations?

\item {} 
(Optional) Perform optimization runs at the extreme separation
distances corresponding to \sphinxcode{\sphinxupquote{scale={[}0.90,1.10{]}}}. Are the individually optimized
wavefunctions of significantly better quality than the one imported
from \sphinxcode{\sphinxupquote{scale=1.00}}? Why? What form of Jastrow factor might give an even better
improvement?

\end{enumerate}


\section{(Optional) Running your system with QMCPACK}
\label{\detokenize{lab_qmc_basics:optional-running-your-system-with-qmcpack}}\label{\detokenize{lab_qmc_basics:your-system}}
This section covers a fairly simple route to get started on QMC calculations of an arbitrary system of interest using the Nexus workflow management system to set up input files and optionally perform the runs.  The example provided in this section uses QE (PWSCF) to generate the orbitals forming the Slater determinant part of the trial wavefunction.  PWSCF is a natural choice for solid\sphinxhyphen{}state systems, and it can be used for surface/slab and molecular systems as well, albeit at the price of describing additional vacuum space with plane waves.

To start out, you will need PPs for each element in your system in both
the UPF (PWSCF) and FSATOM/XML (QMCPACK) formats. A good place to start
is the BFD pseudopotential database
(\sphinxurl{http://www.burkatzki.com/pseudos/index.2.html}), which we have already
used in our study of the oxygen atom. The database does not contain PPs
for the fourth and fifth row transition metals or any of the lanthanides
or actinides. If you need a PP that is not in the BFD database, you may
need to generate and test one manually (e.g., with OPIUM,
\sphinxurl{http://opium.sourceforge.net/}). Otherwise, use \sphinxcode{\sphinxupquote{ppconvert}} as outlined in
{\hyperref[\detokenize{lab_qmc_basics:lqb-pseudo}]{\sphinxcrossref{\DUrole{std,std-ref}{Obtaining and converting a pseudopotential for oxygen}}}} to obtain PPs in the formats used by PWSCF
and QMCPACK. Enter the \sphinxcode{\sphinxupquote{your\_system}} lab directory and place the converted PPs in \sphinxcode{\sphinxupquote{your\_system/pseudopotentials}}.

Before performing production calculations (more than just the initial setup in this section), be sure to converge the plane\sphinxhyphen{}wave energy cutoff in PWSCF as these PPs can be rather hard, sometimes requiring cutoffs in excess of 300 Ry.  Depending on the system under study, the amount of memory required to represent the orbitals (QMCPACK uses 3D B\sphinxhyphen{}splines) can become prohibitive, forcing you to search for softer PPs.

Beyond PPs, all that is required to get started are the atomic positions and the dimensions/shape of the simulation cell.  The Nexus file \sphinxcode{\sphinxupquote{example.py}} illustrates how to set up PWSCF and QMCPACK input files by providing minimal information regarding the physical system (an 8\sphinxhyphen{}atom cubic cell of diamond in the example).  Most of the contents should be familiar from your experience with the automated calculations of the oxygen dimer binding curve in {\hyperref[\detokenize{lab_qmc_basics:dimer-automation}]{\sphinxcrossref{\DUrole{std,std-ref}{Automated binding curve of the oxygen dimer}}}} (if you have skipped ahead you may want to skim that section for relevant information).  The most important change is the expanded description of the physical system:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} details of your physical system (diamond conventional cell below)}
\PYG{n}{my\PYGZus{}project\PYGZus{}name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{diamond\PYGZus{}vmc}\PYG{l+s+s1}{\PYGZsq{}}   \PYG{c+c1}{\PYGZsh{} directory to perform runs}
\PYG{n}{my\PYGZus{}dft\PYGZus{}pps}      \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C.BFD.upf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}   \PYG{c+c1}{\PYGZsh{} pwscf pseudopotentials}
\PYG{n}{my\PYGZus{}qmc\PYGZus{}pps}      \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C.BFD.xml}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}   \PYG{c+c1}{\PYGZsh{} qmcpack pseudopotentials}

\PYG{c+c1}{\PYGZsh{}  generate your system}
\PYG{c+c1}{\PYGZsh{}    units      :  \PYGZsq{}A\PYGZsq{}/\PYGZsq{}B\PYGZsq{} for Angstrom/Bohr}
\PYG{c+c1}{\PYGZsh{}    axes       :  simulation cell axes in cartesian coordinates (a1,a2,a3)}
\PYG{c+c1}{\PYGZsh{}    elem       :  list of atoms in the system}
\PYG{c+c1}{\PYGZsh{}    pos        :  corresponding atomic positions in cartesian coordinates}
\PYG{c+c1}{\PYGZsh{}    kgrid      :  Monkhorst\PYGZhy{}Pack grid}
\PYG{c+c1}{\PYGZsh{}    kshift     :  Monkhorst\PYGZhy{}Pack shift (between 0 and 0.5)}
\PYG{c+c1}{\PYGZsh{}    net\PYGZus{}charge :  system charge in units of e}
\PYG{c+c1}{\PYGZsh{}    net\PYGZus{}spin   :  \PYGZsh{} of up spins \PYGZhy{} \PYGZsh{} of down spins}
\PYG{c+c1}{\PYGZsh{}    C = 4      :  (pseudo) carbon has 4 valence electrons}
\PYG{n}{my\PYGZus{}system} \PYG{o}{=} \PYG{n}{generate\PYGZus{}physical\PYGZus{}system}\PYG{p}{(}
    \PYG{n}{units}      \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{axes}       \PYG{o}{=} \PYG{p}{[}\PYG{p}{[} \PYG{l+m+mf}{3.57000000e+00}\PYG{p}{,} \PYG{l+m+mf}{0.00000000e+00}\PYG{p}{,} \PYG{l+m+mf}{0.00000000e+00}\PYG{p}{]}\PYG{p}{,}
                  \PYG{p}{[} \PYG{l+m+mf}{0.00000000e+00}\PYG{p}{,} \PYG{l+m+mf}{3.57000000e+00}\PYG{p}{,} \PYG{l+m+mf}{0.00000000e+00}\PYG{p}{]}\PYG{p}{,}
                  \PYG{p}{[} \PYG{l+m+mf}{0.00000000e+00}\PYG{p}{,} \PYG{l+m+mf}{0.00000000e+00}\PYG{p}{,} \PYG{l+m+mf}{3.57000000e+00}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{elem}       \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{pos}        \PYG{o}{=} \PYG{p}{[}\PYG{p}{[} \PYG{l+m+mf}{0.00000000e+00}\PYG{p}{,} \PYG{l+m+mf}{0.00000000e+00}\PYG{p}{,} \PYG{l+m+mf}{0.00000000e+00}\PYG{p}{]}\PYG{p}{,}
                  \PYG{p}{[} \PYG{l+m+mf}{8.92500000e\PYGZhy{}01}\PYG{p}{,} \PYG{l+m+mf}{8.92500000e\PYGZhy{}01}\PYG{p}{,} \PYG{l+m+mf}{8.92500000e\PYGZhy{}01}\PYG{p}{]}\PYG{p}{,}
                  \PYG{p}{[} \PYG{l+m+mf}{0.00000000e+00}\PYG{p}{,} \PYG{l+m+mf}{1.78500000e+00}\PYG{p}{,} \PYG{l+m+mf}{1.78500000e+00}\PYG{p}{]}\PYG{p}{,}
                  \PYG{p}{[} \PYG{l+m+mf}{8.92500000e\PYGZhy{}01}\PYG{p}{,} \PYG{l+m+mf}{2.67750000e+00}\PYG{p}{,} \PYG{l+m+mf}{2.67750000e+00}\PYG{p}{]}\PYG{p}{,}
                  \PYG{p}{[} \PYG{l+m+mf}{1.78500000e+00}\PYG{p}{,} \PYG{l+m+mf}{0.00000000e+00}\PYG{p}{,} \PYG{l+m+mf}{1.78500000e+00}\PYG{p}{]}\PYG{p}{,}
                  \PYG{p}{[} \PYG{l+m+mf}{2.67750000e+00}\PYG{p}{,} \PYG{l+m+mf}{8.92500000e\PYGZhy{}01}\PYG{p}{,} \PYG{l+m+mf}{2.67750000e+00}\PYG{p}{]}\PYG{p}{,}
                  \PYG{p}{[} \PYG{l+m+mf}{1.78500000e+00}\PYG{p}{,} \PYG{l+m+mf}{1.78500000e+00}\PYG{p}{,} \PYG{l+m+mf}{0.00000000e+00}\PYG{p}{]}\PYG{p}{,}
                  \PYG{p}{[} \PYG{l+m+mf}{2.67750000e+00}\PYG{p}{,} \PYG{l+m+mf}{2.67750000e+00}\PYG{p}{,} \PYG{l+m+mf}{8.92500000e\PYGZhy{}01}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{kgrid}      \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{kshift}     \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{net\PYGZus{}charge} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,}
    \PYG{n}{net\PYGZus{}spin}   \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,}
    \PYG{n}{C}          \PYG{o}{=} \PYG{l+m+mi}{4}       \PYG{c+c1}{\PYGZsh{} one line like this for each atomic species}
    \PYG{p}{)}

\PYG{n}{my\PYGZus{}bconds}       \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ppp}\PYG{l+s+s1}{\PYGZsq{}}  \PYG{c+c1}{\PYGZsh{}  ppp/nnn for periodic/open BC\PYGZsq{}s in QMC}
                         \PYG{c+c1}{\PYGZsh{}  if nnn, center atoms about (a1+a2+a3)/2}
\end{sphinxVerbatim}

If you have a system you would like to try with QMC, make a copy of \sphinxcode{\sphinxupquote{example.py}} and fill in the relevant information about the PPs, simulation cell axes, and atomic species/positions.  Otherwise, you can proceed with \sphinxcode{\sphinxupquote{example.py}} as it is.

Set “\sphinxcode{\sphinxupquote{generate\_only}}” to \sphinxcode{\sphinxupquote{1}} and type “\sphinxcode{\sphinxupquote{./example.py}}” or similar to generate the input files.  All files will be written to “\sphinxcode{\sphinxupquote{./diamond\_vmc}}” (“\sphinxcode{\sphinxupquote{./{[}my\_project\_name{]}}}” if you have changed “\sphinxcode{\sphinxupquote{my\_project\_name}}” in the file).  The input files for PWSCF, pw2qmcpack, and QMCPACK are \sphinxcode{\sphinxupquote{scf.in}}, \sphinxcode{\sphinxupquote{pw2qmcpack.in}}, and \sphinxcode{\sphinxupquote{vmc.in.xml}}, respectively.  Take some time to inspect the generated input files.  If you have questions about the file contents, or run into issues with the generation process, feel free to consult with a lab instructor.

If desired, you can submit the runs directly with \sphinxcode{\sphinxupquote{example.py}}.  To do this, first reset the Nexus simulation record by typing “\sphinxcode{\sphinxupquote{rm ./diamond\_vmc/sim*/sim.p}}” or similar and set “\sphinxcode{\sphinxupquote{generate\_only}}” back to \sphinxcode{\sphinxupquote{0}}.  Next rerun \sphinxcode{\sphinxupquote{example.py}}  (you may want to redirect the text output).

Alternatively the runs can be submitted by hand:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{np} \PYG{l+m+mi}{4} \PYG{n}{pw}\PYG{o}{.}\PYG{n}{x}\PYG{o}{\PYGZlt{}}\PYG{n}{scf}\PYG{o}{.}\PYG{o+ow}{in}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{n}{scf}\PYG{o}{.}\PYG{n}{out}\PYG{o}{\PYGZam{}}

\PYG{p}{(}\PYG{n}{wait} \PYG{n}{until} \PYG{n}{JOB} \PYG{n}{DONE} \PYG{n}{appears} \PYG{o+ow}{in} \PYG{n}{scf}\PYG{o}{.}\PYG{n}{out}\PYG{p}{)}

\PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{np} \PYG{l+m+mi}{1} \PYG{n}{pw2qmcpack}\PYG{o}{.}\PYG{n}{x}\PYG{o}{\PYGZlt{}}\PYG{n}{p2q}\PYG{o}{.}\PYG{o+ow}{in}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{n}{p2q}\PYG{o}{.}\PYG{n}{out}\PYG{o}{\PYGZam{}}
\end{sphinxVerbatim}

Once the conversion process has finished, the orbitals should be located in the file \sphinxcode{\sphinxupquote{diamond\_vmc/pwscf\_output/pwscf.pwscf.h5}}.  Open \sphinxcode{\sphinxupquote{diamond\_vmc/vmc.in.xml}} and replace “\sphinxcode{\sphinxupquote{MISSING.h5}}” with “\sphinxcode{\sphinxupquote{./pwscf\_output/pwscf.pwscf.h5}}”.  Next submit the VMC run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{np} \PYG{l+m+mi}{4} \PYG{n}{qmcpack} \PYG{n}{vmc}\PYG{o}{.}\PYG{o+ow}{in}\PYG{o}{.}\PYG{n}{xml}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{n}{vmc}\PYG{o}{.}\PYG{n}{out}\PYG{o}{\PYGZam{}}
\end{sphinxVerbatim}

Note: If your system is large, the preceding process may not complete within the time frame of this lab.  Working with a stripped down (but relevant) example is a good idea for exploratory runs.

Once the runs have finished, you may want to begin exploring Jastrow optimization and DMC for your system.  Example calculations are provided at the end of \sphinxcode{\sphinxupquote{example.py}} in the commented out text.


\section{Appendix A: Basic Python constructs}
\label{\detokenize{lab_qmc_basics:appendix-a-basic-python-constructs}}\label{\detokenize{lab_qmc_basics:python-basics}}
Basic Python data types (\sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{float}}, \sphinxcode{\sphinxupquote{str}}, \sphinxcode{\sphinxupquote{tuple}}, \sphinxcode{\sphinxupquote{list}}, \sphinxcode{\sphinxupquote{array}}, \sphinxcode{\sphinxupquote{dict}}, \sphinxcode{\sphinxupquote{obj}}) and programming constructs (\sphinxcode{\sphinxupquote{if}} statements, \sphinxcode{\sphinxupquote{for}} loops, functions w/ keyword arguments) are briefly overviewed in the following.  All examples can be executed interactively in Python.  To do this, type “\sphinxcode{\sphinxupquote{python}}” at the command line and paste any of the shaded text below at the \sphinxcode{\sphinxupquote{\textgreater{}\textgreater{}\textgreater{}}} prompt.  For more information about effective use of Python, consult the detailed online documentation: \sphinxurl{https://docs.python.org/2/}.


\subsection{Intrinsic types: \sphinxstyleliteralintitle{\sphinxupquote{int, float, str}}}
\label{\detokenize{lab_qmc_basics:intrinsic-types-int-float-str}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}this is a comment}
\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{5}                     \PYG{c+c1}{\PYGZsh{} integer}
\PYG{n}{f}\PYG{o}{=}\PYG{l+m+mf}{3.6}                   \PYG{c+c1}{\PYGZsh{} float}
\PYG{n}{s}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{quantum/monte/carlo}\PYG{l+s+s1}{\PYGZsq{}} \PYG{c+c1}{\PYGZsh{} string}
\PYG{n}{n}\PYG{o}{=}\PYG{k+kc}{None}                  \PYG{c+c1}{\PYGZsh{} represents \PYGZdq{}nothing\PYGZdq{}}

\PYG{n}{f}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mf}{1.4}                  \PYG{c+c1}{\PYGZsh{} add\PYGZhy{}assign (\PYGZhy{},*,/ also): 5.0}
\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}                    \PYG{c+c1}{\PYGZsh{} raise to a power: 8}
\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}                  \PYG{c+c1}{\PYGZsh{} int to string: \PYGZsq{}5\PYGZsq{}}
\PYG{n}{s}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/simulations}\PYG{l+s+s1}{\PYGZsq{}}        \PYG{c+c1}{\PYGZsh{} joining strings: \PYGZsq{}quantum/monte/carlo/simulations\PYGZsq{}}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{i=}\PYG{l+s+si}{\PYGZob{}0\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}       \PYG{c+c1}{\PYGZsh{} format string: \PYGZsq{}i=5\PYGZsq{}}
\end{sphinxVerbatim}


\subsection{Container types: \sphinxstyleliteralintitle{\sphinxupquote{tuple, list, array, dict, obj}}}
\label{\detokenize{lab_qmc_basics:container-types-tuple-list-array-dict-obj}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{array}  \PYG{c+c1}{\PYGZsh{} get array from numpy module}
\PYG{k+kn}{from} \PYG{n+nn}{generic} \PYG{k+kn}{import} \PYG{n}{obj}  \PYG{c+c1}{\PYGZsh{} get obj from Nexus\PYGZsq{} generic module}

\PYG{n}{t}\PYG{o}{=}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{42}\PYG{p}{,}\PYG{l+m+mi}{56}\PYG{p}{,}\PYG{l+m+mf}{123.0}\PYG{p}{)}     \PYG{c+c1}{\PYGZsh{} tuple}

\PYG{n}{l}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mf}{3.14}\PYG{p}{,}\PYG{l+m+mi}{196}\PYG{p}{]}        \PYG{c+c1}{\PYGZsh{} list}

\PYG{n}{a}\PYG{o}{=}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}        \PYG{c+c1}{\PYGZsh{} array}

\PYG{n}{d}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{\PYGZcb{}}         \PYG{c+c1}{\PYGZsh{} dict}

\PYG{n}{o}\PYG{o}{=}\PYG{n}{obj}\PYG{p}{(}\PYG{n}{a}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{n}{b}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}          \PYG{c+c1}{\PYGZsh{} obj}

                        \PYG{c+c1}{\PYGZsh{} printing}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}                \PYG{c+c1}{\PYGZsh{}  (\PYGZsq{}A\PYGZsq{}, 42, 56, 123.0)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}                \PYG{c+c1}{\PYGZsh{}  [\PYGZsq{}B\PYGZsq{}, 3.1400000000000001, 196]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}                \PYG{c+c1}{\PYGZsh{}  [1 2 3]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}                \PYG{c+c1}{\PYGZsh{}  \PYGZob{}\PYGZsq{}a\PYGZsq{}: 5, \PYGZsq{}b\PYGZsq{}: 6\PYGZcb{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{o}\PYG{p}{)}                \PYG{c+c1}{\PYGZsh{}    a               = 5}
                        \PYG{c+c1}{\PYGZsh{}    b               = 6}

\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{o}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}number of elements: (4, 3, 3, 2, 2)}

\PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{l}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{d}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{o}\PYG{o}{.}\PYG{n}{a}  \PYG{c+c1}{\PYGZsh{}element access: (\PYGZsq{}A\PYGZsq{}, \PYGZsq{}B\PYGZsq{}, 1, 5, 5)}

\PYG{n}{s} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} slices: works for tuple, list, array}
\PYG{n}{s}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}                    \PYG{c+c1}{\PYGZsh{}   array([0, 1, 2, 3, 4])}
\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{]}                   \PYG{c+c1}{\PYGZsh{}   array([2, 3, 4])}
\PYG{n}{s}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}                   \PYG{c+c1}{\PYGZsh{}   array([0, 1])}
\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{]}                  \PYG{c+c1}{\PYGZsh{}   array([1, 2, 3])}
\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}                \PYG{c+c1}{\PYGZsh{}   array([0, 2, 4])}

                        \PYG{c+c1}{\PYGZsh{} list operations}
\PYG{n}{l2} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}            \PYG{c+c1}{\PYGZsh{}   make independent copy}
\PYG{n}{l}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}             \PYG{c+c1}{\PYGZsh{}   add new element: [\PYGZsq{}B\PYGZsq{}, 3.14, 196, 4]}
\PYG{n}{l}\PYG{o}{+}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{]}               \PYG{c+c1}{\PYGZsh{}   addition: [\PYGZsq{}B\PYGZsq{}, 3.14, 196, 4, 5, 6, 7]}
\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}                 \PYG{c+c1}{\PYGZsh{}   multiplication:  [0, 1, 0, 1, 0, 1]}

\PYG{n}{b}\PYG{o}{=}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{)}        \PYG{c+c1}{\PYGZsh{} array operations}
\PYG{n}{a2} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}           \PYG{c+c1}{\PYGZsh{}   make independent copy}
\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}                     \PYG{c+c1}{\PYGZsh{}   addition: array([ 6, 8, 10])}
\PYG{n}{a}\PYG{o}{+}\PYG{l+m+mi}{3}                     \PYG{c+c1}{\PYGZsh{}   addition: array([ 4, 5, 6])}
\PYG{n}{a}\PYG{o}{*}\PYG{n}{b}                     \PYG{c+c1}{\PYGZsh{}   multiplication: array([ 5, 12, 21])}
\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{a}                     \PYG{c+c1}{\PYGZsh{}   multiplication: array([3, 6, 9])}

                        \PYG{c+c1}{\PYGZsh{} dict/obj operations}
\PYG{n}{d2} \PYG{o}{=} \PYG{n}{d}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}           \PYG{c+c1}{\PYGZsh{}   make independent copy}
\PYG{n}{d}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{7}              \PYG{c+c1}{\PYGZsh{}   add/assign element}
\PYG{n}{d}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}                \PYG{c+c1}{\PYGZsh{}   get element names: [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}c\PYGZsq{}, \PYGZsq{}b\PYGZsq{}]}
\PYG{n}{d}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}              \PYG{c+c1}{\PYGZsh{}   get element values: [5, 7, 6]}

                        \PYG{c+c1}{\PYGZsh{} obj\PYGZhy{}specific operations}
\PYG{n}{o}\PYG{o}{.}\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{7}                 \PYG{c+c1}{\PYGZsh{}   add/assign element}
\PYG{n}{o}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{n}{d}\PYG{o}{=}\PYG{l+m+mi}{8}\PYG{p}{)}          \PYG{c+c1}{\PYGZsh{}   add/assign multiple elements}
\end{sphinxVerbatim}

An important feature of Python to be aware of is that assignment is most often by reference, that is, new values are not always created.  This point is illustrated with an \sphinxcode{\sphinxupquote{obj}} instance in the following example, but it also holds for \sphinxcode{\sphinxupquote{list}}, \sphinxcode{\sphinxupquote{array}}, \sphinxcode{\sphinxupquote{dict}}, and others.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{o} \PYG{o}{=} \PYG{n}{obj}\PYG{p}{(}\PYG{n}{a}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{n}{b}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{p}\PYG{o}{=}\PYG{n}{o}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{p}\PYG{o}{.}\PYG{n}{a}\PYG{o}{=}\PYG{l+m+mi}{7}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{o}\PYG{p}{)}
\PYG{g+go}{  a               = 7}
\PYG{g+go}{  b               = 6}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{q}\PYG{o}{=}\PYG{n}{o}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{q}\PYG{o}{.}\PYG{n}{a}\PYG{o}{=}\PYG{l+m+mi}{9}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{o}\PYG{p}{)}
\PYG{g+go}{  a               = 7}
\PYG{g+go}{  b               = 6}
\end{sphinxVerbatim}

Here \sphinxcode{\sphinxupquote{p}} is just another name for \sphinxcode{\sphinxupquote{o}}, while \sphinxcode{\sphinxupquote{q}} is a fully independent copy of it.


\subsection{Conditional Statements: \sphinxstyleliteralintitle{\sphinxupquote{if/elif/else}}}
\label{\detokenize{lab_qmc_basics:conditional-statements-if-elif-else}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{k}{if} \PYG{n}{a} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a is None}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{elif} \PYG{n}{a}\PYG{o}{==}\PYG{l+m+mi}{4}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a is 4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{elif} \PYG{n}{a}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{6} \PYG{o+ow}{and} \PYG{n}{a}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{2}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a is in the range (2,6]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{elif} \PYG{n}{a}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o+ow}{or} \PYG{n}{a}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{26}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a is not in the range [\PYGZhy{}1,26]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{elif} \PYG{n}{a}\PYG{o}{!=}\PYG{l+m+mi}{10}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a is not 10}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a is 10}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}end if}
\end{sphinxVerbatim}

The “\sphinxcode{\sphinxupquote{\textbackslash{}\#end if}}” is not part of Python syntax, but you will see text like this throughout Nexus for clear encapsulation.


\subsection{Iteration: \sphinxstyleliteralintitle{\sphinxupquote{for}}}
\label{\detokenize{lab_qmc_basics:iteration-for}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{generic} \PYG{k+kn}{import} \PYG{n}{obj}

\PYG{n}{l} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{n}{m} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}
\PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} loop over list indices}
    \PYG{n}{s} \PYG{o}{+}\PYG{o}{=} \PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{n}{m}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{}end for}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}                 \PYG{c+c1}{\PYGZsh{} s is 21}

\PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{l}\PYG{p}{:}              \PYG{c+c1}{\PYGZsh{} loop over list elements}
    \PYG{n}{s} \PYG{o}{+}\PYG{o}{=} \PYG{n}{v}
\PYG{c+c1}{\PYGZsh{}end for}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}                 \PYG{c+c1}{\PYGZsh{} s is 6}

\PYG{n}{o} \PYG{o}{=} \PYG{n}{obj}\PYG{p}{(}\PYG{n}{a}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{n}{b}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{o}\PYG{p}{:}              \PYG{c+c1}{\PYGZsh{} loop over obj elements}
    \PYG{n}{s} \PYG{o}{+}\PYG{o}{=} \PYG{n}{v}
\PYG{c+c1}{\PYGZsh{}end for}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}                 \PYG{c+c1}{\PYGZsh{} s is 11}

\PYG{n}{d} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{n}{n}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{o}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}\PYG{c+c1}{\PYGZsh{} loop over name/value pairs in obj}
    \PYG{n}{d}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{v}
\PYG{c+c1}{\PYGZsh{}end for}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}                 \PYG{c+c1}{\PYGZsh{} d is \PYGZob{}\PYGZsq{}a\PYGZsq{}: 10, \PYGZsq{}b\PYGZsq{}: 10\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Functions: \sphinxstyleliteralintitle{\sphinxupquote{def}}, argument syntax}
\label{\detokenize{lab_qmc_basics:functions-def-argument-syntax}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}          \PYG{c+c1}{\PYGZsh{} basic function, c has a default value}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{c}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}end def f}

\PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{b}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}                 \PYG{c+c1}{\PYGZsh{} prints: 1 2 5}


\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}   \PYG{c+c1}{\PYGZsh{} general function, returns nothing}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{args}\PYG{p}{)}          \PYG{c+c1}{\PYGZsh{}     args: tuple of positional arguments}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{kwargs}\PYG{p}{)}        \PYG{c+c1}{\PYGZsh{}   kwargs: dict of keyword arguments}
\PYG{c+c1}{\PYGZsh{}end def f}

\PYG{n}{f}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{a}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{b}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} 2 pos., 2 kw. args, prints:}
                         \PYG{c+c1}{\PYGZsh{}   (\PYGZsq{}s\PYGZsq{}, (1, 2))}
                         \PYG{c+c1}{\PYGZsh{}   \PYGZob{}\PYGZsq{}a\PYGZsq{}: 3, \PYGZsq{}b\PYGZsq{}: \PYGZsq{}t\PYGZsq{}\PYGZcb{}}

\PYG{n}{l} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{f}\PYG{p}{(}\PYG{o}{*}\PYG{n}{l}\PYG{p}{,}\PYG{n}{a}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}                \PYG{c+c1}{\PYGZsh{} pos. args from list, 1 kw. arg, prints:}
                         \PYG{c+c1}{\PYGZsh{}   (0, 1, 2)}
                         \PYG{c+c1}{\PYGZsh{}   \PYGZob{}\PYGZsq{}a\PYGZsq{}: 6\PYGZcb{}}
\PYG{n}{o} \PYG{o}{=} \PYG{n}{obj}\PYG{p}{(}\PYG{n}{a}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{n}{b}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{f}\PYG{p}{(}\PYG{o}{*}\PYG{n}{l}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{o}\PYG{p}{)}                \PYG{c+c1}{\PYGZsh{} pos./kw. args from list/obj, prints:}
                         \PYG{c+c1}{\PYGZsh{}   (0, 1, 2)}
                         \PYG{c+c1}{\PYGZsh{}   \PYGZob{}\PYGZsq{}a\PYGZsq{}: 5, \PYGZsq{}b\PYGZsq{}: 6\PYGZcb{}}

\PYG{n}{f}\PYG{p}{(}                       \PYG{c+c1}{\PYGZsh{} indented kw. args, prints}
    \PYG{n}{blocks}   \PYG{o}{=} \PYG{l+m+mi}{200}\PYG{p}{,}      \PYG{c+c1}{\PYGZsh{}   ()}
    \PYG{n}{steps}    \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{,}       \PYG{c+c1}{\PYGZsh{}   \PYGZob{}\PYGZsq{}steps\PYGZsq{}: 10, \PYGZsq{}blocks\PYGZsq{}: 200, \PYGZsq{}timestep\PYGZsq{}: 0.01\PYGZcb{}}
    \PYG{n}{timestep} \PYG{o}{=} \PYG{l+m+mf}{0.01}
    \PYG{p}{)}

\PYG{n}{o} \PYG{o}{=} \PYG{n}{obj}\PYG{p}{(}                 \PYG{c+c1}{\PYGZsh{} obj w/ indented kw. args}
    \PYG{n}{blocks}   \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{,}
    \PYG{n}{steps}    \PYG{o}{=}  \PYG{l+m+mi}{5}\PYG{p}{,}
    \PYG{n}{timestep} \PYG{o}{=} \PYG{l+m+mf}{0.02}
    \PYG{p}{)}

\PYG{n}{f}\PYG{p}{(}\PYG{o}{*}\PYG{o}{*}\PYG{n}{o}\PYG{p}{)}                   \PYG{c+c1}{\PYGZsh{} kw. args from obj, prints:}
                         \PYG{c+c1}{\PYGZsh{}   ()}
                         \PYG{c+c1}{\PYGZsh{}   \PYGZob{}\PYGZsq{}timestep\PYGZsq{}: 0.02, \PYGZsq{}blocks\PYGZsq{}: 100, \PYGZsq{}steps\PYGZsq{}: 5\PYGZcb{}}
\end{sphinxVerbatim}




\chapter{Lab 3: Advanced molecular calculations}
\label{\detokenize{lab_advanced_molecules:lab-3-advanced-molecular-calculations}}\label{\detokenize{lab_advanced_molecules:lab-advanced-molecules}}\label{\detokenize{lab_advanced_molecules::doc}}

\section{Topics covered in this lab}
\label{\detokenize{lab_advanced_molecules:topics-covered-in-this-lab}}
This lab covers molecular QMC calculations with wavefunctions of increasing sophistication.  All of the trial wavefunctions are initially generated with the GAMESS code.  Topics covered include:
\begin{itemize}
\item {} 
Generating single\sphinxhyphen{}determinant trial wavefunctions with GAMESS (HF and
DFT)

\item {} 
Generating multideterminant trial wavefunctions with GAMESS (CISD,
CASCI, and SOCI)

\item {} 
Optimizing wavefunctions (Jastrow factors and CSF coefficients) with
QMC

\item {} 
DMC time step and walker population convergence studies

\item {} 
Systematic progressions of Jastrow factors in VMC

\item {} 
Systematic convergence of DMC energies with multideterminant
wavefunctions

\item {} 
Influence of orbitals basis choice on DMC energy

\end{itemize}


\section{Lab directories and files}
\label{\detokenize{lab_advanced_molecules:lab-directories-and-files}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
abs/lab3\PYGZus{}advanced\PYGZus{}molecules/exercises
│
├── ex1\PYGZus{}first\PYGZhy{}run\PYGZhy{}hartree\PYGZhy{}fock    \PYGZhy{} basic work flow from Hatree\PYGZhy{}Fock to DMC
│   ├── gms                        \PYGZhy{} Hatree\PYGZhy{}Fock calculation using GAMESS
│   │   ├── h2o.hf.inp               \PYGZhy{} GAMESS input
│   │   ├── h2o.hf.dat               \PYGZhy{} GAMESS punch file containing orbitals
│   │   └── h2o.hf.out               \PYGZhy{} GAMESS output with orbitals and other info
│   ├── convert                    \PYGZhy{} Convert GAMESS wavefunction to QMCPACK format
│   │   ├── h2o.hf.out               \PYGZhy{} GAMESS output
│   │   ├── h2o.ptcl.xml             \PYGZhy{} converted particle positions
│   │   └── h2o.wfs.xml              \PYGZhy{} converted wave function
│   ├── opt                        \PYGZhy{} VMC optimization
│   │   └── optm.xml                 \PYGZhy{} QMCPACK VMC optimization input
│   ├── dmc\PYGZus{}timestep               \PYGZhy{} Check DMC timestep bias
│   │   └── dmc\PYGZus{}ts.xml               \PYGZhy{} QMCPACK DMC input
│   └── dmc\PYGZus{}walkers                \PYGZhy{} Check DMC population control bias
│       └── dmc\PYGZus{}wk.xml               \PYGZhy{} QMCPACK DMC input template
│
├── ex2\PYGZus{}slater\PYGZhy{}jastrow\PYGZhy{}wf\PYGZhy{}options \PYGZhy{} explore jastrow and orbital options
│   ├── jastrow                    \PYGZhy{} Jastrow options
│   │   ├── 12j                      \PYGZhy{} no 3\PYGZhy{}body Jastrow
│   │   ├── 1j                       \PYGZhy{} only 1\PYGZhy{}body Jastrow
│   │   └── 2j                       \PYGZhy{} only 2\PYGZhy{}body Jastrow
│   └── orbitals                   \PYGZhy{} Orbital options
│       ├── pbe                      \PYGZhy{} PBE orbitals
│       │   └── gms                    \PYGZhy{} DFT calculation using GAMESS
│       │      └── h2o.pbe.inp          \PYGZhy{} GAMESS DFT input
│       ├── pbe0                     \PYGZhy{} PBE0  orbitals
│       ├── blyp                     \PYGZhy{} BLYP  orbitals
│       └── b3lyp                    \PYGZhy{} B3LYP orbitals
│
├── ex3\PYGZus{}multi\PYGZhy{}slater\PYGZhy{}jastrow
│   ├── cisd                      \PYGZhy{} CISD wave function
│   │   ├── gms                     \PYGZhy{} CISD calculation using GAMESS
│   │   │   ├── h2o.cisd.inp           \PYGZhy{} GAMESS input
│   │   │   ├── h2o.cisd.dat           \PYGZhy{} GAMESS punch file containing orbitals
│   │   │   └── h2o.cisd.out           \PYGZhy{} GAMESS output with orbitals and other info
│   │   └── convert                 \PYGZhy{} Convert GAMESS wavefunction to QMCPACK format
│   │      └── h2o.hf.out             \PYGZhy{} GAMESS output
│   ├── casci                     \PYGZhy{} CASCI wave function
│   │   └── gms                     \PYGZhy{} CASCI calculation using GAMESS
│   └── soci                      \PYGZhy{} SOCI wave function
│       ├── gms                     \PYGZhy{} SOCI calculation using GAMESS
│       ├── thres0.01               \PYGZhy{} VMC optimization with few determinants
│       └── thres0.0075             \PYGZhy{} VMC optimization with more determinants
│
└── pseudo
    ├── H.BFD.gamess             \PYGZhy{} BFD pseudopotential for H in GAMESS format
    ├── O.BFD.CCT.gamess         \PYGZhy{} BFD pseudopotential for O in GAMESS format
    ├── H.xml                    \PYGZhy{} BFD pseudopotential for H in QMCPACK format
    └── O.xml                    \PYGZhy{} BFD pseudopotential for H in QMCPACK format
\end{sphinxVerbatim}


\section{Exercise \#1: Basics}
\label{\detokenize{lab_advanced_molecules:exercise-1-basics}}
The purpose of this exercise is to show how to generate wavefunctions for QMCPACK
using GAMESS and to optimize the resulting wavefunctions using VMC. This will be
followed by a study of the time step and walker population dependence of DMC energies.
The exercise will be performed on a water molecule at the equilibrium geometry.


\section{Generation of a Hartree\sphinxhyphen{}Fock wavefunction with GAMESS}
\label{\detokenize{lab_advanced_molecules:generation-of-a-hartree-fock-wavefunction-with-gamess}}
From the top directory, go to “\sphinxcode{\sphinxupquote{ex1\_first\sphinxhyphen{}run\sphinxhyphen{}hartree\sphinxhyphen{}fock/gms}}.” This
directory contains an input file for a HF calculation of a water
molecule using BFD ECPs and the corresponding cc\sphinxhyphen{}pVTZ basis set. The
input file should be named: “h2o.hf.inp.” Study the input file. See
Section {\hyperref[\detokenize{lab_advanced_molecules:lab-adv-mol-gamess}]{\sphinxcrossref{\DUrole{std,std-ref}{Appendix A: GAMESS input}}}}, “Appendix A: GAMESS input” for a
more detailed description of the GAMESS input syntax. However, there
will be a better time to do this soon, so we recommend continuing with
the exercise at this point. After you are done, execute GAMESS with this
input and store the standard output in a file named “h2o.hf.output.”
Finally, in the “convert” folder, use \sphinxcode{\sphinxupquote{convert4qmc}} to generate the
QMCPACK \sphinxcode{\sphinxupquote{particleset}} and \sphinxcode{\sphinxupquote{wavefunction}} files. It is always useful
to rename the files generated by \sphinxcode{\sphinxupquote{convert4qmc}} to something meaningful
since by default they are called \sphinxcode{\sphinxupquote{sample.Gaussian\sphinxhyphen{}G2.xml}} and
\sphinxcode{\sphinxupquote{sample.Gaussian\sphinxhyphen{}G2.ptcl.xml}}. In a standard computer (without
cross\sphinxhyphen{}compilation), these tasks can be accomplished by the following
commands.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cd \PYGZdl{}\PYGZob{}TRAINING TOP\PYGZcb{}/ex1\PYGZus{}first\PYGZhy{}run\PYGZhy{}hartree\PYGZhy{}fock/gms
jobrun\PYGZus{}vesta rungms h2o.hf
cd ../convert
cp ../gms/h2o.hf.output
jobrun\PYGZus{}vesta convert4qmc \PYGZhy{}gamessAscii h2o.hf.output \PYGZhy{}add3BodyJ
mv sample.Gaussian\PYGZhy{}G2.xml h2o.wfs.xml
mv sample.Gaussian\PYGZhy{}G2.ptcl.xml h2o.ptcl.xml
\end{sphinxVerbatim}

The HF energy of the
system is \sphinxhyphen{}16.9600590022 Ha. To search for the energy in the output file quickly, you can
use

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{grep} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TOTAL ENERGY =}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{h2o}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{output}
\end{sphinxVerbatim}

As the job runs on VESTA, it is a good time to review
Section :ref\textasciigrave{}lab\sphinxhyphen{}adv\sphinxhyphen{}mol\sphinxhyphen{}convert4qmc\textasciigrave{}, “Appendix B: convert4qmc,”
which contains a description on the use of the converter.


\subsection{Optimize the wavefunction}
\label{\detokenize{lab_advanced_molecules:optimize-the-wavefunction}}
When execution of the previous steps is completed, there should be two
new files called \sphinxcode{\sphinxupquote{h2o.wfs.xml}} and \sphinxcode{\sphinxupquote{h2o.ptcl.xml}}. Now we will use
VMC to optimize the Jastrow parameters in the wavefunction. From the top
directory, go to “\sphinxcode{\sphinxupquote{ex1\_first\sphinxhyphen{}run\sphinxhyphen{}hartree\sphinxhyphen{}fock/opt}}.” Copy the xml
files generated in the previous step to the current directory. This
directory should already contain a basic QMCPACK input file for an
optimization calculation (\sphinxcode{\sphinxupquote{optm.xml}}) Open \sphinxcode{\sphinxupquote{optm.xml}} with your
favorite text editor and modify the name of the files that contain the
\sphinxcode{\sphinxupquote{wavefunction}} and \sphinxcode{\sphinxupquote{particleset}} XML blocks. These files are
included with the commands:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{include} \PYG{n}{href}\PYG{o}{=}\PYG{n}{ptcl}\PYG{o}{.}\PYG{n}{xml}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{include} \PYG{n}{href}\PYG{o}{=}\PYG{n}{wfs}\PYG{o}{.}\PYG{n}{xml}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

(the particle set must be defined before the wavefunction). The name of
the particle set and wavefunction files should now be \sphinxcode{\sphinxupquote{h2o.ptcl.xml}}
and \sphinxcode{\sphinxupquote{h2o.wfs.xml}}, respectively. Study both files and submit when you
are ready. Notice that the location of the ECPs has been set for you; in
your own calculations you have to make sure you obtain the ECPs from the
appropriate libraries and convert them to QMCPACK format using
ppconvert. While these calculations finish is a good time to study
{\hyperref[\detokenize{lab_advanced_molecules:lab-adv-mol-opt-appendix}]{\sphinxcrossref{\DUrole{std,std-ref}{Appendix C: Wavefunction optimization XML block}}}}, “Appendix C: Wavefunction
optimization XML block,” which contains a review of the main parameters
in the optimization XML block. The previous steps can be accomplished by
the following commands:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cd \PYGZdl{}\PYGZob{}TRAINING TOP\PYGZcb{}/ex1\PYGZus{}first\PYGZhy{}run\PYGZhy{}hartree\PYGZhy{}fock/opt
cp ../convert/h2o.wfs.xml ./
cp ../convert/h2o.ptcl.xml ./
\PYGZsh{} edit optm.xml to include the correct ptcl.xml and wfs.xml
jobrun\PYGZus{}vesta qmcpack optm.xml
\end{sphinxVerbatim}

Use the analysis tool \sphinxcode{\sphinxupquote{qmca}} to analyze the results of the
calculation. Obtain the VMC energy and variance for each step in the
optimization and plot it using your favorite program. Remember that
\sphinxcode{\sphinxupquote{qmca}} has built\sphinxhyphen{}in functions to plot the analyzed data.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qmca} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{e} \PYG{o}{*}\PYG{n}{scalar}\PYG{o}{.}\PYG{n}{dat} \PYG{o}{\PYGZhy{}}\PYG{n}{p}
\end{sphinxVerbatim}

The resulting energy as a function of the optimization step should look
qualitatively similar to \hyperref[\detokenize{lab_advanced_molecules:fig17}]{Fig.\@ \ref{\detokenize{lab_advanced_molecules:fig17}}}. The energy should
decrease quickly as a function of the number of optimization steps.
After 6\textendash{}8 steps, the energy should be converged to \(\sim\)2\textendash{}3
mHa. To improve convergence, we would need to increase the number of
samples used during optimization (You can check this for yourself
later.). With optimized wavefunctions, we are in a position to perform
VMC and DMC calculations. The modified wavefunction files after each
step are written in a file named \sphinxcode{\sphinxupquote{ID.sNNN.opt.xml}}, where ID is the
identifier of the calculation defined in the input file (this is defined
in the project XML block with parameter “id”) and NNN is a series number
that increases with every executable xml block in the input file.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{lab_advanced_molecules_opt_conv}.png}
\caption{VMC energy as a function of optimization step.}\label{\detokenize{lab_advanced_molecules:id1}}\label{\detokenize{lab_advanced_molecules:fig17}}\end{figure}


\subsection{Time\sphinxhyphen{}step study}
\label{\detokenize{lab_advanced_molecules:time-step-study}}
Now we will study the dependence of the DMC energy with time step. From
the top directory, go to “\sphinxcode{\sphinxupquote{ex1\_first\sphinxhyphen{}run\sphinxhyphen{}hartree\sphinxhyphen{}fock/dmc\_timestep}}.”
This folder contains a basic XML input file (\sphinxcode{\sphinxupquote{dmc\_ts.xml}}) that
performs a short VMC calculation and three DMC calculations with varying
time steps (0.1, 0.05, 0.01). Link the \sphinxcode{\sphinxupquote{particleset}} and the last
\sphinxcode{\sphinxupquote{optimization}} file from the previous folder (the file called
\sphinxcode{\sphinxupquote{jopt\sphinxhyphen{}h2o.sNNN.opt.xml}} with the largest value of NNN). Rename the
optimized \sphinxcode{\sphinxupquote{wavefunction}} file to any suitable name if you wish (for
example, \sphinxcode{\sphinxupquote{h2o.opt.xml}}) and change the name of the \sphinxcode{\sphinxupquote{particleset}} and
\sphinxcode{\sphinxupquote{wavefunction}} files in the input file. An optimized wavefunction can
be found in the reference files (same location) in case it is needed.

The main steps needed to perform this exercise are:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cd \PYGZbs{}\PYGZdl{}\PYGZbs{}\PYGZob{}TRAINING TOP\PYGZbs{}\PYGZcb{}/ex1\PYGZus{}first\PYGZhy{}run\PYGZhy{}hartree\PYGZhy{}fock/dmc\PYGZus{}timestep
cp ../opt/h2o.ptcl.xml ./
cp ../opt/jopt\PYGZhy{}h2o.s007.opt.xml h2o.opt.wfs.xml
\PYGZsh{} edit dmc\PYGZus{}ts.xml to include the correct ptcl.xml and wfs.xml
jobrun\PYGZus{}vesta qmcpack dmc\PYGZus{}ts.xml
\end{sphinxVerbatim}

While these runs complete, go to
{\hyperref[\detokenize{lab_advanced_molecules:lab-adv-mol-vmcdmc-appendix}]{\sphinxcrossref{\DUrole{std,std-ref}{Appendix D: VMC and DMC XML block}}}}, “Appendix D: VMC and DMC
XML block,” and review the basic VMC and DMC input blocks. Notice that
in the current DMC blocks the time step is decreased as the number of
blocks is increased. Why is this?

When the simulations are finished, use \sphinxcode{\sphinxupquote{qmca}} to analyze the output
files and plot the DMC energy as a function of time step. Results should
be qualitatively similar to those presented in
\hyperref[\detokenize{lab_advanced_molecules:fig18}]{Fig.\@ \ref{\detokenize{lab_advanced_molecules:fig18}}}; in this case we present more time
steps with well converged results to better illustrate the time step
dependence. In realistic calculations, the time step must be chosen
small enough so that the resulting error is below the desired accuracy.
Alternatively, various calculations can be performed and the results
extrapolated to the zero time\sphinxhyphen{}step limit.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{lab_advanced_molecules_dmc_timestep}.png}
\caption{DMC energy as a function of time step.}\label{\detokenize{lab_advanced_molecules:id2}}\label{\detokenize{lab_advanced_molecules:fig18}}\end{figure}


\subsection{Walker population study}
\label{\detokenize{lab_advanced_molecules:walker-population-study}}
Now we will study the dependence of the DMC energy with the number of
walkers in the simulation. Remember that, in principle, the DMC
distribution is reached in the limit of an infinite number of walkers.
In practice, the energy and most properties converge to high accuracy
with \(\sim\)100\textendash{}1,000 walkers. The actual number of walkers
needed in a calculation will depend on the accuracy of the VMC
wavefunction and on the complexity and size of the system. Also notice
that using too many walkers is not a problem; at worse it will be
inefficient since it will cost more computer time than necessary. In
fact, this is the strategy used when running QMC calculations on large
parallel computers since we can reduce the statistical error bars
efficiently by running with large walker populations distributed across
all processors.

From the top directory, go to
“\sphinxcode{\sphinxupquote{ex1\_first\sphinxhyphen{}run\sphinxhyphen{}hartree\sphinxhyphen{}fock/dmc\_walkers}}.” Copy the optimized
\sphinxcode{\sphinxupquote{wavefunction}} and \sphinxcode{\sphinxupquote{particleset}} files used in the previous
calculations to the current folder; these are the files generated during
step 2 of this exercise. An optimized \sphinxcode{\sphinxupquote{wavefunction}} file can be found
in the reference files (same location) in case it is needed. The
directory contains a sample DMC input file and submission script. Create
three directories named NWx, with x values of 120,240,480, and copy the
input file to each one. Go to “NW120,” and, in the input file, change
the name of the \sphinxcode{\sphinxupquote{wavefunction}} and \sphinxcode{\sphinxupquote{particleset}} files (in this case
they will be located one directory above, so use
“\sphinxcode{\sphinxupquote{../dmc\_timestep/h2.opt.xml}},” for example); change the PP directory
so that it points to one directory above; change “targetWalkers” to 120;
and change the number of steps to 100, the time step to 0.01, and the
number of blocks to 400. Notice that “targetWalkers” is one way to set
the desired (average) number of walkers in a DMC calculation. One can
alternatively set “samples” in the \sphinxcode{\sphinxupquote{\textless{}qmc method="vmc"}} block to carry over de\sphinxhyphen{}correlated VMC
configurations as DMC walkers. For your own simulations, we generally
recommend setting \(\sim\)2*(\#threads) walkers per node (slightly
smaller than this value).

The main steps needed to perform this exercise are

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cd \PYGZdl{}\PYGZob{}TRAINING TOP\PYGZcb{}/ex1\PYGZus{}first\PYGZhy{}run\PYGZhy{}hartree\PYGZhy{}fock/dmc\PYGZus{}walkers
cp ../opt/h2o.ptcl.xml ./
cp ../opt/jopt\PYGZhy{}h2o.s007.opt.xml h2o.opt.wfs.xml
\PYGZsh{} edit dmc\PYGZus{}wk.xml to include the correct ptcl.xml and wfs.xml and
\PYGZsh{}  use the correct pseudopotential directory
mkdir NW120
cp dmc\PYGZus{}wk.xml NW120
\PYGZsh{} edit dmc\PYGZus{}wk.xml to use the desired number of walkers,
\PYGZsh{}  and collect the desired amount of statistics
jobrun\PYGZus{}vesta qmcpack dmc\PYGZus{}wk.xml
\PYGZsh{} repeat for NW240, NW480
\end{sphinxVerbatim}

Repeat the same procedure in the other folders by setting
(targetWalkers=240, steps=100, timestep=0.01, blocks=200) in NW240 and
(targetWalkers=480, steps=100, timestep=0.01, blocks=100) in NW480. When
the simulations complete, use \sphinxcode{\sphinxupquote{qmca}} to analyze and plot the energy as
a function of the number of walkers in the calculation. As always,
\hyperref[\detokenize{lab_advanced_molecules:fig19}]{Fig.\@ \ref{\detokenize{lab_advanced_molecules:fig19}}} shows representative results of the
energy dependence on the number of walkers for a single water molecule.
As shown, less than 240 walkers are needed to obtain an accuracy of 0.1
mHa.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{lab_advanced_molecules_dmc_popcont}.png}
\caption{DMC energy as a function of the average number of walkers.}\label{\detokenize{lab_advanced_molecules:id3}}\label{\detokenize{lab_advanced_molecules:fig19}}\end{figure}


\section{Exercise \#2: Slater\sphinxhyphen{}Jastrow wavefunction options}
\label{\detokenize{lab_advanced_molecules:exercise-2-slater-jastrow-wavefunction-options}}
From this point on in the tutorial we assume familiarity with the basic
parameters in the optimization, VMC, and DMC XML input blocks of
QMCPACK. In addition, we assume familiarity with the submission system.
As a result, the folder structure will not contain any prepared input or
submission files, so you will need to generate them using input files
from exercise 1. In the case of QMCPACK sample files, you will find
\sphinxcode{\sphinxupquote{optm.xml}}, \sphinxcode{\sphinxupquote{vmc dmc.xml}}, and \sphinxcode{\sphinxupquote{submit.csh files}}. Some of the
options in these files can be left unaltered, but many of them will need
to be tailored to the particular calculation.

In this exercise we will study the dependence of the DMC energy on the
choices made in the wavefunction ansatz. In particular, we will study
the influence/dependence of the VMC energy with the various terms in the
Jastrow. We will also study the influence of the VMC and DMC energies on
the SPOs used to form the Slater determinant in single\sphinxhyphen{}determinant
wavefunctions. For this we will use wavefunctions generated with various
exchange\sphinxhyphen{}correlation functionals in DFT. Finally, we will optimize a
simple multideterminant wavefunction and study the dependence of the
energy on the number of configurations used in the expansion. All of
these exercises will be performed on the water molecule at equilibrium.


\subsection{Influence of Jastrow on VMC energy with HF wavefunction}
\label{\detokenize{lab_advanced_molecules:influence-of-jastrow-on-vmc-energy-with-hf-wavefunction}}
In this section we will study the dependence of the VMC energy on the
various Jastrow terms (e.g., 1\sphinxhyphen{}body, 2\sphinxhyphen{}body and 3\sphinxhyphen{}body. From the top
directory, go to “\sphinxcode{\sphinxupquote{ex2\_slater\sphinxhyphen{}jastrow\sphinxhyphen{}wf\sphinxhyphen{}options/jastrow.”}} We will
compare the single\sphinxhyphen{}determinant VMC energy using a 2\sphinxhyphen{}body Jastrow term,
both 1\sphinxhyphen{} and 2\sphinxhyphen{}body terms, and finally 1\sphinxhyphen{}, 2\sphinxhyphen{} and 3\sphinxhyphen{}body terms. Since we
are interested in the influence of the Jastrow, we will use the HF
orbitals calculated in exercise \#1. Make three folders named 2j, 12j,
and 123j. For both 2j and 12j, copy the input file \sphinxcode{\sphinxupquote{optm.xml}} from
“\sphinxcode{\sphinxupquote{ex1\_first\sphinxhyphen{}run\sphinxhyphen{}hartree\sphinxhyphen{}fock/opt.}}” This input file performs both
wavefunction optimization and a VMC calculation. Remember to correct
relative paths to the PP directory. Copy the un\sphinxhyphen{}optimized HF
\sphinxcode{\sphinxupquote{wavefunction}} and \sphinxcode{\sphinxupquote{particleset}} files from
“\sphinxcode{\sphinxupquote{ex1\_first\sphinxhyphen{}run\sphinxhyphen{}hartree\sphinxhyphen{}fock/convert}}”; if you followed the
instructions in exercise \#1 these should be named \sphinxcode{\sphinxupquote{h2o.wfs.xml}} and
\sphinxcode{\sphinxupquote{h2o.ptcl.xml}}. Otherwise, you can obtained them from the REFERENCE
files. Modify the \sphinxcode{\sphinxupquote{h2o.wfs.xml}} file to remove the appropriate Jastrow
blocks. For example, for a 2\sphinxhyphen{}body Jastrow (only), you need to eliminate
the Jastrow blocks named \sphinxcode{\sphinxupquote{\textless{}jastrow name="J1"}} and \sphinxcode{\sphinxupquote{\textless{}jastrow name="J3."}} In
the case of 12j, remove only \sphinxcode{\sphinxupquote{\textless{}jastrow name="J3."}} Recommended settings
for the optimization run are nodes=32, threads=16, blocks=250,
samples=128000, time\sphinxhyphen{}step=0.5, 8 optimization loops. Recommended
settings in the VMC section are walkers=16, blocks=1000, steps=1,
substeps=100. Notice that samples should always be set to blocks*threads
per node*nodes = 32*16*250=128000. Repeat the process in both 2j and 12j
cases. For the 123j case, the wavefunction has already been optimized in
the previous exercise. Copy the optimized HF wavefunction and the
particleset from “\sphinxcode{\sphinxupquote{ex1\_first\sphinxhyphen{}run\sphinxhyphen{}hartree\sphinxhyphen{}fock/opt.}}” Copy the input
file from any of the previous runs and remove the optimization block
from the input, just leave the VMC step. In all three cases, modify the
submission script and submit the run.

Because these simulations will take several minutes to complete, this is
an excellent opportunity to go to
{\hyperref[\detokenize{lab_advanced_molecules:lab-adv-mol-wf-appendix}]{\sphinxcrossref{\DUrole{std,std-ref}{Appendix E: Wavefunction XML block}}}}, “Appendix E: Wavefunction XML
block,” and review the wavefunction XML block used by QMCPACK. When the
simulations are completed, use \sphinxcode{\sphinxupquote{qmca}} to analyze the output files.
Using your favorite plotting program (e.g., gnu plot), plot the energy
and variance as a function of the Jastrow form.
\hyperref[\detokenize{lab_advanced_molecules:fig20}]{Fig.\@ \ref{\detokenize{lab_advanced_molecules:fig20}}} shows a typical result for this
calculation. As can be seen, the VMC energy and variance depends
strongly on the form of the Jastrow. Since the DMC error bar is directly
related to the variance of the VMC energy, improving the Jastrow will
always lead to a reduction in the DMC effort. In addition, systematic
approximations (time step, number of walkers, etc.) are also reduced
with improved wavefunctions.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{lab_advanced_molecules_vmc_jastrow}.png}
\caption{VMC energy as a function of Jastrow type.}\label{\detokenize{lab_advanced_molecules:id4}}\label{\detokenize{lab_advanced_molecules:fig20}}\end{figure}


\subsection{Generation of wavefunctions from DFT using GAMESS}
\label{\detokenize{lab_advanced_molecules:generation-of-wavefunctions-from-dft-using-gamess}}
In this section we will use GAMESS to generate wavefunctions for QMCPACK
from DFT calculations. From the top folder, go to
“\sphinxcode{\sphinxupquote{ex2\_slater\sphinxhyphen{}jastrow\sphinxhyphen{}wf\sphinxhyphen{}options/orbitals}}.” To demonstrate the
variation in DMC energies with the choice of DFT orbitals, we will
choose the following set of exchange\sphinxhyphen{}correlation functionals (PBE, PBE0,
BLYP, B3LYP). For each functional, make a directory using your preferred
naming convention (e.g., the name of the functional). Go into each
folder and copy a GAMESS input file from
“\sphinxcode{\sphinxupquote{ex1\_first\sphinxhyphen{}run\sphinxhyphen{}hartree\sphinxhyphen{}fock/gms}}.” Rename the file with your
preferred naming convention; we suggest using \sphinxcode{\sphinxupquote{h2o.{[}dft{]}.inp}}, where
{[}dft{]} is the name of the functional used in the calculation. At this
point, this input file should be identical to the one used to generate
the HF wavefunction in exercise \#1. To perform a DFT calculation we only
need to add “DFTTYP” to the \sphinxcode{\sphinxupquote{\$CONTRL ... \$END}} section and set it to the desired functional
type, for example, “DFTTYP=PBE” for a PBE functional. This variable must
be set to (PBE, PBE0, BLYP, B3LYP) to obtain the appropriate functional
in GAMESS. For a complete list of implemented functionals, see the
GAMESS input manual.


\subsection{Optimization and DMC calculations with DFT wavefunctions}
\label{\detokenize{lab_advanced_molecules:optimization-and-dmc-calculations-with-dft-wavefunctions}}
In this section we will optimize the wavefunction generated in the
previous step and perform DMC calculations. From the top directory, go
to “\sphinxcode{\sphinxupquote{ex2\_slater\sphinxhyphen{}jastrow\sphinxhyphen{}wf\sphinxhyphen{}options/orbitals}}.” The steps required to
achieve this are identical to those used to optimize the wavefunction
with HF orbitals. Make individual folders for each calculation and
obtain the necessary files to perform optimization, for example, VMC and
DMC calculations from “for \sphinxcode{\sphinxupquote{ex1\_first\sphinxhyphen{}run\sphinxhyphen{}hartree\sphinxhyphen{}fock/opt}}” and
“\sphinxcode{\sphinxupquote{ex1\_first\sphinxhyphen{}run\sphinxhyphen{}hartree\sphinxhyphen{}fock/dmc\_ts}}.” For each functional, make the
appropriate modifications to the input files and copy the
\sphinxcode{\sphinxupquote{particleset}} and \sphinxcode{\sphinxupquote{wavefunction}} files from the appropriate
directory in “\sphinxcode{\sphinxupquote{ex2\_slater\sphinxhyphen{}jastrow\sphinxhyphen{}wf\sphinxhyphen{}options/orbitals/{[}dft{]}}}.” We
recommend the following settings: nodes=32, threads=16, (in
optimization) blocks=250, samples=128000, timestep=0.5, 8 optimization
loops, (in VMC) walkers=16, blocks=100, steps=1, substeps=100, (in DMC)
blocks 400, targetWalkers=960, and timestep=0.01. Submit the runs and
analyze the results using \sphinxcode{\sphinxupquote{qmca}}.

How do the energies compare against each other? How do they compare
against DMC energies with HF orbitals?


\section{Exercise \#3: Multideterminant wavefunctions}
\label{\detokenize{lab_advanced_molecules:exercise-3-multideterminant-wavefunctions}}
In this exercise we will study the dependence of the DMC energy on the set of orbitals
and the type of configurations included in a multideterminant wavefunction.


\subsection{Generation of a CISD wavefunctions using GAMESS}
\label{\detokenize{lab_advanced_molecules:generation-of-a-cisd-wavefunctions-using-gamess}}
In this section we will use GAMESS to generate a multideterminant
wavefunction with configuration interaction with single and double
excitations (CISD). In CISD, the Schrodinger equation is solved exactly
on a basis of determinants including the HF determinant and all its
single and double excitations.

Go to “\sphinxcode{\sphinxupquote{ex3\_multi\sphinxhyphen{}slater\sphinxhyphen{}jastrow/cisd/gms}}” and you will see input and
output files named \sphinxcode{\sphinxupquote{h2o.cisd.inp}} and \sphinxcode{\sphinxupquote{h2o.cisd.out}}. Because of
technical problems with GAMESS in the BGQ architecture of VESTA, we are
unable to use CISD properly in GAMESS. Consequently, the output of the
calculation is already provided in the directory.

There will be time in the next step to study the GAMESS input files and
the description in {\hyperref[\detokenize{lab_advanced_molecules:lab-adv-mol-gamess}]{\sphinxcrossref{\DUrole{std,std-ref}{Appendix A: GAMESS input}}}}, “Appendix A:
GAMESS input.” Since the output is already provided, the only action
needed is to use the converter to generate the appropriate QMCPACK
files.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{jobrun\PYGZus{}vesta} \PYG{n}{convert4qmc} \PYG{n}{h2o}\PYG{o}{.}\PYG{n}{cisd}\PYG{o}{.}\PYG{n}{out} \PYG{o}{\PYGZhy{}}\PYG{n}{ci} \PYG{n}{h2o}\PYG{o}{.}\PYG{n}{cisd}\PYG{o}{.}\PYG{n}{out} \PYGZbs{}
\PYG{o}{\PYGZhy{}}\PYG{n}{readInitialGuess} \PYG{l+m+mi}{57} \PYG{o}{\PYGZhy{}}\PYG{n}{threshold} \PYG{l+m+mf}{0.0075}
\end{sphinxVerbatim}

We used the PRTMO=.T. flag in the GUESS section to include orbitals in
the output file. You should read these orbitals from the output
(\sphinxhyphen{}readInitialGuess 40). The highest occupied orbital in any determinant
should be 34, so reading 40 orbitals is a safe choice. In this case, it
is important to rename the XML files with meaningful names, for example,
\sphinxcode{\sphinxupquote{h2o.cisd.wfs.xml}}. A threshold of 0.0075 is sufficient for the
calculations in the training.


\subsection{Optimization of a multideterminant wavefunction}
\label{\detokenize{lab_advanced_molecules:optimization-of-a-multideterminant-wavefunction}}
In this section we will optimize the wavefunction generated in the
previous step. There is no difference in the optimization steps if a
single determinant and a multideterminant wavefunction. QMCPACK will
recognize the presence of a multideterminant wavefunction and will
automatically optimize the linear coefficients by default. Go to
“\sphinxcode{\sphinxupquote{ex3\_multi\sphinxhyphen{}slater\sphinxhyphen{}jastrow/cisd}}” and make a folder called
\sphinxcode{\sphinxupquote{thres0.01}}. Copy the \sphinxcode{\sphinxupquote{particleset}} and \sphinxcode{\sphinxupquote{wavefunction}} files
created in the previous step to the current directory. With your
favorite text editor, open the \sphinxcode{\sphinxupquote{wavefunction}} file \sphinxcode{\sphinxupquote{h2o.wfs.xml}}.
Look for the multideterminant XML block and change the “cutoff”
parameter in detlist to 0.01. Then follow the same steps used in Section
9.4.3, “Optimization and DMC calculations with DFT wavefunctions” to
optimize the wavefunction. Similar to this case, design a QMCPACK input
file that performs wavefunction optimization followed by VMC and DMC
calculations. Submit the calculation.

This is a good time to review the GAMESS input file description in
{\hyperref[\detokenize{lab_advanced_molecules:lab-adv-mol-gamess}]{\sphinxcrossref{\DUrole{std,std-ref}{Appendix A: GAMESS input}}}}, “Appendix A. GAMESS input.” When
the run is completed, go to the previous directory and make a new folder
named \sphinxcode{\sphinxupquote{thres0.0075}}. Repeat the previous steps to optimize the
wavefunction with a cutoff of 0.01, but use a cutoff of 0.0075 this
time. This will increase the number of determinants used in the
calculation. Notice that the “cutoff” parameter in the XML should be
less than the “\sphinxhyphen{}threshold 0.0075” flag passed to the converted, which is
further bounded by the PRTTOL flag in the GAMESS input.

After the wavefunction is generated, we are ready to optimize. Instead of starting from an un\sphinxhyphen{}optimized wavefunction, we can start from the optimized wavefunction from thres0.01 to speed up convergence. You will need to modify the file and change the cutoff in detlist to 0.0075 with a text editor. Repeat the optimization steps and submit the calculation.

When you are done, use \sphinxcode{\sphinxupquote{qmca}} to analyze the results. Compare the energies at these two
coefficient cutoffs with the energies obtained with DFT orbitals. Because of the time limitations of this tutorial, it is not practical to optimize the wavefunctions with a smaller cutoff since this would require more samples and longer runs due to the larger number of optimizable parameters. \hyperref[\detokenize{lab_advanced_molecules:fig21}]{Fig.\@ \ref{\detokenize{lab_advanced_molecules:fig21}}} shows the results of such exercise: the DMC energy as a function of the cutoff in the wavefunction. As can be seen, a large improvement in the energy is obtained as the number of configurations is increased.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{lab_advanced_molecules_dmc_ci_cisd}.png}
\caption{DMC energy as a function of the sum of the square of CI coefficients from CISD.}\label{\detokenize{lab_advanced_molecules:id5}}\label{\detokenize{lab_advanced_molecules:fig21}}\end{figure}


\subsection{CISD, CASCI, and SOCI}
\label{\detokenize{lab_advanced_molecules:cisd-casci-and-soci}}
Go to “\sphinxcode{\sphinxupquote{ex3\_multi\sphinxhyphen{}slater\sphinxhyphen{}jastrow}}” and inspect the folders for the
remaining wavefunction types: CASCI and SOCI. Follow the steps in the
previous exercise and obtain the optimized wavefunctions for these
determinant choices. Notice that the SOCI GAMESS output is not included
because it is large. Already converted XML inputs can be found in
“\sphinxcode{\sphinxupquote{ex3\_multi\sphinxhyphen{}slater\sphinxhyphen{}jastrow/soci/thres*}}.”

A CASCI wavefunction is produced from a CI calculation that includes all
the determinants in a complete active space (CAS) calculation, in this
case using the orbitals from a previous CASSCF calculation. In this case
we used a CAS(8,8) active space that includes all determinants generated
by distributing 8 electrons in the lowest 8 orbitals. A SOCI calculation
is similar to the CAS\sphinxhyphen{}CI calculation, but in addition to the
determinants in the CAS it also includes all single and double
excitations from all of them, leading to a much larger determinant set.
Since you now have considerable experience optimizing wavefunctions and
calculating DMC energies, we will leave it to you to complete the
remaining tasks on your own. If you need help, refer to previous
exercises in the tutorial. Perform optimizations for both wavefunctions
using cutoffs in the CI expansion of 0.01 an 0.0075. If you have time,
try to optimize the wavefunctions with a cutoff of 0.005. Analyze the
results and plot the energy as a function of cutoff for all three cases:
CISD, CAS\sphinxhyphen{}CI, and SOCI.

\hyperref[\detokenize{lab_advanced_molecules:fig21}]{Fig.\@ \ref{\detokenize{lab_advanced_molecules:fig21}}} shows the result of similar calculations using more samples and smaller cutoffs.
The results should be similar to those produced in the tutorial. For reference, the exact
energy of the water molecule with ECPs is approximately \sphinxhyphen{}17.276 Ha. From the results of the
tutorial, how does the selection of determinants relate to the expected DMC energy?
What about the choice in the set of orbitals?


\section{Appendix A: GAMESS input}
\label{\detokenize{lab_advanced_molecules:appendix-a-gamess-input}}\label{\detokenize{lab_advanced_molecules:lab-adv-mol-gamess}}
In this section we provide a brief description of the GAMESS input needed to produce
trial wavefunction for QMC calculations with QMCPACK. We assume basic familiarity
with GAMESS input structure, particularly regarding the input of atomic coordinates and
the definition of Gaussian basis sets. This section focuses on generation of the output
files needed by the converter tool, \sphinxcode{\sphinxupquote{convert4qmc}}. For a description of the converter, see {\hyperref[\detokenize{lab_advanced_molecules:lab-adv-mol-convert4qmc}]{\sphinxcrossref{\DUrole{std,std-ref}{Appendix B: convert4qmc}}}}, “Appendix B: convert4qmc.”

Only a subset of the methods available in GAMESS can be used to generate
wavefunctions for QMCPACK, and we restrict our description to these. For
a complete description of all the options and methods available in
GAMESS, please refer to the official documentation at
“\sphinxurl{http://www.msg.ameslab.gov/gamess/documentation.html}.”

Currently, \sphinxcode{\sphinxupquote{convert4qmc}} can process output for the following methods in GAMESS (in
SCFTYP): RHF, ROHF, and MCSCF. Both HF and DFT calculations (any DFT
type) can be used in combination with RHF and ROHF calculations. For MCSCF and CI
calculations, ALDET, ORMAS, and GUGA drivers can be used (details follow).


\subsection{HF input}
\label{\detokenize{lab_advanced_molecules:hf-input}}
The following input will perform a restricted HF calculation on a closed\sphinxhyphen{}shell singlet
(multiplicity=1). This will generate RHF orbitals for any molecular system defined in
\sphinxcode{\sphinxupquote{\$DATA ... \$END}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}CONTRL SCFTYP=RHF RUNTYP=ENERGY MULT=1
ISPHER=1 EXETYP=RUN COORD=UNIQUE MAXIT=200 \PYGZdl{}END
\PYGZdl{}SYSTEM MEMORY=150000000 \PYGZdl{}END
\PYGZdl{}GUESS GUESS=HUCKEL \PYGZdl{}END
\PYGZdl{}SCF DIRSCF=.TRUE. \PYGZdl{}END
\PYGZdl{}DATA
...
Atomic Coordinates and basis set
...
\PYGZdl{}END
\end{sphinxVerbatim}

Main options:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
SCFTYP: Type of SCF method, options: RHF, ROHF, MCSCF, UHF and NONE.

\item {} 
RUNTYP: Type of run. For QMCPACK wavefunction generation this should
always be ENERGY.

\item {} 
MULT: Multiplicity of the molecule.

\item {} 
ISPHER: Use spherical harmonics (1) or Cartesian basis functions
(\sphinxhyphen{}1).

\item {} 
COORD: Input structure for the atomic coordinates in \$DATA.

\end{enumerate}


\subsection{DFT calculations}
\label{\detokenize{lab_advanced_molecules:dft-calculations}}
The main difference between the input for a RHF/ROHF calculation and a DFT calculation
is the definition of the DFTTYP parameter. If this is set in the \$CONTROL
section, a DFT calculation will be performed with the appropriate functional. Notice that
although the default values are usually adequate, DFT calculations have many options involving
the integration grids and accuracy settings. Make sure you study the input manual to be
aware of these. Refer to the input manual for a list of the implemented exchange\sphinxhyphen{}correlation
functionals.


\subsection{MCSCF}
\label{\detokenize{lab_advanced_molecules:mcscf}}
MCSCF calculations are performed by setting SCFTYP=MCSCF in the CONTROL
section. If this option is set, an MCSCF section must be added to the input file with the
options for the calculation. An example section for the water molecule used in the tutorial
follows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}MCSCF CISTEP=GUGA MAXIT=1000 FULLNR=.TRUE. ACURCY=1.0D\PYGZhy{}5 \PYGZdl{}END
\end{sphinxVerbatim}

The most important parameter is CISTEP, which defines the CI package used. The only
options compatible with QMCPACK are: ALDET, GUGA, and ORMAS. Depending on the
package used, additional input sections are needed.


\subsection{CI}
\label{\detokenize{lab_advanced_molecules:ci}}
Configuration interaction (full CI, truncated CI, CAS\sphinxhyphen{}CI, etc) calculations are performed
by setting \sphinxcode{\sphinxupquote{SCFTYP=NONE}} and \sphinxcode{\sphinxupquote{CITYP=GUGA,ALDET,ORMAS}}. Each one of these packages
requires further input sections, which are typically slightly different from the input sections
needed for MCSCF runs.


\subsection{GUGA: Unitary group CI package}
\label{\detokenize{lab_advanced_molecules:guga-unitary-group-ci-package}}
The GUGA package is the only alternative if one wants CSFs with GAMESS. We subsequently provide a very brief description of the input sections needed to perform MCSCF, CASCI,
truncated CI, and SOCI with this package. For a complete description of these methods and
all the options available, please refer to the GAMESS input manual.


\subsubsection{GUGA\sphinxhyphen{}MCSCF}
\label{\detokenize{lab_advanced_molecules:guga-mcscf}}
The following input section performs a CASCI calculation with a CAS that includes 8
electrons in 8 orbitals (4 DOC and 4 VAL), for example, CAS(8,8). NMCC is the number of frozen
orbitals (doubly occupied orbitals in all determinants), NDOC is the number of double
occupied orbitals in the reference determinant, NVAL is the number of singly occupied
orbitals in the reference (for spin polarized cases), and NVAL is the number of orbitals in
the active space. Since FORS is set to .TRUE., all configurations in the active space will
be included. ISTSYM defines the symmetry of the desired state.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}MCSCF CISTEP=GUGA MAXIT=1000 FULLNR=.TRUE. ACURCY=1.0D\PYGZhy{}5 \PYGZdl{}END
\PYGZdl{}DRT GROUP=C2v NMCC=0 NDOC=4 NALP=0 NVAL=4 ISTSYM=1 MXNINT= 500000 FORS=.TRUE. \PYGZdl{}END
\end{sphinxVerbatim}


\subsubsection{GUGA\sphinxhyphen{}CASCI}
\label{\detokenize{lab_advanced_molecules:guga-casci}}
The following input section performs a CASCI calculation with a CAS that includes 8
electrons in 8 orbitals (4 DOC and 4 VAL), for example, CAS(8,8). NFZC is the number of frozen
orbitals (doubly occupied orbitals in all determinants). All other parameters are identical
to those in the MCSCF input section.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}CIDRT GROUP=C2v NFZC=0 NDOC=4 NALP=0 NVAL=4 NPRT=2 ISTSYM=1 FORS=.TRUE. MXNINT= 500000 \PYGZdl{}END
\PYGZdl{}GUGDIA PRTTOL=0.001 CVGTOL=1.0E\PYGZhy{}5 ITERMX=1000 \PYGZdl{}END
\end{sphinxVerbatim}


\subsubsection{GUGA\sphinxhyphen{}truncated CI}
\label{\detokenize{lab_advanced_molecules:guga-truncated-ci}}
The following input sections will lead to a truncated CI calculation. In this particular case
it will perform a CISD calculation since IEXCIT is set to 2. Other values in IEXCIT will lead
to different CI truncations; for example, IEXCIT=4 will lead to CISDTQ. Notice that only
the lowest 30 orbitals will be included in the generation of the excited determinants in this
case. For a full CISD calculation, NVAL should be set to the total number of virtual orbitals.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}CIDRT GROUP=C2v NFZC=0 NDOC=4 NALP=0 NVAL=30 NPRT=2 ISTSYM=1 IEXCIT=2 MXNINT= 500000 \PYGZdl{}END
\PYGZdl{}GUGDIA PRTTOL=0.001 CVGTOL=1.0E\PYGZhy{}5 ITERMX=1000 \PYGZdl{}END
\end{sphinxVerbatim}


\subsubsection{GUGA\sphinxhyphen{}SOCI}
\label{\detokenize{lab_advanced_molecules:guga-soci}}
The following input section performs a SOCI calculation with a CAS that includes 8
electrons in 8 orbitals (4 DOC and 4 VAL), for example, CAS(8,8). Since SOCI is set to .TRUE.,
all single and double determinants from all determinants in the CAS(8,8) will be included.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}CIDRT GROUP=C2v NFZC=0 NDOC=4 NALP=0 NVAL=4 NPRT=2 ISTSYM=1 SOCI=.TRUE. NEXT=30 MXNINT= 500000 \PYGZdl{}END
\PYGZdl{}GUGDIA PRTTOL=0.001 CVGTOL=1.0E\PYGZhy{}5 ITERMX=1000 \PYGZdl{}END
\end{sphinxVerbatim}


\subsection{ECP}
\label{\detokenize{lab_advanced_molecules:ecp}}
To use ECPs in GAMESS, you must define a \sphinxcode{\sphinxupquote{\{\$ECP ... \$END\}}}
block. There must be a definition of a potential for every atom in the system, including
symmetry equivalent ones. In addition, they must appear in the particular order expected
by GAMESS. The following example shows an ECP input block for a single water molecule using
BFD ECPs. To turn on the use of ECPs, the option “ECP=READ” must be added to the
CONTROL input block.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}ECP
O\PYGZhy{}QMC GEN 2 1
3
6.00000000 1 9.29793903
55.78763416 3 8.86492204
\PYGZhy{}38.81978498 2 8.62925665
1
38.41914135 2 8.71924452
H\PYGZhy{}QMC GEN 0 0
3
1.000000000000 1 25.000000000000
25.000000000000 3 10.821821902641
\PYGZhy{}8.228005709676 2 9.368618758833
H\PYGZhy{}QMC
\PYGZdl{}END
\end{sphinxVerbatim}


\section{Appendix B: convert4qmc}
\label{\detokenize{lab_advanced_molecules:appendix-b-convert4qmc}}\label{\detokenize{lab_advanced_molecules:lab-adv-mol-convert4qmc}}
To generate the particleset and wavefunction XML blocks required by QMCPACK in
calculations with molecular systems, the converter \sphinxcode{\sphinxupquote{convert4qmc}} must be used. The converter
will read the standard output from the appropriate quantum chemistry calculation and will
generate all the necessary input for QMCPACK. In the following, we describe the main options of the
converter for GAMESS output. In general, there are three ways to use the converter depending
on the type of calculation performed. The minimum syntax for each option is shown subsequently.
For a description of the XML files produced by the converter, see {\hyperref[\detokenize{lab_advanced_molecules:lab-adv-mol-wf-appendix}]{\sphinxcrossref{\DUrole{std,std-ref}{Appendix E: Wavefunction XML block}}}}.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
For all single\sphinxhyphen{}determinant calculations (HF and DFT with any DFTTYP):
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{convert4qmc} \PYG{o}{\PYGZhy{}}\PYG{n}{gamessAscii} \PYG{n}{single} \PYG{n}{det}\PYG{o}{.}\PYG{n}{out}
\end{sphinxVerbatim}
\end{quote}
\begin{itemize}
\item {} 
single det.out is the standard output generated by GAMESS.

\end{itemize}

\item {} 
\sphinxstyleemphasis{(This option is not recommended. Use the following option to avoid
mistakes.)} For multideterminant calculations where the orbitals and
configurations are read from different files (e.g., when using
orbitals from a MCSCF run and configurations from a subsequent CI
run):
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{convert4qmc} \PYG{o}{\PYGZhy{}}\PYG{n}{gamessAscii} \PYG{n}{orbitals} \PYG{n}{multidet}\PYG{o}{.}\PYG{n}{out} \PYG{o}{\PYGZhy{}}\PYG{n}{ci} \PYG{n}{cicoeff}
\PYG{n}{multidet}\PYG{o}{.}\PYG{n}{out}
\end{sphinxVerbatim}
\end{quote}
\begin{itemize}
\item {} 
orbitals\_multidet.out is the standard output from the calculation
that generates the orbitals. cicoeff multidet.out is the standard
output from the calculation that calculates the CI expansion.

\end{itemize}

\item {} 
For multideterminant calculations where the orbitals and
configurations are read from the same file, using PRTMO=.T. in the
GUESS input block:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{convert4qmc} \PYG{o}{\PYGZhy{}}\PYG{n}{gamessAscii} \PYG{n}{multi} \PYG{n}{det}\PYG{o}{.}\PYG{n}{out} \PYG{o}{\PYGZhy{}}\PYG{n}{ci} \PYG{n}{multi} \PYG{n}{det}\PYG{o}{.}\PYG{n}{out}
\PYG{o}{\PYGZhy{}}\PYG{n}{readInitialGuess} \PYG{n}{Norb}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
multi\_det.out is the standard output from the calculation that
calculates the CI expansion.

\end{itemize}

\end{enumerate}

Options:
\begin{itemize}
\item {} 
\sphinxstylestrong{\sphinxhyphen{}gamessAscii file.out}: Standard output of GAMESS calculation.
With the exception of determinant configurations and coefficients in
multideterminant calculations, everything else is read from this file
including atom coordinates, basis sets, SPOs, ECPs, number of
electrons, multiplicity, etc.

\item {} 
\sphinxstylestrong{\sphinxhyphen{}ci file.out}: In multideterminant calculations, determinant
configurations and coefficients are read from this file. Notice that
SPOs are NOT read from this file. Recognized CI packages are ALDET,
GUGA, and ORMAS. Output produced with the GUGA package MUST have the
option “NPRT=2” in the CIDRT or DRT input blocks.

\item {} 
\sphinxstylestrong{\sphinxhyphen{}threshold cutoff}: Cutoff in multideterminant expansion. Only
configurations with coefficients above this value are printed.

\item {} 
\sphinxstylestrong{\sphinxhyphen{}zeroCI}: Sets to zero the CI coefficients of all determinants,
with the exception of the first one.

\item {} 
\sphinxstylestrong{\sphinxhyphen{}readInitialGuess Norb}: Reads Norb initial orbitals (“INITIAL
GUESS ORBITALS”) from GAMESS output. These are orbitals generated by
the GUESS input block and printed with the option “PRTMO=.T.”. Notice
that this is useful only in combination with the option
“GUESS=MOREAD” and in cases where the orbitals are not modified in
the GAMESS calculation, e.g. CI runs. This is the recommended option
in all CI calculations.

\item {} 
\sphinxstylestrong{\sphinxhyphen{}NaturalOrbitals Norb}: Read Norb “NATURAL ORBITALS” from GAMESS
output. The natural orbitals must exists in the output, otherwise the
code aborts.

\item {} 
\sphinxstylestrong{\sphinxhyphen{}add3BodyJ}: Adds 3\sphinxhyphen{}body Jastrow terms (e\sphinxhyphen{}e\sphinxhyphen{}I) between electron
pairs (both same spin and opposite spin terms) and all ion species in
the system. The radial function is initialized to zero, and the
default cutoff is 10.0 bohr. The converter will add a 1\sphinxhyphen{} and 2\sphinxhyphen{}body
Jastrow to the wavefunction block by default.

\end{itemize}


\subsection{Useful notes}
\label{\detokenize{lab_advanced_molecules:useful-notes}}\begin{itemize}
\item {} 
The type of SPOs read by the converter depends on the type of
calculation and on the options used. By default, when neither
\sphinxhyphen{}readInitialGuess nor \sphinxhyphen{}NaturalOrbitals are used, the following
orbitals are read in each case (notice that \sphinxhyphen{}readInitialGuess or
\sphinxhyphen{}NaturalOrbitals are mutually exclusive):
\begin{itemize}
\item {} 
RHF and ROHF: “EIGENVECTORS”

\item {} 
MCSCF: “MCSCF OPTIMIZED ORBITALS”

\item {} 
GUGA, ALDET, ORMAS: Cannot read orbitals without \sphinxhyphen{}readInitialGuess
or \sphinxhyphen{}NaturalOrbitals options.

\end{itemize}

\item {} 
The SPOs and printed CI coefficients in MCSCF calculations are not
consistent in GAMESS. The printed CI coefficients correspond to the
next\sphinxhyphen{}to\sphinxhyphen{}last iteration; they are not recalculated with the final
orbitals. So to get appropriate CI coefficients from MCSCF
calculations, a subsequent CI (no SCF) calculation is needed to
produce consistent orbitals. In principle, it is possible to read the
orbitals from the MCSCF output and the CI coefficients and
configurations from the output of the following CI calculations. This
could lead to problems in principle since GAMESS will rotate initial
orbitals by default to obtain an initial guess consistent with the
symmetry of the molecule. This last step is done by default and can
change the orbitals reported in the MCSCF calculation before the CI
is performed. To avoid this problem, we highly recommend using the
preceding option \#3 to read all the information from the output of
the CI calculation; this requires the use of “PRTMO=.T.” in the GUESS
input block. Since the orbitals are printed after any symmetry
rotation, the resulting output will always be consistent.

\end{itemize}


\section{Appendix C: Wavefunction optimization XML block}
\label{\detokenize{lab_advanced_molecules:appendix-c-wavefunction-optimization-xml-block}}\label{\detokenize{lab_advanced_molecules:lab-adv-mol-opt-appendix}}\sphinxSetupCaptionForVerbatim{Sample XML optimization block.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{lab_advanced_molecules:listing-60}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{o}{\PYGZlt{}}\PYG{n}{loop} \PYG{n+nb}{max}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{linear}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pbyp}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{checkpoint}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{gpu}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}     \PYG{l+m+mi}{10}  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{warmupsteps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{25} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{steps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{substeps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{20} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.5} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{samples}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{10240}  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{cost} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{energy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}                   \PYG{l+m+mf}{0.95} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{cost}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{cost} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{unreweightedvariance}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}     \PYG{l+m+mf}{0.0} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{cost}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{cost} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{reweightedvariance}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}       \PYG{l+m+mf}{0.05} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{cost}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{useDrift}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{n}{yes} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bigchange}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{10.0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LocalEnergy}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{hdf5}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{usebuffer}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{n}{yes} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nonlocalpp}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{n}{yes} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MinMethod}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{quartic}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{exp0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alloweddifference}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1.0e\PYGZhy{}5} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{stepsize}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mf}{0.15} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nstabilizers}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{loop}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Options:
\begin{itemize}
\item {} 
bigchange: (default 50.0) Largest parameter change allowed

\item {} 
usebuffer: (default no) Save useful information during VMC

\item {} 
nonlocalpp: (default no) Include nonlocal energy on 1\sphinxhyphen{}D min

\item {} 
MinMethod: (default quartic) Method to calculate magnitude of
parameter change quartic: fit quartic polynomial to four values of
the cost function obtained using reweighting along chosen direction
linemin: direct line minimization using reweighting rescale: no 1\sphinxhyphen{}D
minimization. Uses Umrigars suggestions.

\item {} 
stepsize: (default 0.25) Step size in either quartic or linemin
methods.

\item {} 
alloweddifference: (default 1e\sphinxhyphen{}4) Allowed increase in energy

\item {} 
exp0: (default \sphinxhyphen{}16.0) Initial value for stabilizer (shift to diagonal
of H). Actual value of stabilizer is 10 exp0

\item {} 
nstabilizers: (default 3) Number of stabilizers to try

\item {} 
stabilizaterScale: (default 2.0) Increase in value of exp0 between
iterations.

\item {} 
max its: (default 1) Number of inner loops with same sample

\item {} 
minwalkers: (default 0.3) Minimum value allowed for the ratio of
effective samples to actual number of walkers in a reweighting step.
The optimization will stop if the effective number of walkers in any
reweighting calculation drops below this value. Last set of
acceptable parameters are kept.

\item {} 
maxWeight: (defaul 1e6) Maximum weight allowed in reweighting. Any
weight above this value will be reset to this value.

\end{itemize}

Recommendations:
\begin{itemize}
\item {} 
Set samples to equal to (\#threads)*blocks.

\item {} 
Set steps to 1. Use substeps to control correlation between samples.

\item {} 
For cases where equilibration is slow, increase both substeps and
warmupsteps.

\item {} 
For hard cases (e.g., simultaneous optimization of long MSD and
3\sphinxhyphen{}Body J), set exp0 to 0 and do a single inner iteration (max its=1)
per sample of configurations.

\end{itemize}


\section{Appendix D: VMC and DMC XML block}
\label{\detokenize{lab_advanced_molecules:appendix-d-vmc-and-dmc-xml-block}}\label{\detokenize{lab_advanced_molecules:lab-adv-mol-vmcdmc-appendix}}\sphinxSetupCaptionForVerbatim{Sample XML blocks for VMC and DMC calculations.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{lab_advanced_molecules:listing-61}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{vmc}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pbyp}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{checkpoint}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{useDrift}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{yes}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{warmupsteps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{100}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{100}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{steps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{substeps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{20}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{walkers}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{30}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.3}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LocalEnergy}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{hdf5}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dmc}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pbyp}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{checkpoint}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nonlocalmoves}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{yes}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{targetWalkers}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1920}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{100}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{steps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{100}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LocalEnergy}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{hdf5}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

General Options:
\begin{itemize}
\item {} 
\sphinxstylestrong{move}: (default “walker”) Type of electron move. Options: “pbyp”
and “walker.”

\item {} 
\sphinxstylestrong{checkpoint}: (default “\sphinxhyphen{}1”) (If \textgreater{} 0) Generate checkpoint files
with given frequency. The calculations can be restarted/continued
with the produced checkpoint files.

\item {} 
\sphinxstylestrong{useDrift}: (default “yes”) Defines the sampling mode. useDrift =
“yes” will use Langevin acceleration to sample the VMC and DMC
distributions, while useDrift=“no” will use random displacements in a
box.

\item {} 
\sphinxstylestrong{warmupSteps}: (default 0) Number of steps warmup steps at the
beginning of the calculation. No output is produced for these steps.

\item {} 
\sphinxstylestrong{blocks}: (default 1) Number of blocks (outer loop).

\item {} 
\sphinxstylestrong{steps}: (default 1) Number of steps per blocks (middle loop).

\item {} 
\sphinxstylestrong{sub steps}: (default 1) Number of substeps per step (inner loop).
During substeps, the local energy is not evaluated in VMC
calculations, which leads to faster execution. In VMC calculations,
set substeps to the average autocorrelation time of the desired
quantity.

\item {} 
\sphinxstylestrong{time step}: (default 0.1) Electronic time step in bohr.

\item {} 
\sphinxstylestrong{samples}: (default 0) Number of walker configurations saved during
the current calculation.

\item {} 
\sphinxstylestrong{walkers}: (default \#threads) In VMC, sets the number of walkers
per node. The total number of walkers in the calculation will be
equal to walkers*(\# nodes).

\end{itemize}

Options unique to DMC:
\begin{itemize}
\item {} 
\sphinxstylestrong{targetWalkers}: (default \#walkers from previous calculation, e.g.,
VMC). Sets the target number of walkers. The actual population of
walkers will fluctuate around this value. The walkers will be
distributed across all the nodes in the calculation. On a given node,
the walkers are split across all the threads in the system.

\item {} 
\sphinxstylestrong{nonlocalmoves}: (default “no”) Set to “yes” to turns on the use of
Casula’s T\sphinxhyphen{}moves.

\end{itemize}


\section{Appendix E: Wavefunction XML block}
\label{\detokenize{lab_advanced_molecules:appendix-e-wavefunction-xml-block}}\label{\detokenize{lab_advanced_molecules:lab-adv-mol-wf-appendix}}\sphinxSetupCaptionForVerbatim{Basic framework for a single\sphinxhyphen{}determinant determinantset XML block.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{lab_advanced_molecules:listing-62}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{o}{\PYGZlt{}}\PYG{n}{wavefunction} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{psi0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{determinantset} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MolecularOrbital}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LCAOBSet}\PYG{l+s+s2}{\PYGZdq{}}
     \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{transform}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{basisset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LCAOBSet}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{atomicBasisSet} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gaussian\PYGZhy{}G2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{angular}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cartesian}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gaussian}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{O}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{normalized}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
        \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{atomicBasisSet}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{basisset}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{slaterdeterminant}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{determinant} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{updet}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
          \PYG{o}{\PYGZlt{}}\PYG{n}{occupation} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ground}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
          \PYG{o}{\PYGZlt{}}\PYG{n}{coefficient} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{57}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{updetC}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
          \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
          \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficient}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinant}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{determinant} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{downdet}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
          \PYG{o}{\PYGZlt{}}\PYG{n}{occupation} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ground}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
          \PYG{o}{\PYGZlt{}}\PYG{n}{coefficient} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{57}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{downdetC}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
          \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
          \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficient}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinant}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{slaterdeterminant}\PYG{o}{\PYGZgt{}}

    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinantset}\PYG{o}{\PYGZgt{}}

    \PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{J2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Two\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{function}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{print}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}

  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{wavefunction}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

In this section we describe the basic format of a QMCPACK wavefunction XML block.
Everything listed in this section is generated by the appropriate converter tools. Little to
no modification is needed when performing standard QMC calculations. As a result, this
section is meant mainly for illustration purposes. Only experts should attempt to modify
these files (with very few exceptions like the cutoff of CI coefficients and the cutoff in Jastrow
functions) since changes can lead to unexpected results.

A QMCPACK wavefunction XML block is a combination of a determinantset,
which contains the antisymmetric part of the wavefunction and one or
more Jastrow blocks. The syntax of the antisymmetric block depends on
whether the wavefunction is a single determinant or a multideterminant
expansion. {\hyperref[\detokenize{lab_advanced_molecules:listing-62}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 62}}}} shows the general
structure of the single\sphinxhyphen{}determinant case. The determinantset block is
composed of a basisset block, which defines the atomic orbital basis
set, and a slaterdeterminant block, which defines the SPOs and
occupation numbers of the Slater determinant.
{\hyperref[\detokenize{lab_advanced_molecules:listing-63}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 63}}}} shows a (piece of a) sample
of a slaterdeterminant block. The slaterdeterminant block consists of
two determinant blocks, one for each electron spin. The parameter “size”
in the determinant block refers to the number of SPOs present while the
“size” parameter in the coefficient block refers to the number of atomic
basis functions per SPO.
\sphinxSetupCaptionForVerbatim{Sample XML block for the single Slater determinant case.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{lab_advanced_molecules:listing-63}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{o}{\PYGZlt{}}\PYG{n}{slaterdeterminant}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{determinant} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{updet}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{occupation} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ground}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{coefficient} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{134}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{updetC}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{l+m+mf}{9.55471000000000e\PYGZhy{}01} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.87000000000000e\PYGZhy{}04}  \PYG{l+m+mf}{6.51140000000000e\PYGZhy{}02}  \PYG{l+m+mf}{2.17700000000000e\PYGZhy{}03}
  \PYG{l+m+mf}{1.43900000000000e\PYGZhy{}03}  \PYG{l+m+mf}{4.00000000000000e\PYGZhy{}06} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.58000000000000e\PYGZhy{}04} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.20000000000000e\PYGZhy{}05}
  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.40000000000000e\PYGZhy{}05}  \PYG{l+m+mf}{6.00000000000000e\PYGZhy{}06} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00}
  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00}
  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00}
  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00}
  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00}
  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00}
  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00}
  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.26000000000000e\PYGZhy{}04}  \PYG{l+m+mf}{2.63000000000000e\PYGZhy{}04}  \PYG{l+m+mf}{2.63000000000000e\PYGZhy{}04}
  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.27000000000000e\PYGZhy{}04}
  \PYG{l+m+mf}{6.30000000000000e\PYGZhy{}05}  \PYG{l+m+mf}{6.30000000000000e\PYGZhy{}05} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00}
  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.20000000000000e\PYGZhy{}05}  \PYG{l+m+mf}{1.60000000000000e\PYGZhy{}05}  \PYG{l+m+mf}{1.60000000000000e\PYGZhy{}05}
  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.00000000000000e+00}  \PYG{l+m+mf}{7.00000000000000e\PYGZhy{}06}
\end{sphinxVerbatim}

{\hyperref[\detokenize{lab_advanced_molecules:listing-64}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 64}}}} shows the general structure of the multideterminant case.
Similar to the
single\sphinxhyphen{}determinant case, the determinantset must contain a basisset block. This definition is
identical to the one described previously. In this case, the definition of the SPOs
must be done independently from the definition of the determinant configurations; the latter
is done in the sposet block, while the former is done on the multideterminant block. Notice
that two sposet sets must be defined, one for each electron spin. The name of each sposet set
is required in the definition of the multideterminant block. The determinants are defined in
terms of occupation numbers based on these orbitals.
\sphinxSetupCaptionForVerbatim{Basic framework for a multideterminant determinantset XML block.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{lab_advanced_molecules:listing-64}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{o}{\PYGZlt{}}\PYG{n}{wavefunction} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{psi0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{determinantset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LCAOBSet}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MolecularOrbital}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{transform}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{basisset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LCAOBSet}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{atomicBasisSet} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gaussian\PYGZhy{}G2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{angular}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cartesian}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gaussian}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{O}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{normalized}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
        \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{atomicBasisSet}\PYG{o}{\PYGZgt{}}
        \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{basisset}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{sposet} \PYG{n}{basisset}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LCAOBSet}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spo\PYGZhy{}up}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{occupation} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ground}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{coefficient} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{40}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{updetC}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficient}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{sposet}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{sposet} \PYG{n}{basisset}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LCAOBSet}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spo\PYGZhy{}dn}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{occupation} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ground}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{coefficient} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{40}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{downdetC}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficient}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{sposet}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{multideterminant} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{spo\PYGZus{}up}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spo\PYGZhy{}up}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{spo\PYGZus{}dn}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spo\PYGZhy{}dn}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{detlist} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{97}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CSF}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{nca}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{ncb}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{nea}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{neb}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{nstates}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{cutoff}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.001}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
          \PYG{o}{\PYGZlt{}}\PYG{n}{csf} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CSFcoeff\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{exctLvl}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{coeff}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.984378}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{qchem\PYGZus{}coeff}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.984378}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{occ}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{22220000}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
            \PYG{o}{\PYGZlt{}}\PYG{n}{det} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{csf\PYGZus{}0\PYGZhy{}0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{coeff}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{11110000}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{beta}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{11110000}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
          \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{csf}\PYG{o}{\PYGZgt{}}
          \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
        \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{detlist}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{multideterminant}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinantset}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{J2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Two\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{function}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{print}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{wavefunction}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

There are various options in the multideterminant block that users
should be aware of.
\begin{itemize}
\item {} 
cutoff: (IMPORTANT! ) Only configurations with (absolute value)
“qchem coeff” larger than this value will be read by QMCPACK.

\item {} 
optimize: Turn on/off the optimization of linear CI coefficients.

\item {} 
coeff: (in csf ) Current coefficient of given configuration. Gets
updated during wavefunction optimization.

\item {} 
qchem coeff: (in csf ) Original coefficient of given configuration
from GAMESS calculation. This is used when applying a cutoff to the
configurations read from the file. The cutoff is applied on this
parameter and not on the optimized coefficient.

\item {} 
nca and nab: Number of core orbitals for up/down electrons. A core
orbital is an orbital that is doubly occupied in all determinant
configurations, not to be confused with core electrons. These are not
explicitly listed on the definition of configurations.

\item {} 
nea and neb: Number of up/down active electrons (those being
explicitly correlated).

\item {} 
nstates: Number of correlated orbitals.

\item {} 
size (in detlist ): Contains the number of configurations in the
list.

\end{itemize}

The remaining part of the determinantset block is the definition of Jastrow factor. Any
number of these can be defined. {\hyperref[\detokenize{lab_advanced_molecules:listing-65}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 65}}}} shows a sample Jastrow
block including 1\sphinxhyphen{}, 2\sphinxhyphen{} and 3\sphinxhyphen{}body terms. This is the standard block produced by
\sphinxcode{\sphinxupquote{convert4qmc}} with the option \sphinxhyphen{}add3BodyJ (this particular example is for a water molecule).
Optimization of individual radial functions can be turned on/off using the “optimize”
parameter. It can be added to any coefficients block, even though it is currently not
present in the J1 and J2 blocks.
\sphinxSetupCaptionForVerbatim{Sample Jastrow XML block.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{lab_advanced_molecules:listing-65}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{J2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Two\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{function}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{print}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{speciesA}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{speciesB}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{uu}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{speciesA}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{speciesB}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ud}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{J1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{One\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{function}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{print}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{cusp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{O}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{eO}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{cusp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{eH}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{J3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{eeI}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{function}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{polynomial}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{print}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{ispecies}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{O}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{especies}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{isize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{esize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{uuO}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{ispecies}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{O}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{especies1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{especies2}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{isize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{esize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{udO}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{ispecies}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{especies}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{isize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{esize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{uuH}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{ispecies}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{especies1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{especies2}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{isize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{esize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{udH}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

This training assumes basic familiarity with the UNIX operating system. In particular,
we use simple scripts written in “csh.” In addition, we assume you have obtained
all the necessary files and executables and that the training files are located
at \$\{TRAINING TOP\}.

The goal of this training is not only to familiarize you with the execution and
options in QMCPACK but also to introduce you to important concepts in QMC calculations and many\sphinxhyphen{}body electronic structure calculations.


\chapter{Lab 4: Condensed Matter Calculations}
\label{\detokenize{lab_condensed_matter:lab-4-condensed-matter-calculations}}\label{\detokenize{lab_condensed_matter:lab-condensed-matter}}\label{\detokenize{lab_condensed_matter::doc}}

\section{Topics covered in this lab}
\label{\detokenize{lab_condensed_matter:topics-covered-in-this-lab}}\begin{itemize}
\item {} 
Tiling DFT primitive cells into QMC supercells

\item {} 
Reducing finite\sphinxhyphen{}size errors via extrapolation

\item {} 
Reducing finite\sphinxhyphen{}size errors via averaging over twisted boundary
conditions

\item {} 
Using the B\sphinxhyphen{}spline mesh factor to reduce memory requirements

\item {} 
Using a coarsely resolved vacuum buffer region to reduce memory
requirements

\item {} 
Calculating the DMC total energies of representative 2D and 3D
extended systems

\end{itemize}


\section{Lab directories and files}
\label{\detokenize{lab_condensed_matter:lab-directories-and-files}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
labs/lab4\PYGZus{}condensed\PYGZus{}matter/
├── Be\PYGZhy{}2at\PYGZhy{}setup.py           \PYGZhy{} DFT only for prim to conv cell
├── Be\PYGZhy{}2at\PYGZhy{}qmc.py             \PYGZhy{} QMC only for prim to conv cell
├── Be\PYGZhy{}16at\PYGZhy{}qmc.py            \PYGZhy{} DFT and QMC for prim to 16 atom cell
├── graphene\PYGZhy{}setup.py         \PYGZhy{} DFT and OPT for graphene
├── graphene\PYGZhy{}loop\PYGZhy{}mesh.py     \PYGZhy{} VMC scan over orbital bspline mesh factors
├── graphene\PYGZhy{}final.py         \PYGZhy{} DMC for final meshfactor
└── pseudopotentials          \PYGZhy{} pseudopotential directory
    ├── Be.ncpp                 \PYGZhy{} Be PP for Quantum ESPRESSO
    ├── Be.xml                  \PYGZhy{} Be PP for QMCPACK
    ├── C.BFD.upf               \PYGZhy{} C  PP for Quantum ESPRESSO
    └── C.BFD.xml               \PYGZhy{} C  PP for QMCPACK
\end{sphinxVerbatim}

The goal of this lab is to introduce you to the somewhat specialized problems involved in performing DMC calculations on condensed matter as opposed to the atoms and molecules that were the focus of the preceding labs.   Calculations will be performed on two different systems.  Firstly, we will perform a series of calculations on BCC beryllium, focusing on the necessary methodology to limit finite\sphinxhyphen{}size effects.  Secondly, we will perform calculations on graphene as an example of a system where QMCPACK’s capability to handle cases with mixed periodic and open boundary conditions is useful.  This example will also focus on strategies to limit memory usage for such systems.
All of the calculations performed in this lab will use the Nexus workflow management system, which vastly simplifies the process by automating the steps of generating trial wavefunctions and performing DMC calculations.


\section{Preliminaries}
\label{\detokenize{lab_condensed_matter:preliminaries}}
For any DMC calculation, we must start with a trial wavefunction. As is typical for our calculations of condensed matter, we will produce this wavefunction using DFT.  Specifically, we will use QE to generate a Slater determinant of SPOs.  This is done as a three\sphinxhyphen{}step process.  First, we calculate the converged charge density by performing a DFT calculation with a fine grid of k\sphinxhyphen{}points to fully sample the Brillouin zone.  Next, a non\sphinxhyphen{}self\sphinxhyphen{} consistent calculation is performed at the specific k\sphinxhyphen{}points needed for the supercell and twists needed in the DMC calculation (more on this later).  Finally, a wavefunction is converted from the binary representation used by QE to the portable hdf5 representation used by QMCPACK.

The choice of k\sphinxhyphen{}points necessary to generate the wavefunctions depends on both the supercell chosen for the DMC calculation and by the supercell twist vectors needed.  Recall that the wavefunction in a plane\sphinxhyphen{}wave DFT calculation is written using Bloch’s theorem as:
\begin{equation}\label{equation:lab_condensed_matter:eq70}
\begin{split}\Psi(\vec{r}) = e^{i\vec{k}\cdot\vec{r}}u(\vec{r})\:,\end{split}
\end{equation}
where \(\vec{k}\) is confined to the first Brillouin zone of the
cell chosen and \(u(\vec{r})\) is periodic in this simulation cell.
A plane\sphinxhyphen{}wave DFT calculation stores the periodic part of the
wavefunction as a linear combination of plane waves for each SPO at all
k\sphinxhyphen{}points selected. The symmetry of the system allows us to generate an
arbitrary supercell of the primitive cell as follows: Consider the set
of primitive lattice vectors, \(\{ \mathbf{a}^p_1, \mathbf{a}^p_2,
\mathbf{a}^p_3\}\). We may write these vectors in a matrix,
\(\mathbf{L}_p\), the rows of which are the primitive lattice
vectors. Consider a nonsingular matrix of integers, \(\mathbf{S}\).
A corresponding set of supercell lattice vectors,
\(\{\mathbf{a}^s_1, \mathbf{a}^s_2, \mathbf{a}^s_3\}\), can be
constructed by the matrix product
\begin{equation}\label{equation:lab_condensed_matter:eq71}
\begin{split}\mathbf{a}^s_i = S_{ij} \mathbf{a}^p_j]\:.\end{split}
\end{equation}
If the primitive cell contains \(N_p\) atoms, the supercell will
then contain \(N_s = |\det(\mathbf{S})| N_p\) atoms.

Now, the wavefunciton at any point in this new supercell can be related
to the wavefunction in the primitive cell by finding the linear
combination of primitive lattice vectors that maps this point back to
the primitive cell:
\begin{equation}\label{equation:lab_condensed_matter:eq72}
\begin{split}\vec{r}' = \vec{r} + x \mathbf{a}^p_1 + y \mathbf{a}^p_2 + z\mathbf{a}^p_3 = \vec{r} + \vec{T}\:,\end{split}
\end{equation}
where \(x, y, z\) are integers. Now the wavefunction in the
supercell at point \(\vec{r}'\) can be written in terms of the
wavefunction in the primitive cell at \(\vec{r}'\) as:
\begin{equation}\label{equation:lab_condensed_matter:eq73}
\begin{split}\Psi(\vec{r}) = \Psi(\vec{r}') e^{i \vec{T} \cdot \vec{k}}\:,\end{split}
\end{equation}
where \(\vec{k}\) is confined to the first Brillouin zone of the
primitive cell. We have also chosen the supercell twist vector, which
places a constraint on the form of the wavefunction in the supercell.
The combination of these two constraints allows us to identify family of
N k\sphinxhyphen{}points in the primitive cell that satisfy the constraints. Thus, for
a given supercell tiling matrix and twist angle, we can write the
wavefunction everywhere in the supercell by knowing the wavefunction a N
k\sphinxhyphen{}points in the primitive cell. This means that the memory necessary to
store the wavefunction in a supercell is only linear in the size of the
supercell rather than the quadratic cost if symmetry were neglected.


\section{Total energy of BCC beryllium}
\label{\detokenize{lab_condensed_matter:total-energy-of-bcc-beryllium}}
When performing calculations of periodic solids with QMC, it is essential to work with a reasonable size supercell rather than the primitive cells that are common in mean field calculations.  Specifically, all of the finite\sphinxhyphen{}size correction schemes discussed in the morning require that the exchange\sphinxhyphen{}correlation hole be considerably smaller than the periodic simulation cell.  Additionally, finite\sphinxhyphen{}size effects are lessened as the distance between the electrons in the cell and their periodic images increases, so it is advantageous to generate supercells that are as spherical as possible to maximize this distance.  However, a competing consideration is that when calculating total energies we often want to extrapolate the energy per particle to the thermodynamic limit by means of the following formula in three dimensions:
\begin{equation}\label{equation:lab_condensed_matter:eq74}
\begin{split} E_{\inf} = C + E_{N}/N\:.\end{split}
\end{equation}
This formula derived assuming the shape of the supercells is consistent
(more specifically that the periodic distances scale uniformly with
system size), meaning we will need to do a uniform tiling, that is,
\(2\times2\times2\), \(3\times3\times3\), etc. As a
\(3\times3\times3\) tiling is 27 times larger than the supercell and
the practical limit of DMC is on the order of 200 atoms (depending on
Z), sometimes it is advantageous to choose a less spherical supercell
with fewer atoms rather than a more spherical one that is too expensive
to tile.

In the case of a BCC crystal, it is possible to tile the one atom
primitive cell to a cubic supercell only by doubling the number of
electrons. This is the best possible combination of a small number of
atoms that can be tiled and a regular box that maximizes the distance
between periodic images. We will need to determine the tiling matrix S
that generates this cubic supercell by solving the following equation
for the coefficients of the S matrix:
\begin{equation}\label{equation:lab_condensed_matter:eq75}
\begin{split}\left[\begin{array}{rrr}
  1 & 0 & 0 \\
  0 & 1 & 0 \\
  0 & 0 & 1
  \end{array}\right] =  \left[\begin{array}{rrr}
  s_{11} & s_{12} & s_{13} \\
  s_{21} & s_{22} & s_{23} \\
  s_{31} & s_{32} & s_{33}
  \end{array}\right] \cdot
\left[\begin{array}{rrr}
  0.5 &  0.5 & -0.5 \\
 -0.5 &  0.5 &  0.5 \\
  0.5 & -0.5 &  0.5
\end{array}\right]\:.\end{split}
\end{equation}
We will now use Nexus to generate the trial wavefunction for this BCC beryllium.

Fortunately, the Nexus will handle determination of the proper k\sphinxhyphen{}vectors given the tiling matrix.  All that is needed is to place the tiling matrix in the \sphinxcode{\sphinxupquote{Be\sphinxhyphen{}2at\sphinxhyphen{}setup.py}} file.   Now the definition of the physical system is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{bcc\PYGZus{}Be} \PYG{o}{=} \PYG{n}{generate\PYGZus{}physical\PYGZus{}system}\PYG{p}{(}
    \PYG{n}{lattice}    \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cubic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{cell}       \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{primitive}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{centering}  \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{atoms}      \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Be}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{constants}  \PYG{o}{=} \PYG{l+m+mf}{3.490}\PYG{p}{,}
    \PYG{n}{units}      \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{net\PYGZus{}charge} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,}
    \PYG{n}{net\PYGZus{}spin}   \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,}
    \PYG{n}{Be}         \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,}
    \PYG{n}{tiling}     \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{d}\PYG{p}{,}\PYG{n}{e}\PYG{p}{,}\PYG{n}{f}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{g}\PYG{p}{,}\PYG{n}{h}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{kgrid}      \PYG{o}{=} \PYG{n}{kgrid}\PYG{p}{,}
    \PYG{n}{kshift}     \PYG{o}{=} \PYG{p}{(}\PYG{o}{.}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{o}{.}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{o}{.}\PYG{l+m+mi}{5}\PYG{p}{)}
    \PYG{p}{)}
\end{sphinxVerbatim}

where the tiling line should be replaced with the preceding row major
tiling matrix. This script file will now perform a converged DFT
calculation to generate the charge density in a directory called
\sphinxcode{\sphinxupquote{bcc\sphinxhyphen{}beryllium/scf}} and perform a non\sphinxhyphen{}self\sphinxhyphen{}consistend DFT calculation
to generate SPOs in the directory \sphinxcode{\sphinxupquote{bcc\sphinxhyphen{}beryllium/nscf}}. Fortunately,
Nexus will calculate the required k\sphinxhyphen{}points needed to tile the
wavefunction to the supercell, so all that is necessary is the
granularity of the supercell twists and whether this grid is shifted
from the origin. Once this is finished, it performs the conversion from
pwscf’s binary format to the hdf5 format used by QMCPACK. Finally, it
will optimize the coefficients of 1\sphinxhyphen{}body and 2\sphinxhyphen{}body Jastrow factors in
the supercell defined by the tiling matrix.

Run these calculations by executing the script \sphinxcode{\sphinxupquote{Be\sphinxhyphen{}2at\sphinxhyphen{}setup.py}}. You
will notice the small calculations required to generate the wavefunction
of beryllium in a one\sphinxhyphen{}atom cell are rather inefficient to run on a
high\sphinxhyphen{}performance computer such as vesta in terms of the time spent doing
calculations versus time waiting on the scheduler and booting compute
nodes. One of the benefits of the portable HDF format that is used by
QMCPACK is that you can generate data like wavefunctions on a local
workstation or other convenient resource and use high\sphinxhyphen{}performance
clusters for the more expensive QMC calculations.

In this case, the wavefunction is generated in the directory
\sphinxcode{\sphinxupquote{bcc\sphinxhyphen{}beryllium/nscf\sphinxhyphen{}2at\_222/pwscf\_ output}} in a file called
\sphinxcode{\sphinxupquote{pwscf.pwscf.h5}}. For debugging purposes, it can be useful to verify
that the contents of this file are what you expect. For instance, you
can use the tool \sphinxcode{\sphinxupquote{h5ls}} to check the geometry of the cell where the
DFT calculations were performed or the number of k\sphinxhyphen{}points or electrons
in the calculation. This is done with the command h5ls \sphinxhyphen{}d
pwscf.pwscf.h5/supercell or h5ls \sphinxhyphen{}d pwscf.pwscf.h5/electrons.

In the course of running \sphinxcode{\sphinxupquote{Be\sphinxhyphen{}2at\sphinxhyphen{}setup.py}}, you will get an error when
attempting to perform the VMC and wavefunction optimization
calculations. This is because the wavefunction has generated supercell
twists of the form (+/\sphinxhyphen{} 1/4, +/\sphinxhyphen{} 1/4, +/\sphinxhyphen{} 1/4). In the case that the
supercell twist contains only 0 or 1/2, it is possible to operate
entirely with real arithmetic. The executable that has been indicated in
\sphinxcode{\sphinxupquote{Be\sphinxhyphen{}2at\sphinxhyphen{}setup.py}} was compiled for this case. Note that where
possible, the memory use is a factor of two less than the general case
and the calculations are somewhat faster. However, it is often necessary
to perform calculations away from these special twist angles to reduce
finite\sphinxhyphen{}size effects. To fix this, delete the directory
\sphinxcode{\sphinxupquote{bcc\sphinxhyphen{}beryllium/opt\sphinxhyphen{}2at}}, change the line near the top of
\sphinxcode{\sphinxupquote{Be\sphinxhyphen{}2at\sphinxhyphen{}setup.py}} from

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qmcpack}    \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/soft/applications/qmcpack/Binaries/qmcpack}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

to

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qmcpack}    \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/soft/applications/qmcpack/Binaries/qmcpack\PYGZus{}comp}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

and rerun the script.

When the optimization calculation has finished, check that everything has proceeded correctly by looking at the output in the \sphinxcode{\sphinxupquote{opt\sphinxhyphen{}2at}} directory.  Firstly, you can grep the output file for Delta to see if the cost function has indeed been decreasing during the optimization.  You should find something like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{OldCost}\PYG{p}{:} \PYG{l+m+mf}{4.8789147e\PYGZhy{}02} \PYG{n}{NewCost}\PYG{p}{:} \PYG{l+m+mf}{4.0695360e\PYGZhy{}02} \PYG{n}{Delta} \PYG{n}{Cost}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{8.0937871e\PYGZhy{}03}
\PYG{n}{OldCost}\PYG{p}{:} \PYG{l+m+mf}{3.8507795e\PYGZhy{}02} \PYG{n}{NewCost}\PYG{p}{:} \PYG{l+m+mf}{3.8338486e\PYGZhy{}02} \PYG{n}{Delta} \PYG{n}{Cost}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.6930674e\PYGZhy{}04}
\PYG{n}{OldCost}\PYG{p}{:} \PYG{l+m+mf}{4.1079105e\PYGZhy{}02} \PYG{n}{NewCost}\PYG{p}{:} \PYG{l+m+mf}{4.0898345e\PYGZhy{}02} \PYG{n}{Delta} \PYG{n}{Cost}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.8076319e\PYGZhy{}04}
\PYG{n}{OldCost}\PYG{p}{:} \PYG{l+m+mf}{4.2681333e\PYGZhy{}02} \PYG{n}{NewCost}\PYG{p}{:} \PYG{l+m+mf}{4.2356598e\PYGZhy{}02} \PYG{n}{Delta} \PYG{n}{Cost}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.2473514e\PYGZhy{}04}
\PYG{n}{OldCost}\PYG{p}{:} \PYG{l+m+mf}{3.9168577e\PYGZhy{}02} \PYG{n}{NewCost}\PYG{p}{:} \PYG{l+m+mf}{3.8552883e\PYGZhy{}02} \PYG{n}{Delta} \PYG{n}{Cost}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.1569350e\PYGZhy{}04}
\PYG{n}{OldCost}\PYG{p}{:} \PYG{l+m+mf}{4.2176276e\PYGZhy{}02} \PYG{n}{NewCost}\PYG{p}{:} \PYG{l+m+mf}{4.2083371e\PYGZhy{}02} \PYG{n}{Delta} \PYG{n}{Cost}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{9.2903058e\PYGZhy{}05}
\PYG{n}{OldCost}\PYG{p}{:} \PYG{l+m+mf}{4.3977361e\PYGZhy{}02} \PYG{n}{NewCost}\PYG{p}{:} \PYG{l+m+mf}{4.2865751e\PYGZhy{}02} \PYG{n}{Delta} \PYG{n}{Cost}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.11161830}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{03}
\PYG{n}{OldCost}\PYG{p}{:} \PYG{l+m+mf}{4.1420944e\PYGZhy{}02} \PYG{n}{NewCost}\PYG{p}{:} \PYG{l+m+mf}{4.0779569e\PYGZhy{}02} \PYG{n}{Delta} \PYG{n}{Cost}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.4137501e\PYGZhy{}04}
\end{sphinxVerbatim}

which shows that the starting wavefunction was fairly good and that most
of the optimization occurred in the first step. Confirm this by using
\sphinxcode{\sphinxupquote{qmca}} to look at how the energy and variance changed over the course
of the calculation with the command: \sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}q ev \sphinxhyphen{}e 10 *.scalar.dat}}
executed in the \sphinxcode{\sphinxupquote{opt\sphinxhyphen{}2at directory}}. You should get output like the
following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
                  \PYG{n}{LocalEnergy}               \PYG{n}{Variance}             \PYG{n}{ratio}
\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{0}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.159139} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.001897}   \PYG{l+m+mf}{0.047343} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000758}   \PYG{l+m+mf}{0.0219}
\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{1}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.163752} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.001305}   \PYG{l+m+mf}{0.039389} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000666}   \PYG{l+m+mf}{0.0182}
\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{2}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.160913} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.001347}   \PYG{l+m+mf}{0.040879} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000682}   \PYG{l+m+mf}{0.0189}
\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{3}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.162043} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.001223}   \PYG{l+m+mf}{0.041183} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.001250}   \PYG{l+m+mf}{0.0190}
\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{4}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.162441} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000865}   \PYG{l+m+mf}{0.039597} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000342}   \PYG{l+m+mf}{0.0183}
\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{5}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.161287} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000732}   \PYG{l+m+mf}{0.039954} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000498}   \PYG{l+m+mf}{0.0185}
\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{6}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.163458} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000973}   \PYG{l+m+mf}{0.044431} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.003583}   \PYG{l+m+mf}{0.0205}
\PYG{n}{opt}  \PYG{n}{series} \PYG{l+m+mi}{7}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.163495} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.001027}   \PYG{l+m+mf}{0.040783} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.000413}   \PYG{l+m+mf}{0.0189}
\end{sphinxVerbatim}

Now that the optimization has completed successfully, we can perform DMC
calculations. The first goal of the calculations will be to try to
eliminate the 1\sphinxhyphen{}body finite\sphinxhyphen{}size effects by twist averaging. The script
\sphinxcode{\sphinxupquote{Be\sphinxhyphen{}2at\sphinxhyphen{}qmc.py}} has the necessary input. Note that on line 42 two
twist grids are specified, (2,2,2) and (3,3,3). Change the tiling matrix
in this input file as in \sphinxcode{\sphinxupquote{Be\sphinxhyphen{}2at\sphinxhyphen{}qmc.py}} and start the calculations.
Note that this workflow takes advantage of QMCPACK’s capability to group
jobs. If you look in the directory \sphinxcode{\sphinxupquote{dmc\sphinxhyphen{}2at\_222}} at the job submission
script (\sphinxcode{\sphinxupquote{dmc.qsub.in}}), you will note that rather than operating on an
XML input file, \sphinxcode{\sphinxupquote{qmcapp}} is targeting a text file called \sphinxcode{\sphinxupquote{dmc.in}}.
This file is a simple text file that contains the names of the eight XML
input files needed for this job, one for each twist. When operated in
this mode, QMCPACK will use MPI groups to run multiple copies of itself
within the same MPI context. This is often useful both in terms of
organizing calculations and for taking advantage of the large job sizes
that computer centers often encourage.

The DMC calculations in this case are designed to complete in a few
minutes. When they have finished running, first look at the
\sphinxcode{\sphinxupquote{scalar.dat}} files corresponding to the DMC calculations at the
various twists in \sphinxcode{\sphinxupquote{dmc\sphinxhyphen{}2at\_222}}. Using a command such as
\sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}q ev \sphinxhyphen{}e 32 *.s001.scalar.dat}} (with a suitably chosen number of
blocks for the equilibration), you will see that the DMC energy in each
calculation is nearly identical within the statistical uncertainty of
the calculations. In the case of a large supercell, this is often
indicative of a situation where the Brillouin zone is so small that the
1\sphinxhyphen{}body finite\sphinxhyphen{}size effects are nearly converged without any twist
averaging. In this case, however, this is because of the symmetry of the
system. For this cubic supercell, all of the twist angles chosen in this
shifted \(2\times2\times2\) grid are equivalent by symmetry. In the
case where substantial resources are required to equilibrate the DMC
calculations, it can be beneficial to avoid repeating such twists and
instead simply weight them properly. In this case, however, where the
equilibration is inexpensive, there is no benefit to adding such
complexity as the calculations can simply be averaged together and the
result is equivalent to performing a single longer calculation.

Using the command \sphinxcode{\sphinxupquote{qmc \sphinxhyphen{}a \sphinxhyphen{}q ev \sphinxhyphen{}e 16 *.s001.scalar.dat}}, average the
DMC energies in \sphinxcode{\sphinxupquote{dmc\sphinxhyphen{}2at\_222 and dmc\sphinxhyphen{}2at\_333}} to see whether the
1\sphinxhyphen{}body finite\sphinxhyphen{}size effects are converged with a \(3\times3\times3\)
grid of twists. When using beryllium as a metal, the convergence is
quite poor (0.025 Ha/Be or 0.7 eV/Be). If this were a production
calculation it would be necessary to perform calculations on much larger
grids of supercell twists to eliminate the 1\sphinxhyphen{}body finite\sphinxhyphen{}size effects.

In this case there are several other calculations that would warrant a
high priority. Script \sphinxcode{\sphinxupquote{Be\sphinxhyphen{}16at\sphinxhyphen{}qmc.py}} has been provided in which you
can input the appropriate tiling matrix for a 16\sphinxhyphen{}atom cell and perform
calculations to estimate the 2\sphinxhyphen{}body finite\sphinxhyphen{}size effects, which will also
be quite large in the 2\sphinxhyphen{}atom calculations. This script will take
approximately 30 minutes to run to completion, so depending on your
interest, you can either run it or work to modify the scripts to address
the other technical issues that would be necessary for a production
calculation such as calculating the population bias or the time step
error in the DMC calculations.

Another useful exercise would be to attempt to validate this PP by
calculating the ionization potential and electron affinity of the
isolated atom and compare it with the experimental values: IP = 9.3227
eV , EA = 2.4 eV.


\section{Handling a 2D system: graphene}
\label{\detokenize{lab_condensed_matter:handling-a-2d-system-graphene}}
In this section we examine a calculation of an isolated sheet of
graphene. Because graphene is a 2D system, we will take advantage of
QMCPACK’s capability to mix periodic and open boundary conditions to
eliminate and spurious interaction of the sheet with its images in the z
direction. Run the script \sphinxcode{\sphinxupquote{graphene\sphinxhyphen{}setup.py}}, which will generate the
wavefunction and optimize one and two body jastrow factors. In the
script; notice line 160: bconds = ’ppn’ in the generate\_qmcpack
function, which specifies this mix of open and periodic boundary
conditions. Consequently, the atoms will need to be kept away from this
open boundary in the z direction as the electronic wavefunction will not
be defined outside of the simulation box in this direction. For this
reason, all of the atom positions at the beginning of the file have z
coordinates 7.5. At this point, run the script \sphinxcode{\sphinxupquote{graphene\sphinxhyphen{}setup.py}}.

Aside from the change in boundary conditions, the main thing that
distinguishes this kind of calculation from the previous beryllium
example is the large amount of vacuum in the cell. Although this is a
very small calculation designed to run quickly in the tutorial, in
general a more converged calculation would quickly become memory limited
on an architecture like BG/Q. When the initial wavefunction optimization
has completed to your satisfaction, run the script
\sphinxcode{\sphinxupquote{graphene\sphinxhyphen{}loop\sphinxhyphen{}mesh.py}}. This examines within VMC an approach to
reducing the memory required to store the wavefunction. In
\sphinxcode{\sphinxupquote{graphene\sphinxhyphen{}loop\sphinxhyphen{}mesh.py}}, the spacing between the B\sphinxhyphen{}spline points is
varied uniformly. The mesh spacing is a prefactor to the linear spacing
between the spline points, so the memory use goes as the cube of the
meshfactor. When you run the calculations, examine the
\sphinxcode{\sphinxupquote{.s000.scalar.dat}} files with \sphinxcode{\sphinxupquote{qmca}} to determine the lowest
possible mesh spacing that preserves both the VMC energy and the
variance.

Finally, edit the file \sphinxcode{\sphinxupquote{graphene\sphinxhyphen{}final.py}}, which will perform two DMC
calculations. In the first, (qmc1) replace the following lines:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{meshfactor}   \PYG{o}{=} \PYG{n}{xxx}\PYG{p}{,}
\PYG{n}{precision}    \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\end{sphinxVerbatim}

with the values you have determined will perform the calculation with as small as possible wavefunction.  Note that we can also use single precision arithmetic to store the wavefunction by specifying precision=\textasciigrave{}single.’  When you run the script, compare the output of the two DMC calculations in terms of energy and variance.  Also, see if you can calculate the fraction of memory that you were able to save by using a meshfactor other than 1 and single precision arithmetic.


\section{Conclusion}
\label{\detokenize{lab_condensed_matter:conclusion}}
Upon completion of this lab, you should be able to use Nexus to perform DMC calculations on periodic solids when provided with a PP.  You should also be able to reduce the size of the wavefunction in a solid\sphinxhyphen{}state calculation in cases where memory is a limiting factor.


\chapter{Lab 5: Excited state calculations}
\label{\detokenize{lab_excited:lab-5-excited-state-calculations}}\label{\detokenize{lab_excited:excited}}\label{\detokenize{lab_excited::doc}}

\section{Topics covered in this lab}
\label{\detokenize{lab_excited:topics-covered-in-this-lab}}\begin{itemize}
\item {} 
Tiling DFT primitive cells into optimal QMC supercells

\item {} 
Fundamentals of between neutral and charged calculations

\item {} 
Calculating quasiparticle excitation energies of condensed matter
systems

\item {} 
Calculating optical excitation energies of condensed matter systems

\end{itemize}


\section{Lab directories and files}
\label{\detokenize{lab_excited:lab-directories-and-files}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
labs/lab5\PYGZus{}excited\PYGZus{}properties/
├── band.py           \PYGZhy{} Band structure calculation for Carbon Diamond
├── optical.py        \PYGZhy{} VMC optical gap calculation using the tiling matrix from band.py
├── quasiparticle.py  \PYGZhy{} VMC quasiparticle gap calculation using the tiling matrix from band.py
└── pseudopotentials      \PYGZhy{} pseudopotential directory
    ├── C.BFD.upf         \PYGZhy{} C PP for Quantum ESPRESSO
    └── C.BFD.xml         \PYGZhy{} C PP for QMCPACK
\end{sphinxVerbatim}

The goal of this lab is to perform neutral and charged excitation
calculations in condensed matter systems using QMCPACK. Throughout this
lab, a working knowledge of \sphinxstyleemphasis{Lab4 Condensed Matter Calculations} is
assumed. First, we will introduce the concepts of neutral and charged
excitations. We will briefly discuss these in relation to the specific
experimental studies that must be used to benchmark DMC results.
Secondly, we will perform charged (quasiparticle) and neutral (optical)
excitations calculations on C\sphinxhyphen{}diamond.


\section{Basics and excited state experiments}
\label{\detokenize{lab_excited:basics-and-excited-state-experiments}}
Although VMC and DMC methods are better suited for studying ground state
properties of materials, they can still provide useful information
regarding the excited states. Unlike the applications of band structure
theory such as DFT and GW, it is more challenging to obtain the complete
excitation spectra using DMC. However, it is relatively straightforward
to calculate the band gap minimum of a condensed matter system using
DMC.

We will briefly discuss the two main ways of obtaining the band gap
minimum through experiments: photoemission and absorption studies. The
energy required to remove an electron from a neutral system is called
the IP (ionization potential), which is available from direct
photoemission experiments. In contrast, the emission energy of a
negatively charged system (or the energy required to convert a
negatively charged system to a neutral system), known as electron
affinity (EA), is available from inverse photoemission experiments.
Outlines of these experiments are shown in \hyperref[\detokenize{lab_excited:fig22}]{Fig.\@ \ref{\detokenize{lab_excited:fig22}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{lab_excited_experiments}.png}
\caption{Direct and inverse photoemission experiments involve charged excitations, whereas optical absorption experiments involve excitations that are just enough to be excited to the conduction band. From \sphinxcite{lab_excited:onida2002a}}\label{\detokenize{lab_excited:id6}}\label{\detokenize{lab_excited:fig22}}\end{figure}

Following the explanation in the previous paragraph and \hyperref[\detokenize{lab_excited:fig22}]{Fig.\@ \ref{\detokenize{lab_excited:fig22}}}, the \sphinxstyleemphasis{quasiparticle} band gap of a material can be defined as:
\begin{equation}\label{equation:lab_excited:eq76}
\begin{split}E_g=EA-IP=(E_{N+1}^{CBM}-E_{N}^{K'})-(E_{N}^{K'}-E_{N-1}^{VBM})=E_{N+1}^{CBM}+E_{N-1}^{VBM}-2*E_{N}^{K'},\end{split}
\end{equation}
where \(N\) is the number of electrons in the neutral system and
\(E_{N}\) is the ground state energy of the neutral system. CBM and
VBM stand for the conduction band minimum and valence band maximum,
respectively. K’ can formally be arbitrary at the infinite limit.
However, in practical calculations, a supertwist that accommodates both
CBM and VBM can be more efficient in terms of computational time and
systematic finite\sphinxhyphen{}size error cancellation. In the literature, the
quasiparticle gap is also called the electronic gap. The term electronic
comes from the fact that in both photoemission experiments, it is
assumed that the perturbed electron is not interacting with the sample.

Additionally, absorption experiments can be performed in which electrons
are perturbed at relatively lower energies, just enough to be excited
into the conduction band. In absorption experiments, electrons are
perturbed at lower energies. Therefore, they are not completely free and
the system is still considered neutral. Since a \sphinxstyleemphasis{quasihole} and
\sphinxstyleemphasis{quasielectron} are formed simultaneously, a bound state is created,
unlike the free electron in the quasiparticle gap as described
previously. This process is also known as \sphinxstyleemphasis{optical} excitation, which is
schematically shown in \hyperref[\detokenize{lab_excited:fig22}]{Fig.\@ \ref{\detokenize{lab_excited:fig22}}}, under “Absorption.” The
optical gap can be formulated as follows:
\begin{equation}\label{equation:lab_excited:eq77}
\begin{split}E_g^{K_1 {\rightarrow} K_2}=E^{K_1 {\rightarrow} K_2}- E_{0},\end{split}
\end{equation}
where \(E^{K_1 {\rightarrow} K_2}\) is the energy of the system when
a valence electron at wavevector \(K_1\) is promoted to the
conduction band at wavevector \(K_2\). Therefore, the
\(E_g^{K_1 {\rightarrow} K_2}\) is called the optical gap for
promoting an electron at \(K_1\) to \(K_2\). If both CBM and VBM
are on the same k\sphinxhyphen{}vector then the material is called direct band gap
since it can directly emit photons without any external perturbation
(phonons). However, if CBM and VBM share different k\sphinxhyphen{}vectors, then the
photon\sphinxhyphen{}emitting electron has to transfer some of its momenta to the
crystal lattice and then decay to the ground state. As this process
involves an intermediate step, this property is called the indirect band
gap. The difference between the optical and electronic band gaps is
called the exciton binding energy. Exciton binding energy is very
important for optoelectronic applications such as lasers. Since the
recombination usually occurs between free holes and free electrons, a
bound electron and hole state means that the spectrum of emission
energies will be narrower. In the examples that follow, we will
investigate the optical excitations of C\sphinxhyphen{}diamond.


\section{Preparation for the excited state calculations}
\label{\detokenize{lab_excited:preparation-for-the-excited-state-calculations}}\label{\detokenize{lab_excited:lab-ex-prep}}
In this section, we will study the preparation steps to perform excited
state calculations with QMC. Here, the most basic steps are listed in
the implementation order:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Identify the high\sphinxhyphen{}symmetry k\sphinxhyphen{}points of the standardized primitive
cell.

\item {} 
Perform DFT band structure calculation along high\sphinxhyphen{}symmetry paths.

\item {} 
Find a supertwist that includes all the k\sphinxhyphen{}points of interest.

\item {} 
Identify the indexing of k\sphinxhyphen{}points in the supertwist to be used in
QMCPACK.

\end{enumerate}


\subsection{Identifying high\sphinxhyphen{}symmetry k\sphinxhyphen{}points}
\label{\detokenize{lab_excited:lab-ex-highk}}\label{\detokenize{lab_excited:identifying-high-symmetry-k-points}}
Primitive cell is the most basic, nonunique repeat unit of a crystal in
real space. However, the translations of the repeat unit, the Bravais
lattice is unique for each crystal and can be represented using discrete
translation operations, \(R_n\):
\begin{equation}\label{equation:lab_excited:eq78}
\begin{split}{\bf R_n} = n_1{\bf a_1} + n_2{\bf a_2} + n_3{\bf a_3}\:,\end{split}
\end{equation}
\(a_n\) are the real\sphinxhyphen{}space lattice vectors in three dimensions.
Thanks to the periodicity of the Bravais lattice, a crystal can also be
represented using periodic functions in the reciprocal space:
\begin{equation}\label{equation:lab_excited:eq79}
\begin{split}f({\bf R_n + r})= \sum_{m}f_me^{iG_m({\bf R_n+r})},\end{split}
\end{equation}
where \(G_m\) are called as the reciprocal lattice vectors.
\eqref{equation:lab_excited:eq79} also satisfies the equality
\(G_m\cdot{R_n}=2{\pi}N\). High\sphinxhyphen{}symmetry structures can be
represented using a subspace of the BZ, which is called as the
irreducible Brillouin Zone (iBZ). If we choose a series of paths of
high\sphinxhyphen{}symmetry k\sphinxhyphen{}points that encapsulates the iBZ, we can determine the
band gap and electronic structure of the material. For more discussion,
please refer to any solid\sphinxhyphen{}state physics textbook.

There are multiple practical ways to find the high\sphinxhyphen{}symmetry k\sphinxhyphen{}point path.
For example, pymatgen, \sphinxcite{lab_excited:ong2013} XCRYSDEN \sphinxcite{lab_excited:kokalj1999} or SeeK\sphinxhyphen{}path \sphinxcite{lab_excited:hinuma2017} can be used.

\hyperref[\detokenize{lab_excited:fig23}]{Fig.\@ \ref{\detokenize{lab_excited:fig23}}} shows the procedure for visualizing the Brillouin Zone using XCRYSDEN after the structure file is loaded.
However, the primitive cell is not unique, and the actual shape of the BZ can depend on the structure used.
In our example, we use the Python libraries of SeeK\sphinxhyphen{}path, using a wrapper written in Nexus.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{lab_excited_xcrysden1}.png}\hspace*{\fill}}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{lab_excited_xcrysden2}.png}
\caption{Visualizing the Brillouin Zone using XCRYSDEN.}\label{\detokenize{lab_excited:id7}}\label{\detokenize{lab_excited:fig23}}\end{figure}

SeeK\sphinxhyphen{}path includes routines to standardize primitive cells, which will be useful for our work.

SeeK\sphinxhyphen{}path can be installed easily using \sphinxcode{\sphinxupquote{pip}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{user} \PYG{n}{seekpath}
\end{sphinxVerbatim}

In the \sphinxcode{\sphinxupquote{band.py}} script, identification of high\sphinxhyphen{}symmetry k\sphinxhyphen{}points and band structure calculations are done within the workflow.
In the script, where the \sphinxcode{\sphinxupquote{dia}} PhysicalSystem object is used as the input structure, \sphinxcode{\sphinxupquote{dia2\_structure}} is the standardized primitive cell and \sphinxcode{\sphinxupquote{dia2\_kpath}} is the respective k\sphinxhyphen{}path around the iBZ.
\sphinxcode{\sphinxupquote{dia2\_kpath}} has a dictionary of the k\sphinxhyphen{}path in various coordinate systems; please make sure you are using the right one.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{structure} \PYG{k+kn}{import} \PYG{n}{get\PYGZus{}primitive\PYGZus{}cell}\PYG{p}{,} \PYG{n}{get\PYGZus{}kpath}
\PYG{n}{dia2\PYGZus{}structure}   \PYG{o}{=} \PYG{n}{get\PYGZus{}primitive\PYGZus{}cell}\PYG{p}{(}\PYG{n}{structure}\PYG{o}{=}\PYG{n}{dia}\PYG{o}{.}\PYG{n}{structure}\PYG{p}{)}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{structure}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{dia2\PYGZus{}kpath}       \PYG{o}{=} \PYG{n}{get\PYGZus{}kpath}\PYG{p}{(}\PYG{n}{structure}\PYG{o}{=}\PYG{n}{dia2\PYGZus{}structure}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{DFT band structure calculation along high\sphinxhyphen{}symmetry paths}
\label{\detokenize{lab_excited:dft-band-structure-calculation-along-high-symmetry-paths}}
After the high\sphinxhyphen{}symmetry k\sphinxhyphen{}points are identified, band structure calculations can be performed in DFT.
For an insulating structure, DFT can provide VBM and CBM wavevectors, which would be of interest to the DMC calculations.
However, if available, CBM and VBM from DFT would need to be compared with the experiments.
Basically,  \sphinxcode{\sphinxupquote{band.py}} will do the following:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Perform an SCF calculation in QE using a high\sphinxhyphen{}density reciprocal
grid.

\item {} 
Identify the high\sphinxhyphen{}symmetry k\sphinxhyphen{}points on the iBZ and provide a k\sphinxhyphen{}path.

\item {} 
Perform a “band” calculation in QE, explicitly writing all the
k\sphinxhyphen{}points on the path. (Make sure to add extra unoccupied bands.)

\item {} 
Plot the band structure curves and location of VBM/CBM if available.

\end{enumerate}

In \hyperref[\detokenize{lab_excited:fig24}]{Fig.\@ \ref{\detokenize{lab_excited:fig24}}}, C\sphinxhyphen{}diamond is shown to have an indirect
band gap between the red and green dots (CBM and VBM, respectively). VBM
is located at \(\Gamma\). CBM is not located on a high\sphinxhyphen{}symmetry
k\sphinxhyphen{}point in this case. Therefore, we can use the symbol \(\Delta\) to
denote the CBM wavevector in the rest of this document. In \sphinxcode{\sphinxupquote{band.py}}
script, once the band structure calculation is finished, you can use the
following lines to get the exact location of VBM and CBM using

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{p} \PYG{o}{=} \PYG{n}{band}\PYG{o}{.}\PYG{n}{load\PYGZus{}analyzer\PYGZus{}image}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{VBM:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}0\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{p}\PYG{o}{.}\PYG{n}{bands}\PYG{o}{.}\PYG{n}{vbm}\PYG{p}{)}
\PYG{n+nb}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CBM:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}0\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{p}\PYG{o}{.}\PYG{n}{bands}\PYG{o}{.}\PYG{n}{cbm}\PYG{p}{)}
\end{sphinxVerbatim}

Output must be the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{VBM}\PYG{p}{:}
  \PYG{n}{band\PYGZus{}number}     \PYG{o}{=} \PYG{l+m+mi}{3}
  \PYG{n}{energy}          \PYG{o}{=} \PYG{l+m+mf}{13.2874}
  \PYG{n}{index}           \PYG{o}{=} \PYG{l+m+mi}{0}
  \PYG{n}{kpoint\PYGZus{}2pi\PYGZus{}alat} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.}\PYG{p}{]}
  \PYG{n}{kpoint\PYGZus{}rel}      \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.}\PYG{p}{]}
  \PYG{n}{pol}             \PYG{o}{=} \PYG{n}{up}

\PYG{n}{CBM}\PYG{p}{:}
  \PYG{n}{band\PYGZus{}number}     \PYG{o}{=} \PYG{l+m+mi}{4}
  \PYG{n}{energy}          \PYG{o}{=} \PYG{l+m+mf}{17.1545}
  \PYG{n}{index}           \PYG{o}{=} \PYG{l+m+mi}{51}
  \PYG{n}{kpoint\PYGZus{}2pi\PYGZus{}alat} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}        \PYG{l+m+mf}{0.1095605} \PYG{l+m+mf}{0.}       \PYG{p}{]}
  \PYG{n}{kpoint\PYGZus{}rel}      \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.3695652} \PYG{l+m+mf}{0.}        \PYG{l+m+mf}{0.3695652}\PYG{p}{]}
  \PYG{n}{pol}             \PYG{o}{=} \PYG{n}{up}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{lab_excited_band_si}.png}
\caption{Band structure calculation of C\sphinxhyphen{}diamond performed at the DFT\sphinxhyphen{}LDA level.
CBMs are shown with red points, and the VBMs are shown with the green
points, both at \(\Gamma\). DFT\sphinxhyphen{}LDA calculations suggest that the
material has an indirect band gap from
\(\Gamma\rightarrow{\Delta}\). However,
\(\Gamma\rightarrow{\Gamma}\) transition can also be investigated
for more complete check.}\label{\detokenize{lab_excited:id8}}\label{\detokenize{lab_excited:fig24}}\end{figure}


\subsection{DFT band structure calculation along high\sphinxhyphen{}symmetry paths}
\label{\detokenize{lab_excited:id5}}
After the high\sphinxhyphen{}symmetry k\sphinxhyphen{}points are identified, band structure calculations can be performed in DFT.
For an insulating structure, DFT can provide VBM and CBM wavevectors, which would be of interest to the DMC calculations.
However, if available, CBM and VBM from DFT would need to be compared with the experiments.
Basically,  \sphinxcode{\sphinxupquote{band.py}} will do the following:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Perform an SCF calculation in QE using a high\sphinxhyphen{}density reciprocal
grid.

\item {} 
Identify the high\sphinxhyphen{}symmetry k\sphinxhyphen{}points on the iBZ and provide a k\sphinxhyphen{}path.

\item {} 
Perform a “band” calculation in QE, explicitly writing all the
k\sphinxhyphen{}points on the path. (Make sure to add extra unoccupied bands.)

\item {} 
Plot the band structure curves and location of VBM/CBM if available.

\end{enumerate}

In \hyperref[\detokenize{lab_excited:fig24}]{Fig.\@ \ref{\detokenize{lab_excited:fig24}}}, C\sphinxhyphen{}diamond is shown to have an indirect
band gap between the red and green dots (CBM and VBM, respectively). VBM
is located at \(\Gamma\). CBM is not located on a high\sphinxhyphen{}symmetry
k\sphinxhyphen{}point in this case. Therefore, we can use the symbol \(\Delta\) to
denote the CBM wavevector in the rest of this document. In script, once
the band structure calculation is finished, you can use the following
lines to get the exact location of VBM and CBM using

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{p} \PYG{o}{=} \PYG{n}{band}\PYG{o}{.}\PYG{n}{load\PYGZus{}analyzer\PYGZus{}image}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{VBM:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}0\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{p}\PYG{o}{.}\PYG{n}{bands}\PYG{o}{.}\PYG{n}{vbm}\PYG{p}{)}
\PYG{n+nb}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CBM:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}0\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{p}\PYG{o}{.}\PYG{n}{bands}\PYG{o}{.}\PYG{n}{cbm}\PYG{p}{)}
\end{sphinxVerbatim}

Output must be the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{VBM}\PYG{p}{:}
  \PYG{n}{band\PYGZus{}number}     \PYG{o}{=} \PYG{l+m+mi}{3}
  \PYG{n}{energy}          \PYG{o}{=} \PYG{l+m+mf}{13.2874}
  \PYG{n}{index}           \PYG{o}{=} \PYG{l+m+mi}{0}
  \PYG{n}{kpoint\PYGZus{}2pi\PYGZus{}alat} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.}\PYG{p}{]}
  \PYG{n}{kpoint\PYGZus{}rel}      \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.}\PYG{p}{]}
  \PYG{n}{pol}             \PYG{o}{=} \PYG{n}{up}

\PYG{n}{CBM}\PYG{p}{:}
  \PYG{n}{band\PYGZus{}number}     \PYG{o}{=} \PYG{l+m+mi}{4}
  \PYG{n}{energy}          \PYG{o}{=} \PYG{l+m+mf}{17.1545}
  \PYG{n}{index}           \PYG{o}{=} \PYG{l+m+mi}{51}
  \PYG{n}{kpoint\PYGZus{}2pi\PYGZus{}alat} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}        \PYG{l+m+mf}{0.1095605} \PYG{l+m+mf}{0.}       \PYG{p}{]}
  \PYG{n}{kpoint\PYGZus{}rel}      \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.3695652} \PYG{l+m+mf}{0.}        \PYG{l+m+mf}{0.3695652}\PYG{p}{]}
  \PYG{n}{pol}             \PYG{o}{=} \PYG{n}{up}
\end{sphinxVerbatim}


\subsection{Finding a supertwist that includes all the k\sphinxhyphen{}points of interest}
\label{\detokenize{lab_excited:finding-a-supertwist-that-includes-all-the-k-points-of-interest}}
Using the VBM and CBM wavevectors defined in the previous section, we
now construct the supertwist, which will hopefully contain both VBM and
CBM. In \hyperref[\detokenize{lab_excited:fig25}]{Fig.\@ \ref{\detokenize{lab_excited:fig25}}}, we provide a simple example using
2D rectangular lattice. Let us assume that we are interested in the
indirect transition, \(\Gamma \rightarrow X_1\). In
\hyperref[\detokenize{lab_excited:fig25}]{Fig.\@ \ref{\detokenize{lab_excited:fig25}}} a, the first BZ of the primitive cell is
shown as the square centered on \(\Gamma\), which is drawn using
dashed lines. Because of the periodicity of the lattice, this primitive
cell BZ repeats itself with spacings equal to the reciprocal lattice
vectors: (2\(\pi\)/a, 0) and (0, 2\(\pi\)/a) or (1,0) and
(0,1) in crystal coordinates. We are interested in the first BZ, where
\(X_1\) is at (0,0.5). In \hyperref[\detokenize{lab_excited:fig25}]{Fig.\@ \ref{\detokenize{lab_excited:fig25}}} b, the first
BZ of the \(2\times2\) supercell is the smaller square, drawn using
solid lines. In \hyperref[\detokenize{lab_excited:fig25}]{Fig.\@ \ref{\detokenize{lab_excited:fig25}}} c, the BZ of the
\(2\times2\) supercell also repeats in the space, similar to
\hyperref[\detokenize{lab_excited:fig25}]{Fig.\@ \ref{\detokenize{lab_excited:fig25}}} a. Therefore, in the \(2\times2\)
supercell, \(X_1\), \(X_2\), and \(R\) are only the periodic
images of \(\Gamma\). The \(2\times2\) supercell calculation can
be performed in reciprocal space using a {[}2,2{]} tiling matrix. Therefore,
individual k\sphinxhyphen{}points (twists) of the primitive cell are combined in the
supercell calculation, which are then called as supertwists. In more
complex primitive cells (hence BZ), more general criteria would be
constructing a set of supercell reciprocal lattice vectors that contain
the \(\Gamma \rightarrow X_1\) (e.g., \(G_1\) in
\hyperref[\detokenize{lab_excited:fig25}]{Fig.\@ \ref{\detokenize{lab_excited:fig25}}}) vector within their convex hull. Under this
constraint, the Wigner\sphinxhyphen{}Seitz radius of the simulation cell can be
maximized in an effort to reduce finite\sphinxhyphen{}size errors.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=600\sphinxpxdimen]{{lab_excited_twists}.png}
\caption{a) First BZ of the primitive cell centered on \(\Gamma\). Dashed
lines indicate zone boundaries. b) First BZ of the \(2\times2\)
supercell inside the first BZ of the primitive cell. First BZ boundaries
of the supercell are shown using solid lines. c) Periodic translations
of the first BZ of the supercell showing that \(\Gamma\) and
\(X_1\) are periodic images of each other given the supercell BZ.}\label{\detokenize{lab_excited:id9}}\label{\detokenize{lab_excited:fig25}}\end{figure}

For the case of the indirect band gap in Diamond, several approximations
might be needed to generate a supertwist that corresponds to a
reasonable simulation cell. In the Diamond band gap, \(\Delta\) is
at . In your calculations, the \(\Delta\) wavevector and the
eigenvalues you find can be slightly different in value. The closest
simple fraction to this number with the smallest denominator is 1/3. If
we use \(\Delta'=[1/3, 0., 1/3]\), we could use a
\(3\times1\times3\) supercell as the simple choice and include both
\(\Delta'\) and \(\Gamma\) in the same supertwist exactly. Near
\(\Delta\), the LDA band curvature is very low and using
\(\Delta'\) can be a good approximation. We can compare the
eigenvalues using their index numbers:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{p}\PYG{o}{.}\PYG{n}{bands}\PYG{o}{.}\PYG{n}{up}\PYG{p}{[}\PYG{l+m+mi}{51}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} CBM, \PYGZdl{}\PYGZbs{}Delta\PYGZdl{} \PYGZsh{}\PYGZsh{}}
\PYG{g+go}{  eigs            = [\PYGZhy{}3.2076  4.9221  7.5433  7.5433 17.1545 19.7598 28.3242 28.3242]}
\PYG{g+go}{  index           = 51}
\PYG{g+go}{  kpoint\PYGZus{}2pi\PYGZus{}alat = [0.        0.1095605 0.       ]}
\PYG{g+go}{  kpoint\PYGZus{}rel      = [0.3695652 0.        0.3695652]}
\PYG{g+go}{  occs            = [1. 1. 1. 1. 0. 0. 0. 0.]}
\PYG{g+go}{  pol             = up}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{p}\PYG{o}{.}\PYG{n}{bands}\PYG{o}{.}\PYG{n}{up}\PYG{p}{[}\PYG{l+m+mi}{46}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZdl{}\PYGZbs{}Delta\PYGZsq{}\PYGZdl{} \PYGZsh{}\PYGZsh{}}
\PYG{g+go}{  eigs            = [\PYGZhy{}4.0953  6.1376  7.9247  7.9247 17.1972 20.6393 27.3653 27.3653]}
\PYG{g+go}{  index           = 46}
\PYG{g+go}{  kpoint\PYGZus{}2pi\PYGZus{}alat = [0.        0.0988193 0.       ]}
\PYG{g+go}{  kpoint\PYGZus{}rel      = [0.3333333 0.        0.3333333]}
\PYG{g+go}{  occs            = [1. 1. 1. 1. 0. 0. 0. 0.]}
\PYG{g+go}{  pol             = up}
\end{sphinxVerbatim}

This shows that the eigenvalues of the first unoccupied bands in
\(\Delta\) and \(\Delta'\) are 17.1545 and 17.1972 eV,
respectively, meaning that according to LDA, a correction of nearly \sphinxhyphen{}40
meV is obtained. After electronic transitions between \(\Gamma\) and
\(\Delta'\) are studied using DMC, the LDA correction can be applied
to extrapolate the results to \(\Gamma\) and \(\Delta\)
transitions.


\subsection{Identifying the indexing of k\sphinxhyphen{}points of interest in the supertwist}
\label{\detokenize{lab_excited:identifying-the-indexing-of-k-points-of-interest-in-the-supertwist}}
At this stage, we must have performed an \sphinxstyleemphasis{scf} calculation using a
converged k\sphinxhyphen{}point grid and then an \sphinxstyleemphasis{nscf} calculation using the
supertwist k\sphinxhyphen{}points given previously. We will be using the orbitals from
neutral DFT calculations; therefore, we need to explicitly define the
band and twist indexes of the excitations in QMCPACK (e.g., to define
electron promotion). In C\sphinxhyphen{}diamond, we can give an example by finding the
band and twist indexes of \(\Gamma\) and \(\Delta'\). For this
end, a mock VMC calculation can be run and the \sphinxcode{\sphinxupquote{einspline.tile\_300010003}} \sphinxcode{\sphinxupquote{.spin\_0.tw\_0.g0.bandinfo.dat}} file read. The Einspline
file prints out the eigenstates information from DFT calculations.
Therefore, we can obtain the band and the state index from this file,
which can later be used to define the electron promotion. You can see in
the following an explanation of how the band and twist indexes are
defined using a portion of the \sphinxcode{\sphinxupquote{einspline.tile\_300010003.spin\_0.tw\_0.g0.bandinfo.dat}} file. Spin\_0 in the file name suggests
that we are reading the spin\sphinxhyphen{}up eigenstates. Band, state, twistindex,
and bandindex numbers all start from zero. We know we have 72 electrons
in the simulation cell, with 36 of them spin\sphinxhyphen{}up polarized. Since the
state number starts from zero, state number 35 must be occupied while
state 36 should be unoccupied. States 35 and 36 have the same reciprocal
crystal coordinates (K1,K2,K3) as \(\Gamma\) and \(\Delta'\),
respectively. Therefore, an electron should be promoted from state
number 35 to 36 to study the indirect band gap here.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}  Band State TwistIndex BandIndex Energy Kx Ky Kz K1 K2 K3 KmK}
\PYG{l+m+mi}{33} \PYG{l+m+mi}{33} \PYG{l+m+mi}{0}  \PYG{l+m+mi}{1}     \PYG{l+m+mf}{0.488302}  \PYG{l+m+mf}{0.0000}  \PYG{l+m+mf}{0.0000}  \PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0000}      \PYG{l+m+mi}{1}
\PYG{l+m+mi}{34} \PYG{l+m+mi}{34} \PYG{l+m+mi}{0}  \PYG{l+m+mi}{2}     \PYG{l+m+mf}{0.488302}  \PYG{l+m+mf}{0.0000}  \PYG{l+m+mf}{0.0000}  \PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0000}      \PYG{l+m+mi}{1}
\PYG{l+m+mi}{35} \PYG{l+m+mi}{35} \PYG{l+m+mi}{0}  \PYG{l+m+mi}{3}     \PYG{l+m+mf}{0.488302}  \PYG{l+m+mf}{0.0000}  \PYG{l+m+mf}{0.0000}  \PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0000}      \PYG{l+m+mi}{1}
\PYG{l+m+mi}{36} \PYG{l+m+mi}{36} \PYG{l+m+mi}{4}  \PYG{l+m+mi}{4}     \PYG{l+m+mf}{0.631985}  \PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.6209}  \PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3333} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3333}      \PYG{l+m+mi}{1}
\PYG{l+m+mi}{37} \PYG{l+m+mi}{37} \PYG{l+m+mi}{8}  \PYG{l+m+mi}{4}     \PYG{l+m+mf}{0.631985}  \PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.2418}  \PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.6667} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.6667}      \PYG{l+m+mi}{1}
\PYG{l+m+mi}{38} \PYG{l+m+mi}{38} \PYG{l+m+mi}{0}  \PYG{l+m+mi}{4}     \PYG{l+m+mf}{0.691907}  \PYG{l+m+mf}{0.0000}  \PYG{l+m+mf}{0.0000}  \PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0000}      \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

However, we should always check whether this is really what we want. It
can be seen that bands 33, 34, and 35 are degenerate (energy eigenvalues
are listed in the 5th column), but they also have the same reciprocal
coordinates in (K1,K2,K3). This is actually expected as one can see from
\hyperref[\detokenize{lab_excited:fig24}]{Fig.\@ \ref{\detokenize{lab_excited:fig24}}}, in the band diagram the band structure is
threefold degenerate at \(\Gamma\). Here, we can choose the state
with the largest band index: (0,3). Following the (twistindex,
bandindex) notation, we can say that \(\Gamma\) to \(\Delta'\)
transition can be defined as from (0,3) to (4,4).

Alternatively, we can also read the band and twist indexes using PwscfAnalyzer and determine the band/twist indexes on the go:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{p} \PYG{o}{=} \PYG{n}{nscf}\PYG{o}{.}\PYG{n}{load\PYGZus{}analyzer\PYGZus{}image}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{band information}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n+nb}{print} \PYG{n}{p}\PYG{o}{.}\PYG{n}{bands}\PYG{o}{.}\PYG{n}{up}
\PYG{n+nb}{print} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{twist 0 k\PYGZhy{}point:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{p}\PYG{o}{.}\PYG{n}{bands}\PYG{o}{.}\PYG{n}{up}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{kpoint\PYGZus{}rel}
\PYG{n+nb}{print} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{twist 4 k\PYGZhy{}point:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{p}\PYG{o}{.}\PYG{n}{bands}\PYG{o}{.}\PYG{n}{up}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{o}{.}\PYG{n}{kpoint\PYGZus{}rel}
\PYG{n+nb}{print} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{twist 0 band 3 eigenvalue:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{p}\PYG{o}{.}\PYG{n}{bands}\PYG{o}{.}\PYG{n}{up}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{eigs}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{n+nb}{print} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{twist 4 band 4 eigenvalue:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{p}\PYG{o}{.}\PYG{n}{bands}\PYG{o}{.}\PYG{n}{up}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{o}{.}\PYG{n}{eigs}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}
\end{sphinxVerbatim}

Giving output:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}
  \PYG{n}{eigs}            \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{8.0883} \PYG{l+m+mf}{13.2874} \PYG{l+m+mf}{13.2874} \PYG{l+m+mf}{13.2874} \PYG{l+m+mf}{18.8277} \PYG{l+m+mf}{18.8277} \PYG{l+m+mf}{18.8277} \PYG{l+m+mf}{25.9151}\PYG{p}{]}
  \PYG{n}{index}           \PYG{o}{=} \PYG{l+m+mi}{0}
  \PYG{n}{kpoint\PYGZus{}2pi\PYGZus{}alat} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.}\PYG{p}{]}
  \PYG{n}{kpoint\PYGZus{}rel}      \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.}\PYG{p}{]}
  \PYG{n}{occs}            \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.}\PYG{p}{]}
  \PYG{n}{pol}             \PYG{o}{=} \PYG{n}{up}
\PYG{l+m+mi}{1}
  \PYG{n}{eigs}            \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.0893}  \PYG{l+m+mf}{3.8761} \PYG{l+m+mf}{10.9518} \PYG{l+m+mf}{10.9518} \PYG{l+m+mf}{21.5031} \PYG{l+m+mf}{21.5031} \PYG{l+m+mf}{21.5361} \PYG{l+m+mf}{28.2574}\PYG{p}{]}
  \PYG{n}{index}           \PYG{o}{=} \PYG{l+m+mi}{1}
  \PYG{n}{kpoint\PYGZus{}2pi\PYGZus{}alat} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0494096}  \PYG{l+m+mf}{0.0494096}  \PYG{l+m+mf}{0.0494096}\PYG{p}{]}
  \PYG{n}{kpoint\PYGZus{}rel}      \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.3333333} \PYG{l+m+mf}{0.}        \PYG{l+m+mf}{0.}       \PYG{p}{]}
  \PYG{n}{occs}            \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.}\PYG{p}{]}
  \PYG{n}{pol}             \PYG{o}{=} \PYG{n}{up}
\PYG{l+m+mi}{2}
  \PYG{n}{eigs}            \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.0893}  \PYG{l+m+mf}{3.8761} \PYG{l+m+mf}{10.9518} \PYG{l+m+mf}{10.9518} \PYG{l+m+mf}{21.5031} \PYG{l+m+mf}{21.5031} \PYG{l+m+mf}{21.5361} \PYG{l+m+mf}{28.2574}\PYG{p}{]}
  \PYG{n}{index}           \PYG{o}{=} \PYG{l+m+mi}{2}
  \PYG{n}{kpoint\PYGZus{}2pi\PYGZus{}alat} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0988193}  \PYG{l+m+mf}{0.0988193}  \PYG{l+m+mf}{0.0988193}\PYG{p}{]}
  \PYG{n}{kpoint\PYGZus{}rel}      \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.6666667} \PYG{l+m+mf}{0.}        \PYG{l+m+mf}{0.}       \PYG{p}{]}
  \PYG{n}{occs}            \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.}\PYG{p}{]}
  \PYG{n}{pol}             \PYG{o}{=} \PYG{n}{up}
\PYG{l+m+mi}{3}
  \PYG{n}{eigs}            \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.0893}  \PYG{l+m+mf}{3.8761} \PYG{l+m+mf}{10.9518} \PYG{l+m+mf}{10.9518} \PYG{l+m+mf}{21.5031} \PYG{l+m+mf}{21.5031} \PYG{l+m+mf}{21.5361} \PYG{l+m+mf}{28.2574}\PYG{p}{]}
  \PYG{n}{index}           \PYG{o}{=} \PYG{l+m+mi}{3}
  \PYG{n}{kpoint\PYGZus{}2pi\PYGZus{}alat} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mf}{0.0494096}  \PYG{l+m+mf}{0.0494096} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0494096}\PYG{p}{]}
  \PYG{n}{kpoint\PYGZus{}rel}      \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}        \PYG{l+m+mf}{0.}        \PYG{l+m+mf}{0.3333333}\PYG{p}{]}
  \PYG{n}{occs}            \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.}\PYG{p}{]}
  \PYG{n}{pol}             \PYG{o}{=} \PYG{n}{up}
\PYG{l+m+mi}{4}
  \PYG{n}{eigs}            \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.0954}  \PYG{l+m+mf}{6.1375}  \PYG{l+m+mf}{7.9247}  \PYG{l+m+mf}{7.9247} \PYG{l+m+mf}{17.1972} \PYG{l+m+mf}{20.6393} \PYG{l+m+mf}{27.3652} \PYG{l+m+mf}{27.3652}\PYG{p}{]}
  \PYG{n}{index}           \PYG{o}{=} \PYG{l+m+mi}{4}
  \PYG{n}{kpoint\PYGZus{}2pi\PYGZus{}alat} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}        \PYG{l+m+mf}{0.0988193} \PYG{l+m+mf}{0.}       \PYG{p}{]}
  \PYG{n}{kpoint\PYGZus{}rel}      \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.3333333} \PYG{l+m+mf}{0.}        \PYG{l+m+mf}{0.3333333}\PYG{p}{]}
  \PYG{n}{occs}            \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.}\PYG{p}{]}
  \PYG{n}{pol}             \PYG{o}{=} \PYG{n}{up}
\PYG{l+m+mi}{5}
  \PYG{n}{eigs}            \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.6681}  \PYG{l+m+mf}{2.3791}  \PYG{l+m+mf}{3.7836}  \PYG{l+m+mf}{8.5596} \PYG{l+m+mf}{19.3423} \PYG{l+m+mf}{26.2181} \PYG{l+m+mf}{26.6666} \PYG{l+m+mf}{28.0506}\PYG{p}{]}
  \PYG{n}{index}           \PYG{o}{=} \PYG{l+m+mi}{5}
  \PYG{n}{kpoint\PYGZus{}2pi\PYGZus{}alat} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0494096}  \PYG{l+m+mf}{0.1482289}  \PYG{l+m+mf}{0.0494096}\PYG{p}{]}
  \PYG{n}{kpoint\PYGZus{}rel}      \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.6666667} \PYG{l+m+mf}{0.}        \PYG{l+m+mf}{0.3333333}\PYG{p}{]}
  \PYG{n}{occs}            \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.}\PYG{p}{]}
  \PYG{n}{pol}             \PYG{o}{=} \PYG{n}{up}
\PYG{l+m+mi}{6}
  \PYG{n}{eigs}            \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.0893}  \PYG{l+m+mf}{3.8761} \PYG{l+m+mf}{10.9518} \PYG{l+m+mf}{10.9518} \PYG{l+m+mf}{21.5031} \PYG{l+m+mf}{21.5031} \PYG{l+m+mf}{21.5361} \PYG{l+m+mf}{28.2574}\PYG{p}{]}
  \PYG{n}{index}           \PYG{o}{=} \PYG{l+m+mi}{6}
  \PYG{n}{kpoint\PYGZus{}2pi\PYGZus{}alat} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mf}{0.0988193}  \PYG{l+m+mf}{0.0988193} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0988193}\PYG{p}{]}
  \PYG{n}{kpoint\PYGZus{}rel}      \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}        \PYG{l+m+mf}{0.}        \PYG{l+m+mf}{0.6666667}\PYG{p}{]}
  \PYG{n}{occs}            \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.}\PYG{p}{]}
  \PYG{n}{pol}             \PYG{o}{=} \PYG{n}{up}
\PYG{l+m+mi}{7}
  \PYG{n}{eigs}            \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.6681}  \PYG{l+m+mf}{2.3791}  \PYG{l+m+mf}{3.7836}  \PYG{l+m+mf}{8.5596} \PYG{l+m+mf}{19.3423} \PYG{l+m+mf}{26.2181} \PYG{l+m+mf}{26.6666} \PYG{l+m+mf}{28.0506}\PYG{p}{]}
  \PYG{n}{index}           \PYG{o}{=} \PYG{l+m+mi}{7}
  \PYG{n}{kpoint\PYGZus{}2pi\PYGZus{}alat} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mf}{0.0494096}  \PYG{l+m+mf}{0.1482289} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0494096}\PYG{p}{]}
  \PYG{n}{kpoint\PYGZus{}rel}      \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.3333333} \PYG{l+m+mf}{0.}        \PYG{l+m+mf}{0.6666667}\PYG{p}{]}
  \PYG{n}{occs}            \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.}\PYG{p}{]}
  \PYG{n}{pol}             \PYG{o}{=} \PYG{n}{up}
\PYG{l+m+mi}{8}
  \PYG{n}{eigs}            \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.0954}  \PYG{l+m+mf}{6.1375}  \PYG{l+m+mf}{7.9247}  \PYG{l+m+mf}{7.9247} \PYG{l+m+mf}{17.1972} \PYG{l+m+mf}{20.6393} \PYG{l+m+mf}{27.3652} \PYG{l+m+mf}{27.3652}\PYG{p}{]}
  \PYG{n}{index}           \PYG{o}{=} \PYG{l+m+mi}{8}
  \PYG{n}{kpoint\PYGZus{}2pi\PYGZus{}alat} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}        \PYG{l+m+mf}{0.1976385} \PYG{l+m+mf}{0.}       \PYG{p}{]}
  \PYG{n}{kpoint\PYGZus{}rel}      \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.6666667} \PYG{l+m+mf}{0.}        \PYG{l+m+mf}{0.6666667}\PYG{p}{]}
  \PYG{n}{occs}            \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.}\PYG{p}{]}
  \PYG{n}{pol}             \PYG{o}{=} \PYG{n}{up}

\PYG{n}{twist} \PYG{l+m+mi}{0} \PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{n}{point}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.}\PYG{p}{]}
\PYG{n}{twist} \PYG{l+m+mi}{4} \PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{n}{point}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{0.3333333} \PYG{l+m+mf}{0.}        \PYG{l+m+mf}{0.3333333}\PYG{p}{]}
\PYG{n}{twist} \PYG{l+m+mi}{0} \PYG{n}{band} \PYG{l+m+mi}{3} \PYG{n}{eigenvalue}\PYG{p}{:} \PYG{l+m+mf}{13.2874}
\PYG{n}{twist} \PYG{l+m+mi}{4} \PYG{n}{band} \PYG{l+m+mi}{4} \PYG{n}{eigenvalue}\PYG{p}{:} \PYG{l+m+mf}{17.1972}
\end{sphinxVerbatim}


\section{Quasiparticle (electronic) gap calculations}
\label{\detokenize{lab_excited:quasiparticle-electronic-gap-calculations}}\label{\detokenize{lab_excited:lab-ex-qp}}
In quasiparticle calculations, it is essential to work with reasonably large sized supercells to avoid spurious “1/N effects.”
Since quasiparticle calculations involve charged cells, large simulation cells ensure that the extra charge is diluted over the simulation cell. Coulombic interactions are conditionally convergent for neutral periodic systems, but they are divergent for the charged systems.
A typical workflow for a quasiparticle calculation includes the following:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Run an SCF calculation in a neutral charged cell with QE using a
high\sphinxhyphen{}density reciprocal grid.

\item {} 
Choose a tiling matrix that will at least approximately include VBM
and CBM k\sphinxhyphen{}points.

\item {} 
Run ‘nscf’/‘p2q’ calculations using the tiling matrix.

\item {} 
Run VMC/DMC calculations for the neutral and positively and
negatively charged cells in QMCPACK.

\item {} 
Check the convergence of the quasiparticle gap with respect to the
simulation cell size.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{particleset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{random}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{36}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{mass}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{c+c1}{\PYGZsh{}\PYGZsh{}Change size to 35}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}              \PYG{o}{\PYGZgt{}}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}                    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mass}\PYG{l+s+s2}{\PYGZdq{}}                \PYG{o}{\PYGZgt{}}    \PYG{l+m+mf}{1.0}                   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{determinantset}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{slaterdeterminant}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{determinant} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{updet}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{group}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{sposet}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spo\PYGZus{}u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{36}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{c+c1}{\PYGZsh{}\PYGZsh{}Change size to 35}
      \PYG{o}{\PYGZlt{}}\PYG{n}{occupation} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ground}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{spindataset}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinant}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{determinant} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{downdet}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{group}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{sposet}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spo\PYGZus{}d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{36}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{occupation} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ground}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{spindataset}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinant}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{slaterdeterminant}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinantset}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Going back to \eqref{equation:lab_excited:eq77}, we can see that it is essential to include VBM and CBM wavevectors in the same twist for quasiparticle calculations as well.
Therefore, the added electron will sit at CBM while the subtracted electron will be removed from VBM.
However, for the charged cell calculations, we may need to make changes in the input files for the fourth step.  Alternatively, in the quasiparticle.py file, the changes in the QMC input are shown for a negatively charged system:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{input}\PYG{o}{.}\PYG{n}{simulation}\PYG{o}{.}\PYG{n}{qmcsystem}\PYG{o}{.}\PYG{n}{particlesets}\PYG{o}{.}\PYG{n}{e}\PYG{o}{.}\PYG{n}{groups}\PYG{o}{.}\PYG{n}{u}\PYG{o}{.}\PYG{n}{size} \PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{p}{(}\PYG{n}{qmc}\PYG{o}{.}\PYG{n}{input}\PYG{o}{.}\PYG{n}{simulation}\PYG{o}{.}\PYG{n}{qmcsystem}\PYG{o}{.}\PYG{n}{wavefunction}\PYG{o}{.}\PYG{n}{determinantset}
 \PYG{o}{.}\PYG{n}{slaterdeterminant}\PYG{o}{.}\PYG{n}{determinants}\PYG{o}{.}\PYG{n}{updet}\PYG{o}{.}\PYG{n}{size} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

Here, the number of up electrons are increased by one (negatively charged system), and QMCPACK is instructed to read more one orbital in the up channel from the \sphinxcode{\sphinxupquote{.h5}} file.

QE uses symmetry to reduce the number of k\sphinxhyphen{}points required for the calculation.
Therefore, all symmetry tags in QE (\sphinxcode{\sphinxupquote{nosym}}, \sphinxcode{\sphinxupquote{noinv}}, and \sphinxcode{\sphinxupquote{nosym\_evc}}) must be set to false.
An easy way to check whether this is the case is to see that all KmK values \sphinxcode{\sphinxupquote{einspline}} files are equal to 1.
Previously, the input for the neutral cell is given, while the changes are denoted as comments for the positively charged cell.
Note that we have used \sphinxcode{\sphinxupquote{det\_format      = "old"}} in the \sphinxcode{\sphinxupquote{vmc\_+/\sphinxhyphen{}e.py}} files.


\section{Optical gap calculations}
\label{\detokenize{lab_excited:optical-gap-calculations}}
Routines for the optical gap calculations are very similar to the
quasiparticle gap calculations. The first three items in the
quasiparticle band gap calculations can be reused for the optical gap
calculations. However, at the VMC/DMC level, the electronic transitions
performed should be explicitly stated. Therefore, compared with the
quasiparticle calculations, only item number 4 is different for optical
gap calculations. Here, the modified input file is given for the
\(\Gamma\rightarrow\Delta'\) transition, which can be compared with
the ground state input file in the previous section.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{determinantset}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{slaterdeterminant}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{determinant} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{updet}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{group}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{sposet}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spo\PYGZus{}u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{36}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{occupation} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{excited}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{spindataset}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{band}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{pairs}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZgt{}}
        \PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{occupation}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinant}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{determinant} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{downdet}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{group}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{sposet}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spo\PYGZus{}d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{36}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{occupation} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ground}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{spindataset}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinant}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{slaterdeterminant}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinantset}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

We have used the (twistindex, bandindex) notation in the annihilaion/creation order for the up\sphinxhyphen{}spin electrons.
After resubmitting the batch job, in the output, you should be able to see the following lines in the \sphinxcode{\sphinxupquote{vmc.out}} file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Sorting} \PYG{n}{the} \PYG{n}{bands} \PYG{n}{now}\PYG{p}{:}
  \PYG{n}{Occupying} \PYG{n}{bands} \PYG{n}{based} \PYG{n}{on} \PYG{p}{(}\PYG{n}{ti}\PYG{p}{,}\PYG{n}{bi}\PYG{p}{)} \PYG{n}{data}\PYG{o}{.}
\PYG{n}{removing} \PYG{n}{orbital} \PYG{l+m+mi}{35}
\PYG{n}{adding} \PYG{n}{orbital} \PYG{l+m+mi}{36}
\PYG{n}{We} \PYG{n}{will} \PYG{n}{read} \PYG{l+m+mi}{36} \PYG{n}{distinct} \PYG{n}{orbitals}\PYG{o}{.}
\PYG{n}{There} \PYG{n}{are} \PYG{l+m+mi}{0} \PYG{n}{core} \PYG{n}{states} \PYG{o+ow}{and} \PYG{l+m+mi}{36} \PYG{n}{valence} \PYG{n}{states}\PYG{o}{.}
\end{sphinxVerbatim}

And the \sphinxcode{\sphinxupquote{einspline.tile\_300010003.spin\_0.tw\_0.g0.bandinfo.dat}} file must be changed in the following way:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}  Band State TwistIndex BandIndex Energy Kx Ky Kz K1 K2 K3 KmK}
\PYG{l+m+mi}{33} \PYG{l+m+mi}{33} \PYG{l+m+mi}{0}       \PYG{l+m+mi}{1} \PYG{l+m+mf}{0.499956}      \PYG{l+m+mf}{0.0000}  \PYG{l+m+mf}{0.0000} \PYG{l+m+mf}{0.0000}  \PYG{l+m+mf}{0.0000} \PYG{l+m+mf}{0.0000}  \PYG{l+m+mf}{0.0000} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{34} \PYG{l+m+mi}{34} \PYG{l+m+mi}{0}       \PYG{l+m+mi}{2} \PYG{l+m+mf}{0.500126}      \PYG{l+m+mf}{0.0000}  \PYG{l+m+mf}{0.0000} \PYG{l+m+mf}{0.0000}  \PYG{l+m+mf}{0.0000} \PYG{l+m+mf}{0.0000}  \PYG{l+m+mf}{0.0000} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{35} \PYG{l+m+mi}{35} \PYG{l+m+mi}{4}       \PYG{l+m+mi}{4} \PYG{l+m+mf}{0.637231}      \PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.6209} \PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3333} \PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3333} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{36} \PYG{l+m+mi}{36} \PYG{l+m+mi}{0}       \PYG{l+m+mi}{3} \PYG{l+m+mf}{0.502916}      \PYG{l+m+mf}{0.0000}  \PYG{l+m+mf}{0.0000} \PYG{l+m+mf}{0.0000}  \PYG{l+m+mf}{0.0000} \PYG{l+m+mf}{0.0000}  \PYG{l+m+mf}{0.0000} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{37} \PYG{l+m+mi}{37} \PYG{l+m+mi}{8}       \PYG{l+m+mi}{4} \PYG{l+m+mf}{0.637231}      \PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.2418} \PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.6667} \PYG{l+m+mf}{0.0000} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.6667} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{38} \PYG{l+m+mi}{38} \PYG{l+m+mi}{0}       \PYG{l+m+mi}{4} \PYG{l+m+mf}{0.699993}      \PYG{l+m+mf}{0.0000}  \PYG{l+m+mf}{0.0000} \PYG{l+m+mf}{0.0000}  \PYG{l+m+mf}{0.0000} \PYG{l+m+mf}{0.0000}  \PYG{l+m+mf}{0.0000} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

Alternatively, the excitations within Nexus can be defined as shown in the \sphinxcode{\sphinxupquote{optical.py}} file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qmc} \PYG{o}{=} \PYG{n}{generate\PYGZus{}qmcpack}\PYG{p}{(}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{n}{excitation} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{up}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0 3 4 4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} (ti, bi) notation}
    \PYG{c+c1}{\PYGZsh{}excitation = [\PYGZsq{}up\PYGZsq{}, \PYGZsq{}\PYGZhy{}35 + 36\PYGZsq{}], \PYGZsh{} Orbital (state) index notation}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{p}{)}
\end{sphinxVerbatim}




\chapter{Additional Tools}
\label{\detokenize{additional_tools:additional-tools}}\label{\detokenize{additional_tools:id1}}\label{\detokenize{additional_tools::doc}}
QMCPACK provides a set of lightweight executables that address certain
common problems in QMC workflow and analysis.  These range from conversion utilities between
different file formats and QMCPACK (e.g., \sphinxcode{\sphinxupquote{ppconvert}} and \sphinxcode{\sphinxupquote{convert4qmc}}),
(qmc\sphinxhyphen{}extract\sphinxhyphen{}eshdf\sphinxhyphen{}kvectors) to postprocessing utilities (\sphinxcode{\sphinxupquote{trace\sphinxhyphen{}density}} and \sphinxcode{\sphinxupquote{qmcfinitesize}}) to many others.  In this section, we cover the use cases, syntax, and features of all additional tools provided with QMCPACK.


\section{Initialization}
\label{\detokenize{additional_tools:initialization}}

\subsection{qmc\sphinxhyphen{}get\sphinxhyphen{}supercell}
\label{\detokenize{additional_tools:qmc-get-supercell}}

\section{Postprocessing}
\label{\detokenize{additional_tools:postprocessing}}

\subsection{qmca}
\label{\detokenize{additional_tools:qmca}}
\sphinxcode{\sphinxupquote{qmca}} is a versatile tool to analyze and plot the raw data from QMCPACK \sphinxcode{\sphinxupquote{*.scalar.dat}} files.
It is a Python executable and part of the Nexus suite of tools.  It can be found in
\sphinxcode{\sphinxupquote{qmcpack/nexus/executables}}. For details, see {\hyperref[\detokenize{analyzing:qmca}]{\sphinxcrossref{\DUrole{std,std-ref}{Using the qmca tool to obtain total energies and related quantities}}}}.


\subsection{qmc\sphinxhyphen{}fit}
\label{\detokenize{additional_tools:qmc-fit}}
\sphinxcode{\sphinxupquote{qmc\sphinxhyphen{}fit}} is a curve fitting tool used to obtain statistical error bars on fitted parameters.
It is useful for DMC time step extrapolation.  For details, see {\hyperref[\detokenize{analyzing:qmcfit}]{\sphinxcrossref{\DUrole{std,std-ref}{Using the qmc\sphinxhyphen{}fit tool for statistical time step extrapolation and curve fitting}}}}.


\subsection{qdens}
\label{\detokenize{additional_tools:qdens}}
\sphinxcode{\sphinxupquote{qdens}} is a command line tool to produce density files from QMCPACK’s \sphinxcode{\sphinxupquote{stat.h5}} output files.  For details, see {\hyperref[\detokenize{analyzing:qdens}]{\sphinxcrossref{\DUrole{std,std-ref}{Using the qdens tool to obtain electron densities}}}}.


\subsection{qmcfinitesize}
\label{\detokenize{additional_tools:qmcfinitesize}}
\sphinxcode{\sphinxupquote{qmcfinitesize}} is a utility to compute many\sphinxhyphen{}body finite\sphinxhyphen{}size corrections to the energy.  It
is a C++ executable that is built alongside the QMCPACK executable.  It can be found in
\sphinxcode{\sphinxupquote{build/bin}}.


\section{Converters}
\label{\detokenize{additional_tools:converters}}

\subsection{convert4qmc}
\label{\detokenize{additional_tools:convert4qmc}}\label{\detokenize{additional_tools:id2}}
\sphinxcode{\sphinxupquote{Convert4qmc}} allows conversion of orbitals and wavefunctions from
quantum chemistry output files to QMCPACK XML and HDF5 input files.
It is a small C++ executable that is built alongside the QMCPACK
executable and can be found in \sphinxcode{\sphinxupquote{build/bin}}.

To date, \sphinxcode{\sphinxupquote{convert4qmc}} supports the following codes:
GAMESS \sphinxcite{intro_wavefunction:schmidt93}, PySCF \sphinxcite{additional_tools:sun2018}, QP \sphinxcite{sCI:qp}
and GAMESS\sphinxhyphen{}FMO \sphinxcite{additional_tools:fedorov2004}\sphinxcite{intro_wavefunction:schmidt93}.


\subsubsection{General use}
\label{\detokenize{additional_tools:general-use}}
General use of \sphinxcode{\sphinxupquote{convert4qmc}} can be prompted by running with no options:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{convert4qmc}

\PYG{n}{Defaults} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{n}{gridtype} \PYG{n}{log} \PYG{o}{\PYGZhy{}}\PYG{n}{first} \PYG{l+m+mf}{1e\PYGZhy{}6} \PYG{o}{\PYGZhy{}}\PYG{n}{last} \PYG{l+m+mi}{100} \PYG{o}{\PYGZhy{}}\PYG{n}{size} \PYG{l+m+mi}{1001} \PYG{o}{\PYGZhy{}}\PYG{n}{ci} \PYG{n}{required} \PYG{o}{\PYGZhy{}}\PYG{n}{threshold} \PYG{l+m+mf}{0.01} \PYG{o}{\PYGZhy{}}\PYG{n}{TargetState} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{n}{prefix} \PYG{n}{sample}

 \PYG{n}{convert} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{gaussian}\PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{n}{casino}\PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{n}{gamesxml}\PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{n}{gamess}\PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{n}{gamessFMO}\PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{n}{QP}\PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{n}{pyscf}\PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{n}{orbitals}\PYG{p}{]}
 \PYG{n}{filename}
\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{nojastrow} \PYG{o}{\PYGZhy{}}\PYG{n}{hdf5} \PYG{o}{\PYGZhy{}}\PYG{n}{prefix} \PYG{n}{title} \PYG{o}{\PYGZhy{}}\PYG{n}{addCusp} \PYG{o}{\PYGZhy{}}\PYG{n}{production} \PYG{o}{\PYGZhy{}}\PYG{n}{NbImages} \PYG{n}{NimageX} \PYG{n}{NimageY} \PYG{n}{NimageZ}\PYG{p}{]}
\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{psi\PYGZus{}tag} \PYG{n}{psi0} \PYG{o}{\PYGZhy{}}\PYG{n}{ion\PYGZus{}tag} \PYG{n}{ion0} \PYG{o}{\PYGZhy{}}\PYG{n}{gridtype} \PYG{n}{log}\PYG{o}{|}\PYG{n}{log0}\PYG{o}{|}\PYG{n}{linear} \PYG{o}{\PYGZhy{}}\PYG{n}{first} \PYG{n}{ri} \PYG{o}{\PYGZhy{}}\PYG{n}{last} \PYG{n}{rf}\PYG{p}{]}
\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{size} \PYG{n}{npts} \PYG{o}{\PYGZhy{}}\PYG{n}{ci} \PYG{n}{file}\PYG{o}{.}\PYG{n}{out} \PYG{o}{\PYGZhy{}}\PYG{n}{threshold} \PYG{n}{cimin} \PYG{o}{\PYGZhy{}}\PYG{n}{TargetState} \PYG{n}{state\PYGZus{}number}
\PYG{o}{\PYGZhy{}}\PYG{n}{NaturalOrbitals} \PYG{n}{NumToRead} \PYG{o}{\PYGZhy{}}\PYG{n}{optDetCoeffs}\PYG{p}{]}
\PYG{n}{Defaults} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{n}{gridtype} \PYG{n}{log} \PYG{o}{\PYGZhy{}}\PYG{n}{first} \PYG{l+m+mf}{1e\PYGZhy{}6} \PYG{o}{\PYGZhy{}}\PYG{n}{last} \PYG{l+m+mi}{100} \PYG{o}{\PYGZhy{}}\PYG{n}{size} \PYG{l+m+mi}{1001} \PYG{o}{\PYGZhy{}}\PYG{n}{ci} \PYG{n}{required}
\PYG{o}{\PYGZhy{}}\PYG{n}{threshold} \PYG{l+m+mf}{0.01} \PYG{o}{\PYGZhy{}}\PYG{n}{TargetState} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{n}{prefix} \PYG{n}{sample}
\PYG{n}{When} \PYG{n}{the} \PYG{n+nb}{input} \PYG{n+nb}{format} \PYG{o+ow}{is} \PYG{n}{missing}\PYG{p}{,} \PYG{n}{the}  \PYG{n}{extension} \PYG{n}{of} \PYG{n}{filename} \PYG{o+ow}{is} \PYG{n}{used} \PYG{n}{to} \PYG{n}{determine}
\PYG{n}{the} \PYG{n+nb}{format}
 \PYG{o}{*}\PYG{o}{.}\PYG{n}{Fchk} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gaussian}\PYG{p}{;} \PYG{o}{*}\PYG{o}{.}\PYG{n}{out} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gamess}\PYG{p}{;} \PYG{o}{*}\PYG{o}{.}\PYG{n}{data} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{casino}\PYG{p}{;} \PYG{o}{*}\PYG{o}{.}\PYG{n}{xml} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gamesxml}
\end{sphinxVerbatim}

As an example, to convert a GAMESS calculation using a single determinant, the following use is sufficient:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{convert4qmc} \PYG{o}{\PYGZhy{}}\PYG{n}{gamess} \PYG{n}{MyGamessOutput}\PYG{o}{.}\PYG{n}{out}
\end{sphinxVerbatim}

By default, the converter will generate multiple files:
\begin{quote}

\sphinxcode{\sphinxupquote{convert4qmc}} output:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{output}
&\sphinxstyletheadfamily 
\sphinxstylestrong{file type}
&\sphinxstyletheadfamily 
\sphinxstylestrong{default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{description}
\\
\hline
\sphinxcode{\sphinxupquote{*.qmc.in\sphinxhyphen{}wfs.xml}}
&
XML
&
default
&
Main input file for QMCPACK
\\
\hline
\sphinxcode{\sphinxupquote{*.qmc.in\sphinxhyphen{}wfnoj.xml}}
&
XML
&
default
&
Main input file for QMCPACK
\\
\hline
\sphinxcode{\sphinxupquote{*.structure.xml}}
&
XML
&
default
&
File containing the structure of the system
\\
\hline
\sphinxcode{\sphinxupquote{*.wfj.xml}}
&
XML
&
default
&
Wavefunction file with 1\sphinxhyphen{}, 2\sphinxhyphen{}, and 3\sphinxhyphen{}body Jastrows
\\
\hline
\sphinxcode{\sphinxupquote{*.wfnoj.xml}}
&
XML
&
default
&
Wavefunction file with no Jastrows
\\
\hline
\sphinxcode{\sphinxupquote{*.orbs.h5}}
&
HDF5
&
with \sphinxhyphen{}hdf5
&
HDF5 file containing all wavefunction data
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}
\end{quote}

If no \sphinxcode{\sphinxupquote{\sphinxhyphen{}prefix}} option is specified, the prefix is taken from
the input file name. For instance, if the GAMESS output file is
\sphinxcode{\sphinxupquote{Mysim}}.out, the files generated by \sphinxcode{\sphinxupquote{convert4qmc}} will use the
prefix \sphinxcode{\sphinxupquote{Mysim}} and output files will be
\sphinxcode{\sphinxupquote{Mysim.qmc.in\sphinxhyphen{}wfs.xml}}, \sphinxcode{\sphinxupquote{Mysim.structure.xml}}, and so on.
\begin{itemize}
\item {} 
Files \sphinxcode{\sphinxupquote{.in\sphinxhyphen{}wfs.xml}} and \sphinxcode{\sphinxupquote{.in\sphinxhyphen{}wfnoj.xml}}

These
are the input files for QMCPACK.  The geometry and the
wavefunction are stored in external files \sphinxcode{\sphinxupquote{*.structure.xml}}
and \sphinxcode{\sphinxupquote{*.wfj.xml}} (referenced from \sphinxcode{\sphinxupquote{*.in\sphinxhyphen{}wfs.xml}}) or
\sphinxcode{\sphinxupquote{*.qmc.wfnoj.xml}} (referenced from
\sphinxcode{\sphinxupquote{*.qmc.in\sphinxhyphen{}wfnoj.xml}}). The Hamiltonian section is included,
and the presence or lack of presence of an ECP is detected during the
conversion. If use of an ECP is detected, a default ECP name is
added (e.g., \sphinxcode{\sphinxupquote{H.qmcpp.xml}}), and it is the responsibility of
the user to modify the ECP name to match the one used to generate
the wavefunction.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYGZlt{}?xml version=\PYGZdq{}1.0\PYGZdq{}?\PYGZgt{}
\PYGZlt{}simulation\PYGZgt{}
  \PYGZlt{}!\PYGZhy{}\PYGZhy{}

Example QMCPACK input file produced by convert4qmc

It is recommend to start with only the initial VMC block and adjust
parameters based on the measured energies, variance, and statistics.

\PYGZhy{}\PYGZhy{}\PYGZgt{}
  \PYGZlt{}!\PYGZhy{}\PYGZhy{}Name and Series number of the project.\PYGZhy{}\PYGZhy{}\PYGZgt{}
  \PYGZlt{}project id=\PYGZdq{}gms\PYGZdq{} series=\PYGZdq{}0\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}!\PYGZhy{}\PYGZhy{}Link to the location of the Atomic Coordinates and the location of
      the Wavefunction.\PYGZhy{}\PYGZhy{}\PYGZgt{}
  \PYGZlt{}include href=\PYGZdq{}gms.structure.xml\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}include href=\PYGZdq{}gms.wfnoj.xml\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}!\PYGZhy{}\PYGZhy{}Hamiltonian of the system. Default ECP filenames are assumed.\PYGZhy{}\PYGZhy{}\PYGZgt{}
  \PYGZlt{}hamiltonian name=\PYGZdq{}h0\PYGZdq{} type=\PYGZdq{}generic\PYGZdq{} target=\PYGZdq{}e\PYGZdq{}\PYGZgt{}
    \PYGZlt{}pairpot name=\PYGZdq{}ElecElec\PYGZdq{} type=\PYGZdq{}coulomb\PYGZdq{} source=\PYGZdq{}e\PYGZdq{} target=\PYGZdq{}e\PYGZdq{}
                                                   physical=\PYGZdq{}true\PYGZdq{}/\PYGZgt{}
    \PYGZlt{}pairpot name=\PYGZdq{}IonIon\PYGZdq{} type=\PYGZdq{}coulomb\PYGZdq{} source=\PYGZdq{}ion0\PYGZdq{} target=\PYGZdq{}ion0\PYGZdq{}/\PYGZgt{}
    \PYGZlt{}pairpot name=\PYGZdq{}PseudoPot\PYGZdq{} type=\PYGZdq{}pseudo\PYGZdq{} source=\PYGZdq{}ion0\PYGZdq{} wavefunction=\PYGZdq{}psi0\PYGZdq{}
                                                           format=\PYGZdq{}xml\PYGZdq{}\PYGZgt{}
      \PYGZlt{}pseudo elementType=\PYGZdq{}H\PYGZdq{} href=\PYGZdq{}H.qmcpp.xml\PYGZdq{}/\PYGZgt{}
      \PYGZlt{}pseudo elementType=\PYGZdq{}Li\PYGZdq{} href=\PYGZdq{}Li.qmcpp.xml\PYGZdq{}/\PYGZgt{}
    \PYGZlt{}/pairpot\PYGZgt{}
  \PYGZlt{}/hamiltonian\PYGZgt{}

The ``qmc.in\PYGZhy{}wfnoj.xml`` file will have one VMC block with a
minimum number of blocks to reproduce the HF/DFT energy used to
generate the trial wavefunction.

::

    \PYGZlt{}qmc method=\PYGZdq{}vmc\PYGZdq{} move=\PYGZdq{}pbyp\PYGZdq{} checkpoint=\PYGZdq{}\PYGZhy{}1\PYGZdq{}\PYGZgt{}
      \PYGZlt{}estimator name=\PYGZdq{}LocalEnergy\PYGZdq{} hdf5=\PYGZdq{}no\PYGZdq{}/\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}warmupSteps\PYGZdq{}\PYGZgt{}100\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}blocks\PYGZdq{}\PYGZgt{}20\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}steps\PYGZdq{}\PYGZgt{}50\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}substeps\PYGZdq{}\PYGZgt{}8\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}timestep\PYGZdq{}\PYGZgt{}0.5\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}usedrift\PYGZdq{}\PYGZgt{}no\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}/qmc\PYGZgt{}
  \PYGZlt{}/simulation\PYGZgt{}
\end{sphinxVerbatim}

If the \sphinxcode{\sphinxupquote{qmc.in\sphinxhyphen{}wfj.xml}} file is used, Jastrow optimization
blocks followed by a VMC and DMC block are included. These blocks
contain default values to allow the user to test the accuracy of a
system; however, they need to be updated and optimized for each
system. The initial values might only be suitable for a small molecule.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYGZlt{}loop max=\PYGZdq{}4\PYGZdq{}\PYGZgt{}
    \PYGZlt{}qmc method=\PYGZdq{}linear\PYGZdq{} move=\PYGZdq{}pbyp\PYGZdq{} checkpoint=\PYGZdq{}\PYGZhy{}1\PYGZdq{}\PYGZgt{}
      \PYGZlt{}estimator name=\PYGZdq{}LocalEnergy\PYGZdq{} hdf5=\PYGZdq{}no\PYGZdq{}/\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}warmupSteps\PYGZdq{}\PYGZgt{}100\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}blocks\PYGZdq{}\PYGZgt{}20\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}timestep\PYGZdq{}\PYGZgt{}0.5\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}walkers\PYGZdq{}\PYGZgt{}1\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}samples\PYGZdq{}\PYGZgt{}16000\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}substeps\PYGZdq{}\PYGZgt{}4\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}usedrift\PYGZdq{}\PYGZgt{}no\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}MinMethod\PYGZdq{}\PYGZgt{}OneShiftOnly\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}minwalkers\PYGZdq{}\PYGZgt{}0.0001\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}/qmc\PYGZgt{}
  \PYGZlt{}/loop\PYGZgt{}
  \PYGZlt{}!\PYGZhy{}\PYGZhy{}

Example follow\PYGZhy{}up VMC optimization using more samples for greater accuracy:

\PYGZhy{}\PYGZhy{}\PYGZgt{}
  \PYGZlt{}loop max=\PYGZdq{}10\PYGZdq{}\PYGZgt{}
    \PYGZlt{}qmc method=\PYGZdq{}linear\PYGZdq{} move=\PYGZdq{}pbyp\PYGZdq{} checkpoint=\PYGZdq{}\PYGZhy{}1\PYGZdq{}\PYGZgt{}
      \PYGZlt{}estimator name=\PYGZdq{}LocalEnergy\PYGZdq{} hdf5=\PYGZdq{}no\PYGZdq{}/\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}warmupSteps\PYGZdq{}\PYGZgt{}100\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}blocks\PYGZdq{}\PYGZgt{}20\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}timestep\PYGZdq{}\PYGZgt{}0.5\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}walkers\PYGZdq{}\PYGZgt{}1\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}samples\PYGZdq{}\PYGZgt{}64000\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}substeps\PYGZdq{}\PYGZgt{}4\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}usedrift\PYGZdq{}\PYGZgt{}no\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}MinMethod\PYGZdq{}\PYGZgt{}OneShiftOnly\PYGZlt{}/parameter\PYGZgt{}
      \PYGZlt{}parameter name=\PYGZdq{}minwalkers\PYGZdq{}\PYGZgt{}0.3\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}/qmc\PYGZgt{}
  \PYGZlt{}/loop\PYGZgt{}
  \PYGZlt{}!\PYGZhy{}\PYGZhy{}

Production VMC and DMC:

Examine the results of the optimization before running these blocks.
For example, choose the best optimized jastrow from all obtained, put in the
wavefunction file, and do not reoptimize.

\PYGZhy{}\PYGZhy{}\PYGZgt{}
  \PYGZlt{}qmc method=\PYGZdq{}vmc\PYGZdq{} move=\PYGZdq{}pbyp\PYGZdq{} checkpoint=\PYGZdq{}\PYGZhy{}1\PYGZdq{}\PYGZgt{}
    \PYGZlt{}estimator name=\PYGZdq{}LocalEnergy\PYGZdq{} hdf5=\PYGZdq{}no\PYGZdq{}/\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}warmupSteps\PYGZdq{}\PYGZgt{}100\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}blocks\PYGZdq{}\PYGZgt{}200\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}steps\PYGZdq{}\PYGZgt{}50\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}substeps\PYGZdq{}\PYGZgt{}8\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}timestep\PYGZdq{}\PYGZgt{}0.5\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}usedrift\PYGZdq{}\PYGZgt{}no\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}!\PYGZhy{}\PYGZhy{}Sample count should match targetwalker count for
      DMC. Will be obtained from all nodes.\PYGZhy{}\PYGZhy{}\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}samples\PYGZdq{}\PYGZgt{}16000\PYGZlt{}/parameter\PYGZgt{}
  \PYGZlt{}/qmc\PYGZgt{}
  \PYGZlt{}qmc method=\PYGZdq{}dmc\PYGZdq{} move=\PYGZdq{}pbyp\PYGZdq{} checkpoint=\PYGZdq{}20\PYGZdq{}\PYGZgt{}
    \PYGZlt{}estimator name=\PYGZdq{}LocalEnergy\PYGZdq{} hdf5=\PYGZdq{}no\PYGZdq{}/\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}targetwalkers\PYGZdq{}\PYGZgt{}16000\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}reconfiguration\PYGZdq{}\PYGZgt{}no\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}warmupSteps\PYGZdq{}\PYGZgt{}100\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}timestep\PYGZdq{}\PYGZgt{}0.005\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}steps\PYGZdq{}\PYGZgt{}100\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}blocks\PYGZdq{}\PYGZgt{}100\PYGZlt{}/parameter\PYGZgt{}
    \PYGZlt{}parameter name=\PYGZdq{}nonlocalmoves\PYGZdq{}\PYGZgt{}yes\PYGZlt{}/parameter\PYGZgt{}
  \PYGZlt{}/qmc\PYGZgt{}
\PYGZlt{}/simulation\PYGZgt{}
\end{sphinxVerbatim}

\item {} 
File \sphinxcode{\sphinxupquote{.structure.xml}}

This file will be referenced from the main QMCPACK input. It contains the geometry of the system, position of the atoms, number of atoms, atomic types and charges, and number of electrons.

\item {} 
Files \sphinxcode{\sphinxupquote{.wfj.xml}} and \sphinxcode{\sphinxupquote{.wfnoj.xml}}

These files contain the basis set detail, orbital coefficients, and
the 1\sphinxhyphen{}, 2\sphinxhyphen{}, and 3\sphinxhyphen{}body Jastrow (in the case of \sphinxcode{\sphinxupquote{.wfj.xml}}). If the
wavefunction is multideterminant, the expansion will be at the end of
the file. We recommend using the option \sphinxcode{\sphinxupquote{\sphinxhyphen{}hdf5}} when large molecules
are studied to store the data more compactly in an HDF5 file.

\item {} 
File \sphinxcode{\sphinxupquote{.orbs.h5}}
This file is generated only if the option \sphinxcode{\sphinxupquote{\sphinxhyphen{}hdf5}} is added as
follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{convert4qmc} \PYG{o}{\PYGZhy{}}\PYG{n}{gamess} \PYG{n}{MyGamessOutput}\PYG{o}{.}\PYG{n}{out} \PYG{o}{\PYGZhy{}}\PYG{n}{hdf5}
\end{sphinxVerbatim}

In this case, the \sphinxcode{\sphinxupquote{.wfj.xml}} or \sphinxcode{\sphinxupquote{.wfnoj.xml}} files will point to
this HDF file. Information about the basis set, orbital coefficients,
and the multideterminant expansion is put in this file and removed from
the wavefunction files, making them smaller.

\end{itemize}

\sphinxcode{\sphinxupquote{convert4qmc}} input type:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{option name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{description}
&\sphinxstyletheadfamily \\
\hline
\sphinxcode{\sphinxupquote{orbitals}}
&
Generic HDF5 input file. Mainly automatically generated from QP and PySCF.
&
Actively maintained
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}pyscf}}
&
PySCF code
&
Actively maintained
\\
\hline
\sphinxcode{\sphinxupquote{QP}}
&
QP code
&
Actively maintained
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}gamess}}
&
Gamess code
&
Maintained
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}gamesFMO}}
&
Gamess FMO
&
Maintained
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}gaussian}}
&
Gaussian code
&
Obsolete/untested
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}casino}}
&
Casino code
&
Obsolete/untested
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}gamesxml}}
&
Gamess xml format code
&
Obsolete/untested
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\subsubsection{Command line options}
\label{\detokenize{additional_tools:command-line-options}}\begin{quote}

\sphinxcode{\sphinxupquote{convert4qmc}} command line options:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{4}{\X{1}{4}|}}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Option Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Value}
&\sphinxstyletheadfamily 
\sphinxstylestrong{default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{description}
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}nojastrow}}
&\begin{itemize}
\item {} 
\end{itemize}
&\begin{itemize}
\item {} 
\end{itemize}
&
Force no Jastrow. \sphinxcode{\sphinxupquote{qmc.in.wfj}} will not be generated
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}hdf5}}
&\begin{itemize}
\item {} 
\end{itemize}
&\begin{itemize}
\item {} 
\end{itemize}
&
Force the wf to be in HDF5 format
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}prefix}}
&
string
&\begin{itemize}
\item {} 
\end{itemize}
&
All created files will have the name of the string
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}multidet}}
&
string
&\begin{itemize}
\item {} 
\end{itemize}
&
HDF5 file containing a multideterminant expansion
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}addCusp}}
&\begin{itemize}
\item {} 
\end{itemize}
&\begin{itemize}
\item {} 
\end{itemize}
&
Force to add orbital cusp correction (ONLY for all\sphinxhyphen{}electron)
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}production}}
&\begin{itemize}
\item {} 
\end{itemize}
&\begin{itemize}
\item {} 
\end{itemize}
&
Generates specific blocks in the input
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}psi\_tag}}
&
string
&
psi0
&
Name of the electrons particles inside QMCPACK
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}ion\_tag}}
&
string
&
ion0
&
Name of the ion particles inside QMCPACK
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}
\end{quote}
\end{quote}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{\sphinxhyphen{}multidet}}

This option is to be used when a multideterminant expansion (mainly a CI expansion) is present in an HDF5 file. The trial wavefunction file will not display the full list of multideterminants and will add a path to the HDF5 file as follows (full example for the C2 molecule in qmcpack/tests/molecules/C2\_pp).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}?xml version=\PYGZdq{}1.0\PYGZdq{}?\PYGZgt{}
\PYGZlt{}qmcsystem\PYGZgt{}
  \PYGZlt{}wavefunction name=\PYGZdq{}psi0\PYGZdq{} target=\PYGZdq{}e\PYGZdq{}\PYGZgt{}
    \PYGZlt{}determinantset type=\PYGZdq{}MolecularOrbital\PYGZdq{} name=\PYGZdq{}LCAOBSet\PYGZdq{} source=\PYGZdq{}ion0\PYGZdq{} transform=\PYGZdq{}yes\PYGZdq{} href=\PYGZdq{}C2.h5\PYGZdq{}\PYGZgt{}
      \PYGZlt{}sposet basisset=\PYGZdq{}LCAOBSet\PYGZdq{} name=\PYGZdq{}spo\PYGZhy{}up\PYGZdq{} size=\PYGZdq{}58\PYGZdq{}\PYGZgt{}
        \PYGZlt{}occupation mode=\PYGZdq{}ground\PYGZdq{}/\PYGZgt{}
        \PYGZlt{}coefficient size=\PYGZdq{}58\PYGZdq{} spindataset=\PYGZdq{}0\PYGZdq{}/\PYGZgt{}
      \PYGZlt{}/sposet\PYGZgt{}
      \PYGZlt{}sposet basisset=\PYGZdq{}LCAOBSet\PYGZdq{} name=\PYGZdq{}spo\PYGZhy{}dn\PYGZdq{} size=\PYGZdq{}58\PYGZdq{}\PYGZgt{}
        \PYGZlt{}occupation mode=\PYGZdq{}ground\PYGZdq{}/\PYGZgt{}
        \PYGZlt{}coefficient size=\PYGZdq{}58\PYGZdq{} spindataset=\PYGZdq{}0\PYGZdq{}/\PYGZgt{}
      \PYGZlt{}/sposet\PYGZgt{}
      \PYGZlt{}multideterminant optimize=\PYGZdq{}no\PYGZdq{} spo\PYGZus{}up=\PYGZdq{}spo\PYGZhy{}up\PYGZdq{} spo\PYGZus{}dn=\PYGZdq{}spo\PYGZhy{}dn\PYGZdq{}\PYGZgt{}
        \PYGZlt{}detlist size=\PYGZdq{}202\PYGZdq{} type=\PYGZdq{}DETS\PYGZdq{} nca=\PYGZdq{}0\PYGZdq{} ncb=\PYGZdq{}0\PYGZdq{} nea=\PYGZdq{}4\PYGZdq{} neb=\PYGZdq{}4\PYGZdq{} nstates=\PYGZdq{}58\PYGZdq{} cutoff=\PYGZdq{}1e\PYGZhy{}20\PYGZdq{} href=\PYGZdq{}C2.h5\PYGZdq{}/\PYGZgt{}
      \PYGZlt{}/multideterminant\PYGZgt{}
    \PYGZlt{}/determinantset\PYGZgt{}
  \PYGZlt{}/wavefunction\PYGZgt{}
\PYGZlt{}/qmcsystem\PYGZgt{}
\end{sphinxVerbatim}

To generate such trial wavefunction, the converter has to be invoked as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}} \PYG{n}{convert4qmc} \PYG{o}{\PYGZhy{}}\PYG{n}{orbitals} \PYG{n}{C2}\PYG{o}{.}\PYG{n}{h5} \PYG{o}{\PYGZhy{}}\PYG{n}{multidet} \PYG{n}{C2}\PYG{o}{.}\PYG{n}{h5}
\end{sphinxVerbatim}

\item {} 
\sphinxcode{\sphinxupquote{\sphinxhyphen{}nojastrow}}

This option generates only an input file, \sphinxcode{\sphinxupquote{*.qmc.in.wfnoj.xml}}, containing no Jastrow optimization blocks and references a wavefunction file, \sphinxcode{\sphinxupquote{*.wfnoj.xml}}, containing no Jastrow section.

\item {} 
\sphinxcode{\sphinxupquote{\sphinxhyphen{}hdf5}}

This option generates the \sphinxcode{\sphinxupquote{*.orbs.h5}} HDF5 file containing the basis set and the orbital coefficients. If the wavefunction contains a multideterminant expansion from QP, it will also be stored in this file. This option minimizes the size of the \sphinxcode{\sphinxupquote{*.wfj.xml}} file, which points to the HDF file, as in the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYGZlt{}?xml version=\PYGZdq{}1.0\PYGZdq{}?\PYGZgt{}
\PYGZlt{}qmcsystem\PYGZgt{}
  \PYGZlt{}wavefunction name=\PYGZdq{}psi0\PYGZdq{} target=\PYGZdq{}e\PYGZdq{}\PYGZgt{}
    \PYGZlt{}determinantset type=\PYGZdq{}MolecularOrbital\PYGZdq{} name=\PYGZdq{}LCAOBSet\PYGZdq{} source=\PYGZdq{}ion0\PYGZdq{}
       transform=\PYGZdq{}yes\PYGZdq{} href=\PYGZdq{}test.orbs.h5\PYGZdq{}\PYGZgt{}
      \PYGZlt{}slaterdeterminant\PYGZgt{}
        \PYGZlt{}determinant id=\PYGZdq{}updet\PYGZdq{} size=\PYGZdq{}39\PYGZdq{}\PYGZgt{}
          \PYGZlt{}occupation mode=\PYGZdq{}ground\PYGZdq{}/\PYGZgt{}
          \PYGZlt{}coefficient size=\PYGZdq{}411\PYGZdq{} spindataset=\PYGZdq{}0\PYGZdq{}/\PYGZgt{}
        \PYGZlt{}/determinant\PYGZgt{}
        \PYGZlt{}determinant id=\PYGZdq{}downdet\PYGZdq{} size=\PYGZdq{}35\PYGZdq{}\PYGZgt{}
          \PYGZlt{}occupation mode=\PYGZdq{}ground\PYGZdq{}/\PYGZgt{}
          \PYGZlt{}coefficient size=\PYGZdq{}411\PYGZdq{} spindataset=\PYGZdq{}0\PYGZdq{}/\PYGZgt{}
        \PYGZlt{}/determinant\PYGZgt{}
      \PYGZlt{}/slaterdeterminant\PYGZgt{}
    \PYGZlt{}/determinantset\PYGZgt{}
  \PYGZlt{}/wavefunction\PYGZgt{}
\PYGZlt{}/qmcsystem\PYGZgt{}
\end{sphinxVerbatim}

Jastrow functions will be included if the option “\sphinxhyphen{}nojastrow” was
not specified. Note that when initially optimization a wavefunction, we recommend
temporarily removing/disabling the 3\sphinxhyphen{}body Jastrow.

\item {} 
\sphinxstylestrong{\sphinxhyphen{}prefix}

Sets the prefix for all output generated by \sphinxcode{\sphinxupquote{convert4qmc}}.
If not specified, \sphinxcode{\sphinxupquote{convert4qmc}} will use the defaults for the
following:
\begin{itemize}
\item {} 
\sphinxstylestrong{Gamess} If the Gamess output file is named “\sphinxstylestrong{Name}.out” or
“\sphinxstylestrong{Name}.output,” all files generated by \sphinxcode{\sphinxupquote{convert4qmc}} will carry
\sphinxstylestrong{Name} as a prefix (i.e., \sphinxstylestrong{Name}.qmc.in.xml).

\item {} 
\sphinxstylestrong{PySCF} If the PySCF output file is named “\sphinxstylestrong{Name}.H5,” all files
generated by \sphinxcode{\sphinxupquote{convert4qmc}} will carry \sphinxstylestrong{Name} as a prefix (i.e.,
\sphinxstylestrong{Name}.qmc.in.xml).

\item {} 
\sphinxstylestrong{QP} If the QP output file is named “\sphinxstylestrong{Name}.dump,” all files
generated by \sphinxcode{\sphinxupquote{convert4qmc}} will carry \sphinxstylestrong{Name} as a prefix (i.e.,
\sphinxstylestrong{Name}.qmc.in.xml).

\item {} 
\sphinxstylestrong{Generic HDF5 input} If a generic HDF5 file (either from PySCF or
QP in the HDF5 format) is named “\sphinxstylestrong{Name}.H5,” all files generated by
\sphinxcode{\sphinxupquote{convert4qmc}} will carry \sphinxstylestrong{Name} as a prefix (i.e.,
\sphinxstylestrong{Name}.qmc.in.xml).

\end{itemize}

\item {} 
\sphinxstylestrong{\sphinxhyphen{}addCusp}

This option is very important for all\sphinxhyphen{}electron (AE) calculations. In
this case, orbitals have to be corrected for the electron\sphinxhyphen{}nuclear
cusp. The cusp correction scheme follows the algorithm described by Ma
et al. \sphinxcite{additional_tools:ma2005} When this option is present, the
wavefunction file has a new set of tags:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qmcsystem}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{n}{wavefunction} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{psi0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{determinantset} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MolecularOrbital}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LCAOBSet}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}}
     \PYG{n}{transform}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{cuspCorrection}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{basisset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LCAOBSet}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

The tag “cuspCorrection” in the \sphinxcode{\sphinxupquote{wfj.xml}} (or \sphinxcode{\sphinxupquote{wfnoj.xml}})
wavefunction file will force correction of the orbitals at the
beginning of the run.
In the “orbitals“ section of the wavefunction file, a new tag
“cuspInfo” will be added for orbitals spin\sphinxhyphen{}up and orbitals spin\sphinxhyphen{}down:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{o}{\PYGZlt{}}\PYG{n}{slaterdeterminant}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{determinant} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{updet}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}
          \PYG{n}{cuspInfo}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{../CuspCorrection/updet.cuspInfo.xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{occupation} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ground}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{coefficient} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{135}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{updetC}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}

\PYG{o}{\PYGZlt{}}\PYG{n}{determinant} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{downdet}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}
         \PYG{n}{cuspInfo}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{../CuspCorrection/downdet.cuspInfo.xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{occupation} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ground}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{coefficient} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{135}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{downdetC}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

These tags will point to the files \sphinxcode{\sphinxupquote{updet.cuspInfo.xml}} and
\sphinxcode{\sphinxupquote{downdet.cuspInfo.xml}}. By default, the converter assumes that
the files are located in the relative path
\sphinxcode{\sphinxupquote{../CuspCorrection/}}. If the directory
\sphinxcode{\sphinxupquote{../CuspCorrection}} does not exist, or if the files are not
present in that directory, QMCPACK will run the cusp correction
algorithm to generate both files.  If the files exist, then QMCPACK
will apply the corrections to the orbitals.

\sphinxstylestrong{Important notes:}

The cusp correction implementations has been parallelized and performance improved.  However, since the correction needs
to be applied for every ion and then for every orbital on that ion, this operation can be costly (slow) for large
systems. We recommend saving and reusing the computed cusp correction files \sphinxcode{\sphinxupquote{updet.cuspInfo.xml}} and
\sphinxcode{\sphinxupquote{downdet.cuspInfo.xml}}, and transferring them between computer systems where relevant.

\item {} 
\sphinxstylestrong{\sphinxhyphen{}psi\_tag}

QMCPACK builds the wavefunction as a named object. In the vast majority of cases, one wavefunction is simulated at a time, but there may be situations where we want to distinguish different parts of a wavefunction, or even use multiple wavefunctions. This option can change the name for these cases.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{wavefunction} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{psi0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{\sphinxhyphen{}ion\_tag}

Although similar to \sphinxstylestrong{\sphinxhyphen{}psi\_tag}, this is used for the type of ions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{particleset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{\sphinxhyphen{}production}

Without this option, input files with standard optimization, VMC, and
DMC blocks are generated. When the “\sphinxhyphen{}production” option is
specified, an input file containing complex options that may be
more suitable for large runs at HPC centers is generated. This option
is for users who are already familiar with QMC and QMCPACK. We encourage feedback
on the standard and production sample inputs.

\end{itemize}

The following options are specific to using MCSCF multideterminants from Gamess.
\begin{quote}

\sphinxcode{\sphinxupquote{convert4qmc}} MCSCF arguments:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{4}{\X{1}{4}|}}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Option Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Value}
&\sphinxstyletheadfamily 
\sphinxstylestrong{default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{description}
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}ci}}
&
String
&
none
&
Name of the file containing the CI expansion
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}threshold}}
&
double
&
1e\sphinxhyphen{}20
&
Cutoff of the weight of the determinants
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}TargetState}}
&
int
&
none
&
?
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}NaturalOrbitals}}
&
int
&
none
&
?
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}optDetCoeffs}}
&\begin{itemize}
\item {} 
\end{itemize}
&
no
&
Enables the optimization of CI coefficients
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}
\end{quote}
\begin{itemize}
\item {} 
keyword \sphinxstylestrong{\sphinxhyphen{}ci} Path/name of the file containing the CI expansion in
a Gamess Format.

\item {} 
keyword \sphinxstylestrong{\sphinxhyphen{}threshold} The CI expansion contains coefficients
(weights) for each determinant. This option sets the maximum
coefficient to include in the QMC run. By default it is set to 1e\sphinxhyphen{}20
(meaning all determinants in an expansion are taken into account). At
the same time, if the threshold is set to a different value, for
example \(1e-5\), any determinant with a weight
\(|weight| < 1e-5\) will be discarded and the determinant will
not be considered.

\item {} 
keyword \sphinxstylestrong{\sphinxhyphen{}TargetState} ?

\item {} 
keyword \sphinxstylestrong{\sphinxhyphen{}NaturalOrbitals} ?

\item {} 
keyword \sphinxstylestrong{\sphinxhyphen{}optDetCoeffs} This flag enables optimization of the CI
expansion coefficients. By default, optimization of the coefficients
is disabled during wavefunction optimization runs.

\end{itemize}

Examples and more thorough descriptions of these options can be found in the lab section of this manual: {\hyperref[\detokenize{lab_advanced_molecules:lab-advanced-molecules}]{\sphinxcrossref{\DUrole{std,std-ref}{Lab 3: Advanced molecular calculations}}}}.


\subsubsection{Grid options}
\label{\detokenize{additional_tools:grid-options}}
These parameters control how the basis set is projected on a grid. The default parameters are chosen to be very efficient. Unless you have a very good reason, we do not recommend modifying them.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline

Tags
&&&\\
\hline
\sphinxstylestrong{keyword}
&
\sphinxstylestrong{Value}
&
\sphinxstylestrong{default}
&
\sphinxstylestrong{description}
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}gridtype}}
&
log|log0|linear
&
log
&
Grid type
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}first}}
&
double
&
1e\sphinxhyphen{}6
&
First point of the grid
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}last}}
&
double
&
100
&
Last point of the grid
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}size}}
&
int
&
1001
&
Number of point in the grid
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{itemize}
\item {} 
\sphinxstylestrong{\sphinxhyphen{}gridtype} Grid type can be logarithmic, logarithmic base 10, or
linear

\item {} 
\sphinxstylestrong{\sphinxhyphen{}first} First value of the grid

\item {} 
\sphinxstylestrong{\sphinxhyphen{}last} Last value of the grid

\item {} 
\sphinxstylestrong{\sphinxhyphen{}size} Number of points in the grid between “first” and “last.”

\end{itemize}


\subsubsection{Supported codes}
\label{\detokenize{additional_tools:supported-codes}}\begin{itemize}
\item {} 
\sphinxstylestrong{PySCF}

PySCF \sphinxcite{additional_tools:sun2018} is an all\sphinxhyphen{}purpose quantum chemistry
code that can run calculations from simple Hartree\sphinxhyphen{}Fock to DFT, MCSCF,
and CCSD, and for both isolated systems and periodic boundary
conditions. PySCF can be downloaded from \sphinxurl{https://github.com/sunqm/pyscf}.
Many examples and tutorials can be found on the PySCF website, and all
types of single determinants calculations are compatible with , thanks
to active support from the authors of PySCF. A few additional steps are
necessary to generate an output readable by \sphinxcode{\sphinxupquote{convert4qmc}}.

This example shows how to run a Hartree\sphinxhyphen{}Fock calculation for the \(LiH\)
dimer molecule from PySCF and convert the wavefunction for QMCPACK.
\begin{itemize}
\item {} 
\sphinxstylestrong{Python path}

PySCF is a Python\sphinxhyphen{}based code. A Python module named \sphinxstylestrong{PyscfToQmcpack}
containing the function \sphinxstylestrong{savetoqmcpack} is provided by and is located
at \sphinxcode{\sphinxupquote{qmcpack/src/QMCTools/PyscfToQmcpack.py}}. To be accessible to the
PySCF script, this path must be added to the PYTHONPATH environment
variable. For the bash shell, this can be done as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
export PYTHONPATH=/PATH\PYGZus{}TO\PYGZus{}QMCPACK/qmcpack/src/QMCTools:\PYGZbs{}\PYGZdl{}PYTHONPATH
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{PySCF Input File}

Copy and paste the following code in a file named LiH.py.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}! /usr/bin/env python3}
\PYG{k+kn}{from} \PYG{n+nn}{pyscf} \PYG{k+kn}{import} \PYG{n}{gto}\PYG{p}{,} \PYG{n}{scf}\PYG{p}{,} \PYG{n}{df}
\PYG{k+kn}{import} \PYG{n+nn}{numpy}

\PYG{n}{cell} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}
   \PYG{n}{atom} \PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{Li 0.0 0.0 0.0}
\PYG{l+s+s1}{H  0.0 0.0 3.0139239778}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{,}
   \PYG{n}{basis} \PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pv5z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
   \PYG{n}{unit}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bohr}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
   \PYG{n}{spin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}
   \PYG{n}{verbose} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,}
   \PYG{n}{cart}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}
\PYG{p}{)}
\PYG{n}{mf} \PYG{o}{=} \PYG{n}{scf}\PYG{o}{.}\PYG{n}{ROHF}\PYG{p}{(}\PYG{n}{cell}\PYG{p}{)}
\PYG{n}{mf}\PYG{o}{.}\PYG{n}{kernel}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}SPECIFIC TO QMCPACK\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{n}{title}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LiH}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k+kn}{from} \PYG{n+nn}{PyscfToQmcpack} \PYG{k+kn}{import} \PYG{n}{savetoqmcpack}

\PYG{n}{savetoqmcpack}\PYG{p}{(}\PYG{n}{cell}\PYG{p}{,}\PYG{n}{mf}\PYG{p}{,}\PYG{n}{title}\PYG{p}{)}
\end{sphinxVerbatim}

The arguments to the function \sphinxstylestrong{savetoqmcpack} are:
\begin{itemize}
\item {} 
\sphinxstylestrong{cell} This is the object returned from gto.M, containing the type
of atoms, geometry, basisset, spin, etc.

\item {} 
\sphinxstylestrong{mf} This is an object representing the PySCF level of theory, in
this example, ROHF. This object contains the orbital coefficients of
the calculations.

\item {} 
\sphinxstylestrong{title} The name of the output file generated by PySCF. By default,
the name of the generated file will be “default” if nothing is
specified.

\end{itemize}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

By adding the three lines below the “SPECIFIC TO QMCPACK” comment in the
input file, the script will dump all the necessary data for QMCPACK into
an HDF5 file using the value of “title” as an output name. PySCF is run
as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{python} \PYG{n}{LiH}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

The generated HDF5 can be read by \sphinxcode{\sphinxupquote{convert4qmc}} to generate the
appropriate QMCPACK input files.

\item {} 
\sphinxstylestrong{Generating input files}

As described in the previous section, generating input files for PySCF is as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}} \PYG{n}{convert4qmc} \PYG{o}{\PYGZhy{}}\PYG{n}{pyscf} \PYG{n}{LiH}\PYG{o}{.}\PYG{n}{h5}
\end{sphinxVerbatim}

The HDF5 file produced by “savetoqmcpack” contains the wavefunction in a
form directly readable by QMCPACK. The wavefunction files from
\sphinxcode{\sphinxupquote{convert4qmc}} reference this HDF file as if the “\sphinxhyphen{}hdf5” option were
specified (converting from PySCF implies the “\sphinxhyphen{}hdf5” option is always
present).

\end{itemize}

\end{itemize}

An implementation of periodic boundary conditions with Gaussian orbitals from PySCF is under development.
\begin{itemize}
\item {} 
\sphinxstylestrong{Quantum Package}

QP \sphinxcite{sCI:qp} is a quantum chemistry code developed by the
LCPQ laboratory in Toulouse, France. It can be downloaded from
\sphinxurl{https://github.com/LCPQ/quantum\_package}, and the tutorial within is
quite extensive. The tutorial section of QP can guide you on how to
install and run the code.

After a QP calculation, the data needed for \sphinxcode{\sphinxupquote{convert4qmc}} can be
generated through

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qp\PYGZus{}run} \PYG{n}{save\PYGZus{}for\PYGZus{}qmcpack} \PYG{n}{Myrun}\PYG{o}{.}\PYG{n}{ezfio} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZgt{}} \PYG{n}{Myrun}\PYG{o}{.}\PYG{n}{dump}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{convert4qmc}} can read this format and generate QMCPACK input files in XML and HDF5 format.  For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{convert4qmc} \PYG{o}{\PYGZhy{}}\PYG{n}{QP} \PYG{n}{Myrun}\PYG{o}{.}\PYG{n}{dump}
\end{sphinxVerbatim}

The main reason to use QP is to access the CIPSI algorithm to generate a
multideterminant wavefunction. CIPSI is the preferred choice for
generating a selected CI trial wavefunction for QMCPACK. An example on
how to use QP for Hartree\sphinxhyphen{}Fock and selected CI can be found in
{\hyperref[\detokenize{sCI:cipsi}]{\sphinxcrossref{\DUrole{std,std-ref}{CIPSI wavefunction interface}}}} of this manual. The converter code is actively
maintained and codeveloped by both QMCPACK and QP developers.

We recommend using a trial wavefunction stored in HDF5 format to reduce the reading time when a multideterminant expansion is too large (more than 1K determinants). This can be done with two paths:

using the \sphinxstyleemphasis{\sphinxhyphen{}hdf5} option in the converter as follows:

\item {} 
\sphinxstylestrong{Using \sphinxhyphen{}hdf5 tag}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{convert4qmc} \PYG{o}{\PYGZhy{}}\PYG{n}{QP} \PYG{n}{Myrun}\PYG{o}{.}\PYG{n}{dump} \PYG{o}{\PYGZhy{}}\PYG{n}{hdf5}
\end{sphinxVerbatim}

This will read the multideterminant expansion in the \sphinxcode{\sphinxupquote{Myrun.dump}} file
and store it in \sphinxcode{\sphinxupquote{Myrun.dump.orbs.h5}}. Note that this method will be
deprecated as QP automatically generates a compatible HDF5 file usable
by QMCPACK directly.

\item {} 
\sphinxstylestrong{Using h5 file}

QP version 2.0 (released in 2019) directly generates an HDF5 file that completely mimics the QMCPACK readable format. This file can be generated after a CIPSI, Hartree\sphinxhyphen{}Fock, or range\sphinxhyphen{}separated DFT in QP as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qp\PYGZus{}run} \PYG{n}{save\PYGZus{}for\PYGZus{}qmcpack} \PYG{n}{Myrun}\PYG{o}{.}\PYG{n}{ezfio} \PYG{o}{\PYGZgt{}} \PYG{n}{Myrun}\PYG{o}{.}\PYG{n}{dump}
\end{sphinxVerbatim}

In addition to \sphinxcode{\sphinxupquote{Myrun.dump}}, an HDF5 file always named \sphinxcode{\sphinxupquote{QMC.h5}} is
created containing all relevant information to start a QMC run. Input
files can be generated as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{convert4qmc} \PYG{o}{\PYGZhy{}}\PYG{n}{orbitals} \PYG{n}{QMC}\PYG{o}{.}\PYG{n}{h5} \PYG{o}{\PYGZhy{}}\PYG{n}{multidet} \PYG{n}{QMC}\PYG{o}{.}\PYG{n}{h5}
\end{sphinxVerbatim}

Note that the \sphinxcode{\sphinxupquote{QMC.h5}} combined with the tags \sphinxcode{\sphinxupquote{\sphinxhyphen{}orbitals}} and
\sphinxcode{\sphinxupquote{\sphinxhyphen{}multidet}} allows the user to choose orbitals from a different code
such as PYSCF and the multideterminant section from QP. These two codes
are fully compatible, and this route is also the only possible route for
multideterminants for solids.

\item {} 
\sphinxstylestrong{GAMESS}

QMCPACK can use the output of GAMESS \sphinxcite{intro_wavefunction:schmidt93} for any type of single determinant calculation (HF or DFT) or multideterminant (MCSCF) calculation. A description with an example can be found in the Advanced Molecular Calculations Lab ({\hyperref[\detokenize{lab_advanced_molecules:lab-advanced-molecules}]{\sphinxcrossref{\DUrole{std,std-ref}{Lab 3: Advanced molecular calculations}}}}).

\end{itemize}


\subsection{pw2qmcpack.x}
\label{\detokenize{additional_tools:pw2qmcpack-x}}\label{\detokenize{additional_tools:pw2qmcpack}}
\sphinxcode{\sphinxupquote{pw2qmcpack.x}} is an executable that converts PWSCF wavefunctions to QMCPACK readable
HDF5 format.  This utility is built alongside the QE postprocessing utilities.
This utility is written in Fortran90 and is distributed as a patch of the QE
source code.  The patch, as well as automated QE download and patch scripts, can be found in
\sphinxcode{\sphinxupquote{qmcpack/external\_codes/quantum\_espresso}}.

pw2qmcpack can be used in serial in small systems and should be used in parallel with large systems for best performance. The K\_POINT gamma optimization is not supported.
\sphinxSetupCaptionForVerbatim{Sample \sphinxcode{\sphinxupquote{pw2qmcpack.x}} input file \sphinxcode{\sphinxupquote{p2q.in}}}
\def\sphinxLiteralBlockLabel{\label{\detokenize{additional_tools:listing-66}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZam{}}\PYG{n}{inputpp}
  \PYG{n}{prefix}     \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bulk\PYGZus{}silicon}\PYG{l+s+s1}{\PYGZsq{}}
  \PYG{n}{outdir}     \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./}\PYG{l+s+s1}{\PYGZsq{}}
  \PYG{n}{write\PYGZus{}psir} \PYG{o}{=} \PYG{o}{.}\PYG{n}{false}\PYG{o}{.}
\PYG{o}{/}
\end{sphinxVerbatim}

This example will cause \sphinxcode{\sphinxupquote{pw2qmcpack.x}} to convert wavefunctions saved from
PWSCF with the prefix “bulk\_silicon.” Perform the conversion via, for
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{np} \PYG{l+m+mi}{1} \PYG{n}{pw2qmcpack}\PYG{o}{.}\PYG{n}{x} \PYG{o}{\PYGZlt{}} \PYG{n}{p2q}\PYG{o}{.}\PYG{o+ow}{in}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{p2q}\PYG{o}{.}\PYG{n}{out}
\end{sphinxVerbatim}

Because of the large plane\sphinxhyphen{}wave energy cutoffs in the pw.x calculation required by accurate PPs and the large system sizes of interest, one limitation of QE can be easily reached:
that \sphinxcode{\sphinxupquote{wf\_collect=.true.}} results in problems of writing and loading correct plane\sphinxhyphen{}wave coefficients on disks by pw.x because of the 32 bit integer limits. Thus, \sphinxcode{\sphinxupquote{pw2qmcpack.x}} fails to convert the orbitals for QMCPACK. Since the release of QE v5.3.0, the converter has been fully parallelized to overcome this limitation completely.

By setting \sphinxcode{\sphinxupquote{wf\_collect=.false.}} (by default \sphinxcode{\sphinxupquote{.false.}} in v6.1 and before and \sphinxcode{\sphinxupquote{.true.}} since v6.2), pw.x does not collect the whole wavefunction into individual files for each k\sphinxhyphen{}point but instead writes one smaller file for each processor.
By running \sphinxcode{\sphinxupquote{pw2qmcpack.x}} in the same parallel setup (MPI tasks and k\sphinxhyphen{}pools) as the last scf/nscf calculation with pw.x,
the orbitals distributed among processors will first be aggregated by the converter into individual temporal HDF5 files for each k\sphinxhyphen{}pool and then merged into the final file.
In large calculations, users should benefit from a significant reduction of time in writing the wavefunction by pw.x thanks to avoiding the wavefunction collection.

pw2qmcpack has been included in the test suite of QMCPACK (see instructions about how to activate the tests in {\hyperref[\detokenize{installation:buildqe}]{\sphinxcrossref{\DUrole{std,std-ref}{Installing and patching Quantum ESPRESSO}}}}).
There are tests labeled “no\sphinxhyphen{}collect” running the pw.x with the setting \sphinxcode{\sphinxupquote{wf\_collect=.false.}}
The input files are stored at \sphinxcode{\sphinxupquote{examples/solids/dft\sphinxhyphen{}inputs\sphinxhyphen{}polarized\sphinxhyphen{}no\sphinxhyphen{}collect}}.
The scf, nscf, and pw2qmcpack runs are performed on 16, 12, and 12 MPI tasks with 16, 2, and 2 k\sphinxhyphen{}pools respectively.


\subsection{convertpw4qmc}
\label{\detokenize{additional_tools:convertpw4qmc}}
Convertpw4qmc is an executable that reads xml from a plane wave based DFT code and produces a QMCPACK readable
HDF5 format wavefunction.  For the moment, this supports both QBox and Quantum Epresso

In order to save the wavefunction from QBox so that convertpw4qmc can work on it, one needs to add a line to the
QBox input like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{save} \PYG{o}{\PYGZhy{}}\PYG{n}{text} \PYG{o}{\PYGZhy{}}\PYG{n}{serial} \PYG{n}{basename}\PYG{o}{.}\PYG{n}{sample}
\end{sphinxVerbatim}

after the end of a converged dft calculation.  This will write an ascii wavefunction file and will avoid
QBox’s optimized parallel IO (which is not currently supported).

After the wavefunction file is written (basename.sample in this case) one can use convertpw4qmc as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{convertpw4qmc} \PYG{n}{basename}\PYG{o}{.}\PYG{n}{sample} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{qmcpackWavefunction}\PYG{o}{.}\PYG{n}{h5}
\end{sphinxVerbatim}

This reads the Qbox wavefunction and performs the Fourier transform before saving to a QMCPACK eshdf format wavefunction.  Currently multiple k\sphinxhyphen{}points are supported, but due to difficulties with the qbox wavefunction file format, the single particle orbitals do not have their proper energies associated with them.  This means that when tiling from a primitive cell to a supercell, the lowest n single particle orbitals from all necessary k\sphinxhyphen{}points will be used.  This can be problematic in the case of a metal and this feature should be used with EXTREME caution.

In the case of quantum espresso, QE must be compiled with HDF support.  If this is the case, then an eshdf file can be generated by targeting the data\sphinxhyphen{}file\sphinxhyphen{}schema.xml file
generated in the output of quantum espresso.  For example, if one is running a calculation with outdir = ‘out’ and prefix=’Pt’ then the converter can be invoked as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{convertpw4qmc} \PYG{n}{out}\PYG{o}{/}\PYG{n}{Pt}\PYG{o}{.}\PYG{n}{save}\PYG{o}{/}\PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{n}{file}\PYG{o}{\PYGZhy{}}\PYG{n}{schema}\PYG{o}{.}\PYG{n}{xml} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{qmcpackWavefunction}\PYG{o}{.}\PYG{n}{h5}
\end{sphinxVerbatim}

Note that this method is insensitive to parallelization options given to quantum espresso.  Additionally, it supports noncollinear magnetism and can be used to generate
wavefunctions suitable for qmcpack calculations with spin\sphinxhyphen{}orbit coupling.


\subsection{ppconvert}
\label{\detokenize{additional_tools:ppconvert}}\label{\detokenize{additional_tools:id12}}
\sphinxcode{\sphinxupquote{ppconvert}} is a utility to convert PPs between different commonly used formats.
It is a stand\sphinxhyphen{}alone C++ executable that is not built by default but that is accessible via adding
\sphinxcode{\sphinxupquote{\sphinxhyphen{}DBUILD\_PPCONVERT=1}} to CMake and then typing \sphinxcode{\sphinxupquote{make ppconvert}}.
Currently it converts CASINO, FHI, UPF (generated by OPIUM), BFD, and GAMESS formats to several other formats
including XML (QMCPACK) and UPF (QE). See all the formats via \sphinxcode{\sphinxupquote{ppconvert \sphinxhyphen{}h}}.
For output formats requiring Kleinman\sphinxhyphen{}Bylander projectors, the atom will be solved with DFT
if the projectors are not provided in the input formats.

This requires providing reference states and sometimes needs extra tuning for heavy elements.
To avoid ghost states, the local channel can be changed via the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}local\_channel}} option. Ghost state considerations are similar to those of DFT calculations but could be worse if ghost states were not considered during the original PP construction.
To make the self\sphinxhyphen{}consistent calculation converge, the density mixing parameter may need to be reduced
via the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}density\_mix}} option.
Note that the reference state should include only the valence electrons.
One reference state should be included for each channel in the PP.

For example, for a sodium atom with a neon core, the reference state would be “1s(1).”
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}s\_ref}} needs to include a 1s state, \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}p\_ref}} needs to include a 2p state,
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}d\_ref}} needs to include a 3d state, etc. If not specified, a corresponding state with zero occupation is added.
If the reference state is chosen as the neon core, setting empty reference states “” is technically correct.
In practice, reasonable reference states should be picked with care.
For PP with semi\sphinxhyphen{}core electrons in the valence, the reference state can be long.
For example, Ti PP has 12 valence electrons. When using the neutral atom state,
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}s\_ref}}, \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}p\_ref}}, and \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}d\_ref}} are all set as “1s(2)2p(6)2s(2)3d(2).”
When using an ionized state, the three reference states are all set as “1s(2)2p(6)2s(2)” or “1s(2)2p(6)2s(2)3d(0).”

Unfortunately, if the generated UPF file is used in QE, the calculation may be incorrect because of the presence of “ghost” states. Potentially these can be removed by adjusting the local channel (e.g., by setting \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}local\_channel 1}}, which chooses the p channel as the local channel instead of d.
For this reason, validation of UPF PPs is always required from the third row and is strongly encouraged in general. For example, check that the expected ionization potential and electron affinities are obtained for the atom and that dimer properties are consistent with those obtained by a quantum chemistry code or a plane\sphinxhyphen{}wave code that does not use the Kleinman\sphinxhyphen{}Bylander projectors.


\section{Obtaining pseudopotentials}
\label{\detokenize{additional_tools:obtaining-pseudopotentials}}

\subsection{Pseudopotentiallibrary.org}
\label{\detokenize{additional_tools:pseudopotentiallibrary-org}}
An open website collecting community developed and tested
pseudopotentials for QMC and other many\sphinxhyphen{}body calculations is being
developed at \sphinxurl{https://pseudopotentiallibrary.org}. This site
includes potentials in QMCPACK format and an increasing range of
electronic structure and quantum chemistry codes. We recommend using
potentials from this site if available and suitable for your science
application.


\subsection{Opium}
\label{\detokenize{additional_tools:opium}}\label{\detokenize{additional_tools:id13}}
Opium is a pseudopotential generation code available from the website \sphinxurl{http://opium.sourceforge.net/}.  Opium can generate pseudopotentials with either Hartree\sphinxhyphen{}Fock or DFT methods.  Once you have a useable pseudopotential param file (for example, Li.param), generate pseudopotentials for use in Quantum ESPRESSO with the upf format as follows:

This generates a UPF\sphinxhyphen{}formatted pseudopotential (\sphinxcode{\sphinxupquote{Li.upf}}, in this case) for use in Quantum ESPRESSO.  The pseudopotential conversion tool \sphinxcode{\sphinxupquote{ppconvert}} can then convert UPF to FSAtom xml format for use in QMCPACK:
\sphinxSetupCaptionForVerbatim{Convert UPF\sphinxhyphen{}formatted pseudopotential to FSAtom xml format}
\def\sphinxLiteralBlockLabel{\label{\detokenize{additional_tools:listing-68}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ppconvert} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{upf\PYGZus{}pot} \PYG{n}{Li}\PYG{o}{.}\PYG{n}{upf} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{xml} \PYG{n}{Li}\PYG{o}{.}\PYG{n}{xml}
\end{sphinxVerbatim}


\subsection{Burkatzki\sphinxhyphen{}Filippi\sphinxhyphen{}Dolg}
\label{\detokenize{additional_tools:burkatzki-filippi-dolg}}\label{\detokenize{additional_tools:bfd}}
Burkatzki \sphinxstyleemphasis{et al.} developed a set of energy\sphinxhyphen{}consistent pseudopotenitals
for use in QMC \sphinxcite{additional_tools:burkatzki07}\sphinxcite{additional_tools:burkatzki08}, available at
\sphinxurl{http://www.burkatzki.com/pseudos/index.2.html}. To convert for use in
QMCPACK, select a pseudopotential (choice of basis set is irrelevant to
conversion) in GAMESS format and copy the ending (pseudopotential) lines
beginning with(element symbol)\sphinxhyphen{}QMC GEN:
\sphinxSetupCaptionForVerbatim{BFD Li pseudopotential in GAMESS format}
\def\sphinxLiteralBlockLabel{\label{\detokenize{additional_tools:listing-69}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Li}\PYG{o}{\PYGZhy{}}\PYG{n}{QMC} \PYG{n}{GEN} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{3}
\PYG{l+m+mf}{1.00000000} \PYG{l+m+mi}{1} \PYG{l+m+mf}{5.41040609}
\PYG{l+m+mf}{5.41040609} \PYG{l+m+mi}{3} \PYG{l+m+mf}{2.70520138}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.60151975} \PYG{l+m+mi}{2} \PYG{l+m+mf}{2.07005488}
\PYG{l+m+mi}{1}
\PYG{l+m+mf}{7.09172172} \PYG{l+m+mi}{2} \PYG{l+m+mf}{1.34319829}
\end{sphinxVerbatim}

Save these lines to a file (here, named \sphinxcode{\sphinxupquote{Li.BFD.gamess}}; the exact name may be anything as long as it is passed to \sphinxcode{\sphinxupquote{ppconvert}} after \textendash{}gamess\_pot).  Then, convert using \sphinxcode{\sphinxupquote{ppconvert}} with the following:
\sphinxSetupCaptionForVerbatim{Convert GAMESS\sphinxhyphen{}formatted pseudopotential to FSAtom xml format}
\def\sphinxLiteralBlockLabel{\label{\detokenize{additional_tools:listing-70}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ppconvert} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{gamess\PYGZus{}pot} \PYG{n}{Li}\PYG{o}{.}\PYG{n}{BFD}\PYG{o}{.}\PYG{n}{gamess} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{s\PYGZus{}ref} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2s(1)}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{p\PYGZus{}ref} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2p(0)}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{xml} \PYG{n}{Li}\PYG{o}{.}\PYG{n}{BFD}\PYG{o}{.}\PYG{n}{xml}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{Convert GAMESS\sphinxhyphen{}formatted pseudopotential to Quantum ESPRESSO UPF format}
\def\sphinxLiteralBlockLabel{\label{\detokenize{additional_tools:listing-71}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ppconvert} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{gamess\PYGZus{}pot} \PYG{n}{Li}\PYG{o}{.}\PYG{n}{BFD}\PYG{o}{.}\PYG{n}{gamess} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{s\PYGZus{}ref} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2s(1)}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{p\PYGZus{}ref} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2p(0)}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{log\PYGZus{}grid} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{upf} \PYG{n}{Li}\PYG{o}{.}\PYG{n}{BFD}\PYG{o}{.}\PYG{n}{upf}
\end{sphinxVerbatim}


\subsection{CASINO}
\label{\detokenize{additional_tools:casino}}\label{\detokenize{additional_tools:id16}}
The QMC code CASINO also makes available its pseudopotentials available at the website \sphinxurl{https://vallico.net/casinoqmc/pplib/}. To use one in QMCPACK, select a pseudopotential and download its summary file (\sphinxcode{\sphinxupquote{summary.txt}}), its tabulated form (\sphinxcode{\sphinxupquote{pp.data}}), and (for ppconvert to construct the projectors to convert to Quantum ESPRESSO’s UPF format) a CASINO atomic wavefunction for each angular momentum channel (\sphinxcode{\sphinxupquote{awfn.data\_*}}).  Then, to convert using ppconvert, issue the following command:
\sphinxSetupCaptionForVerbatim{Convert CASINO\sphinxhyphen{}formatted pseudopotential to Quantum ESPRESSO UPF format}
\def\sphinxLiteralBlockLabel{\label{\detokenize{additional_tools:listing-72}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ppconvert} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{casino\PYGZus{}pot} \PYG{n}{pp}\PYG{o}{.}\PYG{n}{data} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{casino\PYGZus{}us} \PYG{n}{awfn}\PYG{o}{.}\PYG{n}{data\PYGZus{}s1\PYGZus{}2S} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{casino\PYGZus{}up} \PYG{n}{awfn}\PYG{o}{.}\PYG{n}{data\PYGZus{}p1\PYGZus{}2P} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{casino\PYGZus{}ud} \PYG{n}{awfn}\PYG{o}{.}\PYG{n}{data\PYGZus{}d1\PYGZus{}2D} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{upf} \PYG{n}{Li}\PYG{o}{.}\PYG{n}{TN}\PYG{o}{\PYGZhy{}}\PYG{n}{DF}\PYG{o}{.}\PYG{n}{upf}
\end{sphinxVerbatim}

QMCPACK can directly read in the CASINO\sphinxhyphen{}formated pseudopotential (\sphinxcode{\sphinxupquote{pp.data}}), but four parameters found in the pseudopotential summary file must be specified in the pseudo element (\sphinxcode{\sphinxupquote{l\sphinxhyphen{}local}}, \sphinxcode{\sphinxupquote{lmax}}, \sphinxcode{\sphinxupquote{nrule}}, \sphinxcode{\sphinxupquote{cutoff}}){[}see {\hyperref[\detokenize{hamiltonianobservable:nlpp}]{\sphinxcrossref{\DUrole{std,std-ref}{Pseudopotentials}}}} for details{]}:
\sphinxSetupCaptionForVerbatim{XML syntax to use CASINO\sphinxhyphen{}formatted pseudopotentials in QMCPACK}
\def\sphinxLiteralBlockLabel{\label{\detokenize{additional_tools:listing-73}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pseudo}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PseudoPot}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{wavefunction}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{psi0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{pseudo} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Li}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Li.pp.data}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{casino}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{l}\PYG{o}{\PYGZhy{}}\PYG{n}{local}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{s}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{lmax}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{nrule}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{cutoff}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2.19}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{pseudo} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H.pp.data}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{casino}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{l}\PYG{o}{\PYGZhy{}}\PYG{n}{local}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{s}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{lmax}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{nrule}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{cutoff}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{pairpot}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{wftester}
\label{\detokenize{additional_tools:wftester}}\label{\detokenize{additional_tools:id17}}
While not really a stand\sphinxhyphen{}alone application, wftester (short for “Wave
Function Tester”) is a helpful tool for testing pre\sphinxhyphen{}existing and
experimental estimators and observables. It provides the user with
derived quantities from the Hamiltonian and wave function, but evaluated
at a small set of configurations.

The wftester is implemented as a QMCDriver, so one invokes QMCPACK in
the normal manner with a correct input XML, the difference being the
addition of an additional qmc input block. This is the main advantage of
this tool\textendash{}it allows testing of realistic systems and realistic
combinations of observables. It can also be invoked before launching
into optimization, VMC, or DMC runs, as it is a valid \textless{}qmc\textgreater{} block.

As an example, the following code generates a random walker configuration and compares the trial wave function ratio computed in two different ways:
\sphinxSetupCaptionForVerbatim{The following executes the wavefunction ratio test in “wftester”}
\def\sphinxLiteralBlockLabel{\label{\detokenize{additional_tools:listing-74}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{wftester}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ratio}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}    \PYG{n}{yes}    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Here’s a summary of some of the tests provided:
\begin{itemize}
\item {} 
Ratio Test. Invoked with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ratio}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{yes}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

This computes the implemented wave function ratio associated with a
single\sphinxhyphen{}particle move using two different methods.

\item {} 
Clone Test. Invoked with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{clone}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{yes}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

This checks the cloning of TrialWaveFunction, ParticleSet,
Hamiltonian, and Walkers.

\item {} 
Elocal Test. Invoked with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{printEloc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{yes}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

For an input electron configuration (can be random), print the value
of TrialWaveFunction, LocalEnergy, and all local observables for this
configuration.

\item {} 
Derivative Test. Invoked with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ratio}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{deriv}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Computes electron gradients, laplacians, and wave function parameter
derivatives using implemented calls and compares them to
finite\sphinxhyphen{}difference results.

\item {} 
Ion Gradient Test. Invoked with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{source}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ion0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Calls the implemented evaluateGradSource functions and compares them
against finite\sphinxhyphen{}difference results.

\item {} 
“Basic Test”. Invoked with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{basic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{yes}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Performs ratio, gradient, and laplacian tests against
finite\sphinxhyphen{}difference and direct computation of wave function values.

\end{itemize}

The output of the various tests will be to standard out or “wftest.000” after successful execution of qmcpack.




\chapter{External Tools}
\label{\detokenize{external_tools:external-tools}}\label{\detokenize{external_tools:id1}}\label{\detokenize{external_tools::doc}}
This chapter provides some information on using QMCPACK with external tools.


\section{LLVM Sanitizer Libraries}
\label{\detokenize{external_tools:llvm-sanitizer-libraries}}\label{\detokenize{external_tools:id2}}
Using CMake, set one of these flags for using the clang sanitizer libraries with or without lldb.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}}\PYG{n}{DLLVM\PYGZus{}SANITIZE\PYGZus{}ADDRESS}    \PYG{n}{link} \PYG{k}{with} \PYG{n}{the} \PYG{n}{Clang} \PYG{n}{address} \PYG{n}{sanitizer} \PYG{n}{library}
\PYG{o}{\PYGZhy{}}\PYG{n}{DLLVM\PYGZus{}SANITIZE\PYGZus{}MEMORY}     \PYG{n}{link} \PYG{k}{with} \PYG{n}{the} \PYG{n}{Clang} \PYG{n}{memory} \PYG{n}{sanitizer} \PYG{n}{library}
\end{sphinxVerbatim}

These set the basic flags required to build with either of these sanitizer libraries. They require a build of clang with dynamic libraries somehow visible (i.e., through \sphinxcode{\sphinxupquote{LD\_FLAGS=\sphinxhyphen{}L/your/path/to/llvm/lib}}). You must link through clang, which is generally the default when building with it. Depending on your system and linker, this may be incompatible with the “Release” build, so set \sphinxcode{\sphinxupquote{\sphinxhyphen{}DCMAKE\_BUILD\_TYPE=Debug}}. They have been tested with the default spack install of \sphinxhref{mailto:llvm@7.0.0}{llvm@7.0.0} and been manually built with llvm 7.0.1. See the following links for additional information on use, run time, and build options of the sanitizers: \sphinxurl{https://clang.llvm.org/docs/AddressSanitizer.html} \& \sphinxurl{https://clang.llvm.org/docs/MemorySanitizer.html}.

In general, the address sanitizer libraries will catch most pointer\sphinxhyphen{}based errors. ASAN can also catch memory links but requires that additional options be set. MSAN will catch more subtle memory management errors but is difficult to use without a full set of MSAN\sphinxhyphen{}instrumented libraries.


\section{Intel VTune}
\label{\detokenize{external_tools:intel-vtune}}
Intel’s VTune profiler has an API that allows program control over collection (pause/resume) and can add information to the profile data (e.g., delineating tasks).


\subsection{VTune API}
\label{\detokenize{external_tools:vtune-api}}
If the variable \sphinxcode{\sphinxupquote{USE\_VTUNE\_API}} is set, QMCPACK will check that the
include file (\sphinxcode{\sphinxupquote{ittnotify.h}}) and the library (\sphinxcode{\sphinxupquote{libittnotify.a}}) can
be found.
To provide CMake with the VTune paths, add the include path to \sphinxcode{\sphinxupquote{CMAKE\_CXX\_FLAGS}} and the library path to \sphinxcode{\sphinxupquote{CMAKE\_LIBRARY\_PATH}}.

An example of options to be passed to CMake:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}CXX\PYGZus{}FLAGS}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{I}\PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{n}{vtune\PYGZus{}amplifier\PYGZus{}xe}\PYG{o}{/}\PYG{n}{include} \PYGZbs{}
\PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}LIBRARY\PYGZus{}PATH}\PYG{o}{=}\PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{n}{vtune\PYGZus{}amplifier\PYGZus{}xe}\PYG{o}{/}\PYG{n}{lib64}
\end{sphinxVerbatim}


\section{NVIDIA Tools Extensions}
\label{\detokenize{external_tools:nvidia-tools-extensions}}
NVIDIA’s Tools Extensions (NVTX) API enables programmers to annotate their source code when used with the NVIDIA profilers.


\subsection{NVTX API}
\label{\detokenize{external_tools:nvtx-api}}
If the variable \sphinxcode{\sphinxupquote{USE\_NVTX\_API}} is set, QMCPACK will add the library (\sphinxcode{\sphinxupquote{libnvToolsExt.so}}) to the QMCPACK target. To add NVTX annotations
to a function, it is necessary to include the \sphinxcode{\sphinxupquote{nvToolsExt.h}} header file and then make the appropriate calls into the NVTX API. For more information
about the NVTX API, see \sphinxurl{https://docs.nvidia.com/cuda/profiler-users-guide/index.html\#nvtx}. Any additional calls to the NVTX API should be guarded by
the \sphinxcode{\sphinxupquote{USE\_NVTX\_API}} compiler define.


\subsection{Timers as Tasks}
\label{\detokenize{external_tools:timers-as-tasks}}
To aid in connecting the timers in the code to the profile data, the start/stop of
timers will be recorded as a task if \sphinxcode{\sphinxupquote{USE\_VTUNE\_TASKS}} is set.

In addition to compiling with \sphinxcode{\sphinxupquote{USE\_VTUNE\_TASKS}}, an option needs to be set at run time to collect the task API data.
In the graphical user interface (GUI), select the checkbox labeled “Analyze user tasks” when setting up the analysis type.
For the command line, set the \sphinxcode{\sphinxupquote{enable\sphinxhyphen{}user\sphinxhyphen{}tasks}} knob to \sphinxcode{\sphinxupquote{true}}. For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{amplxe}\PYG{o}{\PYGZhy{}}\PYG{n}{cl} \PYG{o}{\PYGZhy{}}\PYG{n}{collect} \PYG{n}{hotspots} \PYG{o}{\PYGZhy{}}\PYG{n}{knob} \PYG{n}{enable}\PYG{o}{\PYGZhy{}}\PYG{n}{user}\PYG{o}{\PYGZhy{}}\PYG{n}{tasks}\PYG{o}{=}\PYG{n}{true} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

Collection with the timers set at “fine” can generate too much task data in the profile.
Collection with the timers at “medium” collects a more reasonable amount of task data.


\section{Scitools Understand}
\label{\detokenize{external_tools:scitools-understand}}
Scitools Understand (\sphinxurl{https://scitools.com/}) is a tool for static
code analysis. The easiest configuration route is to use the JSON output
from CMake, which the Understand project importer can read directly:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Configure QMCPACK by running CMake with \sphinxcode{\sphinxupquote{CMAKE\_EXPORT\_COMPILE\_COMMANDS=ON}}, for example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}C\PYGZus{}COMPILER}\PYG{o}{=}\PYG{n}{clang} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}CXX\PYGZus{}COMPILER}\PYG{o}{=}\PYG{n}{clang}\PYG{o}{+}\PYG{o}{+}
\PYG{o}{\PYGZhy{}}\PYG{n}{DQMC\PYGZus{}MPI}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}EXPORT\PYGZus{}COMPILE\PYGZus{}COMMANDS}\PYG{o}{=}\PYG{n}{ON} \PYG{o}{.}\PYG{o}{.}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{/}
\end{sphinxVerbatim}

\item {} 
Run Understand and create a new C++ project. At the import files
and settings dialog, import the texttt\{compile\_commands.json\} created by
CMake in the build directory.

\end{enumerate}


\chapter{Contributing to the Manual}
\label{\detokenize{contributing:contributing-to-the-manual}}\label{\detokenize{contributing:contrib}}\label{\detokenize{contributing::doc}}
This section briefly describes how to contribute to the manual and is primarily “by developers, for developers.”   This section should iterate until a consistent view on style/contents is reached.

\sphinxstylestrong{Desirable:}
\begin{itemize}
\item {} 
Use the following table templates when describing XML input.

\item {} 
Instead of \sphinxcode{\sphinxupquote{\textbackslash{}texttt}} or \sphinxcode{\sphinxupquote{\textbackslash{}verb}} use
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{\textbackslash{}ishell}} for shell text

\item {} 
\sphinxcode{\sphinxupquote{\textbackslash{}ixml}} for xml text

\item {} 
\sphinxcode{\sphinxupquote{\textbackslash{}icode}} for C++ text

\end{itemize}

\sphinxstylestrong{Except within tabularx or math environments}

\item {} 
Instead of \sphinxcode{\sphinxupquote{\textbackslash{}begin\{verbatim\}}} environments, use the appropriate \sphinxcode{\sphinxupquote{\textbackslash{}begin\{lstlisting\}{[}style=\textless{}see qmcpack\_listings.sty\textgreater{}{]}}}.

\item {} 
\sphinxcode{\sphinxupquote{\textbackslash{}begin\{shade\} can be used in place of \textasciigrave{}\textasciigrave{}\textbackslash{}begin\{lstlisting\}{[}style=SHELL{]}}}.

\item {} 
Unicode rules
\begin{itemize}
\item {} 
Do not use characters for which well\sphinxhyphen{}established latex idiom
exists, especially dashes, quotes, and apostrophes.

\item {} 
Use math mode markup instead of unicode characters for equations.

\item {} 
Be cautious of WYSIWYG word processors; cutting and pasting can
pickup characters promoted to unicode by the program.

\item {} 
Take a look at your text multibyte expanded; that is open it in
(emacs and ‘esc\sphinxhyphen{}x toggle\sphinxhyphen{}enable\sphinxhyphen{}multibyte\sphinxhyphen{}characters’)—see any
unicode you did not intend?

\end{itemize}

\item {} 
Place unformatted text targeted at developers working on the LaTeX in
comments. Include generously.

\item {} 
Encapsulate formatted text aimed at developers (like this entire
chapter), in \sphinxcode{\sphinxupquote{\textbackslash{}dev\{\}}}. Text encapsulated in this way will be removed from the
user version of the manual by editing the definition of \sphinxcode{\sphinxupquote{\textbackslash{}dev\{\}}} in \sphinxcode{\sphinxupquote{qmcpack\_manual.tex}}. Existing
but deprecated or partially functioning features fall in this
category.

\item {} 
Newly added entries to a Bib file should be as complete as possible.
Use a tool such as JabRef or Zotero that can automate creation of
these entries from just a DOI.

\end{itemize}

\sphinxstylestrong{Forbidden:}
\begin{itemize}
\item {} 
Including images instead of using lstlisting sections for text.

\item {} 
Using packages the LaTeX community considers \sphinxhref{https://latex.org/forum/viewtopic.php?f=37\&t=6637}{deprecated}.

\item {} 
Using packages, features, or fonts not included in texlive 2017
unless you ensure they degrade reasonably for 2017.

\item {} 
Adding packages unless they bring great value and are supported by
tex4ht (unless you are willing to add the support).

\item {} 
Saving Tex files and Bib files in encodings other than UTF8. Some may
report being ASCII encoded since they contain no unicode characters.

\end{itemize}

\sphinxstylestrong{Missing sections (these are opinions, not decided priorities):}
\begin{itemize}
\item {} 
Description of XML input in general. Discuss XML format, use of
attributes and \sphinxcode{\sphinxupquote{\textless{}parameter/\textgreater{}}} s in general, case sensitivity
(input is generally case sensitive), and behavior of when
unrecognized XML elements are encountered (they are generally ignored
without notification).

\item {} 
Overview of the input file in general, broad structure, and at least
one full example that works in isolation.

\end{itemize}

\sphinxstylestrong{Information currently missing for a complete reference
specification:}
\begin{itemize}
\item {} 
Noting how many instances of each child element are allowed.
Examples: \sphinxcode{\sphinxupquote{simulation}}\textendash{}1 only, \sphinxcode{\sphinxupquote{method}}\textendash{}1 or more, \sphinxcode{\sphinxupquote{jastrow}}\textendash{}0
or more.

\end{itemize}

Table templates follow for describing XML elements in reference fashion.
A number of examples can be found in, for example,
{\hyperref[\detokenize{hamiltonianobservable:hamiltobs}]{\sphinxcrossref{\DUrole{std,std-ref}{Hamiltonian and Observables}}}}. Preliminary style is (please weigh in with
opinions): typewriter text (\sphinxcode{\sphinxupquote{\textbackslash{}texttt\textbackslash{}\{\}}}) for XML elements, attributes, and
parameter names; normal text for literal information in the datatype,
values, and default columns; bold (\sphinxcode{\sphinxupquote{\textbackslash{}textbf\{\}}}) text if an attribute or parameter
must take on a particular value (values column); italics (\sphinxcode{\sphinxupquote{\textbackslash{}textit\{\}}}) for
descriptive (nonliteral) information in the values column (e.g.,
\sphinxstyleemphasis{anything}, \sphinxstyleemphasis{non\sphinxhyphen{}zero}); and required/optional attributes or parameters
noted by \sphinxcode{\sphinxupquote{some\_attr}} \(^r\)/\sphinxcode{\sphinxupquote{some\_attr}} \(^r\) superscripts. Valid datatypes
are text, integer, real, Boolean, and arrays of each. Fixed length
arrays can be noted, for example, by “real array(3).”

Template for a generic XML element:

\sphinxcode{\sphinxupquote{generic}} element:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{parent1}} \sphinxcode{\sphinxupquote{parent2}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{child1}} \sphinxcode{\sphinxupquote{child2}} \sphinxcode{\sphinxupquote{child3}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}

attributes:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{attr1}}\(^r\)
&
text
&&&\\
\hline
\sphinxcode{\sphinxupquote{attr2}}\(^r\)
&
integer
&&&\\
\hline
\sphinxcode{\sphinxupquote{attr3}}\(^r\)
&
real
&&&\\
\hline
\sphinxcode{\sphinxupquote{attr4}}\(^r\)
&
boolean
&&&\\
\hline
\sphinxcode{\sphinxupquote{attr5}}\(^r\)
&
text array
&&&\\
\hline
\sphinxcode{\sphinxupquote{attr6}}\(^r\)
&
integer array
&&&\\
\hline
\sphinxcode{\sphinxupquote{attr7}}\(^r\)
&
real array
&&&\\
\hline
\sphinxcode{\sphinxupquote{attr8}}\(^r\)
&
boolean array
&&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

parameters:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{param1}}\(^r\)
&
text
&&&\\
\hline
\sphinxcode{\sphinxupquote{param2}}\(^r\)
&
integer
&&&\\
\hline
\sphinxcode{\sphinxupquote{param3}}\(^r\)
&
real
&&&\\
\hline
\sphinxcode{\sphinxupquote{param4}}\(^r\)
&
boolean
&&&\\
\hline
\sphinxcode{\sphinxupquote{param5}}\(^r\)
&
text array
&&&\\
\hline
\sphinxcode{\sphinxupquote{param6}}\(^r\)
&
integer array
&&&\\
\hline
\sphinxcode{\sphinxupquote{param7}}\(^r\)
&
real array
&&&\\
\hline
\sphinxcode{\sphinxupquote{param8}}\(^r\)
&
boolean array
&&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

body text: Long form description of body text format
\end{quote}

“Factory” elements are XML elements that share a tag but whose contents
change based on the value an attribute, or sometimes multiple
attributes, take. The attribute(s) that determines the allowed content
is subsequently referred to as the “type selector” (e.g., for
\sphinxcode{\sphinxupquote{\textless{}estimator/\textgreater{}}} elements, the type selector is usually the \sphinxcode{\sphinxupquote{type}}
attribute). These types of elements are frequently encountered as they
correspond (sometimes loosely, sometimes literally) to polymorphic
classes in QMCPACK that are built in “factories.” This name is true to
the underlying code but may be obscure to the general user (is there a
better name to retain the general meaning?).

The following template should be provided each time a new “factory” type
is encountered (such as \sphinxcode{\sphinxupquote{\textless{}estimator/\textgreater{}}}). The table lists all types of
possible elements (see “type options” in the template) and any
attributes that are common to all possible related elements. Specific
“derived” elements are then described one at a time with the previous
template, noting the type selector in addition to the XML tag (e.g.,
“\sphinxcode{\sphinxupquote{estimator type=density}} element”).

Template for shared information about “factory” elements.

\sphinxcode{\sphinxupquote{generic}} factory element:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{parent1}} \sphinxcode{\sphinxupquote{parent2}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{child1}} \sphinxcode{\sphinxupquote{child2}} \sphinxcode{\sphinxupquote{child3}}
\\
\hline
type selector
&
\sphinxcode{\sphinxupquote{some}} attribute
\\
\hline
type options
&
Selection 1
\\
\hline&
Selection 2
\\
\hline&
Selection 3
\\
\hline&
…
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}

shared attributes:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{attr1}}\(^r\)
&
text
&&&\\
\hline
\sphinxcode{\sphinxupquote{attr2}}\(^r\)
&
integer
&&&\\
\hline
…
&&&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\chapter{Unit Testing}
\label{\detokenize{unit_testing:unit-testing}}\label{\detokenize{unit_testing:id1}}\label{\detokenize{unit_testing::doc}}
Unit testing is a standard software engineering practice to aid in ensuring a quality product. A good suite of unit tests provides confidence in refactoring and changing code, furnishes some documentation on how classes and functions are used, and can drive a more decoupled design.

If unit tests do not already exist for a section of code, you are encouraged to add them when modifying that section of code.  New code additions should also include unit tests.
When possible, fixes for specific bugs should also include a unit test that would have caught the bug.


\section{Unit testing framework}
\label{\detokenize{unit_testing:unit-testing-framework}}
The Catch framework is used for unit testing.
See the project site for a tutorial and documentation: \sphinxurl{https://github.com/philsquared/Catch}.

Catch consists solely of header files. It is distributed as a single include file about 400 KB in size.  In QMCPACK, it is stored in \sphinxcode{\sphinxupquote{external\_codes/catch}}.


\section{Unit test organization}
\label{\detokenize{unit_testing:unit-test-organization}}
The source for the unit tests is located in the \sphinxcode{\sphinxupquote{tests}} directory under each directory in \sphinxcode{\sphinxupquote{src}} (e.g., \sphinxcode{\sphinxupquote{src/QMCWavefunctions/tests}}).
All of the tests in each \sphinxcode{\sphinxupquote{tests}} directory get compiled into an executable.
After building the project, the individual unit test executables can be found in \sphinxcode{\sphinxupquote{build/tests/bin}}.
For example, the tests in \sphinxcode{\sphinxupquote{src/QMCWavefunctions/tests}} are compiled into \sphinxcode{\sphinxupquote{build/tests/bin/test\_wavefunction}}.

All the unit test executables are collected under ctest with the \sphinxcode{\sphinxupquote{unit}} label.
When checking the whole code, it is useful to run through CMake (\sphinxcode{\sphinxupquote{cmake \sphinxhyphen{}L unit}}).
When working on an individual directory, it is useful to run the individual executable.

Some of the tests reference input files. The unit test CMake setup places those input files in particular locations under the \sphinxcode{\sphinxupquote{tests}} directory (e.g., \sphinxcode{\sphinxupquote{tests/xml\_test}}).  The individual test needs to be run from that directory to find the expected input files.

Command line options are available on the unit test executables.  Some of the more useful ones are
\begin{itemize}
\item {} 
List command line options.

\item {} 
List all the tests in the executable.

\end{itemize}

A test name can be given on the command line to execute just that test.  This is useful when iterating
on a particular test or when running in the debugger.   Test names often contain spaces, so most command line environments require enclosing the test name in single or double quotes.


\section{Example}
\label{\detokenize{unit_testing:example}}
The first example is one test from \sphinxcode{\sphinxupquote{src/Numerics/tests/test\_grid\_functor.cpp}}.
\sphinxSetupCaptionForVerbatim{Unit test example using Catch.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{unit_testing:listing-75}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{TEST\PYGZus{}CASE}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{double\PYGZus{}1d\PYGZus{}grid\PYGZus{}functor}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{[numerics]}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{LinearGrid}\PYG{o}{\PYGZlt{}}\PYG{n}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{grid}\PYG{p}{;}
  \PYG{n}{OneDimGridFunctor}\PYG{o}{\PYGZlt{}}\PYG{n}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{f}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{grid}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{grid}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{REQUIRE}\PYG{p}{(}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{REQUIRE}\PYG{p}{(}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{rmin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{REQUIRE}\PYG{p}{(}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{rmax}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{REQUIRE}\PYG{p}{(}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{dh}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{n}{Approx}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{REQUIRE}\PYG{p}{(}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{dr}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{==} \PYG{n}{Approx}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The test function declaration is
\sphinxcode{\sphinxupquote{TEST\_CASE("double\_1d\_grid\_functor","{[}numerics{]}")}}.
The first argument is the test name, and it must be unique in the test suite.
The second argument is an optional list of tags.  Each tag is a name surrounded by brackets (\sphinxcode{\sphinxupquote{"{[}tag1{]}{[}tag2{]}"}}).  It can also be the empty string.

The \sphinxcode{\sphinxupquote{REQUIRE}} macro accepts expressions with C++ comparison operators and records an error if the value of the expression is false.

Floating point numbers may have small differences due to roundoff, etc.   The \sphinxcode{\sphinxupquote{Approx}} class adds some tolerance to the comparison.  Place it on either side of the comparison (e.g., \sphinxcode{\sphinxupquote{Approx(a) == 0.3}} or \sphinxcode{\sphinxupquote{a = Approx(0.3)}}).   To adjust the tolerance, use the \sphinxcode{\sphinxupquote{epsilon}} and \sphinxcode{\sphinxupquote{scale}} methods to \sphinxcode{\sphinxupquote{Approx}} (\sphinxcode{\sphinxupquote{REQUIRE(Approx(a).epsilon(0.001) = 0.3);}}.


\subsection{Expected output}
\label{\detokenize{unit_testing:expected-output}}
When running the test executables individually, the output of a run with no failures should look like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{=}
\PYG{n}{All} \PYG{n}{tests} \PYG{n}{passed} \PYG{p}{(}\PYG{l+m+mi}{26} \PYG{n}{assertions} \PYG{o+ow}{in} \PYG{l+m+mi}{4} \PYG{n}{test} \PYG{n}{cases}\PYG{p}{)}
\end{sphinxVerbatim}

A test with failures will look like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}
test\PYGZus{}numerics is a Catch v1.4.0 host application.
Run with \PYGZhy{}? for options

\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
double\PYGZus{}1d\PYGZus{}grid\PYGZus{}functor
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
/home/user/qmcpack/src/Numerics/tests/test\PYGZus{}grid\PYGZus{}functor.cpp:29
...............................................................................

/home/user/qmcpack/src/Numerics/tests/test\PYGZus{}grid\PYGZus{}functor.cpp:39: FAILED:
  REQUIRE( grid.dh() == Approx(0.6) )
with expansion:
  0.5 == Approx( 0.6 )

===============================================================================
test cases:  4 |  3 passed | 1 failed
assertions: 25 | 24 passed | 1 failed
\end{sphinxVerbatim}


\section{Adding tests}
\label{\detokenize{unit_testing:adding-tests}}
Three scenarios are covered here: adding a new test in an existing file, adding a new test file, and adding a new \sphinxcode{\sphinxupquote{test}} directory.


\subsection{Adding a test to existing file}
\label{\detokenize{unit_testing:adding-a-test-to-existing-file}}
Copy an existing test or from the example shown here.  Be sure to change the test name.


\subsection{Adding a test file}
\label{\detokenize{unit_testing:adding-a-test-file}}
When adding a new test file,
create a file in the test directory, or copy from an existing file.  Add the file name to the \sphinxcode{\sphinxupquote{ADD\_EXECUTABLE}} in the \sphinxcode{\sphinxupquote{CMakeLists.txt}} file in that directory.

One (and only one) file must define the \sphinxcode{\sphinxupquote{main}} function for the test executable by defining \sphinxcode{\sphinxupquote{CATCH\_CONFIG\_MAIN}} before including the Catch header.  If more than one file defines this value, there will be linking errors about multiply defined values.

Some of the tests need to shut down MPI properly to avoid extraneous error messages. Those tests include \sphinxcode{\sphinxupquote{Message/catch\_mpi\_main.hpp}} instead of defining \sphinxcode{\sphinxupquote{CATCH\_CONFIG\_MAIN}}.


\subsection{Adding a test directory}
\label{\detokenize{unit_testing:adding-a-test-directory}}
Copy the \sphinxcode{\sphinxupquote{CMakeLists.txt}} file from an existing \sphinxcode{\sphinxupquote{tests}} directory.
Change the \sphinxcode{\sphinxupquote{SRC\_DIR}} name and the  files in the \sphinxcode{\sphinxupquote{ADD\_EXECUTABLES}} line.  The libraries to link in \sphinxcode{\sphinxupquote{TARGET\_LINK\_LIBRARIES}} may need to be updated.

Add the new test directory to \sphinxcode{\sphinxupquote{src/CMakeLists.txt}} in the \sphinxcode{\sphinxupquote{BUILD\_UNIT\_TESTS}} section near the end.


\section{Testing with random numbers}
\label{\detokenize{unit_testing:testing-with-random-numbers}}
Many algorithms and parts of the code depend on random numbers, which makes validating the results difficult.
One solution is to verify that certain properties hold for any random number.
This approach is valuable at some levels of testing, but is unsatisfying at the unit test level.

The \sphinxcode{\sphinxupquote{Utilities}} directory contains a “fake” random number generator that can be used for deterministic tests of these parts of the code.
Currently it outputs a single, fixed value every time it is called, but it could be expanded to produce more varied, but still deterministic, sequences.
See \sphinxcode{\sphinxupquote{src/QMCDrivers/test\_vmc.cpp}} for an example of using the fake random number generator.


\chapter{QMCPACK Design and Feature Documentation}
\label{\detokenize{design_features:qmcpack-design-and-feature-documentation}}\label{\detokenize{design_features:design-features}}\label{\detokenize{design_features::doc}}
This section contains information on the overall design of QMCPACK.  Also included are detailed explanations/derivations of major features and algorithms present in the code.


\section{QMCPACK design}
\label{\detokenize{design_features:qmcpack-design}}
TBD.


\section{Feature: Optimized long\sphinxhyphen{}range breakup (Ewald)}
\label{\detokenize{design_features:feature-optimized-long-range-breakup-ewald}}
Consider a group of particles interacting with long\sphinxhyphen{}range central
potentials, \(v^{\alpha \beta}(|r^{\alpha}_i - r^{\beta}_j|)\),
where the Greek superscripts represent the particle species (e.g.,
\(\alpha=\text{electron}\), \(\beta=\text{proton}\)), and Roman
subscripts refer to particle number within a species. We can then write
the total interaction energy for the system as
\begin{equation}\label{equation:design_features:eq80}
\begin{split}V = \sum_\alpha \left\{\sum_{i<j} v^{\alpha\alpha}(|\mathbf{r}^\alpha_i - \mathbf{r}^\alpha_j|) +
\sum_{\beta<\alpha}
\sum_{i,j} v^{\alpha \beta}(|\mathbf{r}^{\alpha}_i - \mathbf{r}^{\beta}_j|) \right\}\end{split}
\end{equation}

\subsection{The long\sphinxhyphen{}range problem}
\label{\detokenize{design_features:the-long-range-problem}}
Consider such a system in periodic boundary conditions in a cell defined
by primitive lattice vectors \(\mathbf{a}_1\), \(\mathbf{a}_2\),
and \(\mathbf{a}_3\). Let
\(\mathbf{L}\equiv n_1 \mathbf{a}_1 + n_2 \mathbf{a}_2 + n_3\mathbf{a}_3\)
be a direct lattice vector. Then the interaction energy per cell for the
periodic system is given by
\begin{equation}\label{equation:design_features:eq81}
\begin{split}\begin{split}
V = & \sum_\mathbf{L}\sum_\alpha \left\{
\overbrace{\sum_{i<j} v^{\alpha\alpha}(|\mathbf{r}^\alpha_i - \mathbf{r}^\alpha_j + \mathbf{L}|)}^{\text{homologous}} +
\overbrace{\sum_{\beta<\alpha}
\sum_{i,j} v^{\alpha \beta}(|\mathbf{r}^{\alpha}_i - \mathbf{r}^{\beta}_j+\mathbf{L}|)}^{\text{heterologous}}
\right\}  \\
& + \underbrace{\sum_{\mathbf{L}\neq \mathbf{0}} \sum_\alpha N^\alpha v^{\alpha \alpha} (|\mathbf{L}|)}_\text{Madelung}\:.
\end{split}\end{split}
\end{equation}
where \(N^\alpha\) is the number particles of species
\(\alpha\). If the potentials \(v^{\alpha\beta}(r)\) are indeed
long\sphinxhyphen{}range, the summation over direct lattice vectors will not converge
in this naive form. A solution to the problem was posited by Ewald. We
break the central potentials into two pieces—a short\sphinxhyphen{}range and a
long\sphinxhyphen{}range part defined by
\begin{equation}\label{equation:design_features:eq82}
\begin{split}v^{\alpha \beta}(r) = v_s^{\alpha\beta}(r) + v_l^{\alpha \beta}(r)\:.\end{split}
\end{equation}
We will perform the summation over images for the short\sphinxhyphen{}range part in
real space, while performing the sum for the long\sphinxhyphen{}range part in
reciprocal space. For simplicity, we choose
\(v^{\alpha \beta}_s(r)\) so that it is identically zero at the
half\sphinxhyphen{}the\sphinxhyphen{}box length. This eliminates the need to sum over images in real
space.


\subsection{Reciprocal\sphinxhyphen{}space sums}
\label{\detokenize{design_features:reciprocal-space-sums}}

\subsubsection{Heterologous terms}
\label{\detokenize{design_features:heterologous-terms}}
We begin with eq:\sphinxtitleref{eq81}, starting with the heterologous terms (i.e., the terms involving particles of different species).  The
short\sphinxhyphen{}range terms are trivial, so we neglect them here.
\begin{equation}\label{equation:design_features:eq83}
\begin{split}\text{heterologous} = \frac{1}{2} \sum_{\alpha \neq \beta} \sum_{i,j} \sum_\mathbf{L}
 v^{\alpha\beta}_l(\mathbf{r}_i^\alpha - \mathbf{r}_j^\beta + \mathbf{L})\:.\end{split}
\end{equation}
We insert the resolution of unity in real space twice:
\begin{equation}\label{equation:design_features:eq84}
\begin{split}\begin{aligned}
 \text{heterologous} & = & \frac{1}{2}\sum_{\alpha \neq \beta} \int_\text{cell} d\mathbf{r}\, d\mathbf{r}' \, \sum_{i,j}
 \delta(\mathbf{r}_i^\alpha - \mathbf{r}) \delta(\mathbf{r}_j^\beta-\mathbf{r}') \sum_\mathbf{L}
 v^{\alpha\beta}_l(|\mathbf{r}- \mathbf{r}' + \mathbf{L}|)\:, \\
 & = & \frac{1}{2\Omega^2}\sum_{\alpha \neq \beta} \int_\text{cell} d\mathbf{r}\, d\mathbf{r}' \, \sum_{\mathbf{k}, \mathbf{k}', i, j} e^{i\mathbf{k}\cdot(\mathbf{r}_i^\alpha
   - \mathbf{r})} e^{i\mathbf{k}'\cdot(\mathbf{r}_j^\beta - \mathbf{r}')} \sum_\mathbf{L}
 v^{\alpha\beta}_l(|\mathbf{r}- \mathbf{r}' + \mathbf{L}|) \nonumber\:, \\
 & = & \frac{1}{2\Omega^2} \sum_{\alpha \neq \beta} \int_\text{cell} d\mathbf{r}\, d\mathbf{r}'\,
 \sum_{\mathbf{k}, \mathbf{k}', \mathbf{k}'', i, j} e^{i\mathbf{k}\cdot(\mathbf{r}_i^\alpha - \mathbf{r})}
 e^{i\mathbf{k}'\cdot(\mathbf{r}_j^\beta-\mathbf{r}')} e^{i\mathbf{k}''\cdot(\mathbf{r}-\mathbf{r}')}
 v^{\alpha\beta}_{\mathbf{k}''}\nonumber\:.\end{aligned}\end{split}
\end{equation}
Here, the \(\mathbf{k}\) summations are over reciprocal lattice
vectors given by
\(\mathbf{k}= m_1 \mathbf{b}_1 + m_2\mathbf{b}_2 + m_3\mathbf{b}_3\),
where
\begin{equation}\label{equation:design_features:eq85}
\begin{split}\begin{aligned}
\mathbf{b}_1 & = & 2\pi \frac{\mathbf{a}_2 \times \mathbf{a}_3}{\mathbf{a}_1 \cdot (\mathbf{a}_2 \times
  \mathbf{a}_3)} \nonumber\:, \\
\mathbf{b}_2 & = & 2\pi \frac{\mathbf{a}_3 \times \mathbf{a}_1}{\mathbf{a}_1 \cdot (\mathbf{a}_2 \times
  \mathbf{a}_3)}\:, \\
\mathbf{b}_3 & = & 2\pi \frac{\mathbf{a}_1 \times \mathbf{a}_2}{\mathbf{a}_1 \cdot (\mathbf{a}_2 \times
  \mathbf{a}_3)} \nonumber\:.\end{aligned}\end{split}
\end{equation}
We note that \(\mathbf{k}\cdot \mathbf{L}= 2\pi(n_1 m_1 + n_2 m_2 + n_3 m_3)\).
\begin{equation}\label{equation:design_features:eq86}
\begin{split}\begin{aligned}
v_{k''}^{\alpha \beta} & = &
\frac{1}{\Omega} \int_{\text{cell}} d\mathbf{r}'' \sum_\mathbf{L}
e^{-i\mathbf{k}''\cdot(|\mathbf{r}''+\mathbf{L}|)} v^{\alpha\beta}(|\mathbf{r}''+\mathbf{L}|)\:, \\
& = & \frac{1}{\Omega} \int_\text{all space} d\tilde{\mathbf{r}} \,
    e^{-i\mathbf{k}'' \cdot \tilde{\mathbf{r}}} v^{\alpha\beta}(\tilde{r})\:, \end{aligned}\end{split}
\end{equation}
where \(\Omega\) is the volume of the cell. Here we have used the
fact that summing over all cells of the integral over the cell is
equivalent to integrating over all space.
\begin{equation}\label{equation:design_features:eq87}
\begin{split}\text{hetero} = \frac{1}{2\Omega^2} \sum_{\alpha \neq \beta}
\int_\text{cell} d\mathbf{r}\, d\mathbf{r}' \, \sum_{\mathbf{k}, \mathbf{k}', \mathbf{k}'', i, j}
e^{i(\mathbf{k}\cdot \mathbf{r}_i^\alpha + \mathbf{k}' \cdot\mathbf{r}_j^\beta)} e^{i(\mathbf{k}''-\mathbf{k})\cdot \mathbf{r}}
e^{-i(\mathbf{k}'' + \mathbf{k}')\cdot \mathbf{r}'} v^{\alpha \beta}_{\mathbf{k}''}\:.\end{split}
\end{equation}
We have
\begin{equation}\label{equation:design_features:eq88}
\begin{split}\frac{1}{\Omega} \int d\mathbf{r}\  e^{i(\mathbf{k}-\mathbf{k}')\cdot \mathbf{r}} =
\delta_{\mathbf{k},\mathbf{k}'}\:.\end{split}
\end{equation}
Then, performing the integrations we have
\begin{equation}\label{equation:design_features:eq89}
\begin{split}\begin{aligned}
\text{hetero} = \frac{1}{2} \sum_{\alpha \neq \beta}
\sum_{\mathbf{k}, \mathbf{k}', \mathbf{k}'', i, j}
e^{i(\mathbf{k}\cdot \mathbf{r}_i^\alpha + \mathbf{k}' \cdot\mathbf{r}_j^\beta)} \delta_{\mathbf{k},\mathbf{k}''}
\delta_{-\mathbf{k}', \mathbf{k}''} v^{\alpha \beta}_{\mathbf{k}''}\:.\end{aligned}\end{split}
\end{equation}
We now separate the summations, yielding
\begin{equation}\label{equation:design_features:eq90}
\begin{split}\text{hetero} = \frac{1}{2} \sum_{\alpha \neq \beta} \sum_{\mathbf{k}, \mathbf{k}'}
\underbrace{\left[\sum_i e^{i\mathbf{k}\cdot \mathbf{r}_i^\alpha} \rule{0cm}{0.705cm}
    \right]}_{\rho_\mathbf{k}^\alpha}
\underbrace{\left[\sum_j e^{i\mathbf{k}' \cdot \mathbf{r}_j^\beta} \right]}_{\rho_{\mathbf{k}'}^\beta}
 \delta_{\mathbf{k},\mathbf{k}''} \delta_{-\mathbf{k}', \mathbf{k}''} v^{\alpha
  \beta}_{\mathbf{k}''}\:.\end{split}
\end{equation}
Summing over \(\mathbf{k}\) and \(\mathbf{k}'\), we have
\begin{equation}\label{equation:design_features:eq91}
\begin{split}\text{hetero} = \frac{1}{2} \sum_{\alpha \neq \beta} \sum_{\mathbf{k}''}
\rho_{\mathbf{k}''}^\alpha \, \rho_{-\mathbf{k}''}^\beta v_{k''}^{\alpha \beta}\:.\end{split}
\end{equation}
We can simplify the calculation a bit further by rearranging the
sums over species:
\begin{equation}\label{equation:design_features:eq92}
\begin{split}\begin{aligned}
\text{hetero} & = & \frac{1}{2} \sum_{\alpha > \beta} \sum_{\mathbf{k}}
\left(\rho^\alpha_\mathbf{k}\rho^\beta_{-\mathbf{k}} + \rho^\alpha_{-\mathbf{k}}
\rho^\beta_\mathbf{k}\right) v_{k}^{\alpha\beta}\:, \\
& = & \sum_{\alpha > \beta} \sum_\mathbf{k}\mathcal{R}e\left(\rho_\mathbf{k}^\alpha
\rho_{-\mathbf{k}}^\beta\right)v_k^{\alpha\beta} .\end{aligned}\end{split}
\end{equation}

\subsubsection{Homologous terms}
\label{\detokenize{design_features:homologous-terms}}
We now consider the terms involving particles of the same species
interacting with each other.  The algebra is very similar to the
preceding, with the slight difficulty of avoiding the self\sphinxhyphen{}interaction term.
\begin{equation}\label{equation:design_features:eq93}
\begin{split}\begin{aligned}
\text{homologous} & = & \sum_\alpha \sum_L \sum_{i<j} v_l^{\alpha
  \alpha}(|\mathbf{r}_i^\alpha - \mathbf{r}_j^\alpha + \mathbf{L}|)\:, \\
 & = & \frac{1}{2} \sum_\alpha \sum_L \sum_{i\neq j} v_l^{\alpha
  \alpha}(|\mathbf{r}_i^\alpha - \mathbf{r}_j^\alpha + \mathbf{L}|)\:. \end{aligned}\end{split}
\end{equation}\begin{equation}\label{equation:design_features:eq94}
\begin{split}\begin{aligned}
\text{homologous} & = & \frac{1}{2} \sum_\alpha \sum_L
\left[
-N^\alpha v_l^{\alpha \alpha}(|\mathbf{L}|)  + \sum_{i,j} v^{\alpha \alpha}_l(|\mathbf{r}_i^\alpha - \mathbf{r}_j^\alpha + \mathbf{L}|)
  \right]\:, \\
& = & \frac{1}{2} \sum_\alpha \sum_\mathbf{k}\left(|\rho_k^\alpha|^2 - N
\right) v_k^{\alpha \alpha}\:.\end{aligned}\end{split}
\end{equation}

\subsubsection{Madelung terms}
\label{\detokenize{design_features:madelung-terms}}
Let us now consider the Madelung term for a single particle of species
\(\alpha\). This term corresponds to the interaction of a particle
with all of its periodic images.
\begin{equation}\label{equation:design_features:eq95}
\begin{split}\begin{aligned}
v_M^{\alpha} & = & \frac{1}{2} \sum_{\mathbf{L}\neq \mathbf{0}} v^{\alpha
  \alpha}(|\mathbf{L}|)\:, \\
& = & \frac{1}{2} \left[ -v_l^{\alpha \alpha}(0) + \sum_\mathbf{L}v^{\alpha
  \alpha}(|\mathbf{L}|) \right]\:, \\
& = & \frac{1}{2} \left[ -v_l^{\alpha \alpha}(0) + \sum_\mathbf{k}v^{\alpha
  \alpha}_\mathbf{k}\right]\:.  \end{aligned}\end{split}
\end{equation}

\subsubsection{\protect\(\mathbf{k}=\mathbf{0}\protect\) terms}
\label{\detokenize{design_features:mathbf-k-mathbf-0-terms}}
Thus far, we have neglected what happens at the special point
\(\mathbf{k}=
\mathbf{0}\). For many long\sphinxhyphen{}range potentials, such as the Coulomb
potential, \(v_k^{\alpha \alpha}\) diverges for \(k=0\).
However, we recognize that for a charge\sphinxhyphen{}neutral system, the divergent
part of the terms cancel each other. If all the potential in the system
were precisely Coulomb, the \(\mathbf{k}=\mathbf{0}\) terms would
cancel precisely, yielding zero. For systems involving PPs, however, it
may be that the resulting term is finite, but nonzero. Consider the
terms from \(\mathbf{k}=\mathbf{0}\):
\begin{equation}\label{equation:design_features:eq96}
\begin{split}\begin{aligned}
V_{k=0} & = & \sum_{\alpha>\beta} N^\alpha N^\beta v^{\alpha \beta}_{k=0}
+ \frac{1}{2} \sum_\alpha \left(N^{\alpha}\right)^2 v^{\alpha\alpha}_{k=0}\:, \\
& = & \frac{1}{2} \sum_{\alpha,\beta} N^\alpha N^\beta v^{\alpha
  \beta}_{k=0}\:.
\end{aligned}\end{split}
\end{equation}
Next, we must compute \(v^{\alpha \beta}_{k=0}\).
\begin{equation}\label{equation:design_features:eq97}
\begin{split}v^{\alpha \beta}_{k=0} = \frac{4 \pi}{\Omega} \int_0^\infty dr\ r^2
v_l^{\alpha \beta}(r)\:.\end{split}
\end{equation}
We recognize that this integral will not converge because of the
large\sphinxhyphen{}\(r\) behavior. However, we recognize that when we do the sum
in \eqref{equation:design_features:eq96}, the large\sphinxhyphen{}\(r\) parts of the integrals
will cancel precisely. Therefore, we define
\begin{equation}\label{equation:design_features:eq98}
\begin{split}\tilde{v}^{\alpha \beta}_{k=0} = \frac{4 \pi}{\Omega}
\int_0^{r_\text{end}} dr\ r^2 v_l^{\alpha \beta}(r)\:,\end{split}
\end{equation}
where \(r_{\text{end}}\) is some cutoff value after which the
potential tails precisely cancel.


\subsubsection{Neutralizing background terms}
\label{\detokenize{design_features:neutralizing-background-terms}}
For systems with a net charge, such as the one\sphinxhyphen{}component plasma
(jellium), we add a uniform background charge, which makes the system
neutral.  When we do this, we must add a term that comes from the
interaction of the particle with the neutral background.  It is a
constant term, independent of the particle positions.  In general, we
have a compensating background for each species, which largely cancels
out for neutral systems.
\begin{equation}\label{equation:design_features:eq99}
\begin{split}V_\text{background} = -\frac{1}{2} \sum_\alpha \left(N^\alpha\right)^2
v^{\alpha \alpha}_{s\mathbf{0}}
-\sum_{\alpha > \beta} N_\alpha N_\beta
v^{\alpha\beta}_{s\mathbf{0}}\:,\end{split}
\end{equation}
where \(v^{\alpha \beta}_{s\mathbf{0}}\) is given by
\begin{equation}\label{equation:design_features:eq100}
\begin{split}\begin{aligned}
v^{\alpha \beta}_{s\mathbf{0}} & = & \frac{1}{\Omega} \int_0^{r_c} d^3 r\
v^{\alpha \beta}_s(r)\:, \\
& = & \frac{4 \pi}{\Omega} \int_0^{r_c} r^2 v_s(r) \ dr \nonumber\:.\end{aligned}\end{split}
\end{equation}

\subsection{Combining terms}
\label{\detokenize{design_features:combining-terms}}
Here, we sum all of the terms we computed in the previous sections:
\begin{equation}\label{equation:design_features:eq101}
\begin{split}\begin{aligned}
V & = & \sum_{\alpha > \beta} \left[\sum_{i,j} v_s(|\mathbf{r}_i^\alpha
  -\mathbf{r}_j^\beta|) + \sum_\mathbf{k}\mathcal{R}e\left(\rho_\mathbf{k}^\alpha
  \rho_{-\mathbf{k}}^\beta\right)v^{\alpha\beta}_k  -N^\alpha N^\beta
  v^{\alpha \beta}_{s\mathbf{0}}  \right] \nonumber\:, \\
& + & \sum_\alpha \left[ N^\alpha v_M^\alpha + \sum_{i>j} v_s(|\mathbf{r}_i^\alpha -
  \mathbf{r}_j^\alpha|) + \frac{1}{2} \sum_\mathbf{k}\left( |\rho_\mathbf{k}^\alpha|^2 -
  N\right) v^{\alpha\alpha}_\mathbf{k}-\frac{1}{2}\left(N_\alpha\right)^2 v_{s\mathbf{0}}^{\alpha\alpha}\right] \nonumber\:, \\
& = & \sum_{\alpha > \beta} \left[\sum_{i,j} v_s(|\mathbf{r}_i^\alpha
  -\mathbf{r}_j^\beta|) + \sum_\mathbf{k}\mathcal{R}e\left(\rho_\mathbf{k}^\alpha
  \rho_{-\mathbf{k}}^\beta\right) v^{\alpha \beta}_k   -N^\alpha N^\beta
  v^{\alpha \beta}_{s\mathbf{0}}  +\tilde{V}_{k=0} \right]\:, \\
& + & \sum_\alpha \left[ -\frac{N^\alpha v_l^{\alpha \alpha}(0)}{2}  + \sum_{i>j} v_s(|\mathbf{r}_i^\alpha -
  \mathbf{r}_j^\alpha|) + \frac{1}{2} \sum_\mathbf{k}|\rho_\mathbf{k}^\alpha|^2 v^{\alpha\alpha}_\mathbf{k}- \frac{1}{2}\left(N_\alpha\right)^2
  v_{s\mathbf{0}}^{\alpha\alpha} +\tilde{V}_{k=0}\right]  \nonumber\:.\end{aligned}\end{split}
\end{equation}

\subsection{Computing the reciprocal potential}
\label{\detokenize{design_features:computing-the-reciprocal-potential}}
Now we return to \eqref{equation:design_features:eq86}. Without loss of generality, we
define for convenience \(\mathbf{k}= k\hat{\mathbf{z}}\).
\begin{equation}\label{equation:design_features:eq102}
\begin{split}v^{\alpha \beta}_k = \frac{2\pi}{\Omega} \int_0^\infty dr \int_{-1}^1
  d\cos(\theta) \ r^2 e^{-i k r \cos(\theta)} v_l^{\alpha \beta}(r)\:.\end{split}
\end{equation}
We do the angular integral first.  By inversion symmetry, the
imaginary part of the integral vanishes, yielding
\begin{equation}\label{equation:design_features:eq103}
\begin{split}v^{\alpha \beta}_k = \frac{4\pi}{\Omega k}\int _0^\infty dr\ r \sin(kr)
v^{\alpha \beta}_l(r)\:.\end{split}
\end{equation}

\subsection{The Coulomb potential}
\label{\detokenize{design_features:the-coulomb-potential}}
For the case of the Coulomb potential, the preceding integral is not
formally convergent if we do the integral naively. We may remedy the
situation by including a convergence factor, \(e^{-k_0 r}\). For a
potential of the form \(v^{\text{coul}}(r) = q_1 q_2/r\), this
yields
\begin{equation}\label{equation:design_features:eq104}
\begin{split}\begin{aligned}
v^{\text{screened coul}}_k & = & \frac{4\pi q_1 q_2}{\Omega k} \int_0^\infty dr\ \sin(kr)
e^{-k_0r}\:, \\
& = & \frac{4\pi q_1 q_2}{\Omega (k^2 + k_0^2)}\:.\end{aligned}\end{split}
\end{equation}
Allowing the convergence factor to tend to zero, we have
\begin{equation}\label{equation:design_features:eq105}
\begin{split}v_k^\text{coul} = \frac{4 \pi q_1 q_2}{\Omega k^2}\:.\end{split}
\end{equation}
For more generalized potentials with a Coulomb tail, we cannot
evaluate \eqref{equation:design_features:eq103} numerically but must handle the coulomb part
analytically.  In this case, we have
\begin{equation}\label{equation:design_features:eq106}
\begin{split}v_k^{\alpha \beta} = \frac{4\pi}{\Omega}
\left\{ \frac{q_1 q_2}{k^2} + \int_0^\infty dr \ r \sin(kr) \left[ v_l^{\alpha \beta}(r) -
  \frac{q_1 q_2}{r} \right] \right\}\:.\end{split}
\end{equation}

\subsection{Efficient calculation methods}
\label{\detokenize{design_features:efficient-calculation-methods}}

\subsubsection{Fast computation of \protect\(\rho_\mathbf{k}\protect\)}
\label{\detokenize{design_features:fast-computation-of-rho-mathbf-k}}
We wish to quickly calculate the quantity
\begin{equation}\label{equation:design_features:eq107}
\begin{split}\rho_\mathbf{k}^\alpha \equiv \sum_i e^{i\mathbf{k}\cdot r_i^\alpha}\:.\end{split}
\end{equation}
First, we write
\begin{equation}\label{equation:design_features:eq108}
\begin{split}\begin{aligned}
\mathbf{k}& = & m_1 \mathbf{b}_1 + m_2 \mathbf{b}_2 + m_3 \mathbf{b}_3\:, \\
\mathbf{k}\cdot \mathbf{r}_i^\alpha & = &  m_1 \mathbf{b}_1 \cdot \mathbf{r}_i^\alpha +
m_2 \mathbf{b}_2 \cdot \mathbf{r}_i^\alpha + m_3 \mathbf{b}_3 \cdot \mathbf{r}_i^\alpha\:, \\
e^{i\mathbf{k}\cdot r_i^\alpha} & = &
{\underbrace{\left[e^{i \mathbf{b}_1 \cdot\mathbf{r}_i^\alpha}\right]}_{C^{i\alpha}_1}}^{m_1}
{\underbrace{\left[e^{i \mathbf{b}_2 \cdot\mathbf{r}_i^\alpha}\right]}_{C^{i\alpha}_2}}^{m_2}
{\underbrace{\left[e^{i \mathbf{b}_3 \cdot\mathbf{r}_i^\alpha}\right]}_{C^{i\alpha}_3}}^{m_3}\:.\end{aligned}\end{split}
\end{equation}
Now, we note that
\begin{equation}\label{equation:design_features:eq109}
\begin{split}^{m_1} = C^{i\alpha}_1 [C^{i\alpha}]^{(m_1-1)}\:.\end{split}
\end{equation}
This allows us to recursively build up an array of the
\(C^{i\alpha}\)s and then compute \(\rho_\mathbf{k}\) for all
\(\mathbf{k}\)\sphinxhyphen{}vectors by looping over all k\sphinxhyphen{}vectors, requiring only
two complex multiplies per particle per \(\mathbf{k}\).

\begin{center}Algorithm to quickly calculate \(\rho_\mathbf{k}^\alpha\).
\end{center}
\begin{DUlineblock}{0em}
\item[] Create list of \(\mathbf{k}\)\sphinxhyphen{}vectors and corresponding \((m_1, m_2, m_3)\) indices.
\item[] \sphinxstylestrong{for all} \(\alpha \in\) species
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Zero out \(\rho_\mathbf{k}^\alpha\)
\item[] \sphinxstylestrong{for all} \(i \in\) particles \sphinxstylestrong{do}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxstylestrong{for} \(j \in [1\cdots3]\) \sphinxstylestrong{do}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Compute \(C^{i \alpha}_j \equiv e^{i \mathbf{b}_j \cdot  \mathbf{r}^{\alpha}_i}\)
\item[] \sphinxstylestrong{for} \(m \in [-m_{\text{max}}\dots m_{\text{max}}]\) \sphinxstylestrong{do}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Compute \([C^{i \alpha}_j]^m\) and store in array
\end{DUlineblock}
\item[] \sphinxstylestrong{end for}
\end{DUlineblock}
\item[] \sphinxstylestrong{end for}
\item[] \sphinxstylestrong{for all} \((m_1, m_2, m_3) \in\) index list \sphinxstylestrong{do}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Compute \(e^{i \mathbf{k}\cdot r^\alpha_i} = [C^{i\alpha}_1]^{m_1} [C^{i\alpha}_2]^{m_2}[C^{i\alpha}_3]^{m_3}\) from array
\end{DUlineblock}
\item[] \sphinxstylestrong{end for}
\end{DUlineblock}
\item[] \sphinxstylestrong{end for}
\end{DUlineblock}
\item[] \sphinxstylestrong{end for}
\end{DUlineblock}


\subsection{Gaussian charge screening breakup}
\label{\detokenize{design_features:gaussian-charge-screening-breakup}}
This original approach to the short\sphinxhyphen{} and long\sphinxhyphen{}range breakup adds an
opposite screening charge of Gaussian shape around each point charge.
It then removes the charge in the long\sphinxhyphen{}range part of the potential.
In this potential,
\begin{equation}\label{equation:design_features:eq110}
\begin{split}v_{\text{long}}(r) = \frac{q_1 q_2}{r} \text{erf}(\alpha r)\:,\end{split}
\end{equation}
where \(\alpha\) is an adjustable parameter used to control how
short ranged the potential should be. If the box size is \(L\), a
typical value for \(\alpha\) might be \(7/(Lq_1 q_2)\). We
should note that this form for the long\sphinxhyphen{}range potential should also work
for any general potential with a Coulomb tail (e.g., pseudo\sphinxhyphen{}Hamiltonian
potentials. For this form of the long\sphinxhyphen{}range potential, we have in
\(k\)\sphinxhyphen{}space
\begin{equation}\label{equation:design_features:eq111}
\begin{split}v_k = \frac{4\pi q_1 q_2 \exp\left[\frac{-k^2}{4\alpha^2}\right]}{\Omega k^2}\:.\end{split}
\end{equation}

\subsection{Optimized breakup method}
\label{\detokenize{design_features:optimized-breakup-method}}
In this section, we undertake the task of choosing a
long\sphinxhyphen{}range/short\sphinxhyphen{}range partitioning of the potential, which is optimal
in that it minimizes the error for given real and \(k\)\sphinxhyphen{}space
cutoffs \(r_c\) and \(k_c\). Here, we slightly modify the method
introduced by Natoli and Ceperley \sphinxcite{design_features:natoli1995}. We
choose \(r_c = \frac{1}{2}\min\{L_i\}\) so that we require the nearest image in
real\sphinxhyphen{}space summation. \(k_c\) is then chosen to satisfy our accuracy
requirements.

Here we modify our notation slightly to accommodate details not
previously required. We restrict our discussion to the interaction of
two particle species (which may be the same), and drop our species
indices. Thus, we are looking for short\sphinxhyphen{} and long\sphinxhyphen{}range potentials
defined by
\begin{equation}\label{equation:design_features:eq112}
\begin{split}v(r) = v^s(r) + v^\ell(r)\:.\end{split}
\end{equation}
Define \(v^s_k\) and \(v^\ell_k\) to be the respective Fourier
transforms of the previous equation. The goal is to choose
\(v_s(r)\) such that its value and first two derivatives vanish at
\(r_c\), while making \(v^\ell(r)\) as smooth as possible so
that \(k\)\sphinxhyphen{}space components, \(v^\ell_k\), are very small for
\(k>k_c\). Here, we describe how to do this in an optimal way.

Define the periodic potential, \(V_p\), as
\begin{equation}\label{equation:design_features:eq113}
\begin{split}V_p(\mathbf{r}) = \sum_l v(|\mathbf{r}+ \mathbf{l}|),\end{split}
\end{equation}
where \(\mathbf{r}\) is the displacement between the two particles
and \(\mathbf{l}\) is a lattice vector. Let us then define our
approximation to this potential, \(V_a\), as
\begin{equation}\label{equation:design_features:eq114}
\begin{split}V_a(\mathbf{r}) = v^s(r) + \sum_{|\mathbf{k}| < k_c} v^\ell_k e^{i \mathbf{k} \cdot \mathbf{r}}\:.\end{split}
\end{equation}
Now, we seek to minimize the RMS error over the cell,
\begin{equation}\label{equation:design_features:eq115}
\begin{split}\chi^2 = \frac{1}{\Omega}\int_\Omega d^3 \mathbf{r} \
\left| V_p(\mathbf{r}) - V_a(\mathbf{r})\right|^2\:.\end{split}
\end{equation}
We may write
\begin{equation}\label{equation:design_features:eq116}
\begin{split}V_p(\mathbf{r}) = \sum_{\mathbf{k}} v_k e^{i \mathbf{k}\cdot \mathbf{r}}\:,\end{split}
\end{equation}
where
\begin{equation}\label{equation:design_features:eq117}
\begin{split}v_k = \frac{1}{\Omega} \int d^3\mathbf{r}\ e^{-i\mathbf{k}\cdot\mathbf{r}}v(r)\:.\end{split}
\end{equation}
We now need a basis in which to represent the broken\sphinxhyphen{}up potential. We
may choose to represent either \(v^s(r)\) or \(v^\ell(r)\) in a
real\sphinxhyphen{}space basis. Natoli and Ceperley chose the former in their paper.
We choose the latter for a number of reasons. First, singular potentials
are difficult to represent in a linear basis unless the singularity is
explicitly included. This requires a separate basis for each type of
singularity. The short\sphinxhyphen{}range potential may have an arbitrary number of
features for \(r<r_c\) and still be a valid potential. By
construction, however, we desire that \(v^\ell(r)\) be smooth in
real\sphinxhyphen{}space so that its Fourier transform falls off quickly with
increasing \(k\). We therefore expect that, in general,
\(v^\ell(r)\) should be well represented by fewer basis functions
than \(v^s(r)\). Therefore, we define
\begin{equation}\label{equation:design_features:eq118}
\begin{split}v^\ell(r) \equiv
\begin{cases}
 \sum_{n=0}^{J-1} t_n h_n(r) & \text{for } r \le r_c \\
 v(r) & \text{for } r > r_c.
\end{cases}\:,\end{split}
\end{equation}
where the \(h_n(r)\) are a set of \(J\) basis functions. We
require that the two cases agree on the value and first two derivatives
at \(r_c\). We may then define
\begin{equation}\label{equation:design_features:eq119}
\begin{split}c_{nk} \equiv \frac{1}{\Omega} \int_0^{r_c} d^3 \mathbf{r}\ e^{-i\mathbf{k}\cdot\mathbf{r}} h_n(r)\:.\end{split}
\end{equation}
Similarly, we define
\begin{equation}\label{equation:design_features:eq120}
\begin{split}x_k \equiv -\frac{1}{\Omega} \int_{r_c}^\infty d^3\mathbf{r}\ e^{-i\mathbf{k}\cdot\mathbf{r}} v(r)\:.\end{split}
\end{equation}
Therefore,
\begin{equation}\label{equation:design_features:eq121}
\begin{split}v^\ell_k = -x_k + \sum_{n=0}^{J-1} t_n c_{nk}\:.\end{split}
\end{equation}
Because \(v^s(r)\) goes identically to zero at the box edge, inside
the cell we may write
\begin{equation}\label{equation:design_features:eq122}
\begin{split}v^s(\mathbf{r}) = \sum_\mathbf{k}v^s_k e^{i\mathbf{k}\cdot \mathbf{r}}\:.\end{split}
\end{equation}
We then write
\begin{equation}\label{equation:design_features:eq123}
\begin{split}\chi^2 = \frac{1}{\Omega} \int_\Omega d^3 \mathbf{r}\
\left| \sum_\mathbf{k}e^{i\mathbf{k}\cdot \mathbf{r}} \left(v_k - v^s_k \right)
-\sum_{|\mathbf{k}| \le k_c} v^\ell_k \right|^2\:.\end{split}
\end{equation}
We see that if we define
\begin{equation}\label{equation:design_features:eq124}
\begin{split}v^s(r) \equiv v(r) - v^\ell(r)\:.\end{split}
\end{equation}
Then
\begin{equation}\label{equation:design_features:eq125}
\begin{split}v^\ell_k + v^s_k = v_k\:,\end{split}
\end{equation}
which then cancels out all terms for \(|\mathbf{k}| < k_c\). Then we
have
\begin{equation}\label{equation:design_features:eq126}
\begin{split}\begin{aligned}
\chi^2 & = & \frac{1}{\Omega} \int_\Omega d^3 \mathbf{r}\
\left|\sum_{|\mathbf{k}|>k_c} e^{i\mathbf{k}\cdot\mathbf{r}}
\left(v_k -v^s_k \right)\right|^2\:, \\
& = & \frac{1}{\Omega} \int_\Omega d^3 \mathbf{r}\
\left|\sum_{|\mathbf{k}|>k_c} e^{i\mathbf{k}\cdot\mathbf{r}} v^\ell_k \right|^2\:, \\
& = &
\frac{1}{\Omega} \int_\Omega d^3 \mathbf{r}
\left|\sum_{|\mathbf{k}|>k_c} e^{i\mathbf{k}\cdot\mathbf{r}}\left( -x_k + \sum_{n=0}^{J-1} t_n
c_{nk}\right) \right|^2\:.\end{aligned}\end{split}
\end{equation}
We expand the summation,
\begin{equation}\label{equation:design_features:eq127}
\begin{split}\chi^2 = \frac{1}{\Omega} \int_\Omega d^3 \mathbf{r}\negthickspace\negthickspace\negthickspace
\sum_{\{|\mathbf{k}|,|\mathbf{k}'|\}>k_c} \negthickspace\negthickspace\negthickspace\negthickspace\negthickspace
 e^{i(\mathbf{k}-\mathbf{k}')\cdot \mathbf{r}}
\left(x_k -\sum_{n=0}^{J-1} t_n c_{nk} \right)
\left(x_k -\sum_{m=0}^{J-1} t_{m} c_{mk'} \right)\:.\end{split}
\end{equation}
We take the derivative w.r.t. \(t_{m}\):
\begin{equation}\label{equation:design_features:eq128}
\begin{split}\frac{\partial (\chi^2)}{\partial t_{m}} =
\frac{2}{\Omega}\int_\Omega d^3 \mathbf{r}\negthickspace\negthickspace\negthickspace
\sum_{\{|\mathbf{k}|,|\mathbf{k}'|\}>k_c} \negthickspace\negthickspace\negthickspace\negthickspace\negthickspace
 e^{i(\mathbf{k}-\mathbf{k}')\cdot \mathbf{r}}
\left(x_k -\sum_{n=0}^{J-1} t_n c_{nk} \right) c_{mk'}\:.\end{split}
\end{equation}
We integrate w.r.t. \(\mathbf{r}\), yielding a Kronecker
\(\delta\).
\begin{equation}\label{equation:design_features:eq129}
\begin{split}\frac{\partial (\chi^2)}{\partial t_{m}} =
2 \negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace
\sum_{\ \ \ \ \{|\mathbf{k}|,|\mathbf{k}'|\}>k_c} \negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\delta_{\mathbf{k}, \mathbf{k}'}
\left(x_k -\sum_{n=0}^{J-1} t_n c_{nk} \right) c_{mk'}\:.\end{split}
\end{equation}
Summing over \(\mathbf{k}'\) and equating the derivative to zero, we
find the minimum of our error function is given by
\begin{equation}\label{equation:design_features:eq130}
\begin{split}\sum_{n=0}^{J-1} \sum_{|\mathbf{k}|>k_c} c_{mk}c_{nk} t_n =
\sum_{|\mathbf{k}|>k_c} x_k c_{mk}\:,\end{split}
\end{equation}
which is equivalent in form to Equation 19 in
\sphinxcite{design_features:natoli1995}, where we have \(x_k\) instead of
\(V_k\). Thus, we see that we can optimize the short\sphinxhyphen{} or long\sphinxhyphen{}range
potential simply by choosing to use \(V_k\) or \(x_k\) in the
preceding equation. We now define
\begin{equation}\label{equation:design_features:eq131}
\begin{split}\begin{aligned}
A_{mn} & \equiv & \sum_{|\mathbf{k}|>k_c} c_{mk} c_{nk}\:, \\
b_{m} & \equiv & \sum_{|\mathbf{k}|>k_c} x_k c_{mk}\:.\end{aligned}\end{split}
\end{equation}
Thus, it becomes clear that our minimization equations can be cast in
the canonical linear form
\begin{equation}\label{equation:design_features:eq132}
\begin{split}\mathbf{A}\mathbf{t} = \mathbf{b}\:.\end{split}
\end{equation}

\subsubsection{Solution by SVD}
\label{\detokenize{design_features:solution-by-svd}}
In practice, we note that the matrix \(\mathbf{A}\) frequently
becomes singular in practice. For this reason, we use the singular value
decomposition to solve for \(t_n\). This factorization decomposes
\(A\) as
\begin{equation}\label{equation:design_features:eq133}
\begin{split}\mathbf{A}= \mathbf{U}\mathbf{S}\mathbf{V}^T\:,\end{split}
\end{equation}
where \(\mathbf{U}^T\mathbf{U}= \mathbf{V}^T\mathbf{V}= 1\) and
\(\mathbf{S}\) is diagonal. In this form, we have
\begin{equation}\label{equation:design_features:eq134}
\begin{split}\mathbf{t} = \sum_{i=0}^{J-1} \left( \frac{\mathbf{U}_{(i)} \cdot
  \mathbf{b}}{\mathbf{S}_{ii}} \right) \mathbf{V}_{(i)}\:,\end{split}
\end{equation}
where the parenthesized subscripts refer to columns. The advantage of
this form is that if \(\mathbf{S}_{ii}\) is zero or very near zero,
the contribution of the \(i^{\text{th}}\) of \(\mathbf{V}\) may
be neglected since it represents a numerical instability and has little
physical meaning. It represents the fact that the system cannot
distinguish between two linear combinations of the basis functions.
Using the SVD in this manner is guaranteed to be stable. This
decomposition is available in LAPACK in the DGESVD subroutine.


\subsubsection{Constraining Values}
\label{\detokenize{design_features:constraining-values}}\label{\detokenize{design_features:constraints}}
Often, we wish to constrain the value of \(t_n\) to have a fixed
value to enforce a boundary condition, for example. To do this, we
define
\begin{equation}\label{equation:design_features:eq135}
\begin{split}\mathbf{b}' \equiv \mathbf{b}- t_n \mathbf{A}_{(n)}\:.\end{split}
\end{equation}
We then define \(\mathbf{A}^*\) as \(\mathbf{A}\) with the
\(n^{\text{th}}\) row and column removed and \(\mathbf{b}^*\) as
\(\mathbf{b}'\) with the \(n^{\text{th}}\) element removed. Then
we solve the reduced equation
\(\mathbf{A}^* \mathbf{t}^* = \mathbf{b}^*\) and finally insert
\(t_n\) back into the appropriate place in \(\mathbf{t}^*\) to
recover the complete, constrained vector \(\mathbf{t}\). This may be
trivially generalized to an arbitrary number of constraints.


\subsubsection{The LPQHI basis}
\label{\detokenize{design_features:the-lpqhi-basis}}
The preceding discussion is general and independent of the basis used to
represent \(v^\ell(r)\). In this section, we introduce a convenient
basis of localized interpolant functions, similar to those used for
splines, which have a number of properties that are convenient for our
purposes.

First, we divide the region from 0 to \(r_c\) into \(M-1\)
subregions, bounded above and below by points we term \sphinxstyleemphasis{knots}, defined
by \(r_j
\equiv j\Delta\), where \(\Delta \equiv r_c/(M-1)\). We then define
compact basis elements, \(h_{j\alpha}\), which span the region
\([r_{j-1},r_{j+1}]\), except for \(j=0\) and \(j=M\). For
\(j=0\), only the region \([r_0,r_1]\), while for \(j=M\),
only \([r_{M-1}, r_M]\). Thus, the index \(j\) identifies the
knot the element is centered on, while \(\alpha\) is an integer from
0 to 2 indicating one of three function shapes. The dual index can be
mapped to the preceding single index by the relation
\(n = 3j + \alpha\). The basis functions are then defined as
\begin{equation}\label{equation:design_features:eq136}
\begin{split}h_{j\alpha}(r) =
\begin{cases}
\ \ \ \, \Delta^\alpha \, \, \sum_{n=0}^5 S_{\alpha n}
\left( \frac{r-r_j}{\Delta}\right)^n,    & r_j < r \le r_{j+1} \\
(-\Delta)^\alpha \sum_{n=0}^5 S_{\alpha n}
\left( \frac{r_j-r}{\Delta}\right)^n,    & r_{j-1} < r \le r_j \\
\quad\quad\quad\quad\quad 0, & \text{otherwise}\:,
\end{cases}\end{split}
\end{equation}
where the matrix \(S_{\alpha n}\) is given by
\begin{equation}\label{equation:design_features:eq137}
\begin{split}S =
\left[\begin{matrix}
1 & 0 & 0 & -10 & 15 & -6 \\
0 & 1 & 0 & -6  &  8 & -3 \\
0 & 0 & \frac{1}{2} & -\frac{3}{2} & \frac{3}{2} & -\frac{1}{2}
\end{matrix}\right]\:.\end{split}
\end{equation}
\hyperref[\detokenize{design_features:fig26}]{Fig.\@ \ref{\detokenize{design_features:fig26}}} shows plots of these function shapes.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{LPQHI}.png}
\caption{Basis functions \(h_{j0}\), \(h_{j1}\), and \(h_{j2}\) are
shown. We note that at the left and right extremes, the values and first
two derivatives of the functions are zero; while at the center,
\(h_{j0}\) has a value of 1, \(h_{j1}\) has a first derivative
of 1, and \(h_{j2}\) has a second derivative of 1.}\label{\detokenize{design_features:id5}}\label{\detokenize{design_features:fig26}}\end{figure}

The basis functions have the property that at the left and right
extremes (i.e., \(r_{j-1}\) and \(r_{j+1}\)) their values and
first two derivatives are zero. At the center, \(r_j\), we have the
properties
\begin{equation}\label{equation:design_features:eq138}
\begin{split}\begin{aligned}
h_{j0}(r_j)=1, & h'_{j0}(r_j)=0, & h''_{j0}(r_j)= 0\:, \\
h_{j1}(r_j)=0, & h'_{j1}(r_j)=1, & h''_{j1}(r_j)= 0\:, \\
h_{j2}(r_j)=0, & h'_{j2}(r_j)=0, & h''_{j2}(r_j)= 1\:. \end{aligned}\end{split}
\end{equation}
These properties allow the control of the value and first two derivatives
of the represented function at any knot value simply by setting the
coefficients of the basis functions centered around that knot.  Used
in combination with the method described in
{\hyperref[\detokenize{design_features:constraints}]{\sphinxcrossref{\DUrole{std,std-ref}{Constraining Values}}}}, boundary conditions can easily be
enforced.  In our case, we wish require that
\begin{equation}\label{equation:design_features:eq139}
\begin{split}h_{M0} = v(r_c), \ \ h_{M1} = v'(r_c), \ \ \text{and} \ \  h_{M2} = v''(r_c)\:.\end{split}
\end{equation}
This ensures that \(v^s\) and its first two derivatives vanish at
\(r_c\).


\subsubsection{Fourier coefficients}
\label{\detokenize{design_features:fourier-coefficients}}
We wish now to calculate the Fourier transforms of the basis
functions, defined as
\begin{equation}\label{equation:design_features:eq140}
\begin{split}c_{j\alpha k} \equiv \frac{1}{\Omega} \int_0^{r_c} d^3 \mathbf{r}
e^{-i \mathbf{k}\cdot \mathbf{r}} h_{j\alpha}(r)\:.\end{split}
\end{equation}
We may then write,
\begin{equation}\label{equation:design_features:eq141}
\begin{split}c_{j\alpha k} =
\begin{cases}
\Delta^\alpha \sum_{n=0}^5 S_{\alpha n} D^+_{0 k n}, & j = 0 \\
\Delta^\alpha \sum_{n=0}^5 S_{\alpha n} (-1)^{\alpha+n} D^-_{M k n}, &
j = M \\
\Delta^\alpha \sum_{n=0}^5 S_{\alpha n}
\left[ D^+_{j k n} + (-1)^{\alpha+n}D^-_{j k n} \right] & \text{otherwise}\:,
\end{cases}\end{split}
\end{equation}
where
\begin{equation}\label{equation:design_features:eq142}
\begin{split}D^{\pm}_{jkn} \equiv \frac{1}{\Omega} \int_{r_j}^{r_{j\pm1}} d^3\!\mathbf{r}\
e^{-i\mathbf{k}\cdot \mathbf{r}} \left( \frac{r-r_j}{\Delta}\right)^n\:.\end{split}
\end{equation}
We then further make the definition that
\begin{equation}\label{equation:design_features:eq143}
\begin{split}D^{\pm}_{jkn} = \pm \frac{4\pi}{k \Omega}
\left[ \Delta \text{Im}\left(E^{\pm}_{jk(n+1)}\right) +
r_j \text{Im}\left(E^{\pm}_{jkn}\right)\right]\:.\end{split}
\end{equation}
It can then be shown that
\begin{equation}\label{equation:design_features:eq144}
\begin{split}E^{\pm}_{jkn} =
\begin{cases}
-\frac{i}{k} e^{ikr_j} \left( e^{\pm i k \Delta} - 1 \right) &
\text{if } n=0, \\
-\frac{i}{k}
\left[ \left(\pm1\right)^n e^{i k (r_j \pm \Delta)} - \frac{n}{\Delta}
E^\pm_{jk(n-1)}  \right] & \text{otherwise}\:.
\end{cases}\end{split}
\end{equation}
Note that these equations correct typographical errors present in \sphinxcite{design_features:natoli1995}.


\subsubsection{Enumerating \protect\(k\protect\)\sphinxhyphen{}points}
\label{\detokenize{design_features:enumerating-k-points}}
We note that the summations over \(k\), which are ubiquitous in this
paper, require enumeration of the \(k\)\sphinxhyphen{}vectors. In particular, we
should sum over all \(|\mathbf{k}| > k_c\). In practice, we must
limit our summation to some finite cutoff value
\(k_c < |\mathbf{k}| < k_{\text{max}}\), where
\(k_{\text{max}}\) should be on the order of \(3,000/L\), where
\(L\) is the minimum box dimension. Enumerating these vectors in a
naive fashion even for this finite cutoff would prove quite prohibitive,
as it would require \(\sim10^9\) vectors.

Our first optimization comes in realizing that all quantities in this
calculation require only \(|\mathbf{k}|\) and not \(\mathbf{k}\)
itself. Thus, we may take advantage of the great degeneracy of
\(|\mathbf{k}|\). We create a list of \((k,N)\) pairs, where
\(N\) is the number of vectors with magnitude \(k\). We make
nested loops over \(n_1\), \(n_2\), and \(n_3\), yielding
\(\mathbf{k}= n_1 \mathbf{b}_1 + n_2 \mathbf{b}_2 + n_3
\mathbf{b}_3\). If \(|\mathbf{k}|\) is in the required range, we
check to see whether there is already an entry with that magnitude on
our list and increment the corresponding \(N\) if there is, or
create a new entry if not. Doing so typically saves a factor of
\(\sim200\) in storage and computation.

This reduction is not sufficient for large \(k_max\) since it
requires that we still look over \(10^9\) entries. To further reduce
costs, we may pick an intermediate cutoff, \(k_{\text{cont}}\),
above which we will approximate the degeneracy assuming a continuum of
\(k\)\sphinxhyphen{}points. We stop our exact enumeration at
\(k_{\text{cont}}\) and then add \(\sim1,000\) points,
\(k_i\), uniformly spaced between \(k_{\text{cont}}\) and
\(k_{\text{max}}\). We then approximate the degeneracy by
\begin{equation}\label{equation:design_features:eq145}
\begin{split}N_i = \frac{4 \pi}{3} \frac{\left( k_b^3 -k_a^3\right)}{(2\pi)^3/\Omega}\:,\end{split}
\end{equation}
where \(k_b = (k_i + k_{i+1})/2\) and \(k_a = (k_i + k_{i-1})\).
In doing so, we typically reduce our total number of k\sphinxhyphen{}points to sum
more than \(\sim2,500\) from the \(10^9\) we had to start.


\subsubsection{Calculating \protect\(x_k\protect\)’s}
\label{\detokenize{design_features:calculating-x-k-s}}

\paragraph{The Coulomb potential}
\label{\detokenize{design_features:id4}}
For \(v(r) = \frac{1}{r}\), \(x_k\) is given by
\begin{equation}\label{equation:design_features:eq146}
\begin{split}x_k^{\text{coulomb}} = -\frac{4 \pi}{\Omega k^2} \cos(k r_c)\:.\end{split}
\end{equation}

\paragraph{The \protect\(1/r^2\protect\) potential}
\label{\detokenize{design_features:the-1-r-2-potential}}
For \(v(r) = \frac{1}{r^2}\), \(x_k\) is given by
\begin{equation}\label{equation:design_features:eq147}
\begin{split}x_k^{1/r^2} = \frac{4 \pi}{\omega k}
\left[ \text{Si}(k r_c) -\frac{\pi}{2}\right],\end{split}
\end{equation}
where the \sphinxstyleemphasis{sin integral}, \(\text{Si}(z)\), is given by
\begin{equation}\label{equation:design_features:eq148}
\begin{split}\text{Si}(z) \equiv \int_0^z \frac{\sin \ t}{t} dt\:.\end{split}
\end{equation}

\paragraph{The \protect\(1/r^3\protect\) potential}
\label{\detokenize{design_features:the-1-r-3-potential}}
For \(v(r) = \frac{1}{r^3}\), \(x_k\) is given by
\begin{equation}\label{equation:design_features:eq149}
\begin{split}x_k^{1/r^2} = \frac{4 \pi}{\omega k}
\left[ \text{Si}(k r_c) -\frac{\pi}{2}\right],\end{split}
\end{equation}
where the \sphinxstyleemphasis{cosine integral}, \(\text{Ci}(z)\), is given by
\begin{equation}\label{equation:design_features:eq150}
\begin{split}\text{Ci}(z) \equiv -\int_z^\infty \frac{\cos t}{t} dt\:.\end{split}
\end{equation}

\paragraph{The \protect\(1/r^4\protect\) potential}
\label{\detokenize{design_features:the-1-r-4-potential}}
For \(v(r) = \frac{1}{r^4}\), \(x_k\) is given by
\begin{equation}\label{equation:design_features:eq151}
\begin{split}x_k^{1/r^4} = -\frac{4 \pi}{\Omega k}
\left\{
\frac{k \cos(k r_c)}{2 r_c} + \frac{\sin(k r_c)}{2r_c^2} + \frac{k^2}{2} \left[ \text{Si}(k r_c) - \frac{\pi}{2}\right]\right\}\:.\end{split}
\end{equation}

\section{Feature: Optimized long\sphinxhyphen{}range breakup (Ewald) 2}
\label{\detokenize{design_features:feature-optimized-long-range-breakup-ewald-2}}
Given a lattice of vectors \(\mathbf{L}\), its associated reciprocal
lattice of vectors \(\mathbf{k}\) and a function
\(\psi(\mathbf{r})\) periodic on the lattice we define its Fourier
transform \(\widetilde{\psi}(\mathbf{k})\) as
\begin{equation}\label{equation:design_features:eq152}
\begin{split}\widetilde{\psi}(\mathbf{k})=\frac{1}{\Omega}\int_\Omega d\mathbf{r}\psi(\mathbf{r}) e^{-i\mathbf{k}\mathbf{r}}\:,\end{split}
\end{equation}
where we indicated both the cell domain and the cell volume by
\(\Omega\). \(\psi(\mathbf{r})\) can then be expressed as
\begin{equation}\label{equation:design_features:eq153}
\begin{split}\psi(\mathbf{r})=\sum_{\mathbf{k}} \widetilde{\psi}(\mathbf{k})e^{i\mathbf{k}\mathbf{r}}\:.\end{split}
\end{equation}
The potential generated by charges sitting on the lattice positions at a
particular point \(\mathbf{r}\) inside the cell is given by
\begin{equation}\label{equation:design_features:eq154}
\begin{split}V(\mathbf{r})=\sum_{\mathbf{L}}v(|\mathbf{r}+\mathbf{L}|)\:,\end{split}
\end{equation}
and its Fourier transform can be explicitly written as a function of
\(V\) or \(v\)
\begin{equation}\label{equation:design_features:eq155}
\begin{split}\widetilde{V}(\mathbf{k})=\frac{1}{\Omega}\int_\Omega d\mathbf{r}V(\mathbf{r}) e^{-i\mathbf{k}\mathbf{r}}=
\frac{1}{\Omega}\int_{\mathbb{R}^3} d\mathbf{r}v(\mathbf{r}) e^{-i\mathbf{k}\mathbf{r}}\:,\end{split}
\end{equation}
where \(\mathbb{R}^3\) denotes the whole 3D space. We now want to
find the best (“best” to be defined later) approximate potential of the
form
\begin{equation}\label{equation:design_features:eq156}
\begin{split}V_a(\mathbf{r})=\sum_{k\le k_c} \widetilde{Y}(k) e^{i\mathbf{k}\mathbf{r}} + W(r)\:,\end{split}
\end{equation}
where \(W(r)\) has been chosen to go smoothly to \(0\) when
\(r=r_c\), being \(r_c\) lower or equal to the Wigner\sphinxhyphen{}Seitz
radius of the cell. Note also the cutoff \(k_c\) on the momentum
summation.

The best form of \(\widetilde{Y}(k)\) and \(W(r)\) is given by
minimizing
\begin{equation}\label{equation:design_features:eq157}
\begin{split}\chi^2=\frac{1}{\Omega}\int d\mathbf{r}\left(V(\mathbf{r})-W(\mathbf{r})-
  \sum_{k\le k_c}\widetilde{Y}(k)e^{i\mathbf{k}\mathbf{r}}\right)^2
  \:,\end{split}
\end{equation}
or the reciprocal space equivalent
\begin{equation}\label{equation:design_features:eq158}
\begin{split}\chi^2=\sum_{k\le k_c}(\widetilde{V}(k)-\widetilde{W}(k)-\widetilde{Y}(k))^2+\sum_{k>k_c}(\widetilde{V}(k)-\widetilde{W}(k))^2
  \:.\end{split}
\end{equation}
\eqref{equation:design_features:eq158} follows from \eqref{equation:design_features:eq157} and the unitarity
(norm conservation) of the Fourier transform.

This last condition is minimized by
\begin{equation}\label{equation:design_features:eq159}
\begin{split}\widetilde{Y}(k)=\widetilde{V}(k)-\widetilde{W}(k)\qquad \min_{\widetilde{W}(k)}\sum_{k>k_c}(\widetilde{V}(k)-\widetilde{W}(k))^2.\end{split}
\end{equation}
We now use a set of basis function \(c_i(r)\) vanishing smoothly at
\(r_c\) to expand \(W(r)\); that is,
\begin{equation}\label{equation:design_features:eq160}
\begin{split}W(r)=\sum_i t_i c_i(r)\qquad\text{or}\qquad \widetilde{W}(k)=\sum_i t_i \widetilde{c}_i(k)\:.\end{split}
\end{equation}
Inserting the reciprocal space expansion of \(\widetilde{W}\) in the
second condition of \eqref{equation:design_features:eq159} and minimizing with respect to
\(t_i\) leads immediately to the linear system
\(\mathbf{A}\mathbf{t}=\mathbf{b}\) where
\begin{equation}\label{equation:design_features:eq161}
\begin{split} \begin{aligned}
 A_{ij}=\sum_{k>k_c}\widetilde{c}_i(k)\widetilde{c}_j(k)\qquad b_j=\sum_{k>k_c} V(k) \widetilde{c}_j(k)
 \:.\end{aligned}\end{split}
\end{equation}

\subsection{Basis functions}
\label{\detokenize{design_features:basis-functions}}
The basis functions are splines. We define a uniform grid with
\(N_{\text{knot}}\) uniformly spaced knots at position
\(r_i=i\frac{r_c}{N_{\text{knot}}}\), where
\(i\in[0,N_{\text{knot}}-1]\). On each knot we center \(m+1\)
piecewise polynomials \(c_{i\alpha}(r)\) with
\(\alpha\in[0,m]\), defined as
\begin{equation}\label{equation:design_features:eq162}
\begin{split} \begin{aligned}
 c_{i\alpha}(r)=\begin{cases}
 \Delta^\alpha \sum_{n=0}^\mathcal{N} S_{\alpha n}(\frac{r-r_i}{\Delta})^n & r_i<r\le r_{i+1} \\
 \Delta^{-\alpha} \sum_{n=0}^\mathcal{N} S_{\alpha n}(\frac{r_i-r}{\Delta})^n & r_{i-1}<r\le r_i \\
 0 & |r-r_i| > \Delta
 \end{cases}
 \:.\end{aligned}\end{split}
\end{equation}
These functions and their derivatives are, by construction, continuous
and odd (even) (with respect to \(r-r_i\rightarrow r_i-r\)) when
\(\alpha\) is odd (even). We further ask them to satisfy
\begin{equation}\label{equation:design_features:eq163}
\begin{split} \begin{aligned}
 \left.\frac{d^\beta}{dr^\beta} c_{i\alpha}(r)\right|_{r=r_i}=
 \delta_{\alpha\beta} \quad \beta\in[0,m]\:,\\
 \left.\frac{d^{\beta}}{dr^{\beta}} c_{i\alpha}(r)\right|_{r=r_{i+1}}=0\quad \beta\in[0,m]
 \:.\end{aligned}\end{split}
\end{equation}
(The parity of the functions guarantees that the second constraint is
satisfied at \(r_{i-1}\) as well). These constraints have a simple
interpretation: the basis functions and their first \(m\)
derivatives are \(0\) on the boundary of the subinterval where they
are defined; the only function to have a nonzero \(\beta\)\sphinxhyphen{}th
derivative in \(r_i\) is \(c_{i\beta}\). These \(2(m+1)\)
constraints therefore impose \(\mathcal{N}=2m+1\). Inserting the
definitions of \eqref{equation:design_features:eq162} in the constraints of
\eqref{equation:design_features:eq163} leads to the set of \(2(m+1)\) linear equation
that fixes the value of \(S_{\alpha n}\):
\begin{equation}\label{equation:design_features:eq164}
\begin{split} \begin{aligned}
 \Delta^{\alpha-\beta} S_{\alpha\beta} \beta!=\delta_{\alpha\beta}
 \\
 \Delta^{\alpha-\beta}\sum_{n=\beta}^{2m+1} S_{\alpha n} \frac{n!}{(n-\beta)!}=0\:.\end{aligned}\end{split}
\end{equation}
We can further simplify inserting the first of these equations into the
second and write the linear system as
\begin{equation}\label{equation:design_features:eq165}
\begin{split} \sum_{n=m+1}^{2m+1} S_{\alpha n} \frac{n!}{(n-\beta)!}=\begin{cases}
 -\frac{1}{(\alpha-\beta)!}& \alpha\ge \beta \\
 0 & \alpha < \beta
 \end{cases}
 \:.\end{split}
\end{equation}

\subsection{Fourier components of the basis functions in 3D}
\label{\detokenize{design_features:fourier-components-of-the-basis-functions-in-3d}}

\subsubsection{\protect\(k\ne 0\protect\), non\sphinxhyphen{}Coulomb case}
\label{\detokenize{design_features:k-ne-0-non-coulomb-case}}
We now need to evaluate the Fourier transform
\(\widetilde{c}_{i\alpha}(k)\). Let us start by writing the
definition
\begin{equation}\label{equation:design_features:eq166}
\begin{split}\widetilde{c}_{i\alpha}(k)=\frac{1}{\omega}\int_\Omega d\mathbf{r}e^{-i\mathbf{k}\mathbf{r}} c_{i\alpha}(r)\:.\end{split}
\end{equation}
Because \(c_{i\alpha}\) is different from zero only inside the
spherical crown defined by \(r_{i-1}<r<r_i\), we can conveniently
compute the integral in spherical coordinates as
\begin{equation}\label{equation:design_features:eq167}
\begin{split} \begin{aligned}
 \widetilde{c}_{i\alpha}(k)=\Delta^\alpha\sum_{n=0}^\mathcal{N} S_{\alpha n} \left[
 D_{in}^+(k) +w_{\text{knot}}(-1)^{\alpha+n}D_{in}^-(k)\right]\:,
 \end{aligned}\end{split}
\end{equation}
where we used the definition \(w_{\text{knot}}=1-\delta_{i0}\) and
\begin{equation}\label{equation:design_features:eq168}
\begin{split} D_{in}^\pm(k)=\pm\frac{4\pi}{k\Omega}\text{Im}\left[\int_{r_i}^{r_i\pm\Delta}
 dr\left(\frac{r-r_i}{\Delta}\right)^n r e^{ikr}\right]\:,\end{split}
\end{equation}
obtained by integrating the angular part of the Fourier transform. Using
the identity
\begin{equation}\label{equation:design_features:eq169}
\begin{split}\left(\frac{r-r_i}{\Delta}\right)^n r=\Delta\left(\frac{r-r_i}{\Delta}\right)^{n+1}+\left(\frac{r-r_i}{\Delta}\right)^n r_i\end{split}
\end{equation}
and the definition
\begin{equation}\label{equation:design_features:eq170}
\begin{split} E_{in}^\pm(k)=\int_{r_i}^{r_i\pm\Delta}
 dr\left(\frac{r-r_i}{\Delta}\right)^n e^{ikr}\:,\end{split}
\end{equation}
we rewrite Equation \eqref{equation:design_features:eq168} as
\begin{equation*}
\begin{split}\begin{aligned}
D_{in}^\pm(k)=\pm\frac{4\pi}{k\Omega}\text{Im}\left[\Delta E_{i(n+1)}^\pm(k)+
r_i E_{in}^\pm(k)\right]\:.
\end{aligned}\end{split}
\end{equation*}
Finally, using integration by part, we can define \(E^\pm_{in}\)
recursively as
\begin{equation}\label{equation:design_features:eq171}
\begin{split} \begin{aligned}
 E^\pm_{in}(k)=\frac{1}{ik}\left[(\pm)^ne^{ik(r_i\pm\Delta)}-\frac{n}{\Delta}
 E^\pm_{i(n-1)}(k)\right]\:.
 \end{aligned}\end{split}
\end{equation}
Starting from the \(n=0\) term,
\begin{equation}\label{equation:design_features:eq172}
\begin{split} \begin{aligned}
 E^\pm_{i0}(k)=\frac{1}{ik}e^{ikr_i}\left(e^{\pm ik\Delta}-1\right)\:.
 \end{aligned}\end{split}
\end{equation}

\subsubsection{\protect\(k\ne 0\protect\), Coulomb case}
\label{\detokenize{design_features:k-ne-0-coulomb-case}}
To efficiently treat the Coulomb divergence at the origin, it is
convenient to use a basis set \(c_{i\alpha}^{\text{coul}}\) of the
form
\begin{equation}\label{equation:design_features:eq173}
\begin{split}c_{i\alpha}^{\text{coul}}=\frac{c_{i\alpha}}{r}\:.\end{split}
\end{equation}
An equation identical to \eqref{equation:design_features:eq168} holds but with the modified
definition
\begin{equation}\label{equation:design_features:eq174}
\begin{split} D_{in}^\pm(k)=\pm\frac{4\pi}{k\Omega}\text{Im}\left[\int_{r_i}^{r_i\pm\Delta}
 dr\left(\frac{r-r_i}{\Delta}\right)^n e^{ikr}\right]\:,\end{split}
\end{equation}
which can be simply expressed using \(E^\pm_{in}(k)\) as
\begin{equation}\label{equation:design_features:eq175}
\begin{split} \begin{aligned}
 D_{in}^\pm(k)=\pm\frac{4\pi}{k\Omega}\text{Im}\left[E_{in}^\pm(k)\right]\:.
 \end{aligned}\end{split}
\end{equation}

\subsubsection{\protect\(k=0\protect\) Coulomb and non\sphinxhyphen{}Coulomb case}
\label{\detokenize{design_features:k-0-coulomb-and-non-coulomb-case}}
The definitions of \(D_{in}(k)\) given so far are clearly
incompatible with the choice \(k=0\) (they involve division by
\(k\)). For the non\sphinxhyphen{}Coulomb case, the starting definition is
\begin{equation}\label{equation:design_features:eq176}
\begin{split} D^\pm_{in}(0)=\pm\frac{4\pi}{\Omega}\int_{r_i}^{r_i\pm\Delta}r^2
 \left(\frac{r-r_i}{\Delta}\right)^ndr\:.\end{split}
\end{equation}
Using the definition \(I_n^\pm=(\pm)^{n+1}\Delta/(n+1)\), we can
express this as
\begin{equation}\label{equation:design_features:eq177}
\begin{split} \begin{aligned}
 D^\pm_{in}(0)=\pm\frac{4\pi}{\Omega}\left[\Delta^2 I_{n+2}^\pm
 +2r_i\Delta I_{n+1}^\pm+2r_i^2I_n^\pm\right]\:.
 \end{aligned}\end{split}
\end{equation}
For the Coulomb case, we get
\begin{equation}\label{equation:design_features:eq178}
\begin{split} \begin{aligned}
 D^\pm_{in}(0)=\pm\frac{4\pi}{\Omega}\left(
 \Delta I^\pm_{n+1} + r_i I^\pm_n\right)\:.
 \end{aligned}\end{split}
\end{equation}

\subsection{Fourier components of the basis functions in 2D}
\label{\detokenize{design_features:fourier-components-of-the-basis-functions-in-2d}}
\eqref{equation:design_features:eq167} still holds provided we define
\begin{equation}\label{equation:design_features:eq179}
\begin{split} D^\pm_{in}(k)=\pm\frac{2\pi}{\Omega \Delta^n} \sum_{j=0}^n \binom{n}{j}
 (-r_i)^{n-j}\int_{r_i}^{r_i\pm \Delta}\negthickspace \negthickspace
 \negthickspace \negthickspace \negthickspace \negthickspace \negthickspace
 dr r^{j+1-C} J_0(kr)\:,\end{split}
\end{equation}
where \(C=1(=0)\) for the Coulomb(non\sphinxhyphen{}Coulomb) case.
\eqref{equation:design_features:eq179} is obtained using the integral definition of the
zero order Bessel function of the first kind:
\begin{equation}\label{equation:design_features:eq180}
\begin{split}J_0(z)=\frac{1}{\pi}\int_0^\pi e^{iz\cos\theta}d\theta\:,\end{split}
\end{equation}
and the binomial expansion for \((r-r_i)^n\). The integrals can be
computed recursively using the following identities:
\begin{equation}\label{equation:design_features:eq181}
\begin{split} \begin{aligned}
 &\int dz J_0(z)=\frac{z}{2}\left[\pi J_1(z)H_0(z)+J_0(z)(2-\pi H_1(z))\right]
 \:,\\
 &\int dz z J_0(z)= z J_1(z)
 \:,\\
 &\int dz z^n J_0(z)= z^nJ_1(z)+(n-1)x^{n-1}J_0(z)
 -(n-1)^2\int dz z^{n-2} J_0(z)\:.
 \end{aligned}\end{split}
\end{equation}
The bottom equation of \eqref{equation:design_features:eq181} is obtained using the second equation in the same set, integration by part, and
the identity \(\int J_1(z) dz =-J_0(z)\). In the top equation, \(H_0\) and \(H_1\) are Struve functions.


\subsection{Construction of the matrix elements}
\label{\detokenize{design_features:construction-of-the-matrix-elements}}
Using the previous equations, we can construct the matrix elements in
\eqref{equation:design_features:eq161} and proceed solving for \(t_i\). It is
sometimes desirable to put some constraints on the value of \(t_i\).
For example, when the Coulomb potential is concerned, we might want to
set \(t_{0}=1\). If the first \(g\) variable is constrained by
\(t_{m}=\gamma_m\) with \(m=[1,g]\), we can simply redefine
\eqref{equation:design_features:eq161} as
\begin{equation}\label{equation:design_features:182}
\begin{split} \begin{split}
 A_{ij}=&\sum_{k>k_c} \widetilde{c}_i(k)\widetilde{c}_j(k)  \quad i,j\notin[1,g]\:, \\
 b_j=&\sum_{k>k_c} \left(\widetilde{V}(k)-\sum_{m=1}^g \gamma_m \widetilde{c}_m(k)\right)\widetilde{c}_j(k)\quad j\notin[1,g]\:.
 \end{split}\end{split}
\end{equation}

\section{Feature: Cubic spline interpolation}
\label{\detokenize{design_features:feature-cubic-spline-interpolation}}
We present the basic equations and algorithms necessary to
construct and evaluate cubic interpolating splines in one, two, and
three dimensions.  Equations are provided for both natural and
periodic boundary conditions.


\subsection{One dimension}
\label{\detokenize{design_features:one-dimension}}
Let us consider the problem in which we have a function \(y(x)\)
specified at a discrete set of points \(x_i\), such that
\(y(x_i) = y_i\). We wish to construct a piecewise cubic polynomial
interpolating function, \(f(x)\), which satisfies the following
conditions:
\begin{itemize}
\item {} 
\(f(x_i) = y_i\).

\item {} 
\(f'(x_i^-) = f'(x_i^+)\).

\item {} 
\(f''(x_i^-) = f''(x_i+)\).

\end{itemize}


\subsubsection{Hermite interpolants}
\label{\detokenize{design_features:hermite-interpolants}}
In our piecewise representation, we wish to store only the values
\(y_i\) and first derivatives, \(y'_i\), of our function at each
point \(x_i\), which we call \sphinxstyleemphasis{knots}. Given this data, we wish to
construct the piecewise cubic function to use between \(x_i\) and
\(x_{i+1}\), which satisfies the preceding conditions. In
particular, we wish to find the unique cubic polynomial, \(P(x)\),
satisfying
\begin{equation}\label{equation:design_features:eq183}
\begin{split} \begin{aligned}
 P(x_i)      & = & y_i      \:, \\
 P(x_{i+1})  & = & y_{i+1}  \:, \\
 P'(x_i)     & = & y'_i     \:, \\
 P'(x_{i+1}) & = & y'_{i+1} \:.\end{aligned}\end{split}
\end{equation}\begin{equation}\label{equation:design_features:eq184}
\begin{split} \begin{aligned}
 h_i & \equiv & x_{i+1} - {x_i}\:, \\
 t & \equiv & \frac{x-x_i}{h_i}\:.\end{aligned}\end{split}
\end{equation}
We then define the basis functions,
\begin{equation}\label{equation:design_features:eq185}
\begin{split} \begin{aligned}
 p_1(t) & = & (1+2t)(t-1)^2  \:, \\
 q_1(t) & = & t (t-1)^2\:,       \\
 p_2(t) & = & t^2(3-2t)\:,       \\
 q_2(t) & = & t^2(t-1)\:.       \end{aligned}\end{split}
\end{equation}
On the interval, \((x_i, x_{i+1}]\), we define the interpolating
function
\begin{equation}\label{equation:design_features:eq186}
\begin{split}P(x) = y_i p_1(t) + y_{i+1}p_2(t) + h\left[y'_i q_1(t) + y'_{i+1} q_2(t)\right]\:.\end{split}
\end{equation}
It can be easily verified that \(P(x)\) satisfies conditions of
equations 1 through 3 of \eqref{equation:design_features:eq183}. It is now left to determine the
proper values for the \(y'_i\,\)s such that the continuity
conditions given previously are satisfied.

By construction, the value of the function and derivative will match at
the knots; that is,
\begin{equation*}
\begin{split}P(x_i^-) = P(x_i^+), \ \ \ \ P'(x_i^-) = P'(x_i^+)\:.\end{split}
\end{equation*}
Then we must now enforce only the second derivative continuity:
\begin{equation}\label{equation:design_features:eq187}
\begin{split} \begin{aligned}
 P''(x_i^-) & = & P''(x_i^+)\:,  \\
 \frac{1}{h_{i-1}^2}\left[\rule{0pt}{0.3cm}6 y_{i-1} -6 y_i + h_{i-1}\left(2 y'_{i-1} +4 y'_i\right) \right]& = &
 \frac{1}{h_i^2}\left[\rule{0pt}{0.3cm}-6 y_i + 6 y_{i+1} +h_i\left( -4 y'_i -2 y'_{i+1} \right)\right] \nonumber\:. \end{aligned}\end{split}
\end{equation}
Let us define
\begin{equation}\label{equation:design_features:eq188}
\begin{split} \begin{aligned}
 \lambda_i & \equiv & \frac{h_i}{2(h_i+h_{i-1})}\:,  \\
 \mu_i & \equiv & \frac{h_{i-1}}{2(h_i+h_{i-1})}  = \frac{1}{2} - \lambda_i\:. \end{aligned}\end{split}
\end{equation}
Then we may rearrange
\begin{equation}\label{equation:design_features:eq189}
\begin{split} \lambda_i y'_{i-1} + y'_i + \mu_i y'_{i+1} = \underbrace{3 \left[\lambda_i \frac{y_i - y_{i-1}}{h_{i-1}} + \mu_i \frac{y_{i+1}
     - y_i}{h_i} \right] }_{d_i}\:.\end{split}
\end{equation}
This equation holds for all \(0<i<(N-1)\), so we have a tridiagonal
set of equations. The equations for \(i=0\) and \(i=N-1\) depend
on the boundary conditions we are using.


\subsubsection{Periodic boundary conditions}
\label{\detokenize{design_features:periodic-boundary-conditions}}
For periodic boundary conditions, we have
\begin{equation}\label{equation:design_features:eq190}
\begin{split} \begin{matrix}
 y'_0           & +  & \mu_0 y'_1     &   &                   &            & \dots                   & +  \lambda_0 y'_{N-1} & = & d_0\:,  \\
 \lambda_1 y'_0 & +  & y'_1           & + &  \mu_1 y'_2       &            & \dots                   &                       & = & d_1\:,  \\
                &    & \lambda_2 y'_1 & + &  y'_2           + & \mu_2 y'_3 & \dots                   &                       & = & d_2\:,  \\
                &    &                &   &  \vdots           &            &                         &                       &   &     \\
 \mu_{N-1} y'_0 &    &                &   &                   &            & +\lambda_{N-1} y'_{N-1} & +  y'_{N-2}           & = & d_3\:.
 \end{matrix}\end{split}
\end{equation}
Or, in matrix form, we have
\begin{equation}\label{equation:design_features:eq191}
\begin{split}   \begin{pmatrix}
   1         & \mu_0     &    0   &   0           & \dots         &      0        & \lambda_0 \\
   \lambda_1 &  1        & \mu_1  &   0           & \dots         &      0        &     0     \\
   0         & \lambda_2 &   1    & \mu_2         & \dots         &      0        &     0     \\
   \vdots    & \vdots    & \vdots & \vdots        & \ddots        &   \vdots      &  \vdots   \\
   0         &   0       &   0    & \lambda_{N-3} &      1        & \mu_{N-3}     &    0      \\
   0         &   0       &   0    &   0           & \lambda_{N-2} &      1        & \mu_{N-2} \\
   \mu_{N-1} &   0       &   0    &   0           &   0           & \lambda_{N-1} &  1
   \end{pmatrix}
   \begin{pmatrix} y'_0 \\ y'_1 \\ y'_2 \\ \vdots \\ y'_{N-3} \\ y'_{N-2} \\ y'_{N-1} \end{pmatrix} =
   \begin{pmatrix} d_0  \\  d_1 \\  d_2 \\ \vdots \\  d_{N-3} \\  d_{N-2} \\  d_{N-1} \end{pmatrix} .\end{split}
\end{equation}
The system is tridiagonal except for the two elements in the upper right
and lower left corners. These terms complicate the solution a bit,
although it can still be done in \(\mathcal{O}(N)\) time. We first
proceed down the rows, eliminating the the first non\sphinxhyphen{}zero term in each
row by subtracting the appropriate multiple of the previous row. At the
same time, we eliminate the first element in the last row, shifting the
position of the first non\sphinxhyphen{}zero element to the right with each iteration.
When we get to the final row, we will have the value for
\(y'_{N-1}\). We can then proceed back upward, backsubstituting
values from the rows below to calculate all the derivatives.


\subsubsection{Complete boundary conditions}
\label{\detokenize{design_features:complete-boundary-conditions}}
If we specify the first derivatives of our function at the end points,
we have what is known as \sphinxstyleemphasis{complete} boundary conditions.  The
equations in that case are trivial to solve:
\begin{equation}\label{equation:design_features:eq192}
\begin{split} \begin{pmatrix}
 1         &  0        &    0   &   0           & \dots         &      0        &     0     \\
 \lambda_1 &  1        & \mu_1  &   0           & \dots         &      0        &     0     \\
 0         & \lambda_2 &   1    & \mu_2         & \dots         &      0        &     0     \\
 \vdots    & \vdots    & \vdots & \vdots        & \ddots        &   \vdots      &  \vdots   \\
 0         &   0       &   0    & \lambda_{N-3} &      1        & \mu_{N-3}     &    0      \\
 0         &   0       &   0    &   0           & \lambda_{N-2} &      1        & \mu_{N-2} \\
 0         &   0       &   0    &   0           &   0           &      0        &  1
 \end{pmatrix}
 \begin{pmatrix} y'_0 \\ y'_1 \\ y'_2 \\ \vdots \\ y'_{N-3} \\ y'_{N-2} \\ y'_{N-1} \end{pmatrix} =
 \begin{pmatrix} d_0  \\  d_1 \\  d_2 \\ \vdots \\  d_{N-3} \\  d_{N-2} \\  d_{N-1} \end{pmatrix} .\end{split}
\end{equation}
This system is completely tridiagonal, and we may solve trivially by
performing row eliminations downward, then proceeding upward as before.


\subsubsection{Natural boundary conditions}
\label{\detokenize{design_features:natural-boundary-conditions}}
If we do not have information about the derivatives at the boundary
conditions, we may construct a \sphinxstyleemphasis{natural spline}, which assumes the
second derivatives are zero at the end points of our spline. In this
case our system of equations is the following:
\begin{equation}\label{equation:design_features:eq193}
\begin{split} \begin{pmatrix}
 1         & \frac{1}{2} &    0   &   0           & \dots         &      0        &     0     \\
 \lambda_1 &  1          & \mu_1  &   0           & \dots         &      0        &     0     \\
 0         & \lambda_2   &   1    & \mu_2         & \dots         &      0        &     0     \\
 \vdots    & \vdots      & \vdots & \vdots        & \ddots        &   \vdots      &  \vdots   \\
 0         &   0         &   0    & \lambda_{N-3} &      1        & \mu_{N-3}     &    0      \\
 0         &   0         &   0    &   0           & \lambda_{N-2} &      1        & \mu_{N-2} \\
 0         &   0         &   0    &   0           &   0           &  \frac{1}{2}  &  1
 \end{pmatrix}
 \begin{pmatrix} y'_0 \\ y'_1 \\ y'_2 \\ \vdots \\ y'_{N-3} \\ y'_{N-2} \\ y'_{N-1} \end{pmatrix} =
 \begin{pmatrix} d_0  \\  d_1 \\  d_2 \\ \vdots \\  d_{N-3} \\  d_{N-2} \\  d_{N-1} \end{pmatrix} ,\end{split}
\end{equation}
with
\begin{equation}\label{equation:design_features:eq194}
\begin{split}d_0 = \frac{3}{2} \frac{y_1-y_1}{h_0}\:,  \ \ \ \ \ d_{N-1} = \frac{3}{2} \frac{y_{N-1}-y_{N-2}}{h_{N-1}}\:.\end{split}
\end{equation}

\subsection{Bicubic splines}
\label{\detokenize{design_features:bicubic-splines}}
It is possible to extend the cubic spline interpolation method to
functions of two variables, that is, \(F(x,y)\). In this case, we
have a rectangular mesh of points given by
\(F_{ij} \equiv F(x_i,y_j)\). In the case of 1D splines, we needed
to store the value of the first derivative of the function at each
point, in addition to the value. In the case of \sphinxstyleemphasis{bicubic splines}, we
need to store four quantities for each mesh point:
\begin{equation}\label{equation:design_features:eq195}
\begin{split} \begin{aligned}
 F_{ij}    & \equiv & F(x_i, y_i)\:,             \\
 F^x_{ij}  & \equiv & \partial_x F(x_i, y_i)\:,  \\
 F^y_{ij}  & \equiv & \partial_y F(x_i, y_i)\:,  \\
 F^{xy}    & \equiv & \partial_x \partial_y F(x_i, y_i)\:. \end{aligned}\end{split}
\end{equation}
Consider the point \((x,y)\) at which we wish to interpolate
\(F\). We locate the rectangle that contains this point, such that
\(x_i <= x <
x_{i+1}\) and \(y_i <= x < y_{i+1}\). Let
\begin{equation}\label{equation:design_features:eq196}
\begin{split} \begin{aligned}
 h & \equiv & x_{i+1}-x_i\:,  \\
 l & \equiv & y_{i+1}-y_i\:,  \\
 u & \equiv & \frac{x-x_i}{h}\:,  \\
 v & \equiv & \frac{y-y_i}{l}\:. \end{aligned}\end{split}
\end{equation}
Then, we calculate the interpolated value as
\begin{equation}\label{equation:design_features:eq197}
\begin{split} F(x,y) =
 \begin{pmatrix}
 p_1(u) \\ p_2(u) \\ h q_1(u) \\ h q_2(u)
 \end{pmatrix}^T
 \begin{pmatrix}({*{20}{c}})
 F_{i,j}     & F_{i+1,j}     & F^y_{i,j}      & F^y_{i,j+1}     \\
 F_{i+1,j}   & F_{i+1,j+1}   & F^y_{i+1,j}    & F^y_{i+1,j+1}   \\
 F^x_{i,j}   & F^x_{i,j+1}   & F^{xy}_{i,j}   & F^{xy}_{i,j+1}  \\
 F^x_{i+1,j} & F^x_{i+1,j+1} & F^{xy}_{i+1,j} & F^{xy}_{i+1,j+1}
 \end{pmatrix}
 \begin{pmatrix}
 p_1(v)\\ p_2(v)\\ k q_1(v) \\ k q_2(v)
 \end{pmatrix}\:.\end{split}
\end{equation}

\subsubsection{Construction bicubic splines}
\label{\detokenize{design_features:construction-bicubic-splines}}
We now address the issue of how to compute the derivatives that are
needed for the interpolation. The algorithm is quite simple. For every
\(x_i\), we perform the tridiagonal solution as we did in the 1D
splines to compute \(F^y_{ij}\). Similarly, we perform a tridiagonal
solve for every value of \(F^x_{ij}\). Finally, to compute the
cross\sphinxhyphen{}derivative we may \sphinxstyleemphasis{either} to the tridiagonal solve in the
\(y\) direction of \(F^x_{ij}\), \sphinxstyleemphasis{or} solve in the \(x\)
direction for \(F^y_{ij}\) to obtain the cross\sphinxhyphen{}derivatives
\(F^{xy}_{ij}\). Hence, only minor modifications to the \(1D\)
interpolations are necessary.


\subsection{Tricubic splines}
\label{\detokenize{design_features:tricubic-splines}}
Bicubic interpolation required two 4\sphinxhyphen{}component vectors and a
\(4 \times 4\) matrix. By extension, tricubic interpolation requires
three 4\sphinxhyphen{}component vectors and a \(4 \times 4 \times 4\) tensor. We
summarize the forms of these vectors in the following:
\begin{equation}\label{equation:design_features:eq198}
\begin{split} \begin{aligned}
 h & \equiv & x_{i+1}-x_i\:, \\
 l & \equiv & y_{i+1}-y_i\:, \\
 m & \equiv & z_{i+1}-z_i\:, \\
 u & \equiv & \frac{x-x_i}{h}\:, \\
 v & \equiv & \frac{y-y_i}{l}\:, \\
 w & \equiv & \frac{z-z_i}{m}\:.\end{aligned}\end{split}
\end{equation}\begin{equation}\label{equation:design_features:eq199}
\begin{split} \begin{aligned}
 \vec{a} & = &
 \begin{pmatrix}
 p_1(u) & p_2(u) & h q_1(u) & h q_2(u)
 \end{pmatrix}^T\:, \\
 \vec{b} & = &
 \begin{pmatrix}
 p_1(v) & p_2(v) & k q_1(v) & k q_2(v)
 \end{pmatrix}^T\:, \\
 \vec{c} & = &
 \begin{pmatrix}
 p_1(w) & p_2(w) & l q_1(w) & l q_2(w)
 \end{pmatrix}^T\:. \end{aligned}\end{split}
\end{equation}\begin{equation}\label{equation:design_features:eq200}
\begin{split} \begin{pmatrix}
 A_{000} = F_{i,j,k}     & A_{001}=F_{i,j,k+1}     & A_{002}=F^z_{i,j,k}      & A_{003}=F^z_{i,j,k+1}      \\
 A_{010} = F_{i,j+1,k}   & A_{011}=F_{i,j+1,k+1}   & A_{012}=F^z_{i,j+1,k}    & A_{013}=F^z_{i,j+1,k+1}    \\
 A_{020} = F^y_{i,j,k}   & A_{021}=F^y_{i,j,k+1}   & A_{022}=F^{yz}_{i,j,k}   & A_{023}=F^{yz}_{i,j,k+1}   \\
 A_{030} = F^y_{i,j+1,k} & A_{031}=F^y_{i,j+1,k+1} & A_{032}=F^{yz}_{i,j+1,k} & A_{033}=F^{yz}_{i,j+1,k+1} \\
                         &                         &                          &                            \\
 A_{100} = F_{i+1,j,k}     & A_{101}=F_{i+1,j,k+1}     & A_{102}=F^z_{i+1,j,k}      & A_{103}=F^z_{i+1,j,k+1}      \\
 A_{110} = F_{i+1,j+1,k}   & A_{111}=F_{i+1,j+1,k+1}   & A_{112}=F^z_{i+1,j+1,k}    & A_{113}=F^z_{i+1,j+1,k+1}    \\
 A_{120} = F^y_{i+1,j,k}   & A_{121}=F^y_{i+1,j,k+1}   & A_{122}=F^{yz}_{i+1,j,k}   & A_{123}=F^{yz}_{i+1,j,k+1}   \\
 A_{130} = F^y_{i+1,j+1,k} & A_{131}=F^y_{i+1,j+1,k+1} & A_{132}=F^{yz}_{i+1,j+1,k} & A_{133}=F^{yz}_{i+1,j+1,k+1} \\
                         &                         &                          &                            \\
 A_{200} = F^x_{i,j,k}      & A_{201}=F^x_{i,j,k+1}      & A_{202}=F^{xz}_{i,j,k}      & A_{203}=F^{xz}_{i,j,k+1}    \\
 A_{210} = F^x_{i,j+1,k}    & A_{211}=F^x_{i,j+1,k+1}    & A_{212}=F^{xz}_{i,j+1,k}    & A_{213}=F^{xz}_{i,j+1,k+1}  \\
 A_{220} = F^{xy}_{i,j,k}   & A_{221}=F^{xy}_{i,j,k+1}   & A_{222}=F^{xyz}_{i,j,k}     & A_{223}=F^{xyz}_{i,j,k+1}   \\
 A_{230} = F^{xy}_{i,j+1,k} & A_{231}=F^{xy}_{i,j+1,k+1} & A_{232}=F^{xyz}_{i,j+1,k}   & A_{233}=F^{xyz}_{i,j+1,k+1} \\
                         &                         &                          &                                      \\
 A_{300} = F^x_{i+1,j,k}      & A_{301}=F^x_{i+1,j,k+1}      & A_{302}=F^{xz}_{i+1,j,k}    & A_{303}=F^{xz}_{i+1,j,k+1}   \\
 A_{310} = F^x_{i+1,j+1,k}    & A_{311}=F^x_{i+1,j+1,k+1}    & A_{312}=F^{xz}_{i+1,j+1,k}  & A_{313}=F^{xz}_{i+1,j+1,k+1} \\
 A_{320} = F^{xy}_{i+1,j,k}   & A_{321}=F^{xy}_{i+1,j,k+1}   & A_{322}=F^{xyz}_{i+1,j,k}   & A_{323}=F^{xyz}_{i+1,j,k+1}  \\
 A_{330} = F^{xy}_{i+1,j+1,k} & A_{331}=F^{xy}_{i+1,j+1,k+1} & A_{332}=F^{xyz}_{i+1,j+1,k} & A_{333}=F^{xyz}_{i+1,j+1,k+1}
 \end{pmatrix}\:.\end{split}
\end{equation}
Now, we can write
\begin{equation}\label{equation:design_features:eq201}
\begin{split}F(x,y,z) = \sum_{i=0}^3 a_i \sum_{j=0}^3 b_j \sum_{k=0}^3 c_k \ A_{i,j,k}\:.\end{split}
\end{equation}
The appropriate derivatives of \(F\) may be computed by a
generalization of the previous method used for bicubic splines.


\section{Feature: B\sphinxhyphen{}spline orbital tiling (band unfolding)}
\label{\detokenize{design_features:feature-b-spline-orbital-tiling-band-unfolding}}
In continuum QMC simulations, it is necessary to evaluate the electronic
orbitals of a system at real\sphinxhyphen{}space positions hundreds of millions of
times. It has been found that if these orbitals are represented in a
localized, B\sphinxhyphen{}spline basis, each evaluation takes a small, constant time
that is independent of system size.

Unfortunately, the memory required for storing the B\sphinxhyphen{}spline grows with
the second power of the system size. If we are studying perfect
crystals, however, this can be reduced to linear scaling if we \sphinxstyleemphasis{tile}
the primitive cell. In this approach, a supercell is constructed by
tiling the primitive cell \(N_1 \times N_2 \times N_3\) in the three
lattice directions. The orbitals are then represented in real space only
in the primitive cell and an \(N_1 \times N_2 \times N_3\) k\sphinxhyphen{}point
mesh. To evaluate an orbital at any point in the supercell, it is only
necessary to wrap that point back into the primitive cell, evaluate the
spline, and then multiply the phase factor,
\(e^{-i\mathbf{k}\cdot\mathbf{r}}\).

Here, we show that this approach can be generalized to a tiling
constructed with a \(3\times 3\) nonsingular matrix of integers, of
which the preceding approach is a special case. This generalization
brings with it a number of advantages. The primary reason for performing
supercell calculations in QMC is to reduce finite\sphinxhyphen{}size errors. These
errors result from three sources: (1) the quantization of the crystal
momentum, (2) the unphysical periodicity of the exchange\sphinxhyphen{}correlation
(XC) hole of the electron, and (3) the kinetic\sphinxhyphen{}energy contribution from
the periodicity of the long\sphinxhyphen{}range Jastrow correlation functions. The
first source of error can be largely eliminated by twist averaging. If
the simulation cell is large enough that XC hole does not “leak” out of
the simulation cell, the second source can be eliminated either through
use of the MPC interaction or the \sphinxstyleemphasis{a postiori} correction of Chiesa et
al.

The satisfaction of the leakage requirement is controlled by whether the
minimum distance, \(L_{\text{min}}\), from one supercell image to
the next is greater than the width of the XC hole. Therefore, given a
choice, it is best to use a cell that is as nearly cubic as possible
since this choice maximizes \(L_{\text{min}}\) for a given number of
atoms. Most often, however, the primitive cell is not cubic. In these
cases, if we wish to choose the optimal supercell to reduce finite\sphinxhyphen{}size
effects, we cannot use the simple primitive tiling scheme. In the
generalized scheme we present, it is possible to choose far better
supercells (from the standpoint of finite\sphinxhyphen{}size errors), while retaining
the storage efficiency of the original tiling scheme.


\subsection{The mathematics}
\label{\detokenize{design_features:the-mathematics}}
Consider the set of primitive lattice vectors,
\(\{\mathbf{a}^{\text{p}}_1, \mathbf{a}^{\text{p}}_2,
\mathbf{a}^{\text{p}}_3\}\). We may write these vectors in a matrix,
\(\mathbf{L}_p\), whose rows are the primitive lattice vectors.
Consider a nonsingular matrix of integers, \(\mathbf{S}\). A
corresponding set of supercell lattice vectors,
\(\{\mathbf{a}^{\text{s}}_1, \mathbf{a}^{\text{s}}_2, \mathbf{a}^{\text{s}}_3\}\),
can be constructed by the matrix product
\begin{equation}\label{equation:design_features:eq202}
\begin{split}\mathbf{a}^{\text{s}}_i = S_{ij} \mathbf{a}^{\text{p}}_j\:.\end{split}
\end{equation}
If the primitive cell contains \(N_p\) atoms, the supercell will
then contain \(N_s = |\det(\mathbf{S})| N_p\) atoms.


\subsection{Example: FeO}
\label{\detokenize{design_features:example-feo}}
As an example, consider the primitive cell for antiferromagnetic FeO
(wustite) in the rocksalt structure.  The primitive vectors, given in
units of the lattice constant, are given by
\begin{equation}\label{equation:design_features:eq203}
\begin{split} \begin{aligned}
 \mathbf{a}^{\text{p}}_1 & = & \frac{1}{2}\hat{\mathbf{x}}+ \frac{1}{2}\hat{\mathbf{y}}+      \ \   \hat{\mathbf{z}}\:, \\
 \mathbf{a}^{\text{p}}_2 & = & \frac{1}{2}\hat{\mathbf{x}}+      \ \   \hat{\mathbf{y}}+ \frac{1}{2}\hat{\mathbf{z}}\:, \\
 \mathbf{a}^{\text{p}}_3 & = &   \ \      \hat{\mathbf{x}}+ \frac{1}{2}\hat{\mathbf{y}}+ \frac{1}{2}\hat{\mathbf{z}}\:. \end{aligned}\end{split}
\end{equation}
This primitive cell contains two iron atoms and two oxygen atoms. It is
a very elongated cell with acute angles and, thus, has a short minimum
distance between adjacent images.

The smallest cubic cell consistent with the AFM ordering can be
constructed with the matrix
\begin{equation}\label{equation:design_features:eq204}
\begin{split} \mathbf{S}= \left[\begin{array}{rrr}
   -1 & -1 &  3 \\
   -1 &  3 & -1 \\
    3 & -1 & -1
   \end{array}\right]\:.\end{split}
\end{equation}
This cell has \(2|\det(\mathbf{S})| = 32\) iron atoms and 32 oxygen
atoms. In this example, we may perform the simulation in the 32\sphinxhyphen{}iron
supercell, while storing the orbitals only in the 2\sphinxhyphen{}iron primitive cell,
for a savings of a factor of 16.


\subsubsection{The k\sphinxhyphen{}point mesh}
\label{\detokenize{design_features:the-k-point-mesh}}
To be able to use the generalized tiling scheme, we need to have the
appropriate number of bands to occupy in the supercell. This may be
achieved by appropriately choosing the k\sphinxhyphen{}point mesh. In this section, we
explain how these points are chosen.

For simplicity, let us assume that the supercell calculation will be
performed at the \(\Gamma\)\sphinxhyphen{}point. We can easily lift this
restriction later. The fact that supercell calculation is performed at
\(\Gamma\) implies that the k\sphinxhyphen{}points used in the primitive\sphinxhyphen{}cell
calculation must be \(\mathbf{G}\)\sphinxhyphen{}vectors of the superlattice. This
still leaves us with an infinite set of vectors. We may reduce this set
to a finite number by considering that the orbitals must form a linearly
independent set. Orbitals with k\sphinxhyphen{}vectors \(\mathbf{k}^p_1\) and
\(\mathbf{k}^p_2\) will differ by at most a constant factor of
\(\mathbf{k}^p_1 - \mathbf{k}^p_2 = \mathbf{G}^p\), where
\(\mathbf{G}^p\) is a reciprocal lattice vector of the primitive
cell.

Combining these two considerations gives us a prescription for
generating our k\sphinxhyphen{}point mesh. The mesh may be taken to be the set of
k\sphinxhyphen{}point which are G\sphinxhyphen{}vectors of the superlattice, reside within the first
Brillouin zone (FBZ) of the primitive lattice, whose members do not
differ a G\sphinxhyphen{}vector of the primitive lattice. Upon constructing such a
set, we find that the number of included k\sphinxhyphen{}points is equal to
\(|\det(\mathbf{S})|\), precisely the number we need. This can by
considering the fact that the supercell has a volume
\(|\det(\mathbf{S})|\) times that of the primitive cell. This
implies that the volume of the supercell’s FBZ is
\(|\det(\mathbf{S})|^{-1}\) times that of the primitive cell. Hence,
\(|\det(\mathbf{S})|\) G\sphinxhyphen{}vectors of the supercell will fit in the
FBZ of the primitive cell. Removing duplicate k\sphinxhyphen{}vectors, which differ
from another by a reciprocal lattice vector, avoids double\sphinxhyphen{}counting
vectors that lie on zone faces.


\subsubsection{Formulae}
\label{\detokenize{design_features:formulae}}
Let \(\mathbf{A}\) be the matrix whose rows are the direct lattice
vectors, \(\{\mathbf{a}_i\}\). Then, let the matrix
\(\mathbf{B}\) be defined as \(2\pi(\mathbf{A}^{-1})^\dagger\).
Its rows are the primitive reciprocal lattice vectors. Let
\(\mathbf{A}_p\) and \(\mathbf{A}_s\) represent the primitive
and superlattice matrices, respectively, and similarly for their
reciprocals. Then we have
\begin{equation}\label{equation:design_features:eq205}
\begin{split} \begin{aligned}
 \mathbf{A}_s & = & \mathbf{S}\mathbf{A}_p\:, \\
 \mathbf{B}_s & = & 2\pi\left[(\mathbf{S}\mathbf{A}_p)^{-1}\right]^\dagger\:, \\
         & = & 2\pi\left[\mathbf{A}_p^{-1} \mathbf{S}^{-1}\right]^\dagger\:, \\
         & = & 2\pi(\mathbf{S}^{-1})^\dagger (\mathbf{A}_p^{-1})^\dagger\:, \\
         & = & (\mathbf{S}^{-1})^\dagger \mathbf{B}_p\:.\end{aligned}\end{split}
\end{equation}
Consider a k\sphinxhyphen{}vector, \(\mathbf{k}\). It may alternatively be written
in basis of reciprocal lattice vectors as \(\mathbf{t}\).
\begin{equation}\label{equation:design_features:eq206}
\begin{split} \begin{aligned}
 \mathbf{k}& = & (\mathbf{t}^\dagger \mathbf{B})^\dagger\:, \\
     & = & \mathbf{B}^\dagger \mathbf{t}\:,           \\
 \mathbf{t}& = & (\mathbf{B}^\dagger)^{-1} \mathbf{k}\:,    \\
     & = & (\mathbf{B}^{-1})^\dagger \mathbf{k}\:,    \\
     & = & \frac{\mathbf{A}\mathbf{k}}{2\pi}\:.\end{aligned}\end{split}
\end{equation}
We may then express a twist vector of the primitive lattice,
\(\mathbf{t}_p\), in terms of the superlattice.
\begin{equation}\label{equation:design_features:eq207}
\begin{split} \begin{aligned}
 \mathbf{t}_s & = & \frac{\mathbf{A}_s \mathbf{k}}{2\pi}\:,                           \\
       & = & \frac{\mathbf{A}_s \mathbf{B}_p^\dagger \mathbf{t}_p}{2\pi}\:,         \\
       & = & \frac{\mathbf{S}\mathbf{A}_p \mathbf{B}_p^\dagger \mathbf{t}_p}{2\pi}\:,   \\
       & = & \frac{2\pi \mathbf{S}\mathbf{A}_p \mathbf{A}_p^{-1} \mathbf{t}_p}{2\pi}\:, \\
       & = & \mathbf{S}\mathbf{t}_p\:.\end{aligned}\end{split}
\end{equation}
This gives the simple result that twist vectors transform in precisely
the same way as direct lattice vectors.


\section{Feature: Hybrid orbital representation}
\label{\detokenize{design_features:feature-hybrid-orbital-representation}}\begin{equation}\label{equation:design_features:eq208}
\begin{split} \phi(\mathbf{r}) = \sum_{\ell=0}^{\ell_\text{max}} \sum_{m=-\ell}^\ell Y_\ell^m (\hat{\Omega})
 u_{\ell m}(r)\:,\end{split}
\end{equation}
where \(u_{lm}(r)\) are complex radial functions represented in some
radial basis (e.g., splines).


\subsection{Real spherical harmonics}
\label{\detokenize{design_features:real-spherical-harmonics}}
If \(\phi(\mathbf{r})\) can be written as purely real, we can change
the representation so that
\begin{equation}\label{equation:design_features:eq209}
\begin{split} \phi(\mathbf{r}) = \sum_{l=0}^{l_\text{max}} \sum_{m=-\ell}^\ell Y_{\ell m}(\hat{\Omega})
 \bar{u}_{lm}(r)\:,\end{split}
\end{equation}
where \(\bar{Y}_\ell^m\) are the \sphinxstyleemphasis{real} spherical harmonics defined
by
\begin{equation}\label{equation:design_features:eq210}
\begin{split} Y_{\ell m} = \begin{cases}
 Y_\ell^0 & \mbox{if } m=0\\
 {1\over 2}\left(Y_\ell^m+(-1)^m \, Y_\ell^{-m}\right) \ = \rm Re\left[Y_\ell^m\right]
 %\sqrt{2} N_{(\ell,m)} P_\ell^m(\cos \theta) \cos m\varphi
 & \mbox{if } m>0 \\
 {1\over i 2}\left(Y_\ell^{-m}-(-1)^{m}\, Y_\ell^{m}\right) = \rm Im\left[Y_\ell^{-m}\right]
 %\sqrt{2} N_{(\ell,m)} P_\ell^{-m}(\cos \theta) \sin m\varphi
 &\mbox{if } m<0\:.
 \end{cases}\end{split}
\end{equation}
We need then to relate \(\bar{u}_{\ell m}\) to \(u_{\ell m}\).
We wish to express
\begin{equation}\label{equation:design_features:eq211}
\begin{split} \rm Re\left[\phi(\mathbf{r})\right] = \sum_{\ell=0}^{\ell_\text{max}} \sum_{m=-\ell}^\ell
 \rm Re\left[Y_\ell^m (\hat{\Omega}) u_{\ell m}(r)\right]\end{split}
\end{equation}
in terms of \(\bar{u}_{\ell m}(r)\) and \(Y_{\ell m}\).
\begin{equation}\label{equation:design_features:eq212}
\begin{split} \begin{aligned}
 \rm Re\left[Y_\ell^m u_{\ell m}\right] & = & \rm Re\left[Y_\ell^m\right]
 \rm Re\left[u_{\ell m}\right] - \rm Im\left[Y_\ell^m\right] \rm Im\left[u_{\ell m}\right]\:.\end{aligned}\end{split}
\end{equation}
For \(m>0\),
\begin{equation}\label{equation:design_features:eq213}
\begin{split}\rm Re\left[Y_\ell^m\right] = Y_{\ell m} \qquad \text{and} \qquad \rm Im\left[Y_\ell^m\right] = Y_{\ell\,-m}\:.\end{split}
\end{equation}
For \(m<0\),
\begin{equation}\label{equation:design_features:eq214}
\begin{split}\rm Re\left[Y_\ell^m\right] = (-1)^m Y_{\ell\, -m} \qquad \text and \qquad \rm Im\left[Y_\ell^m\right] = -(-1)^m Y_{\ell m}\:.\end{split}
\end{equation}
Then for \(m > 0\),
\begin{equation}\label{equation:design_features:eq215}
\begin{split} \begin{aligned}
 \bar{u}_{\ell m} & = & \rm Re\left[u_{\ell m}\right] + (-1)^m \rm Re\left[u_{\ell\,-m}\right]\:, \\
 \bar{u}_{\ell\, -m} & = & -\rm Im\left[u_{\ell m}\right] + (-1)^m \rm Im\left[u_{\ell\,-m}\right]\:.\end{aligned}\end{split}
\end{equation}

\subsection{Projecting to atomic orbitals}
\label{\detokenize{design_features:projecting-to-atomic-orbitals}}
Inside a muffin tin, orbitals are represented as products of spherical
harmonics and 1D radial functions, primarily represented by splines. For
a muffin tin centered at \(\mathbf{I}\),
\begin{equation}\label{equation:design_features:eq216}
\begin{split} \phi_n(\mathbf{r}) = \sum_{\ell,m} Y_\ell^m(\hat{\mathbf{r}-\mathbf{I}})
 u_{lm}\left(\left|\mathbf{r}- \mathbf{I}\right|\right) \:.\end{split}
\end{equation}
Let use consider the case that our original representation for
\(\phi(\mathbf{r})\) is of the form
\begin{equation}\label{equation:design_features:eq217}
\begin{split}\phi_{n,\mathbf{k}}(\mathbf{r}) = \sum_\mathbf{G}c_{\mathbf{G}+\mathbf{k}}^n e^{i(\mathbf{G}+ \mathbf{k})\cdot \mathbf{r}}\:.\end{split}
\end{equation}
Recall that
\begin{equation}\label{equation:design_features:eq218}
\begin{split} e^{i\mathbf{k}\cdot\mathbf{r}} = 4\pi \sum_{\ell,m} i^\ell j_\ell(|\mathbf{r}||\mathbf{k}|)
 Y_\ell^m(\hat{\mathbf{k}}) \left[Y_\ell^m(\hat{\mathbf{r}})\right]^*\:.\end{split}
\end{equation}
Conjugating,
\begin{equation}\label{equation:design_features:eq219}
\begin{split} e^{-i\mathbf{k}\cdot\mathbf{r}} = 4\pi\sum_{\ell,m} (-i)^\ell j_\ell(|\mathbf{r}||\mathbf{k}|)
 \left[Y_\ell^m(\hat{\mathbf{k}})\right]^* Y_\ell^m(\hat{\mathbf{r}})\:.\end{split}
\end{equation}
Setting \(\mathbf{k}\rightarrow -k\),
\begin{equation}\label{equation:design_features:eq220}
\begin{split} e^{i\mathbf{k}\cdot\mathbf{r}} = 4\pi\sum_{\ell,m} i^\ell j_\ell(|\mathbf{r}||\mathbf{k}|)
 \left[Y_\ell^m(\hat{\mathbf{k}})\right]^* Y_\ell^m(\hat{\mathbf{r}})\:.\end{split}
\end{equation}
Then,
\begin{equation}\label{equation:design_features:eq221}
\begin{split} e^{i\mathbf{k}\cdot(\mathbf{r}-\mathbf{I})} = 4\pi\sum_{\ell,m} i^\ell j_\ell(|\mathbf{r}-\mathbf{I}||\mathbf{k}|)
 \left[Y_\ell^m(\hat{\mathbf{k}})\right]^* Y_\ell^m(\hat{\mathbf{r}-\mathbf{I}})\:.\end{split}
\end{equation}\begin{equation}\label{equation:design_features:eq222}
\begin{split} e^{i\mathbf{k}\cdot\mathbf{r}} = 4\pi e^{i\mathbf{k}\cdot\mathbf{I}} \-\sum_{\ell,m} i^\ell j_\ell(|\mathbf{r}-\mathbf{I}||\mathbf{k}|)
 \left[Y_\ell^m(\hat{\mathbf{k}})\right]^* Y_\ell^m(\hat{\mathbf{r}-\mathbf{I}})\:.\end{split}
\end{equation}
Then
\begin{equation}\label{equation:design_features:eq223}
\begin{split} \phi_{n,\mathbf{k}}(\mathbf{r}) =  \sum_\mathbf{G}4\pi c_{\mathbf{G}+\mathbf{k}}^n
 e^{i(\mathbf{G}+\mathbf{k})\cdot\mathbf{I}} \sum_{\ell,m}
   i^\ell j_\ell(|\mathbf{G}+\mathbf{k}||\mathbf{r}-\mathbf{I}|)
   \left[Y_\ell^m(\hat{\mathbf{G}+\mathbf{k}})\right]^*
 Y_\ell^m(\hat{\mathbf{r}- \mathbf{I}})\:.\end{split}
\end{equation}
Comparing with \eqref{equation:design_features:eq216},
\begin{equation}\label{equation:design_features:eq224}
\begin{split} u_{\ell m}^n(r) = 4\pi i^\ell \sum_G c_{\mathbf{G}+\mathbf{k}}^n e^{i(\mathbf{G}+\mathbf{k})\cdot\mathbf{I}}  j_\ell\left(|\mathbf{G}+ \mathbf{k}|r|\right)
 \left[Y_\ell^m(\hat{\mathbf{G}+ \mathbf{k}})\right]^*\:.\end{split}
\end{equation}
If we had adopted the opposite sign convention for Fourier transforms
(as is unfortunately the case in wfconvert), we would have
\begin{equation}\label{equation:design_features:eq225}
\begin{split} u_{\ell m}^n(r) = 4\pi (-i)^\ell \sum_G c_{\mathbf{G}+\mathbf{k}}^n e^{-i(\mathbf{G}+\mathbf{k})\cdot\mathbf{I}}  j_\ell\left(|\mathbf{G}+ \mathbf{k}|r|\right)
 \left[Y_\ell^m(\hat{\mathbf{G}+ \mathbf{k}})\right]^*\:.\end{split}
\end{equation}

\section{Feature: Electron\sphinxhyphen{}electron\sphinxhyphen{}ion Jastrow factor}
\label{\detokenize{design_features:feature-electron-electron-ion-jastrow-factor}}
The general form of the 3\sphinxhyphen{}body Jastrow we describe here depends on the
three interparticle distances, \((r_{ij}, r_{iI}, r_{jI})\).
\begin{equation}\label{equation:design_features:eq226}
\begin{split} J_3 = \sum_{I\in\text{ions}} \sum_{i,j \in\text{elecs};i\neq j} U(r_{ij}, r_{iI},
 r_{jI})\:.\end{split}
\end{equation}
Note that we constrain the form of \(U\) such that
\(U(r_{ij}, r_{iI},r_{jI}) = U(r_{ij}, r_{jI},r_{iI})\) to preserve
the particle symmetry of the wavefunction. We then compute the gradient
as
\begin{equation}\label{equation:design_features:eq227}
\begin{split} \nabla_i J_3 =  \sum_{I\in\text{ions}} \sum_{j \neq i}
 \left[\frac{\partial U(r_{ij}, r_{iI},r_{jI})}{\partial r_{ij}}
   \frac{\mathbf{r}_i - \mathbf{r}_j}{|\mathbf{r}_i - \mathbf{r}_j|}
 + \frac{\partial U(r_{ij}, r_{iI},r_{jI})}{\partial r_{iI}}
   \frac{\mathbf{r}_i - \mathbf{I}}{|\mathbf{r}_i - \mathbf{I}|}  \right]\:.\end{split}
\end{equation}
To compute the Laplacian, we take
\begin{equation}\label{equation:design_features:eq228}
\begin{split} \begin{aligned}
 \nabla_i^2 J_3 & = & \nabla_i \cdot \left(\nabla_i J_3\right)\:, \\
 & = & \sum_{I\in\text{ions}} \sum_{j\neq i } \left[
 \frac{\partial^2 U}{\partial r_{ij}^2} + \frac{2}{r_{ij}} \frac{\partial
   U}{\partial r_{ij}} + 2 \frac{\partial^2 U}{\partial r_{ij}\partial
   r_{iI}}\frac{\mathbf{r}_{ij}\cdot\mathbf{r}_{iI}}{r_{ij}r_{iI}} +\frac{\partial^2 U}{\partial
   r_{iI}^2}
 + \frac{2}{r_{iI}}\frac{\partial U}{\partial r_{iI}} \nonumber
 \right]\:.\end{aligned}\end{split}
\end{equation}
We now wish to compute the gradient of these terms w.r.t. the ion
position, \(I\).
\begin{equation}\label{equation:design_features:eq229}
\begin{split} \nabla_I J_3 = -\sum_{j\neq i} \left[ \frac{\partial U(r_{ij}, r_{iI},r_{jI})}{\partial r_{iI}}
   \frac{\mathbf{r}_i - \mathbf{I}}{|\mathbf{r}_i - \mathbf{I}|}
 +\frac{\partial U(r_{ij}, r_{iI},r_{jI})}{\partial r_{jI}}
   \frac{\mathbf{r}_j - \mathbf{I}}{|\mathbf{r}_j - \mathbf{I}|} \right]\:.\end{split}
\end{equation}
For the gradient w.r.t. \(i\) of the gradient w.r.t. \(I\), the
result is a tensor:
\begin{equation}\label{equation:design_features:eq230}
\begin{split} \begin{aligned}
 \nabla_I \nabla_i J_3 & = & \nabla_I \sum_{j \neq i}
 \left[\frac{\partial U(r_{ij}, r_{iI},r_{jI})}{\partial r_{ij}}
   \frac{\mathbf{r}_i - \mathbf{r}_j}{|\mathbf{r}_i - \mathbf{r}_j|}
 + \frac{\partial U(r_{ij}, r_{iI},r_{jI})}{\partial r_{iI}}
   \frac{\mathbf{r}_i - \mathbf{I}}{|\mathbf{r}_i - \mathbf{I}|}  \right]\:, \\\nonumber \\\nonumber
 & = & -\sum_{j\neq i} \left[
 \frac{\partial^2 U}{\partial r_{ij}r_{iI}} \hat{\mathbf{r}}_{ij} \otimes
 \hat{\mathbf{r}}_{iI} + \left(\frac{\partial^2 U}{\partial r_{iI}^2} -
 \frac{1}{r_{iI}} \frac{\partial U}{\partial r_{iI}}\right)
 \hat{\mathbf{r}}_{iI} \otimes \hat{\mathbf{r}}_{iI} \right. + \\\nonumber
 & & \left. \qquad \ \ \  \frac{\partial^U}{\partial r_{ij}r_{jI}} \hat{\mathbf{r}}_{ij} \otimes \hat{\mathbf{r}}_{jI} + \frac{\partial^2 U}{\partial r_{iI}\partial r_{jI}}
 \hat{\mathbf{r}}_{iI}\otimes \hat{\mathbf{r}}_{jI}  +
 \frac{1}{r_{iI}} \frac{\partial U}{\partial r_{iI}} \overleftrightarrow{\mathbf{1}}\right]\:.\end{aligned}\end{split}
\end{equation}\begin{equation}\label{equation:design_features:eq231}
\begin{split} \begin{aligned}
 \nabla_I \nabla_i J_3 & = & \nabla_I \sum_{j \neq i}
 \left[\frac{\partial U(r_{ij}, r_{iI},r_{jI})}{\partial r_{ij}}
   \frac{\mathbf{r}_i - \mathbf{r}_j}{|\mathbf{r}_i - \mathbf{r}_j|}
 + \frac{\partial U(r_{ij}, r_{iI},r_{jI})}{\partial r_{iI}}
   \frac{\mathbf{r}_i - \mathbf{I}}{|\mathbf{r}_i - \mathbf{I}|}  \right]\:, \\\nonumber
 & = & \sum_{j\neq i} \left[ -\frac{\partial^2 U}{\partial r_{ij}\partial r_{iI}} \hat{\mathbf{r}}_{ij} \otimes \hat{\mathbf{r}}_{iI} +
 \left(-\frac{\partial^2 U}{\partial r_{iI}^2}  + \frac{1}{r_{iI}}\frac{\partial U}{\partial r_{iI}} \right)
 \hat{\mathbf{r}}_{iI} \otimes \hat{\mathbf{r}}_{iI} - \frac{1}{r_{iI}}\frac{\partial U}{\partial r_{iI}} \overleftrightarrow{\mathbf{1}}
 \right]\:.\end{aligned}\end{split}
\end{equation}
For the Laplacian,
\begin{equation}\label{equation:design_features:eq232}
\begin{split} \begin{aligned}
 \nabla_I \nabla_i^2 J_3 & = & \nabla_I\left[\nabla_i \cdot \left(\nabla_i J_3\right)\right]\:, \\
 & = & \nabla_I \sum_{j\neq i } \left[
 \frac{\partial^2 U}{\partial r_{ij}^2} + \frac{2}{r_{ij}} \frac{\partial
   U}{\partial r_{ij}} + 2 \frac{\partial^2 U}{\partial r_{ij}\partial
   r_{iI}}\frac{\mathbf{r}_{ij}\cdot\mathbf{r}_{iI}}{r_{ij}r_{iI}} +\frac{\partial^2 U}{\partial
   r_{iI}^2}
 + \frac{2}{r_{iI}}\frac{\partial U}{\partial r_{iI}} \nonumber
 \right]\:, \\
 & = & \sum_{j\neq i }
 \left[ \frac{\partial^3 U}{\partial r_{iI} \partial^2 r_{ij}} +
 \frac{2}{r_{ij}} \frac{\partial^2 U}{\partial r_{iI} \partial r_{ij}}
 + 2\left(\frac{\partial^3 U}{\partial r_{ij}\partial^2 r_{iI}} -\frac{1}{r_{iI}} \frac{\partial^2 U}{\partial r_{ij}\partial r_{iI}}\right)\frac{\mathbf{r}_{ij}\cdot\mathbf{r}_{iI}}{r_{ij}r_{iI}} + \frac{\partial^3 U}{\partial^3 r_{iI}} - \frac{2}{r_{iI}^2} \frac{\partial U}{ \partial r_{iI}} + \frac{2}{r_{iI}} \frac{\partial^2 U}{\partial^2 r_{iI}}
 \right] \frac{\mathbf{I} - \mathbf{r}_i}{|\mathbf{I} - \mathbf{r}_i|} + \nonumber \\\nonumber
  & & \sum_{j\neq i } \left[ \frac{\partial^3U}{\partial r_{ij}^2 \partial r_{jI}} + \frac{2}{r_{ij}}\frac{\partial^2 U}{\partial r_{jI}\partial r_{ij}}
 + 2\frac{\partial^3 U}{\partial r_{ij}\partial r_{iI}\partial r_{jI}}\frac{\mathbf{r}_{ij}\cdot\mathbf{r}_{iI}}{r_{ij}r_{iI}}
 +\frac{\partial^3 U}{\partial r_{iI}^2 \partial r_{jI}} + \frac{2}{r_{iI}}\frac{\partial^2 U}{\partial r_{iI}\partial r_{jI}} \right]
 \frac{\mathbf{I} - \mathbf{r}_j}{|\mathbf{r}_j - \mathbf{I}|} + \\\nonumber
 & & \sum_{j\neq i } \left[ -\frac{2}{r_{iI}}\frac{\partial^2 U}{\partial r_{ij}\partial r_{iI}}\right] \frac{\mathbf{r}_{ij}}{r_{ij}}\:.\end{aligned}\end{split}
\end{equation}

\section{Feature: Reciprocal\sphinxhyphen{}space Jastrow factors}
\label{\detokenize{design_features:feature-reciprocal-space-jastrow-factors}}\label{\detokenize{design_features:feature-kspace-jastrow}}

\subsection{Two\sphinxhyphen{}body Jastrow}
\label{\detokenize{design_features:two-body-jastrow}}\begin{equation}\label{equation:design_features:eq233}
\begin{split}J_2 = \sum_{\mathbf{G}\neq \mathbf{0}}\sum_{i\neq j} a_\mathbf{G}e^{i\mathbf{G}\cdot(\mathbf{r}_i-\mathbf{r}_j)}\:.\end{split}
\end{equation}
This may be rewritten as
\begin{equation}\label{equation:design_features:eq234}
\begin{split} \begin{aligned}
 J_2 & = & \sum_{\mathbf{G}\neq \mathbf{0}}\sum_{i\neq j} a_\mathbf{G}e^{i\mathbf{G}\cdot\mathbf{r}_i}e^{-i\mathbf{G}\cdot\mathbf{r}_j}\:, \\
 & = & \sum_{\mathbf{G}\neq \mathbf{0}} a_\mathbf{G}\left\{
 \underbrace{\left[\sum_i e^{i\mathbf{G}\cdot\mathbf{r}_i} \right]}_{\rho_\mathbf{G}}
 \underbrace{\left[\sum_j e^{-i\mathbf{G}\cdot\mathbf{r}_j} \right]}_{\rho_{-\mathbf{G}}}  -1 \right\}\:.\end{aligned}\end{split}
\end{equation}
The \(-1\) is just a constant term and may be subsumed into the
\(a_\mathbf{G}\) coefficient by a simple redefinition. This leaves a
simple, but general, form:
\begin{equation}\label{equation:design_features:eq235}
\begin{split}J_2 = \sum_{\mathbf{G}\neq\mathbf{0}} a_\mathbf{G}\rho_\mathbf{G}\rho_{-\mathbf{G}}\:.\end{split}
\end{equation}
We may now further constrain this on physical grounds. First, we
recognize that \(J_2\) should be real. Since
\(\rho_{-\mathbf{G}} =
\rho_\mathbf{G}^*\), it follows that
\(\rho_{\mathbf{G}}\rho_{-\mathbf{G}} = |\rho_\mathbf{G}|^2\) is
real, so that \(a_\mathbf{G}\) must be real. Furthermore, we group
the \(\mathbf{G}\)’s into \((+\mathbf{G}, -\mathbf{G})\) pairs
and sum over only the positive vectors to save time.


\subsection{One\sphinxhyphen{}body Jastrow}
\label{\detokenize{design_features:one-body-jastrow}}
The 1\sphinxhyphen{}body Jastrow has a similar form but depends on the displacement
from the electrons to the ions in the system.
\begin{equation}\label{equation:design_features:eq236}
\begin{split} J_1 = \sum_{\mathbf{G}\neq\mathbf{0}} \sum_{\alpha}
 \sum_{i\in\mathbf{I}^\alpha}\sum_{j\in\text{elec.}} b^{\alpha}_\mathbf{G}
   e^{i\mathbf{G}\cdot(\mathbf{I}^{\alpha}_i - \mathbf{r}_j)}\:,\end{split}
\end{equation}
where \(\alpha\) denotes the different ionic species. We may rewrite
this in terms of \(\rho^{\alpha}_\mathbf{G}\):
\begin{equation}\label{equation:design_features:eq237}
\begin{split} J_1 = \sum_{\mathbf{G}\neq\mathbf{0}} \left[\sum_\alpha b^\alpha_\mathbf{G}
   \rho_\mathbf{G}^\alpha\right] \rho_{-\mathbf{G}}\:,\end{split}
\end{equation}
where
\begin{equation}\label{equation:design_features:eq238}
\begin{split}\rho^\alpha_\mathbf{G}= \sum_{i\in\mathbf{I}^\alpha} e^{i\mathbf{G}\cdot\mathbf{I}^\alpha_i}\:.\end{split}
\end{equation}
We note that in the preceding equation, for a single configuration of
the ions, the sum in brackets can be rewritten as a single constant.
This implies that the per\sphinxhyphen{}species 1\sphinxhyphen{}body coefficients,
\(b^\alpha_\mathbf{G}\), are underdetermined for single
configuration of the ions. In general, if we have \(N\) species, we
need \(N\) linearly independent ion configurations to uniquely
determine \(b^{\alpha}_\mathbf{G}\). For this reason, we will drop
the \(\alpha\) superscript of \(b_\mathbf{G}\) for now.

If we do desire to find a reciprocal space 1\sphinxhyphen{}body Jastrow that is
transferable to systems with different ion positions and \(N\) ionic
species, we must perform compute \(b_\mathbf{G}\) for \(N\)
different ion configurations. We may then construct \(N\) equations
at each value of \(\mathbf{G}\) to solve for the \(N\) unknown
values, \(b^\alpha_\mathbf{G}\).

In the 2\sphinxhyphen{}body case, \(a_\mathbf{G}\) was constrained to be real by
the fact that \(\rho_\mathbf{G}\rho_{-\mathbf{G}}\) was real.
However, in the 1\sphinxhyphen{}body case, there is no such guarantee about
\(\rho^\alpha_\mathbf{G}\rho_\mathbf{G}\). Therefore, in general,
\(b_\mathbf{G}\) may be complex.


\subsection{Symmetry considerations}
\label{\detokenize{design_features:symmetry-considerations}}
For a crystal, many of the \(\mathbf{G}\)\sphinxhyphen{}vectors will be equivalent
by symmetry. It is useful then to divide the \(\mathbf{G}\)\sphinxhyphen{}vectors
into symmetry\sphinxhyphen{}related groups and then require that they share a common
coefficient. Two vectors, \(\mathbf{G}\) and \(\mathbf{G}'\),
may be considered to be symmetry related if, for all \(\alpha\) and
\(\beta\)
\begin{equation}\label{equation:design_features:eq239}
\begin{split}\rho^\alpha_\mathbf{G}\rho^\beta_{-\mathbf{G}} = \rho^\alpha_{\mathbf{G}'} \rho^\beta_{-\mathbf{G}'}\:.\end{split}
\end{equation}
For the 1\sphinxhyphen{}body term, we may also omit from our list of
\(\mathbf{G}\)\sphinxhyphen{}vectors those for which all species structure factors
are zero. This is equivalent to saying that if we are tiling a primitive
cell we should include only the \(\mathbf{G}\)\sphinxhyphen{}vectors of the
primitive cell and not the supercell. Note that this is not the case for
the 2\sphinxhyphen{}body term since the XC hole should not have the periodicity of the
primitive cell.


\subsection{Gradients and Laplacians}
\label{\detokenize{design_features:gradients-and-laplacians}}\begin{equation}\label{equation:design_features:eq240}
\begin{split} \begin{aligned}
 \nabla_{\mathbf{r}_i} J_2 & = & \sum_{\mathbf{G}\neq 0} a_\mathbf{G}\left[\left(\nabla_{\mathbf{r}_i}\rho_\mathbf{G}\right) \rho_{-\mathbf{G}} + \text{c.c.}\right]\:, \\
 & = & \sum_{\mathbf{G}\neq \mathbf{0}} 2\mathbf{G}a_\mathbf{G}\mathbf{Re}\left(i e^{i\mathbf{G}\cdot\mathbf{r}_i} \rho_{-\mathbf{G}} \right)\:, \\
 & = & \sum_{\mathbf{G}\neq \mathbf{0}} -2\mathbf{G}a_\mathbf{G}\mathbf{Im}\left(e^{i\mathbf{G}\cdot\mathbf{r}_i} \rho_{-\mathbf{G}} \right)\:.\end{aligned}\end{split}
\end{equation}
The Laplacian is then given by
\begin{equation}\label{equation:design_features:eq241}
\begin{split} \begin{aligned}
   \nabla^2 J_2 & = & \sum_{\mathbf{G}\neq\mathbf{0}} a_\mathbf{G}\left[\left(\nabla^2 \rho_\mathbf{G}\right) \rho_{-\mathbf{G}} + \text{c.c.}
   + 2\left(\nabla \rho_\mathbf{G})\cdot(\nabla \rho_{-\mathbf{G}}\right)\right]\:, \\
 & = & \sum_{\mathbf{G}\neq\mathbf{0}} a_\mathbf{G}\left[ -2G^2\mathbf{Re}(e^{i\mathbf{G}\cdot\mathbf{r}_i}\rho_{-\mathbf{G}}) +
     2\left(i\mathbf{G}e^{i\mathbf{G}\cdot\mathbf{r}_i}\right) \cdot \left(-i\mathbf{G}e^{-i\mathbf{G}\cdot\mathbf{r}_i}\right)
 \right]\:, \\
 & = & 2 \sum_{\mathbf{G}\neq\mathbf{0}} G^2 a_\mathbf{G}\left[-\mathbf{Re}\left(e^{i\mathbf{G}\cdot\mathbf{r}_i}\rho_{-\mathbf{G}}\right) + 1\right]\:. \end{aligned}\end{split}
\end{equation}



\chapter{Development Guide}
\label{\detokenize{developing:development-guide}}\label{\detokenize{developing:developguide}}\label{\detokenize{developing::doc}}
The section gives guidance on how to extend the functionality of QMCPACK. Future examples will likely include topics such as the addition of a Jastrow function or a new QMC method.


\section{QMCPACK coding standards}
\label{\detokenize{developing:qmcpack-coding-standards}}
This chapter presents what we collectively have agreed are best practices for the code. This includes formatting style, naming conventions, documentation conventions, and certain prescriptions for C++ language use. At the moment only the formatting can be enforced in an objective fashion.

New development should follow these guidelines, and contributors are expected to adhere to them as they represent an integral part of our effort to continue QMCPACK as a world\sphinxhyphen{}class, sustainable QMC code. Although some of the source code has a ways to go to live up to these ideas, new code, even in old files, should follow the new conventions not the local conventions of the file whenever possible. Work on the code with continuous improvement in mind rather than a commitment to stasis.

The \sphinxhref{https://github.com/QMCPACK/qmcpack/wiki/Development-workflow}{current workflow conventions} for the project are described in the wiki on the GitHub repository. It will save you and all the maintainers considerable time if you read these and ask questions up front.

A PR should follow these standards before inclusion in the mainline. You can be sure of properly following the formatting conventions if you use clang\sphinxhyphen{}format.  The mechanics of clang\sphinxhyphen{}format setup and use can be found at \sphinxurl{https://github.com/QMCPACK/qmcpack/wiki/Source-formatting}.

The clang\sphinxhyphen{}format file found at \sphinxcode{\sphinxupquote{qmcpack/src/.clang\sphinxhyphen{}format}} should be run over all code touched in a PR before a pull request is prepared. We also encourage developers to run clang\sphinxhyphen{}tidy with the \sphinxcode{\sphinxupquote{qmcpack/src/.clang\sphinxhyphen{}tidy}} configuration over all new code.

As much as possible, try to break up refactoring, reformatting, feature, and bugs into separate, small PRs. Aim for something that would take a reviewer no more than an hour. In this way we can maintain a good collective development velocity.


\section{Files}
\label{\detokenize{developing:files}}
Each file should start with the header.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}
\PYG{o}{/}\PYG{o}{/} \PYG{n}{This} \PYG{n}{file} \PYG{o+ow}{is} \PYG{n}{distributed} \PYG{n}{under} \PYG{n}{the} \PYG{n}{University} \PYG{n}{of} \PYG{n}{Illinois}\PYG{o}{/}\PYG{n}{NCSA} \PYG{n}{Open} \PYG{n}{Source} \PYG{n}{License}\PYG{o}{.}
\PYG{o}{/}\PYG{o}{/} \PYG{n}{See} \PYG{n}{LICENSE} \PYG{n}{file} \PYG{o+ow}{in} \PYG{n}{top} \PYG{n}{directory} \PYG{k}{for} \PYG{n}{details}\PYG{o}{.}
\PYG{o}{/}\PYG{o}{/}
\PYG{o}{/}\PYG{o}{/} \PYG{n}{Copyright} \PYG{p}{(}\PYG{n}{c}\PYG{p}{)} \PYG{l+m+mi}{2018} \PYG{n}{QMCPACK} \PYG{n}{developers}
\PYG{o}{/}\PYG{o}{/}
\PYG{o}{/}\PYG{o}{/} \PYG{n}{File} \PYG{n}{developed} \PYG{n}{by}\PYG{p}{:} \PYG{n}{Name}\PYG{p}{,} \PYG{n}{email}\PYG{p}{,} \PYG{n}{affiliation}
\PYG{o}{/}\PYG{o}{/}
\PYG{o}{/}\PYG{o}{/} \PYG{n}{File} \PYG{n}{created} \PYG{n}{by}\PYG{p}{:} \PYG{n}{Name}\PYG{p}{,} \PYG{n}{email}\PYG{p}{,} \PYG{n}{affiliation}
\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}
\end{sphinxVerbatim}

If you make significant changes to an existing file, add yourself to the list of “developed by” authors.


\subsection{File organization}
\label{\detokenize{developing:file-organization}}
Header files should be placed in the same directory as their implementations.
Unit tests should be written for all new functionality. These tests should be placed in a \sphinxcode{\sphinxupquote{tests}} subdirectory below the implementations.


\subsection{File names}
\label{\detokenize{developing:file-names}}
Each class should be defined in a separate file with the same name as the class name. Use separate \sphinxcode{\sphinxupquote{.cpp}} implementation files whenever possible to aid in incremental compilation.

The filenames of tests are composed by the filename of the object tested and the prefix \sphinxcode{\sphinxupquote{test\_}}.
The filenames of \sphinxstyleemphasis{fake} and \sphinxstyleemphasis{mock} objects used in tests are composed by the prefixes \sphinxcode{\sphinxupquote{fake\_}} and \sphinxcode{\sphinxupquote{mock\_}}, respectively, and the filename of the object that is imitated.


\subsection{Header files}
\label{\detokenize{developing:header-files}}
All header files should be self\sphinxhyphen{}contained (i.e., not dependent on following any other header when it is included). Nor should they include files that are not necessary for their use (i.e., headers needed only by the implementation). Implementation files should not include files only for the benefit of files they include.

There are many header files that currently violate this.
Each header must use \sphinxcode{\sphinxupquote{\textbackslash{}\#define}} guards to prevent multiple inclusion.
The symbol name of the \sphinxcode{\sphinxupquote{\textbackslash{}\#define}} guards should be \sphinxcode{\sphinxupquote{NAMESPACE(s)\_CLASSNAME\_H}}.


\subsection{Includes}
\label{\detokenize{developing:includes}}
Header files should be included with the full path based on the \sphinxcode{\sphinxupquote{src}} directory.
For example, the file \sphinxcode{\sphinxupquote{qmcpack/src/QMCWaveFunctions/SPOSet.h}} should be included as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}QMCWaveFunctions/SPOSet.h\PYGZdq{}}
\end{sphinxVerbatim}

Even if the included file is located in the same directory as the including file, this rule should be obeyed. Header files from external projects and standard libraries should be includes using the \sphinxcode{\sphinxupquote{\textless{}iostream\textgreater{}}} convention, while headers that are part of the QMCPACK project should be included using the \sphinxcode{\sphinxupquote{"our\_header.h"}} convention.

For readability, we suggest using the following standard order of includes:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
related header

\item {} 
std C library headers

\item {} 
std C++ library headers

\item {} 
Other libraries’ headers

\item {} 
QMCPACK headers

\end{enumerate}

In each section the included files should be sorted in alphabetical order.


\section{Naming}
\label{\detokenize{developing:naming}}
The balance between description and ease of implementation should be balanced such that the code remains self\sphinxhyphen{}documenting within a single terminal window.  If an extremely short variable name is used, its scope must be shorter than \(\sim 40\) lines. An exception is made for template parameters, which must be in all CAPS.


\subsection{Namespace names}
\label{\detokenize{developing:namespace-names}}
Namespace names should be one word, lowercase.


\subsection{Type and class names}
\label{\detokenize{developing:type-and-class-names}}
Type and class names should start with a capital letter and have a capital letter for each new word.
Underscores (\sphinxcode{\sphinxupquote{\_}}) are not allowed.


\subsection{Variable names}
\label{\detokenize{developing:variable-names}}
Variable names should not begin with a capital letter, which is reserved for type and class names. Underscores (\sphinxcode{\sphinxupquote{\_}}) should be used to separate words.


\subsection{Class data members}
\label{\detokenize{developing:class-data-members}}
Class private/protected data members names should follow the convention of variable names with a trailing underscore (\sphinxcode{\sphinxupquote{\_}}).


\subsection{(Member) function names}
\label{\detokenize{developing:member-function-names}}
Function names should start with a lowercase character and have a capital letter for each new word.


\subsection{Lambda expressions}
\label{\detokenize{developing:lambda-expressions}}
Named lambda expressions follow the naming convention for functions:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{auto} \PYG{n}{myWhatever} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{i}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{p}{;} \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Macro names}
\label{\detokenize{developing:macro-names}}
Macro names should be all uppercase and can include underscores (\sphinxcode{\sphinxupquote{\_}}).
The underscore is not allowed as first or last character.


\subsection{Test case and test names}
\label{\detokenize{developing:test-case-and-test-names}}
Test code files should be named as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{DiracMatrix}\PYG{p}{;}
\PYG{o}{/}\PYG{o}{/}\PYG{n}{leads} \PYG{n}{to}
\PYG{n}{test\PYGZus{}dirac\PYGZus{}matrix}\PYG{o}{.}\PYG{n}{cpp}
\PYG{o}{/}\PYG{o}{/}\PYG{n}{which} \PYG{n}{contains} \PYG{n}{test} \PYG{n}{cases} \PYG{n}{named}
\PYG{n}{TEST\PYGZus{}CASE}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DiracMatrix\PYGZus{}update\PYGZus{}row}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{[wavefunction][fermion]}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

where the test case covers the \sphinxcode{\sphinxupquote{updateRow}} and  \sphinxcode{\sphinxupquote{{[}wavefunction{]}{[}fermion{]}}} indicates the test belongs to the fermion wavefunction functionality.


\section{Comments}
\label{\detokenize{developing:comments}}

\subsection{Comment style}
\label{\detokenize{developing:comment-style}}
Use the \sphinxcode{\sphinxupquote{// Comment}} syntax for actual comments.

Use

\begin{sphinxVerbatim}[commandchars=\\\{\}]
/** base class for Single\PYGZhy{}particle orbital sets
 *
 * SPOSet stands for S(ingle)P(article)O(rbital)Set which contains
 * a number of single\PYGZhy{}particle orbitals with capabilities of
 * evaluating \PYGZbs{}f\PYGZdl{} \PYGZbs{}psi\PYGZus{}j(\PYGZob{}\PYGZbs{}bf r\PYGZcb{}\PYGZus{}i)\PYGZbs{}f\PYGZdl{}
 */
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{n}{index} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{builder} \PYG{n+nb}{list} \PYG{n}{of} \PYG{n}{sposets}
\PYG{n+nb}{int} \PYG{n}{builder\PYGZus{}index}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Documentation}
\label{\detokenize{developing:documentation}}
Doxygen will be used for source documentation. Doxygen commands should be used when appropriate guidance on this has been decided.


\subsubsection{File docs}
\label{\detokenize{developing:file-docs}}
Do not put the file name after the \sphinxcode{\sphinxupquote{\textbackslash{}file}} Doxygen command. Doxygen will fill it in for the file the tag appears in.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{*}\PYG{o}{*} \PYGZbs{}\PYG{n}{file}
 \PYG{o}{*}  \PYG{n}{File} \PYG{n}{level} \PYG{n}{documentation}
 \PYG{o}{*}\PYG{o}{/}
\end{sphinxVerbatim}


\subsubsection{Class docs}
\label{\detokenize{developing:class-docs}}
Every class should have a short description (in the header of the file) of what it is and what is does.
Comments for public class member functions follow the same rules as general function comments.
Comments for private members are allowed but are not mandatory.


\subsubsection{Function docs}
\label{\detokenize{developing:function-docs}}
For function parameters whose type is non\sphinxhyphen{}const reference or pointer to non\sphinxhyphen{}const memory,
it should be specified if they are input (In:), output (Out:) or input\sphinxhyphen{}output parameters (InOut:).

Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Updates} \PYG{n}{foo} \PYG{o+ow}{and} \PYG{n}{computes} \PYG{n}{bar} \PYG{n}{using} \PYG{n}{in\PYGZus{}1} \PYG{o}{.}\PYG{o}{.} \PYG{n}{in\PYGZus{}5}\PYG{o}{.}
 \PYG{o}{*} \PYGZbs{}\PYG{n}{param}\PYG{p}{[}\PYG{o+ow}{in}\PYG{p}{]} \PYG{n}{in\PYGZus{}3}
 \PYG{o}{*} \PYGZbs{}\PYG{n}{param}\PYG{p}{[}\PYG{o+ow}{in}\PYG{p}{]} \PYG{n}{in\PYGZus{}5}
 \PYG{o}{*} \PYGZbs{}\PYG{n}{param}\PYG{p}{[}\PYG{o+ow}{in}\PYG{p}{,}\PYG{n}{out}\PYG{p}{]} \PYG{n}{foo}
 \PYG{o}{*} \PYGZbs{}\PYG{n}{param}\PYG{p}{[}\PYG{n}{out}\PYG{p}{]} \PYG{n}{bar}
 \PYG{o}{*}\PYG{o}{/}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{This} \PYG{o+ow}{is} \PYG{n}{probably} \PYG{o+ow}{not} \PYG{n}{what} \PYG{n}{our} \PYG{n}{clang}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{format} \PYG{n}{would} \PYG{n}{do}
\PYG{n}{void} \PYG{n}{computeFooBar}\PYG{p}{(}\PYG{n}{Type} \PYG{n}{in\PYGZus{}1}\PYG{p}{,} \PYG{n}{const} \PYG{n}{Type}\PYG{o}{\PYGZam{}} \PYG{n}{in\PYGZus{}2}\PYG{p}{,} \PYG{n}{Type}\PYG{o}{\PYGZam{}} \PYG{n}{in\PYGZus{}3}\PYG{p}{,}
                   \PYG{n}{const} \PYG{n}{Type}\PYG{o}{*} \PYG{n}{in\PYGZus{}4}\PYG{p}{,} \PYG{n}{Type}\PYG{o}{*} \PYG{n}{in\PYGZus{}5}\PYG{p}{,} \PYG{n}{Type}\PYG{o}{\PYGZam{}} \PYG{n}{foo}\PYG{p}{,}
                   \PYG{n}{Type}\PYG{o}{\PYGZam{}} \PYG{n}{bar}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Variable documentation}
\label{\detokenize{developing:variable-documentation}}
Name should be self\sphinxhyphen{}descriptive.  If you need documentation consider renaming first.


\subsection{Golden rule of comments}
\label{\detokenize{developing:golden-rule-of-comments}}
If you modify a piece of code, also adapt the comments that belong to it if necessary.


\section{Formatting and “style”}
\label{\detokenize{developing:formatting-and-style}}
Use the provided clang\sphinxhyphen{}format style in \sphinxcode{\sphinxupquote{src/.clang\sphinxhyphen{}format\}}} to format \sphinxcode{\sphinxupquote{.h}}, \sphinxcode{\sphinxupquote{.hpp}}, \sphinxcode{\sphinxupquote{.cu}}, and \sphinxcode{\sphinxupquote{.cpp}} files. Many of the following rules will be applied to the code by clang\sphinxhyphen{}format, which should allow you to ignore most of them if you always run it on your modified code.

You should use clang\sphinxhyphen{}format support and the \sphinxcode{\sphinxupquote{.clangformat}} file with your editor, use a Git precommit hook to run clang\sphinxhyphen{}format or run clang\sphinxhyphen{}format manually on every file you modify.  However, if you see numerous formatting updates outside of the code you have modified, first commit the formatting changes in a separate PR.


\subsection{Indentation}
\label{\detokenize{developing:indentation}}
Indentation consists of two spaces. Do not use tabs in the code.


\subsection{Line length}
\label{\detokenize{developing:line-length}}
The length of each line of your code should be at most \sphinxstyleemphasis{120} characters.


\subsection{Horizontal spacing}
\label{\detokenize{developing:horizontal-spacing}}
No trailing white spaces should be added to any line.
Use no space before a comma (\sphinxcode{\sphinxupquote{,}}) and a semicolon (\sphinxcode{\sphinxupquote{;}}), and add a space after them if they are not at the end of a line.


\subsection{Preprocessor directives}
\label{\detokenize{developing:preprocessor-directives}}
The preprocessor directives are not indented.
The hash is the first character of the line.


\subsection{Binary operators}
\label{\detokenize{developing:binary-operators}}
The assignment operators should always have spaces around them.


\subsection{Unary operators}
\label{\detokenize{developing:unary-operators}}
Do not put any space between an unary operator and its argument.


\subsection{Types}
\label{\detokenize{developing:types}}
The \sphinxcode{\sphinxupquote{using}} syntax is preferred to \sphinxcode{\sphinxupquote{typedef}} for type aliases.
If the actual type is not excessively long or complex, simply use it; renaming simple types makes code less understandable.


\subsection{Pointers and references}
\label{\detokenize{developing:pointers-and-references}}
Pointer or reference operators should go with the type. But understand the compiler reads them from right to left.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Type}\PYG{o}{*} \PYG{n}{var}\PYG{p}{;}
\PYG{n}{Type}\PYG{o}{\PYGZam{}} \PYG{n}{var}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Understand} \PYG{n}{this} \PYG{o+ow}{is} \PYG{n}{incompatible} \PYG{k}{with} \PYG{n}{multiple} \PYG{n}{declarations}
\PYG{n}{Type}\PYG{o}{*} \PYG{n}{var1}\PYG{p}{,} \PYG{n}{var2}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{var1} \PYG{o+ow}{is} \PYG{n}{a} \PYG{n}{pointer} \PYG{n}{to} \PYG{n}{Type} \PYG{n}{but} \PYG{n}{var2} \PYG{o+ow}{is} \PYG{n}{a} \PYG{n}{Type}\PYG{o}{.}
\end{sphinxVerbatim}


\subsection{Templates}
\label{\detokenize{developing:templates}}
The angle brackets of templates should not have any external or internal padding.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{C}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{Class1}\PYG{p}{;}

\PYG{n}{Class1}\PYG{o}{\PYGZlt{}}\PYG{n}{Class2}\PYG{o}{\PYGZlt{}}\PYG{n}{type1}\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n+nb}{object}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Vertical spacing}
\label{\detokenize{developing:vertical-spacing}}
Use empty lines when it helps to improve the readability of the code, but do not use too many.
Do not use empty lines after a brace that opens a scope
or before a brace that closes a scope.
Each file should contain an empty line at the end of the file.
Some editors add an empty line automatically, some do not.


\subsection{Variable declarations and definitions}
\label{\detokenize{developing:variable-declarations-and-definitions}}\begin{itemize}
\item {} 
Avoid declaring multiple variables in the same declaration, especially if they are not fundamental types:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{;}                        \PYG{o}{/}\PYG{o}{/} \PYG{n}{Not} \PYG{n}{recommended}
\PYG{n}{Matrix} \PYG{n}{a}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{my\PYGZhy{}matrix}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{n}{size}\PYG{p}{)}\PYG{p}{;}  \PYG{o}{/}\PYG{o}{/} \PYG{n}{Not} \PYG{n}{allowed}

\PYG{o}{/}\PYG{o}{/} \PYG{n}{Preferred}
\PYG{n+nb}{int} \PYG{n}{x}\PYG{p}{;}
\PYG{n+nb}{int} \PYG{n}{y}\PYG{p}{;}
\PYG{n}{Matrix} \PYG{n}{a}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{my\PYGZhy{}matrix}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Matrix} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
Use the following order for keywords and modifiers in  variable declarations:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{General} \PYG{n+nb}{type}
\PYG{p}{[}\PYG{n}{static}\PYG{p}{]} \PYG{p}{[}\PYG{n}{const}\PYG{o}{/}\PYG{n}{constexpr}\PYG{p}{]} \PYG{n}{Type} \PYG{n}{variable\PYGZus{}name}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/} \PYG{n}{Pointer}
\PYG{p}{[}\PYG{n}{static}\PYG{p}{]} \PYG{p}{[}\PYG{n}{const}\PYG{p}{]} \PYG{n}{Type}\PYG{o}{*} \PYG{p}{[}\PYG{n}{const}\PYG{p}{]} \PYG{n}{variable\PYGZus{}name}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/} \PYG{n}{Integer}
\PYG{o}{/}\PYG{o}{/} \PYG{n}{the} \PYG{n+nb}{int} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n}{optional} \PYG{o+ow}{not} \PYG{n+nb}{all} \PYG{n}{platforms} \PYG{n}{support} \PYG{n}{long}\PYG{p}{,} \PYG{n}{etc}\PYG{o}{.}
\PYG{p}{[}\PYG{n}{static}\PYG{p}{]} \PYG{p}{[}\PYG{n}{const}\PYG{o}{/}\PYG{n}{constexpr}\PYG{p}{]} \PYG{p}{[}\PYG{n}{signedness}\PYG{p}{]} \PYG{p}{[}\PYG{n}{size}\PYG{p}{]} \PYG{n+nb}{int} \PYG{n}{variable\PYGZus{}name}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/} \PYG{n}{Examples}\PYG{p}{:}
\PYG{n}{static} \PYG{n}{const} \PYG{n}{Matrix} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}


\PYG{n}{const} \PYG{n}{double}\PYG{o}{*} \PYG{n}{const} \PYG{n}{d}\PYG{p}{(}\PYG{l+m+mf}{3.14}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{constexpr} \PYG{n}{unsigned} \PYG{n}{long} \PYG{n}{l}\PYG{p}{(}\PYG{l+m+mi}{42}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{itemize}


\subsection{Function declarations and definitions}
\label{\detokenize{developing:function-declarations-and-definitions}}
The return type should be on the same line as the function name.
Parameters should also be on the same line unless they do not fit on it, in which case one parameter
per line aligned with the first parameter should be used.

Also include the parameter names in the declaration of a function, that is,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{calculates} \PYG{n}{a}\PYG{o}{*}\PYG{n}{b}\PYG{o}{+}\PYG{n}{c}
\PYG{n}{double} \PYG{n}{function}\PYG{p}{(}\PYG{n}{double} \PYG{n}{a}\PYG{p}{,} \PYG{n}{double} \PYG{n}{b}\PYG{p}{,} \PYG{n}{double} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/} \PYG{n}{avoid}
\PYG{n}{double} \PYG{n}{function}\PYG{p}{(}\PYG{n}{double}\PYG{p}{,} \PYG{n}{double}\PYG{p}{,} \PYG{n}{double}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{dont} \PYG{n}{do} \PYG{n}{this}
\PYG{n}{double} \PYG{n}{function}\PYG{p}{(}\PYG{n}{BigTemplatedSomething}\PYG{o}{\PYGZlt{}}\PYG{n}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{a}\PYG{p}{,} \PYG{n}{BigTemplatedSomething}\PYG{o}{\PYGZlt{}}\PYG{n}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{b}\PYG{p}{,}
                \PYG{n}{BigTemplatedSomething}\PYG{o}{\PYGZlt{}}\PYG{n}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{do} \PYG{n}{this}
\PYG{n}{double} \PYG{n}{function}\PYG{p}{(}\PYG{n}{BigTemplatedSomething}\PYG{o}{\PYGZlt{}}\PYG{n}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{a}\PYG{p}{,}
                \PYG{n}{BigTemplatedSomething}\PYG{o}{\PYGZlt{}}\PYG{n}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{b}\PYG{p}{,}
                \PYG{n}{BigTemplatedSomething}\PYG{o}{\PYGZlt{}}\PYG{n}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Conditionals}
\label{\detokenize{developing:conditionals}}
Examples:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{condition}\PYG{p}{)}
  \PYG{n}{statement}\PYG{p}{;}
\PYG{k}{else}
  \PYG{n}{statement}\PYG{p}{;}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{condition}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{statement}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{condition2}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{statement}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else}
\PYG{p}{\PYGZob{}}
  \PYG{n}{statement}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Switch statement}
\label{\detokenize{developing:switch-statement}}
Switch statements should always have a default case.

Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{switch} \PYG{p}{(}\PYG{n}{var}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{case} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{n}{statement1}\PYG{p}{;}
    \PYG{n}{statement2}\PYG{p}{;}
    \PYG{k}{break}\PYG{p}{;}

  \PYG{n}{case} \PYG{l+m+mi}{1}\PYG{p}{:}
    \PYG{n}{statement1}\PYG{p}{;}
    \PYG{n}{statement2}\PYG{p}{;}
    \PYG{k}{break}\PYG{p}{;}

  \PYG{n}{default}\PYG{p}{:}
    \PYG{n}{statement1}\PYG{p}{;}
    \PYG{n}{statement2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Loops}
\label{\detokenize{developing:loops}}
Examples:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{n}{statement}\PYG{p}{;} \PYG{n}{condition}\PYG{p}{;} \PYG{n}{statement}\PYG{p}{)}
  \PYG{n}{statement}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{(}\PYG{n}{statement}\PYG{p}{;} \PYG{n}{condition}\PYG{p}{;} \PYG{n}{statement}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{statement1}\PYG{p}{;}
  \PYG{n}{statement2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{while} \PYG{p}{(}\PYG{n}{condition}\PYG{p}{)}
  \PYG{n}{statement}\PYG{p}{;}

\PYG{k}{while} \PYG{p}{(}\PYG{n}{condition}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{statement1}\PYG{p}{;}
  \PYG{n}{statement2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{do}
\PYG{p}{\PYGZob{}}
  \PYG{n}{statement}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{while} \PYG{p}{(}\PYG{n}{condition}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Class format}
\label{\detokenize{developing:class-format}}\label{\detokenize{developing:id1}}
\sphinxcode{\sphinxupquote{public}}, \sphinxcode{\sphinxupquote{protected}}, and \sphinxcode{\sphinxupquote{private}} keywords are not indented.

Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Foo} \PYG{p}{:} \PYG{n}{public} \PYG{n}{Bar}
\PYG{p}{\PYGZob{}}
\PYG{n}{public}\PYG{p}{:}
  \PYG{n}{Foo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{explicit} \PYG{n}{Foo}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{var}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{void} \PYG{n}{function}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{void} \PYG{n}{emptyFunction}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

  \PYG{n}{void} \PYG{n}{setVar}\PYG{p}{(}\PYG{n}{const} \PYG{n+nb}{int} \PYG{n}{var}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{var\PYGZus{}} \PYG{o}{=} \PYG{n}{var}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{n+nb}{int} \PYG{n}{getVar}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{var\PYGZus{}}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

\PYG{n}{private}\PYG{p}{:}
  \PYG{n+nb}{bool} \PYG{n}{privateFunction}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

  \PYG{n+nb}{int} \PYG{n}{var\PYGZus{}}\PYG{p}{;}
  \PYG{n+nb}{int} \PYG{n}{var2\PYGZus{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Constructor initializer lists}
\label{\detokenize{developing:constructor-initializer-lists}}
Examples:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{When} \PYG{n}{everything} \PYG{n}{fits} \PYG{n}{on} \PYG{n}{one} \PYG{n}{line}\PYG{p}{:}
\PYG{n}{Foo}\PYG{p}{:}\PYG{p}{:}\PYG{n}{Foo}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{var}\PYG{p}{)} \PYG{p}{:} \PYG{n}{var\PYGZus{}}\PYG{p}{(}\PYG{n}{var}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{statement}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{o}{/}\PYG{o}{/} \PYG{n}{If} \PYG{n}{the} \PYG{n}{signature} \PYG{o+ow}{and} \PYG{n}{the} \PYG{n}{initializer} \PYG{n+nb}{list} \PYG{n}{do} \PYG{o+ow}{not}
\PYG{o}{/}\PYG{o}{/} \PYG{n}{fit} \PYG{n}{on} \PYG{n}{one} \PYG{n}{line}\PYG{p}{,} \PYG{n}{the} \PYG{n}{colon} \PYG{o+ow}{is} \PYG{n}{indented} \PYG{n}{by} \PYG{l+m+mi}{4} \PYG{n}{spaces}\PYG{p}{:}
\PYG{n}{Foo}\PYG{p}{:}\PYG{p}{:}\PYG{n}{Foo}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{var}\PYG{p}{)}
    \PYG{p}{:} \PYG{n}{var\PYGZus{}}\PYG{p}{(}\PYG{n}{var}\PYG{p}{)}\PYG{p}{,} \PYG{n}{var2\PYGZus{}}\PYG{p}{(}\PYG{n}{var} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{statement}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{o}{/}\PYG{o}{/} \PYG{n}{If} \PYG{n}{the} \PYG{n}{initializer} \PYG{n+nb}{list} \PYG{n}{occupies} \PYG{n}{more} \PYG{n}{lines}\PYG{p}{,}
\PYG{o}{/}\PYG{o}{/} \PYG{n}{they} \PYG{n}{are} \PYG{n}{aligned} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{following} \PYG{n}{way}\PYG{p}{:}
\PYG{n}{Foo}\PYG{p}{:}\PYG{p}{:}\PYG{n}{Foo}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{var}\PYG{p}{)}
    \PYG{p}{:} \PYG{n}{some\PYGZus{}var\PYGZus{}}\PYG{p}{(}\PYG{n}{var}\PYG{p}{)}\PYG{p}{,}
      \PYG{n}{some\PYGZus{}other\PYGZus{}var\PYGZus{}}\PYG{p}{(}\PYG{n}{var} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{statement}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{o}{/}\PYG{o}{/} \PYG{n}{No} \PYG{n}{statements}\PYG{p}{:}
\PYG{n}{Foo}\PYG{p}{:}\PYG{p}{:}\PYG{n}{Foo}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{var}\PYG{p}{)}
    \PYG{p}{:} \PYG{n}{some\PYGZus{}var\PYGZus{}}\PYG{p}{(}\PYG{n}{var}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Namespace formatting}
\label{\detokenize{developing:namespace-formatting}}
The content of namespaces is not indented.
A comment should indicate when a namespace is closed. (clang\sphinxhyphen{}format will add these if absent).
If nested namespaces are used, a comment with the full namespace is required after opening a set of namespaces or an inner namespace.

Examples:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{namespace} \PYG{n}{ns}
\PYG{p}{\PYGZob{}}
\PYG{n}{void} \PYG{n}{foo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}  \PYG{o}{/}\PYG{o}{/} \PYG{n}{ns}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{namespace} \PYG{n}{ns1}
\PYG{p}{\PYGZob{}}
\PYG{n}{namespace} \PYG{n}{ns2}
\PYG{p}{\PYGZob{}}
\PYG{o}{/}\PYG{o}{/} \PYG{n}{ns1}\PYG{p}{:}\PYG{p}{:}\PYG{n}{ns2}\PYG{p}{:}\PYG{p}{:}
\PYG{n}{void} \PYG{n}{foo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{namespace} \PYG{n}{ns3}
\PYG{p}{\PYGZob{}}
\PYG{o}{/}\PYG{o}{/} \PYG{n}{ns1}\PYG{p}{:}\PYG{p}{:}\PYG{n}{ns2}\PYG{p}{:}\PYG{p}{:}\PYG{n}{ns3}\PYG{p}{:}\PYG{p}{:}
\PYG{n}{void} \PYG{n}{bar}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}  \PYG{o}{/}\PYG{o}{/} \PYG{n}{ns3}
\PYG{p}{\PYGZcb{}}  \PYG{o}{/}\PYG{o}{/} \PYG{n}{ns2}

\PYG{n}{namespace} \PYG{n}{ns4}
\PYG{p}{\PYGZob{}}
\PYG{n}{namespace} \PYG{n}{ns5}
\PYG{p}{\PYGZob{}}
\PYG{o}{/}\PYG{o}{/} \PYG{n}{ns1}\PYG{p}{:}\PYG{p}{:}\PYG{n}{ns4}\PYG{p}{:}\PYG{p}{:}\PYG{n}{ns5}\PYG{p}{:}\PYG{p}{:}
\PYG{n}{void} \PYG{n}{foo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}  \PYG{o}{/}\PYG{o}{/} \PYG{n}{ns5}
\PYG{p}{\PYGZcb{}}  \PYG{o}{/}\PYG{o}{/} \PYG{n}{ns4}
\PYG{p}{\PYGZcb{}}  \PYG{o}{/}\PYG{o}{/} \PYG{n}{ns1}
\end{sphinxVerbatim}


\section{QMCPACK C++ guidance}
\label{\detokenize{developing:qmcpack-c-guidance}}
The guidance here, like any advice on how to program, should not be treated as a set of rules but rather the hard\sphinxhyphen{}won wisdom of many hours of suffering development. In the past, many rules were ignored, and the absolute worst results of that will affect whatever code you need to work with. Your PR should go much smoother if you do not ignore them.


\subsection{Encapsulation}
\label{\detokenize{developing:encapsulation}}
A class is not just a naming scheme for a set of variables and functions. It should provide a logical set of methods, could contain the state of a logical object, and might allow access to object data through a well\sphinxhyphen{}defined interface related variables, while preserving maximally ability to change internal implementation of the class.

Do not use \sphinxcode{\sphinxupquote{struct}} as a way to avoid controlling access to the class. Only in rare cases where a class is a fully public data structure \sphinxcode{\sphinxupquote{struct}} is this appropriate. Ignore (or fix one) the many examples of this in QMCPACK.

Do not use inheritance primarily as a means to break encapsulation. If your class could aggregate or compose another class, do that, and access it solely through its public interface. This will reduce dependencies.


\subsection{Casting}
\label{\detokenize{developing:casting}}
In C++ source, avoid C style casts; they are difficult to search for and imprecise in function.
An exception is made for controlling implicit conversion of simple numerical types.

Explicit C++ style casts make it clear what the safety of the cast is and what sort of conversion is expected to be possible.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n+nb}{int} \PYG{n}{d} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{n}{double} \PYG{n}{a}\PYG{p}{;}
\PYG{n}{a} \PYG{o}{=} \PYG{p}{(}\PYG{n}{double}\PYG{p}{)}\PYG{n}{c} \PYG{o}{/} \PYG{n}{d}\PYG{p}{;}  \PYG{o}{/}\PYG{o}{/} \PYG{n}{Ok}

\PYG{n}{const} \PYG{n}{class1} \PYG{n}{c1}\PYG{p}{;}
\PYG{n}{class2}\PYG{o}{*} \PYG{n}{c2}\PYG{p}{;}
\PYG{n}{c2} \PYG{o}{=} \PYG{p}{(}\PYG{n}{class2}\PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{c1}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{NO}
\PYG{n}{SPOSetAdvanced}\PYG{o}{*} \PYG{n}{spo\PYGZus{}advanced} \PYG{o}{=} \PYG{n}{new} \PYG{n}{SPOSetAdvanced}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{SPOSet}\PYG{o}{*} \PYG{n}{spo} \PYG{o}{=} \PYG{p}{(}\PYG{n}{SPOSet}\PYG{o}{*}\PYG{p}{)}\PYG{n}{spo\PYGZus{}advanced}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{NO}
\PYG{n}{SPOSet}\PYG{o}{*} \PYG{n}{spo} \PYG{o}{=} \PYG{n}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{SPOSet}\PYG{o}{*}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{spo\PYGZus{}advanced}\PYG{p}{)}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{OK} \PYG{k}{if} \PYG{n}{upcast}\PYG{p}{,} \PYG{n}{dangerous} \PYG{k}{if} \PYG{n}{downcast}
\end{sphinxVerbatim}


\subsection{Pre\sphinxhyphen{}increment and pre\sphinxhyphen{}decrement}
\label{\detokenize{developing:pre-increment-and-pre-decrement}}
Use the pre\sphinxhyphen{}increment (pre\sphinxhyphen{}decrement) operator when a variable is incremented (decremented) and the value of the expression is not used.
In particular, use the pre\sphinxhyphen{}increment (pre\sphinxhyphen{}decrement) operator for loop counters where i is not used:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{N}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{doSomething}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{for} \PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{N}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{doSomething}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The post\sphinxhyphen{}increment and post\sphinxhyphen{}decrement operators create an unnecessary copy that the compiler cannot optimize away in the case of iterators or other classes with overloaded increment and decrement operators.


\subsection{Alternative operator representations}
\label{\detokenize{developing:alternative-operator-representations}}
Alternative representations of operators and other tokens such as \sphinxcode{\sphinxupquote{and}}, \sphinxcode{\sphinxupquote{or}}, and \sphinxcode{\sphinxupquote{not}} instead of \sphinxcode{\sphinxupquote{\&\&}}, \sphinxcode{\sphinxupquote{||}}, and \sphinxcode{\sphinxupquote{!}} are not allowed.
For the reason of consistency, the far more common primary tokens should always be used.


\subsection{Use of const}
\label{\detokenize{developing:use-of-const}}\begin{itemize}
\item {} 
Add the \sphinxcode{\sphinxupquote{const}} qualifier to all function parameters that are not modified in the function body.

\item {} 
For parameters passed by value, add only the keyword in the function definition.

\item {} 
Member functions should be specified const whenever possible.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{Declaration}
\PYG{n+nb}{int} \PYG{n}{computeFoo}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{bar}\PYG{p}{,} \PYG{n}{const} \PYG{n}{Matrix}\PYG{o}{\PYGZam{}} \PYG{n}{m}\PYG{p}{)}

\PYG{o}{/}\PYG{o}{/} \PYG{n}{Definition}
\PYG{n+nb}{int} \PYG{n}{computeFoo}\PYG{p}{(}\PYG{n}{const} \PYG{n+nb}{int} \PYG{n}{bar}\PYG{p}{,} \PYG{n}{const} \PYG{n}{Matrix}\PYG{o}{\PYGZam{}} \PYG{n}{m}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n+nb}{int} \PYG{n}{foo} \PYG{o}{=} \PYG{l+m+mi}{42}\PYG{p}{;}

  \PYG{o}{/}\PYG{o}{/} \PYG{n}{Compute} \PYG{n}{foo} \PYG{n}{without} \PYG{n}{changing} \PYG{n}{bar} \PYG{o+ow}{or} \PYG{n}{m}\PYG{o}{.}
  \PYG{o}{/}\PYG{o}{/} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

  \PYG{k}{return} \PYG{n}{foo}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{class} \PYG{n+nc}{MyClass}
\PYG{p}{\PYGZob{}}
  \PYG{n+nb}{int} \PYG{n}{count\PYGZus{}}
  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
  \PYG{n+nb}{int} \PYG{n}{getCount}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{n}{count\PYGZus{}}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}


\section{Scalar estimator implementation}
\label{\detokenize{developing:scalar-estimator-implementation}}

\subsection{Introduction: Life of a specialized OperatorBase}
\label{\detokenize{developing:introduction-life-of-a-specialized-operatorbase}}
Almost all observables in QMCPACK are implemented as specialized derived
classes of the OperatorBase base class. Each observable is instantiated
in HamiltonianFactory and added to QMCHamiltonian for tracking.
QMCHamiltonian tracks two types of observables: main and auxiliary. Main
observables contribute to the local energy. These observables are
elements of the simulated Hamiltonian such as kinetic or potential
energy. Auxiliary observables are expectation values of matrix elements
that do not contribute to the local energy. These Hamiltonians do not
affect the dynamics of the simulation. In the code, the main observables
are labeled by “physical” flag; the auxiliary observables have
“physical” set to false.


\subsubsection{Initialization}
\label{\detokenize{developing:initialization}}
When an \sphinxcode{\sphinxupquote{\textless{}estimator type="est\_type" name="est\_name" other\_stuff="value"/\textgreater{}}} tag is present in the \sphinxcode{\sphinxupquote{\textless{}hamiltonian/\textgreater{}}} section, it is first read by HamiltonianFactory. In general, the \sphinxcode{\sphinxupquote{type}} of the estimator will determine which specialization of OperatorBase should be instantiated, and a derived class with \sphinxcode{\sphinxupquote{myName="est\_name"}} will be constructed. Then, the put() method of this specific class will be called to read any other parameters in the \sphinxcode{\sphinxupquote{\textless{}estimator/\textgreater{}}} XML node. Sometimes these parameters will instead be read by HamiltonianFactory because it can access more objects than OperatorBase.


\subsubsection{Cloning}
\label{\detokenize{developing:cloning}}
When \sphinxcode{\sphinxupquote{OpenMP}} threads are spawned, the estimator will be cloned by the \sphinxcode{\sphinxupquote{CloneManager}}, which is a parent class of many QMC drivers.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{CloneManager}\PYG{o}{.}\PYG{n}{cpp}
\PYG{c+c1}{\PYGZsh{}pragma omp parallel for shared(w,psi,ham)}
\PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{ip}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{ip}\PYG{o}{\PYGZlt{}}\PYG{n}{NumThreads}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{ip}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{wClones}\PYG{p}{[}\PYG{n}{ip}\PYG{p}{]}\PYG{o}{=}\PYG{n}{new} \PYG{n}{MCWalkerConfiguration}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{psiClones}\PYG{p}{[}\PYG{n}{ip}\PYG{p}{]}\PYG{o}{=}\PYG{n}{psi}\PYG{o}{.}\PYG{n}{makeClone}\PYG{p}{(}\PYG{o}{*}\PYG{n}{wClones}\PYG{p}{[}\PYG{n}{ip}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{hClones}\PYG{p}{[}\PYG{n}{ip}\PYG{p}{]}\PYG{o}{=}\PYG{n}{ham}\PYG{o}{.}\PYG{n}{makeClone}\PYG{p}{(}\PYG{o}{*}\PYG{n}{wClones}\PYG{p}{[}\PYG{n}{ip}\PYG{p}{]}\PYG{p}{,}\PYG{o}{*}\PYG{n}{psiClones}\PYG{p}{[}\PYG{n}{ip}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

In the preceding snippet, \sphinxcode{\sphinxupquote{ham}} is the reference to the estimator on the master thread. If the implemented estimator does not allocate memory for any array, then the default constructor should suffice for the \sphinxcode{\sphinxupquote{makeClone}} method.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{SpeciesKineticEnergy}\PYG{o}{.}\PYG{n}{cpp}
\PYG{n}{OperatorBase}\PYG{o}{*} \PYG{n}{SpeciesKineticEnergy}\PYG{p}{:}\PYG{p}{:}\PYG{n}{makeClone}\PYG{p}{(}\PYG{n}{ParticleSet}\PYG{o}{\PYGZam{}} \PYG{n}{qp}\PYG{p}{,} \PYG{n}{TrialWaveFunction}\PYG{o}{\PYGZam{}} \PYG{n}{psi}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{return} \PYG{n}{new} \PYG{n}{SpeciesKineticEnergy}\PYG{p}{(}\PYG{o}{*}\PYG{n}{this}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

If memory is allocated during estimator construction (usually when parsing the XML node in the \sphinxcode{\sphinxupquote{put}} method), then the \sphinxcode{\sphinxupquote{makeClone}} method should perform the same initialization on each thread.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{OperatorBase}\PYG{o}{*} \PYG{n}{LatticeDeviationEstimator}\PYG{p}{:}\PYG{p}{:}\PYG{n}{makeClone}\PYG{p}{(}\PYG{n}{ParticleSet}\PYG{o}{\PYGZam{}} \PYG{n}{qp}\PYG{p}{,} \PYG{n}{TrialWaveFunction}\PYG{o}{\PYGZam{}} \PYG{n}{psi}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{LatticeDeviationEstimator}\PYG{o}{*} \PYG{n}{myclone} \PYG{o}{=} \PYG{n}{new} \PYG{n}{LatticeDeviationEstimator}\PYG{p}{(}\PYG{n}{qp}\PYG{p}{,}\PYG{n}{spset}\PYG{p}{,}\PYG{n}{tgroup}\PYG{p}{,}\PYG{n}{sgroup}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{myclone}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{put}\PYG{p}{(}\PYG{n}{input\PYGZus{}xml}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{return} \PYG{n}{myclone}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Evaluate}
\label{\detokenize{developing:evaluate}}
After the observable class (derived class of OperatorBase) is constructed and prepared (by the put() method), it is ready to be used in a QMCDriver. A QMCDriver will call \sphinxcode{\sphinxupquote{H.auxHevaluate(W,thisWalker)}} after every accepted move, where H is the QMCHamiltonian that holds all main and auxiliary Hamiltonian elements, W is a MCWalkerConfiguration, and thisWalker is a pointer to the current walker being worked on. As shown in the following, this function goes through each auxiliary Hamiltonian element and evaluates it using the current walker configuration. Under the hood, observables are calculated and dumped to the main particle set’s property list for later collection.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{QMCHamiltonian}\PYG{o}{.}\PYG{n}{cpp}
\PYG{o}{/}\PYG{o}{/} \PYG{n}{This} \PYG{o+ow}{is} \PYG{n}{more} \PYG{n}{efficient}\PYG{o}{.}
\PYG{o}{/}\PYG{o}{/} \PYG{n}{Only} \PYG{n}{calculate} \PYG{n}{auxH} \PYG{n}{elements} \PYG{k}{if} \PYG{n}{moves} \PYG{n}{are} \PYG{n}{accepted}\PYG{o}{.}
\PYG{n}{void} \PYG{n}{QMCHamiltonian}\PYG{p}{:}\PYG{p}{:}\PYG{n}{auxHevaluate}\PYG{p}{(}\PYG{n}{ParticleSet}\PYG{o}{\PYGZam{}} \PYG{n}{P}\PYG{p}{,} \PYG{n}{Walker\PYGZus{}t}\PYG{o}{\PYGZam{}} \PYG{n}{ThisWalker}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+c1}{\PYGZsh{}if !defined(REMOVE\PYGZus{}TRACEMANAGER)}
  \PYG{n}{collect\PYGZus{}walker\PYGZus{}traces}\PYG{p}{(}\PYG{n}{ThisWalker}\PYG{p}{,}\PYG{n}{P}\PYG{o}{.}\PYG{n}{current\PYGZus{}step}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{\PYGZsh{}endif}
  \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{auxH}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{auxH}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setHistories}\PYG{p}{(}\PYG{n}{ThisWalker}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{RealType} \PYG{n}{sink} \PYG{o}{=} \PYG{n}{auxH}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{evaluate}\PYG{p}{(}\PYG{n}{P}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{auxH}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setObservables}\PYG{p}{(}\PYG{n}{Observables}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{\PYGZsh{}if !defined(REMOVE\PYGZus{}TRACEMANAGER)}
    \PYG{n}{auxH}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{collect\PYGZus{}scalar\PYGZus{}traces}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{\PYGZsh{}endif}
    \PYG{n}{auxH}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setParticlePropertyList}\PYG{p}{(}\PYG{n}{P}\PYG{o}{.}\PYG{n}{PropertyList}\PYG{p}{,}\PYG{n}{myIndex}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

For estimators that contribute to the local energy (main observables), the return value of evaluate() is used in accumulating the local energy. For auxiliary estimators, the return value is not used (\sphinxcode{\sphinxupquote{sink}} local variable above); only the value of Value is recorded property lists by the setObservables() method as shown in the preceding code snippet. By default, the setObservables() method will transfer \sphinxcode{\sphinxupquote{auxH{[}i{]}\sphinxhyphen{}\textgreater{}Value}} to \sphinxcode{\sphinxupquote{P.PropertyList{[}auxH{[}i{]}\sphinxhyphen{}\textgreater{}myIndex{]}}}. The same property list is also kept by the particle set being moved by QMCDriver. This list is updated by \sphinxcode{\sphinxupquote{auxH{[}i{]}\sphinxhyphen{}\textgreater{}setParticlePropertyList(P.PropertyList,myIndex)}}, where myIndex is the starting index of space allocated to this specific auxiliary Hamiltonian in the property list kept by the target particle set P.


\subsubsection{Collection}
\label{\detokenize{developing:collection}}
The actual statistics are collected within the QMCDriver, which owns
an EstimatorManager object. This object (or a clone in the case of
multithreading) will be registered with each mover it owns. For each mover
(such as VMCUpdatePbyP derived from QMCUpdateBase), an accumulate() call
is made, which by default, makes an accumulate(walkerset) call to the
EstimatorManager it owns. Since each walker has a property set, EstimatorManager uses that local copy to calculate statistics. The EstimatorManager performs block averaging and file I/O.


\subsection{Single scalar estimator implementation guide}
\label{\detokenize{developing:single-scalar-estimator-implementation-guide}}
Almost all of the defaults can be used for a single scalar observable. With any luck, only the put() and evaluate() methods need to be implemented. As an example, this section presents a step\sphinxhyphen{}by\sphinxhyphen{}step guide for implementing a verb|SpeciesKineticEnergy| estimator that calculates the kinetic energy of a specific species instead of the entire particle set. For example, a possible input to this estimator can be:

\sphinxcode{\sphinxupquote{\textless{}estimator type="specieskinetic" name="ukinetic" group="u"/\textgreater{}}}

\sphinxcode{\sphinxupquote{\textless{}estimator type="specieskinetic" name="dkinetic" group="d"/\textgreater{}}}.

This should create two extra columns in the \sphinxcode{\sphinxupquote{scalar.dat}} file that contains the kinetic energy of the up and down electrons in two separate columns. If the estimator is properly implemented, then the sum of these two columns should be equal to the default \sphinxcode{\sphinxupquote{Kinetic}} column.


\subsubsection{Barebone}
\label{\detokenize{developing:barebone}}
The first step is to create a barebone class structure for this simple scalar estimator. The goal is to be able to instantiate this scalar estimator with an XML node and have it print out a column of zeros in the \sphinxcode{\sphinxupquote{scalar.dat}} file.

To achieve this, first create a header file “SpeciesKineticEnergy.h” in the QMCHamiltonians folder, with only the required functions declared as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{SpeciesKineticEnergy}\PYG{o}{.}\PYG{n}{h}
\PYG{c+c1}{\PYGZsh{}ifndef QMCPLUSPLUS\PYGZus{}SPECIESKINETICENERGY\PYGZus{}H}
\PYG{c+c1}{\PYGZsh{}define QMCPLUSPLUS\PYGZus{}SPECIESKINETICENERGY\PYGZus{}H}

\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}Particle/WalkerSetRef.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}QMCHamiltonians/OperatorBase.h\PYGZgt{}}

\PYG{n}{namespace} \PYG{n}{qmcplusplus}
\PYG{p}{\PYGZob{}}

\PYG{k}{class} \PYG{n+nc}{SpeciesKineticEnergy}\PYG{p}{:} \PYG{n}{public} \PYG{n}{OperatorBase}
\PYG{p}{\PYGZob{}}
\PYG{n}{public}\PYG{p}{:}

  \PYG{n}{SpeciesKineticEnergy}\PYG{p}{(}\PYG{n}{ParticleSet}\PYG{o}{\PYGZam{}} \PYG{n}{P}\PYG{p}{)}\PYG{p}{:}\PYG{n}{tpset}\PYG{p}{(}\PYG{n}{P}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{p}{\PYGZcb{}}\PYG{p}{;}

  \PYG{n+nb}{bool} \PYG{n}{put}\PYG{p}{(}\PYG{n}{xmlNodePtr} \PYG{n}{cur}\PYG{p}{)}\PYG{p}{;}         \PYG{o}{/}\PYG{o}{/} \PYG{n}{read} \PYG{n+nb}{input} \PYG{n}{xml} \PYG{n}{node}\PYG{p}{,} \PYG{n}{required}
  \PYG{n+nb}{bool} \PYG{n}{get}\PYG{p}{(}\PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{os}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{k}{class} \PYG{n+nc}{description}\PYG{p}{,} \PYG{n}{required}

  \PYG{n}{Return\PYGZus{}t} \PYG{n}{evaluate}\PYG{p}{(}\PYG{n}{ParticleSet}\PYG{o}{\PYGZam{}} \PYG{n}{P}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{inline} \PYG{n}{Return\PYGZus{}t} \PYG{n}{evaluate}\PYG{p}{(}\PYG{n}{ParticleSet}\PYG{o}{\PYGZam{}} \PYG{n}{P}\PYG{p}{,} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{NonLocalData}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{Txy}\PYG{p}{)}
  \PYG{p}{\PYGZob{}} \PYG{o}{/}\PYG{o}{/} \PYG{n}{delegate} \PYG{n}{responsity} \PYG{n}{inline} \PYG{k}{for} \PYG{n}{speed}
    \PYG{k}{return} \PYG{n}{evaluate}\PYG{p}{(}\PYG{n}{P}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{o}{/}\PYG{o}{/} \PYG{n}{pure} \PYG{n}{virtual} \PYG{n}{functions} \PYG{n}{require} \PYG{n}{overrider}
  \PYG{n}{void} \PYG{n}{resetTargetParticleSet}\PYG{p}{(}\PYG{n}{ParticleSet}\PYG{o}{\PYGZam{}} \PYG{n}{P}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{p}{\PYGZcb{}}                         \PYG{o}{/}\PYG{o}{/} \PYG{n}{required}
  \PYG{n}{OperatorBase}\PYG{o}{*} \PYG{n}{makeClone}\PYG{p}{(}\PYG{n}{ParticleSet}\PYG{o}{\PYGZam{}} \PYG{n}{qp}\PYG{p}{,} \PYG{n}{TrialWaveFunction}\PYG{o}{\PYGZam{}} \PYG{n}{psi}\PYG{p}{)}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{required}

\PYG{n}{private}\PYG{p}{:}
  \PYG{n}{ParticleSet}\PYG{o}{\PYGZam{}} \PYG{n}{tpset}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{SpeciesKineticEnergy}

\PYG{p}{\PYGZcb{}} \PYG{o}{/}\PYG{o}{/} \PYG{n}{namespace} \PYG{n}{qmcplusplus}
\PYG{c+c1}{\PYGZsh{}endif}
\end{sphinxVerbatim}

Notice that a local reference \sphinxcode{\sphinxupquote{tpset}} to the target particle set \sphinxcode{\sphinxupquote{P}} is saved in the constructor. The target particle set carries much information useful for calculating observables. Next, make “SpeciesKineticEnergy.cpp,” and make vacuous definitions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{SpeciesKineticEnergy}\PYG{o}{.}\PYG{n}{cpp}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}QMCHamiltonians/SpeciesKineticEnergy.h\PYGZgt{}}
\PYG{n}{namespace} \PYG{n}{qmcplusplus}
\PYG{p}{\PYGZob{}}

\PYG{n+nb}{bool} \PYG{n}{SpeciesKineticEnergy}\PYG{p}{:}\PYG{p}{:}\PYG{n}{put}\PYG{p}{(}\PYG{n}{xmlNodePtr} \PYG{n}{cur}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{return} \PYG{n}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n+nb}{bool} \PYG{n}{SpeciesKineticEnergy}\PYG{p}{:}\PYG{p}{:}\PYG{n}{get}\PYG{p}{(}\PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{os}\PYG{p}{)} \PYG{n}{const}
\PYG{p}{\PYGZob{}}
  \PYG{k}{return} \PYG{n}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{SpeciesKineticEnergy}\PYG{p}{:}\PYG{p}{:}\PYG{n}{Return\PYGZus{}t} \PYG{n}{SpeciesKineticEnergy}\PYG{p}{:}\PYG{p}{:}\PYG{n}{evaluate}\PYG{p}{(}\PYG{n}{ParticleSet}\PYG{o}{\PYGZam{}} \PYG{n}{P}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{Value} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
  \PYG{k}{return} \PYG{n}{Value}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{OperatorBase}\PYG{o}{*} \PYG{n}{SpeciesKineticEnergy}\PYG{p}{:}\PYG{p}{:}\PYG{n}{makeClone}\PYG{p}{(}\PYG{n}{ParticleSet}\PYG{o}{\PYGZam{}} \PYG{n}{qp}\PYG{p}{,} \PYG{n}{TrialWaveFunction}\PYG{o}{\PYGZam{}} \PYG{n}{psi}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{o}{/}\PYG{o}{/} \PYG{n}{no} \PYG{n}{local} \PYG{n}{array} \PYG{n}{allocated}\PYG{p}{,} \PYG{n}{default} \PYG{n}{constructor} \PYG{n}{should} \PYG{n}{be} \PYG{n}{enough}
  \PYG{k}{return} \PYG{n}{new} \PYG{n}{SpeciesKineticEnergy}\PYG{p}{(}\PYG{o}{*}\PYG{n}{this}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}} \PYG{o}{/}\PYG{o}{/} \PYG{n}{namespace} \PYG{n}{qmcplusplus}
\end{sphinxVerbatim}

Now, head over to HamiltonianFactory and instantiate this observable if an XML node is found requesting it. Look for “gofr” in HamiltonianFactory.cpp, for example, and follow the if block.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{HamiltonianFactory}\PYG{o}{.}\PYG{n}{cpp}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}QMCHamiltonians/SpeciesKineticEnergy.h\PYGZgt{}}
\PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{potType} \PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{specieskinetic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{SpeciesKineticEnergy}\PYG{o}{*} \PYG{n}{apot} \PYG{o}{=} \PYG{n}{new} \PYG{n}{SpeciesKineticEnergy}\PYG{p}{(}\PYG{o}{*}\PYG{n}{target\PYGZus{}particle\PYGZus{}set}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{apot}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{put}\PYG{p}{(}\PYG{n}{cur}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{targetH}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{addOperator}\PYG{p}{(}\PYG{n}{apot}\PYG{p}{,}\PYG{n}{potName}\PYG{p}{,}\PYG{n}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The last argument of addOperator() (i.e., the \sphinxcode{\sphinxupquote{false}} flag) is \sphinxstylestrong{crucial}. This tells QMCPACK that the observable we implemented is not a physical Hamiltonian; thus, it will not contribute to the local energy. Changes to the local energy will alter the dynamics of the simulation. Finally, add “SpeciesKineticEnergy.cpp” to HAMSRCS in “CMakeLists.txt” located in the QMCHamiltonians folder. Now, recompile QMCPACK and run it on an input that requests \sphinxcode{\sphinxupquote{\textless{}estimator type="specieskinetic" name="ukinetic"/\textgreater{}}} in the \sphinxcode{\sphinxupquote{hamiltonian}} block. A column of zeros should appear in the \sphinxcode{\sphinxupquote{scalar.dat}} file under the name “ukinetic.”


\subsubsection{Evaluate}
\label{\detokenize{developing:id2}}
The evaluate() method is where we perform the calculation of the desired observable. In a first iteration, we will simply hard\sphinxhyphen{}code the name and mass of the particles.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{SpeciesKineticEnergy}\PYG{o}{.}\PYG{n}{cpp}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}QMCHamiltonians/BareKineticEnergy.h\PYGZgt{} // laplaician() defined here}
\PYG{n}{SpeciesKineticEnergy}\PYG{p}{:}\PYG{p}{:}\PYG{n}{Return\PYGZus{}t} \PYG{n}{SpeciesKineticEnergy}\PYG{p}{:}\PYG{p}{:}\PYG{n}{evaluate}\PYG{p}{(}\PYG{n}{ParticleSet}\PYG{o}{\PYGZam{}} \PYG{n}{P}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{string} \PYG{n}{group}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{RealType} \PYG{n}{minus\PYGZus{}over\PYGZus{}2m} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{;}

  \PYG{n}{SpeciesSet}\PYG{o}{\PYGZam{}} \PYG{n}{tspecies}\PYG{p}{(}\PYG{n}{P}\PYG{o}{.}\PYG{n}{getSpeciesSet}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{Value} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{iat}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iat}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{.}\PYG{n}{getTotalNum}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{iat}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{tspecies}\PYG{o}{.}\PYG{n}{speciesName}\PYG{p}{[} \PYG{n}{P}\PYG{o}{.}\PYG{n}{GroupID}\PYG{p}{(}\PYG{n}{iat}\PYG{p}{)} \PYG{p}{]} \PYG{o}{==} \PYG{n}{group}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{Value} \PYG{o}{+}\PYG{o}{=} \PYG{n}{minus\PYGZus{}over\PYGZus{}2m}\PYG{o}{*}\PYG{n}{laplacian}\PYG{p}{(}\PYG{n}{P}\PYG{o}{.}\PYG{n}{G}\PYG{p}{[}\PYG{n}{iat}\PYG{p}{]}\PYG{p}{,}\PYG{n}{P}\PYG{o}{.}\PYG{n}{L}\PYG{p}{[}\PYG{n}{iat}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{return} \PYG{n}{Value}\PYG{p}{;}

  \PYG{o}{/}\PYG{o}{/} \PYG{n}{Kinetic} \PYG{n}{column} \PYG{n}{has}\PYG{p}{:}
  \PYG{o}{/}\PYG{o}{/} \PYG{n}{Value} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{p}{(} \PYG{n}{Dot}\PYG{p}{(}\PYG{n}{P}\PYG{o}{.}\PYG{n}{G}\PYG{p}{,}\PYG{n}{P}\PYG{o}{.}\PYG{n}{G}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Sum}\PYG{p}{(}\PYG{n}{P}\PYG{o}{.}\PYG{n}{L}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Voila}—you should now be able to compile QMCPACK, rerun, and see that the values in the “ukinetic” column are no longer zero. Now, the only task left to make this basic observable complete is to read in the extra parameters instead of hard\sphinxhyphen{}coding them.


\subsubsection{Parse extra input}
\label{\detokenize{developing:parse-extra-input}}
The preferred method to parse extra input parameters in the XML node is
to implement the put() function of our specific observable. Suppose we
wish to read in a single string that tells us whether to record the
kinetic energy of the up electron (group=“u”) or the down electron
(group=“d”). This is easily achievable using the OhmmsAttributeSet
class,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{SpeciesKineticEnergy}\PYG{o}{.}\PYG{n}{cpp}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}OhmmsData/AttributeSet.h\PYGZgt{}}
\PYG{n+nb}{bool} \PYG{n}{SpeciesKineticEnergy}\PYG{p}{:}\PYG{p}{:}\PYG{n}{put}\PYG{p}{(}\PYG{n}{xmlNodePtr} \PYG{n}{cur}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{o}{/}\PYG{o}{/} \PYG{n}{read} \PYG{o+ow}{in} \PYG{n}{extra} \PYG{n}{parameter} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{group}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{n}{OhmmsAttributeSet} \PYG{n}{attrib}\PYG{p}{;}
  \PYG{n}{attrib}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{group}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{group}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{attrib}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{n}{cur}\PYG{p}{)}\PYG{p}{;}

  \PYG{o}{/}\PYG{o}{/} \PYG{n}{save} \PYG{n}{mass} \PYG{n}{of} \PYG{n}{specified} \PYG{n}{group} \PYG{n}{of} \PYG{n}{particles}
  \PYG{n}{SpeciesSet}\PYG{o}{\PYGZam{}} \PYG{n}{tspecies}\PYG{p}{(}\PYG{n}{tpset}\PYG{o}{.}\PYG{n}{getSpeciesSet}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{n+nb}{int} \PYG{n}{group\PYGZus{}id}  \PYG{o}{=} \PYG{n}{tspecies}\PYG{o}{.}\PYG{n}{findSpecies}\PYG{p}{(}\PYG{n}{group}\PYG{p}{)}\PYG{p}{;}
  \PYG{n+nb}{int} \PYG{n}{massind}   \PYG{o}{=} \PYG{n}{tspecies}\PYG{o}{.}\PYG{n}{getAttribute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mass}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{minus\PYGZus{}over\PYGZus{}2m} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{tspecies}\PYG{p}{(}\PYG{n}{massind}\PYG{p}{,}\PYG{n}{group\PYGZus{}id}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{return} \PYG{n}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

where we may keep “group” and “minus\_over\_2m” as local variables to our specific class.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{SpeciesKineticEnergy}\PYG{o}{.}\PYG{n}{h}
\PYG{n}{private}\PYG{p}{:}
  \PYG{n}{ParticleSet}\PYG{o}{\PYGZam{}} \PYG{n}{tpset}\PYG{p}{;}
  \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{string}  \PYG{n}{group}\PYG{p}{;}
  \PYG{n}{RealType} \PYG{n}{minus\PYGZus{}over\PYGZus{}2m}\PYG{p}{;}
\end{sphinxVerbatim}

Notice that the previous operations are made possible by the saved reference to the target particle set. Last but not least, compile and run a full example (i.e., a short DMC calculation) with the following XML nodes in your input:

\sphinxcode{\sphinxupquote{\textless{}estimator type="specieskinetic" name="ukinetic" group="u"/\textgreater{}}}

\sphinxcode{\sphinxupquote{\textless{}estimator type="specieskinetic" name="dkinetic" group="d"/\textgreater{}}}

Make sure the sum of the “ukinetic” and “dkinetic” columns is
\sphinxstylestrong{exactly} the same as the Kinetic columns at \sphinxstylestrong{every block}.

For easy reference, a summary of the complete list of changes follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{HamiltonianFactory}\PYG{o}{.}\PYG{n}{cpp}
\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}QMCHamiltonians/SpeciesKineticEnergy.h\PYGZdq{}}
\PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{potType} \PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{specieskinetic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
      \PYG{n}{SpeciesKineticEnergy}\PYG{o}{*} \PYG{n}{apot} \PYG{o}{=} \PYG{n}{new} \PYG{n}{SpeciesKineticEnergy}\PYG{p}{(}\PYG{o}{*}\PYG{n}{targetPtcl}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{apot}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{put}\PYG{p}{(}\PYG{n}{cur}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{targetH}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{addOperator}\PYG{p}{(}\PYG{n}{apot}\PYG{p}{,}\PYG{n}{potName}\PYG{p}{,}\PYG{n}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
// In SpeciesKineticEnergy.h
\PYGZsh{}include \PYGZlt{}Particle/WalkerSetRef.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}QMCHamiltonians/OperatorBase.h\PYGZgt{}

namespace qmcplusplus
\PYGZob{}

class SpeciesKineticEnergy: public OperatorBase
\PYGZob{}
public:

  SpeciesKineticEnergy(ParticleSet\PYGZam{} P):tpset(P)\PYGZob{} \PYGZcb{};

  // xml node is read by HamiltonianFactory, eg. the sum of following should be equivalent to Kinetic
  // \PYGZlt{}estimator name=\PYGZdq{}ukinetic\PYGZdq{} type=\PYGZdq{}specieskinetic\PYGZdq{} target=\PYGZdq{}e\PYGZdq{} group=\PYGZdq{}u\PYGZdq{}/\PYGZgt{}
  // \PYGZlt{}estimator name=\PYGZdq{}dkinetic\PYGZdq{} type=\PYGZdq{}specieskinetic\PYGZdq{} target=\PYGZdq{}e\PYGZdq{} group=\PYGZdq{}d\PYGZdq{}/\PYGZgt{}
  bool put(xmlNodePtr cur);         // read input xml node, required
  bool get(std::ostream\PYGZam{} os) const; // class description, required

  Return\PYGZus{}t evaluate(ParticleSet\PYGZam{} P);
  inline Return\PYGZus{}t evaluate(ParticleSet\PYGZam{} P, std::vector\PYGZlt{}NonLocalData\PYGZgt{}\PYGZam{} Txy)
  \PYGZob{} // delegate responsity inline for speed
    return evaluate(P);
  \PYGZcb{}

  // pure virtual functions require overrider
  void resetTargetParticleSet(ParticleSet\PYGZam{} P) \PYGZob{} \PYGZcb{}                         // required
  OperatorBase* makeClone(ParticleSet\PYGZam{} qp, TrialWaveFunction\PYGZam{} psi); // required

private:
  ParticleSet\PYGZam{}       tpset; // reference to target particle set
  std::string        group; // name of species to track
  RealType   minus\PYGZus{}over\PYGZus{}2m; // mass of the species !! assume same mass
  // for multiple species, simply initialize multiple estimators

\PYGZcb{}; // SpeciesKineticEnergy

\PYGZcb{} // namespace qmcplusplus
\PYGZsh{}endif
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{SpeciesKineticEnergy}\PYG{o}{.}\PYG{n}{cpp}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}QMCHamiltonians/SpeciesKineticEnergy.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}QMCHamiltonians/BareKineticEnergy.h\PYGZgt{} // laplaician() defined here}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}OhmmsData/AttributeSet.h\PYGZgt{}}

\PYG{n}{namespace} \PYG{n}{qmcplusplus}
\PYG{p}{\PYGZob{}}

\PYG{n+nb}{bool} \PYG{n}{SpeciesKineticEnergy}\PYG{p}{:}\PYG{p}{:}\PYG{n}{put}\PYG{p}{(}\PYG{n}{xmlNodePtr} \PYG{n}{cur}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{o}{/}\PYG{o}{/} \PYG{n}{read} \PYG{o+ow}{in} \PYG{n}{extra} \PYG{n}{parameter} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{group}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{n}{OhmmsAttributeSet} \PYG{n}{attrib}\PYG{p}{;}
  \PYG{n}{attrib}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{group}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{group}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{attrib}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{n}{cur}\PYG{p}{)}\PYG{p}{;}

  \PYG{o}{/}\PYG{o}{/} \PYG{n}{save} \PYG{n}{mass} \PYG{n}{of} \PYG{n}{specified} \PYG{n}{group} \PYG{n}{of} \PYG{n}{particles}
  \PYG{n+nb}{int} \PYG{n}{group\PYGZus{}id}  \PYG{o}{=} \PYG{n}{tspecies}\PYG{o}{.}\PYG{n}{findSpecies}\PYG{p}{(}\PYG{n}{group}\PYG{p}{)}\PYG{p}{;}
  \PYG{n+nb}{int} \PYG{n}{massind}   \PYG{o}{=} \PYG{n}{tspecies}\PYG{o}{.}\PYG{n}{getAttribute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mass}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{minus\PYGZus{}over\PYGZus{}2m} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{tspecies}\PYG{p}{(}\PYG{n}{massind}\PYG{p}{,}\PYG{n}{group\PYGZus{}id}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{return} \PYG{n}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n+nb}{bool} \PYG{n}{SpeciesKineticEnergy}\PYG{p}{:}\PYG{p}{:}\PYG{n}{get}\PYG{p}{(}\PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{os}\PYG{p}{)} \PYG{n}{const}
\PYG{p}{\PYGZob{}} \PYG{o}{/}\PYG{o}{/} \PYG{k}{class} \PYG{n+nc}{description}
  \PYG{n}{os} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SpeciesKineticEnergy: }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{myName} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ for species }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{group}\PYG{p}{;}
  \PYG{k}{return} \PYG{n}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{SpeciesKineticEnergy}\PYG{p}{:}\PYG{p}{:}\PYG{n}{Return\PYGZus{}t} \PYG{n}{SpeciesKineticEnergy}\PYG{p}{:}\PYG{p}{:}\PYG{n}{evaluate}\PYG{p}{(}\PYG{n}{ParticleSet}\PYG{o}{\PYGZam{}} \PYG{n}{P}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{Value} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{iat}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iat}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{.}\PYG{n}{getTotalNum}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{iat}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{tspecies}\PYG{o}{.}\PYG{n}{speciesName}\PYG{p}{[} \PYG{n}{P}\PYG{o}{.}\PYG{n}{GroupID}\PYG{p}{(}\PYG{n}{iat}\PYG{p}{)} \PYG{p}{]} \PYG{o}{==} \PYG{n}{group}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{Value} \PYG{o}{+}\PYG{o}{=} \PYG{n}{minus\PYGZus{}over\PYGZus{}2m}\PYG{o}{*}\PYG{n}{laplacian}\PYG{p}{(}\PYG{n}{P}\PYG{o}{.}\PYG{n}{G}\PYG{p}{[}\PYG{n}{iat}\PYG{p}{]}\PYG{p}{,}\PYG{n}{P}\PYG{o}{.}\PYG{n}{L}\PYG{p}{[}\PYG{n}{iat}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{return} \PYG{n}{Value}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{OperatorBase}\PYG{o}{*} \PYG{n}{SpeciesKineticEnergy}\PYG{p}{:}\PYG{p}{:}\PYG{n}{makeClone}\PYG{p}{(}\PYG{n}{ParticleSet}\PYG{o}{\PYGZam{}} \PYG{n}{qp}\PYG{p}{,} \PYG{n}{TrialWaveFunction}\PYG{o}{\PYGZam{}} \PYG{n}{psi}\PYG{p}{)}
\PYG{p}{\PYGZob{}} \PYG{o}{/}\PYG{o}{/}\PYG{n}{default} \PYG{n}{constructor}
  \PYG{k}{return} \PYG{n}{new} \PYG{n}{SpeciesKineticEnergy}\PYG{p}{(}\PYG{o}{*}\PYG{n}{this}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}} \PYG{o}{/}\PYG{o}{/} \PYG{n}{namespace} \PYG{n}{qmcplusplus}
\end{sphinxVerbatim}


\subsection{Multiple scalars}
\label{\detokenize{developing:multiple-scalars}}
It is fairly straightforward to create more than one column in the \sphinxcode{\sphinxupquote{scalar.dat}} file with a single observable class. For example, if we want a single SpeciesKineticEnergy estimator to simultaneously record the kinetic energies of all species in the target particle set, we only have to write two new methods: addObservables() and setObservables(), then tweak the behavior of evaluate(). First, we will have to override the default behavior of addObservables() to make room for more than one column in the \sphinxcode{\sphinxupquote{scalar.dat}} file as follows,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{SpeciesKineticEnergy}\PYG{o}{.}\PYG{n}{cpp}
\PYG{n}{void} \PYG{n}{SpeciesKineticEnergy}\PYG{p}{:}\PYG{p}{:}\PYG{n}{addObservables}\PYG{p}{(}\PYG{n}{PropertySetType}\PYG{o}{\PYGZam{}} \PYG{n}{plist}\PYG{p}{,} \PYG{n}{BufferType}\PYG{o}{\PYGZam{}} \PYG{n}{collectables}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{myIndex} \PYG{o}{=} \PYG{n}{plist}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{ispec}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ispec}\PYG{o}{\PYGZlt{}}\PYG{n}{num\PYGZus{}species}\PYG{p}{;} \PYG{n}{ispec}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
  \PYG{p}{\PYGZob{}} \PYG{o}{/}\PYG{o}{/} \PYG{n}{make} \PYG{n}{columns} \PYG{n}{named} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}myName\PYGZus{}u}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}myName\PYGZus{}d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{etc}\PYG{o}{.}
    \PYG{n}{plist}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{myName} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{species\PYGZus{}names}\PYG{p}{[}\PYG{n}{ispec}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

where “num\_species” and “species\_name” can be local variables
initialized in the constructor. We should also initialize some local
arrays to hold temporary data.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{SpeciesKineticEnergy}\PYG{o}{.}\PYG{n}{h}
\PYG{n}{private}\PYG{p}{:}
  \PYG{n+nb}{int} \PYG{n}{num\PYGZus{}species}\PYG{p}{;}
  \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{species\PYGZus{}names}\PYG{p}{;}
  \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{RealType}\PYG{o}{\PYGZgt{}} \PYG{n}{species\PYGZus{}kinetic}\PYG{p}{,}\PYG{n}{vec\PYGZus{}minus\PYGZus{}over\PYGZus{}2m}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{SpeciesKineticEnergy}\PYG{o}{.}\PYG{n}{cpp}
\PYG{n}{SpeciesKineticEnergy}\PYG{p}{:}\PYG{p}{:}\PYG{n}{SpeciesKineticEnergy}\PYG{p}{(}\PYG{n}{ParticleSet}\PYG{o}{\PYGZam{}} \PYG{n}{P}\PYG{p}{)}\PYG{p}{:}\PYG{n}{tpset}\PYG{p}{(}\PYG{n}{P}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{SpeciesSet}\PYG{o}{\PYGZam{}} \PYG{n}{tspecies}\PYG{p}{(}\PYG{n}{P}\PYG{o}{.}\PYG{n}{getSpeciesSet}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{n+nb}{int} \PYG{n}{massind} \PYG{o}{=} \PYG{n}{tspecies}\PYG{o}{.}\PYG{n}{getAttribute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mass}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{num\PYGZus{}species} \PYG{o}{=} \PYG{n}{tspecies}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{species\PYGZus{}kinetic}\PYG{o}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{n}{num\PYGZus{}species}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{vec\PYGZus{}minus\PYGZus{}over\PYGZus{}2m}\PYG{o}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{n}{num\PYGZus{}species}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{species\PYGZus{}names}\PYG{o}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{n}{num\PYGZus{}species}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{ispec}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ispec}\PYG{o}{\PYGZlt{}}\PYG{n}{num\PYGZus{}species}\PYG{p}{;} \PYG{n}{ispec}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{species\PYGZus{}names}\PYG{p}{[}\PYG{n}{ispec}\PYG{p}{]} \PYG{o}{=} \PYG{n}{tspecies}\PYG{o}{.}\PYG{n}{speciesName}\PYG{p}{[}\PYG{n}{ispec}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{vec\PYGZus{}minus\PYGZus{}over\PYGZus{}2m}\PYG{p}{[}\PYG{n}{ispec}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{tspecies}\PYG{p}{(}\PYG{n}{massind}\PYG{p}{,}\PYG{n}{ispec}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Next, we need to override the default behavior of \sphinxcode{\sphinxupquote{setObservables()}} to transfer multiple values to the property list kept by the main particle set, which eventually goes into the \sphinxcode{\sphinxupquote{scalar.dat}} file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{SpeciesKineticEnergy}\PYG{o}{.}\PYG{n}{cpp}
\PYG{n}{void} \PYG{n}{SpeciesKineticEnergy}\PYG{p}{:}\PYG{p}{:}\PYG{n}{setObservables}\PYG{p}{(}\PYG{n}{PropertySetType}\PYG{o}{\PYGZam{}} \PYG{n}{plist}\PYG{p}{)}
\PYG{p}{\PYGZob{}} \PYG{o}{/}\PYG{o}{/} \PYG{n}{slots} \PYG{o+ow}{in} \PYG{n}{plist} \PYG{n}{must} \PYG{n}{be} \PYG{n}{allocated} \PYG{n}{by} \PYG{n}{addObservables}\PYG{p}{(}\PYG{p}{)} \PYG{n}{first}
  \PYG{n}{copy}\PYG{p}{(}\PYG{n}{species\PYGZus{}kinetic}\PYG{o}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{species\PYGZus{}kinetic}\PYG{o}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{plist}\PYG{o}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{o}{+}\PYG{n}{myIndex}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Finally, we need to change the behavior of evaluate() to fill the local
vector “species\_kinetic” with appropriate observable values.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SpeciesKineticEnergy}\PYG{p}{:}\PYG{p}{:}\PYG{n}{Return\PYGZus{}t} \PYG{n}{SpeciesKineticEnergy}\PYG{p}{:}\PYG{p}{:}\PYG{n}{evaluate}\PYG{p}{(}\PYG{n}{ParticleSet}\PYG{o}{\PYGZam{}} \PYG{n}{P}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{fill}\PYG{p}{(}\PYG{n}{species\PYGZus{}kinetic}\PYG{o}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{species\PYGZus{}kinetic}\PYG{o}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{for} \PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{iat}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iat}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{.}\PYG{n}{getTotalNum}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{iat}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n+nb}{int} \PYG{n}{ispec} \PYG{o}{=} \PYG{n}{P}\PYG{o}{.}\PYG{n}{GroupID}\PYG{p}{(}\PYG{n}{iat}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{species\PYGZus{}kinetic}\PYG{p}{[}\PYG{n}{ispec}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{vec\PYGZus{}minus\PYGZus{}over\PYGZus{}2m}\PYG{p}{[}\PYG{n}{ispec}\PYG{p}{]}\PYG{o}{*}\PYG{n}{laplacian}\PYG{p}{(}\PYG{n}{P}\PYG{o}{.}\PYG{n}{G}\PYG{p}{[}\PYG{n}{iat}\PYG{p}{]}\PYG{p}{,}\PYG{n}{P}\PYG{o}{.}\PYG{n}{L}\PYG{p}{[}\PYG{n}{iat}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{n}{Value} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{Value} \PYG{o+ow}{is} \PYG{n}{no} \PYG{n}{longer} \PYG{n}{used}
  \PYG{k}{return} \PYG{n}{Value}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

That’s it! The SpeciesKineticEnergy estimator no longer needs the “group” input and will automatically output the kinetic energy of every species in the target particle set in multiple columns. You should now be able to run with
\sphinxcode{\sphinxupquote{\textless{}estimator type="specieskinetic" name="skinetic"/\textgreater{}}} and check that the sum of all columns that start with “skinetic” is equal to the default “Kinetic” column.


\subsection{HDF5 output}
\label{\detokenize{developing:hdf5-output}}
If we desire an observable that will output hundreds of scalars per simulation step (e.g., SkEstimator), then it is preferred to output to the \sphinxcode{\sphinxupquote{stat.h5}} file instead of the \sphinxcode{\sphinxupquote{scalar.dat}} file for better organization. A large chunk of data to be registered in the \sphinxcode{\sphinxupquote{stat.h5}} file is called a “Collectable” in QMCPACK. In particular, if a OperatorBase object is initialized with \sphinxcode{\sphinxupquote{UpdateMode.set(COLLECTABLE,1)}}, then the “Collectables” object carried by the main particle set will be processed and written to the \sphinxcode{\sphinxupquote{stat.h5}} file, where “UpdateMode” is a bit set (i.e., a collection of flags) with the following enumeration:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{OperatorBase}\PYG{o}{.}\PYG{n}{h}
\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{n}{enum} \PYG{k}{for} \PYG{n}{UpdateMode}
\PYG{n}{enum} \PYG{p}{\PYGZob{}}\PYG{n}{PRIMARY}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}
  \PYG{n}{OPTIMIZABLE}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}
  \PYG{n}{RATIOUPDATE}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,}
  \PYG{n}{PHYSICAL}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,}
  \PYG{n}{COLLECTABLE}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}
  \PYG{n}{NONLOCAL}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,}
  \PYG{n}{VIRTUALMOVES}\PYG{o}{=}\PYG{l+m+mi}{6}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

As a simple example, to put the two columns we produced in the previous section into the \sphinxcode{\sphinxupquote{stat.h5}} file, we will first need to declare that our observable uses “Collectables.”

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{constructor} \PYG{n}{add}\PYG{p}{:}
\PYG{n}{hdf5\PYGZus{}out} \PYG{o}{=} \PYG{n}{true}\PYG{p}{;}
\PYG{n}{UpdateMode}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{COLLECTABLE}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Then make some room in the “Collectables” object carried by the target particle set.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{addObservables}\PYG{p}{(}\PYG{n}{PropertySetType}\PYG{o}{\PYGZam{}} \PYG{n}{plist}\PYG{p}{,} \PYG{n}{BufferType}\PYG{o}{\PYGZam{}} \PYG{n}{collectables}\PYG{p}{)} \PYG{n}{add}\PYG{p}{:}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{hdf5\PYGZus{}out}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{h5\PYGZus{}index} \PYG{o}{=} \PYG{n}{collectables}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{RealType}\PYG{o}{\PYGZgt{}} \PYG{n}{tmp}\PYG{p}{(}\PYG{n}{num\PYGZus{}species}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{collectables}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{tmp}\PYG{o}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{tmp}\PYG{o}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Next, make some room in the \sphinxcode{\sphinxupquote{stat.h5}} file by overriding the registerCollectables() method.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{SpeciesKineticEnergy}\PYG{o}{.}\PYG{n}{cpp}
\PYG{n}{void} \PYG{n}{SpeciesKineticEnergy}\PYG{p}{:}\PYG{p}{:}\PYG{n}{registerCollectables}\PYG{p}{(}\PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{observable\PYGZus{}helper}\PYG{o}{*}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{h5desc}\PYG{p}{,} \PYG{n}{hid\PYGZus{}t} \PYG{n}{gid}\PYG{p}{)} \PYG{n}{const}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{hdf5\PYGZus{}out}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{ndim}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{num\PYGZus{}species}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{observable\PYGZus{}helper}\PYG{o}{*} \PYG{n}{h5o}\PYG{o}{=}\PYG{n}{new} \PYG{n}{observable\PYGZus{}helper}\PYG{p}{(}\PYG{n}{myName}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{h5o}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{set\PYGZus{}dimensions}\PYG{p}{(}\PYG{n}{ndim}\PYG{p}{,}\PYG{n}{h5\PYGZus{}index}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{h5o}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{gid}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{h5desc}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{h5o}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Finally, edit evaluate() to use the space in the “Collectables” object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
// In SpeciesKineticEnergy.cpp
SpeciesKineticEnergy::Return\PYGZus{}t SpeciesKineticEnergy::evaluate(ParticleSet\PYGZam{} P)
\PYGZob{}
  RealType wgt = tWalker\PYGZhy{}\PYGZgt{}Weight; // MUST explicitly use DMC weights in Collectables!
  std::fill(species\PYGZus{}kinetic.begin(),species\PYGZus{}kinetic.end(),0.0);

  for (int iat=0; iat\PYGZlt{}P.getTotalNum(); iat++)
  \PYGZob{}
    int ispec = P.GroupID(iat);
    species\PYGZus{}kinetic[ispec] += vec\PYGZus{}minus\PYGZus{}over\PYGZus{}2m[ispec]*laplacian(P.G[iat],P.L[iat]);
    P.Collectables[h5\PYGZus{}index + ispec] += vec\PYGZus{}minus\PYGZus{}over\PYGZus{}2m[ispec]*laplacian(P.G[iat],P.L[iat])*wgt;
  \PYGZcb{}

  Value = 0.0; // Value is no longer used
  return Value;
\PYGZcb{}
\end{sphinxVerbatim}

There should now be a new entry in the \sphinxcode{\sphinxupquote{stat.h5}} file containing the same columns of data as the \sphinxcode{\sphinxupquote{stat.h5}} file. After this check, we should clean up the code by
\begin{itemize}
\item {} 
making “hdf5\_out” and input flag by editing the put() method and

\item {} 
disabling output to \sphinxcode{\sphinxupquote{scalar.dat}} when the “hdf5\_out” flag is on.

\end{itemize}


\section{Estimator output}
\label{\detokenize{developing:estimator-output}}

\subsection{Estimator definition}
\label{\detokenize{developing:estimator-definition}}
For simplicity, consider a local property \(O(\bf{R})\), where
\(\bf{R}\) is the collection of all particle coordinates. An
\sphinxstyleemphasis{estimator} for \(O(\bf{R})\) is a weighted average over walkers:
\begin{equation}\label{equation:developing:eq242}
\begin{split} \begin{aligned}
 E[O] = \left(\sum\limits_{i=1}^{N^{tot}_{walker}} w_i O(\bf{R}_i) \right) / \left( \sum \limits_{i=1}^{N^{tot}_{walker}} w_i \right). \end{aligned}\end{split}
\end{equation}
\(N^{tot}_{walker}\) is the total number of walkers collected in the
entire simulation. Notice that \(N^{tot}_{walker}\) is typically far
larger than the number of walkers held in memory at any given simulation
step. \(w_i\) is the weight of walker \(i\).

In a VMC simulation, the weight of every walker is 1.0. Further, the
number of walkers is constant at each step. Therefore,
\eqref{equation:developing:eq242} simplifies to
\begin{equation}\label{equation:developing:eq243}
\begin{split} \begin{aligned}
 E_{VMC}[O] = \frac{1}{N_{step}N_{walker}^{ensemble}} \sum_{s,e} O(\bf{R}_{s,e})\:.\end{aligned}\end{split}
\end{equation}
Each walker \(\bf{R}_{s,e}\) is labeled by \sphinxstyleemphasis{step index} s and
\sphinxstyleemphasis{ensemble index} e.

In a DMC simulation, the weight of each walker is different and may
change from step to step. Further, the ensemble size varies from step to
step. Therefore, \eqref{equation:developing:eq242} simplifies to
\begin{equation}\label{equation:developing:eq244}
\begin{split} \begin{aligned}
 E_{DMC}[O] = \frac{1}{N_{step}} \sum_{s} \left\{ \left(\sum_e w_{s,e} O(\bf{R}_{s,e})  \right) / \left( \sum \limits_{e} w_{s,e} \right)  \right\}\:.\end{aligned}\end{split}
\end{equation}
We will refer to the average in the \(\{\}\) as \sphinxstyleemphasis{ensemble average}
and to the remaining averages as \sphinxstyleemphasis{block average}. The process of
calculating \(O(\mathbf{R})\) is \sphinxstyleemphasis{evaluate}.


\subsection{Class relations}
\label{\detokenize{developing:class-relations}}
A large number of classes are involved in the estimator collection process. They often have misleading class or method names. Check out the document gotchas in the following list:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxcode{\sphinxupquote{EstimatorManager}} is an unused copy of \sphinxcode{\sphinxupquote{EstimatorManagerBase}}.
\sphinxcode{\sphinxupquote{EstimatorManagerBase}} is the class used in the QMC drivers. (PR
\#371 explains this.)

\item {} 
\sphinxcode{\sphinxupquote{EstimatorManagerBase::Estimators}} is completely different from
\sphinxcode{\sphinxupquote{QMCDriver::Estimators}}, which is subtly different from
\sphinxcode{\sphinxupquote{OperatorBase::Estimators}}. The first is a list of pointers to
\sphinxcode{\sphinxupquote{ScalarEstimatorBase}}. The second is the master estimator (one per
MPI group). The third is the slave estimator that exists one per
OpenMP thread.

\item {} 
\sphinxcode{\sphinxupquote{QMCHamiltonian}} is NOT a parent class of \sphinxcode{\sphinxupquote{OperatorBase}}.
Instead, \sphinxcode{\sphinxupquote{QMCHamiltonian}} owns two lists of \sphinxcode{\sphinxupquote{OperatorBase}} named
\sphinxcode{\sphinxupquote{H}} and \sphinxcode{\sphinxupquote{auxH}}.

\item {} 
\sphinxcode{\sphinxupquote{QMCDriver::H}} is NOT the same as \sphinxcode{\sphinxupquote{QMCHamiltonian::H}}. The first
is a pointer to a \sphinxcode{\sphinxupquote{QMCHamiltonian}}. \sphinxcode{\sphinxupquote{QMCHamiltonian::H}} is a
list.

\item {} 
\sphinxcode{\sphinxupquote{EstimatorManager::stopBlock(std::vector)}} is completely different
from \sphinxcode{\sphinxupquote{EstimatorManager::}} \sphinxcode{\sphinxupquote{stopBlock(RealType)}}, which is the
same as \sphinxcode{\sphinxupquote{stopBlock(RealType, true)}} but that is subtly different
from \sphinxcode{\sphinxupquote{stopBlock(RealType, false)}}. The first three methods are
intended to be called by the master estimator, which exists one per
MPI group. The last method is intended to be called by the slave
estimator, which exists one per OpenMP thread.

\end{enumerate}


\subsection{Estimator output stages}
\label{\detokenize{developing:estimator-output-stages}}
Estimators take four conceptual stages to propagate to the output files: evaluate, load ensemble, unload ensemble, and collect. They are easier to understand in reverse order.


\subsubsection{Collect stage}
\label{\detokenize{developing:collect-stage}}
File output is performed by the master \sphinxcode{\sphinxupquote{EstimatorManager}} owned by \sphinxcode{\sphinxupquote{QMCDriver}}. The first 8+ entries in \sphinxcode{\sphinxupquote{EstimatorManagerBase::AverageCache}} will be written to \sphinxcode{\sphinxupquote{scalar.dat}}. The remaining entries in \sphinxcode{\sphinxupquote{AverageCache}} will be written to \sphinxcode{\sphinxupquote{stat.h5}}. File writing is triggered by \sphinxcode{\sphinxupquote{EstimatorManagerBase}} \sphinxcode{\sphinxupquote{::collectBlockAverages}} inside \sphinxcode{\sphinxupquote{EstimatorManagerBase::stopBlock}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{EstimatorManagerBase}\PYG{o}{.}\PYG{n}{cpp}\PYG{p}{:}\PYG{p}{:}\PYG{n}{collectBlockAverages}
  \PYG{k}{if}\PYG{p}{(}\PYG{n}{Archive}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{o}{*}\PYG{n}{Archive} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{setw}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RecordCount}\PYG{p}{;}
    \PYG{n+nb}{int} \PYG{n}{maxobjs}\PYG{o}{=}\PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{BlockAverages}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{max4ascii}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j}\PYG{o}{\PYGZlt{}}\PYG{n}{maxobjs}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
      \PYG{o}{*}\PYG{n}{Archive} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{setw}\PYG{p}{(}\PYG{n}{FieldWidth}\PYG{p}{)} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{AverageCache}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j}\PYG{o}{\PYGZlt{}}\PYG{n}{PropertyCache}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
      \PYG{o}{*}\PYG{n}{Archive} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{setw}\PYG{p}{(}\PYG{n}{FieldWidth}\PYG{p}{)} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{PropertyCache}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
    \PYG{o}{*}\PYG{n}{Archive} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{o}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{o}\PYG{o}{\PYGZlt{}}\PYG{n}{h5desc}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{o}\PYG{p}{)}
      \PYG{n}{h5desc}\PYG{p}{[}\PYG{n}{o}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{write}\PYG{p}{(}\PYG{n}{AverageCache}\PYG{o}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{SquaredAverageCache}\PYG{o}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{H5Fflush}\PYG{p}{(}\PYG{n}{h\PYGZus{}file}\PYG{p}{,}\PYG{n}{H5F\PYGZus{}SCOPE\PYGZus{}LOCAL}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{EstimatorManagerBase::collectBlockAverages}} is triggered from the master\sphinxhyphen{}thread estimator via either \sphinxcode{\sphinxupquote{stopBlock(std::vector)}} or \sphinxcode{\sphinxupquote{stopBlock(RealType, true)}}. Notice that file writing is NOT triggered by the slave\sphinxhyphen{}thread estimator method \sphinxcode{\sphinxupquote{stopBlock(RealType, false)}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{EstimatorManagerBase}\PYG{o}{.}\PYG{n}{cpp}
\PYG{n}{void} \PYG{n}{EstimatorManagerBase}\PYG{p}{:}\PYG{p}{:}\PYG{n}{stopBlock}\PYG{p}{(}\PYG{n}{RealType} \PYG{n}{accept}\PYG{p}{,} \PYG{n+nb}{bool} \PYG{n}{collectall}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{o}{/}\PYG{o}{/}\PYG{n}{take} \PYG{n}{block} \PYG{n}{averages} \PYG{o+ow}{and} \PYG{n}{update} \PYG{n}{properties} \PYG{n}{per} \PYG{n}{block}
  \PYG{n}{PropertyCache}\PYG{p}{[}\PYG{n}{weightInd}\PYG{p}{]}\PYG{o}{=}\PYG{n}{BlockWeight}\PYG{p}{;}
  \PYG{n}{PropertyCache}\PYG{p}{[}\PYG{n}{cpuInd}\PYG{p}{]} \PYG{o}{=} \PYG{n}{MyTimer}\PYG{o}{.}\PYG{n}{elapsed}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{PropertyCache}\PYG{p}{[}\PYG{n}{acceptInd}\PYG{p}{]} \PYG{o}{=} \PYG{n}{accept}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{Estimators}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{Estimators}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{takeBlockAverage}\PYG{p}{(}\PYG{n}{AverageCache}\PYG{o}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{SquaredAverageCache}\PYG{o}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{if}\PYG{p}{(}\PYG{n}{Collectables}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{Collectables}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{takeBlockAverage}\PYG{p}{(}\PYG{n}{AverageCache}\PYG{o}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{SquaredAverageCache}\PYG{o}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{if}\PYG{p}{(}\PYG{n}{collectall}\PYG{p}{)}
    \PYG{n}{collectBlockAverages}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{ScalarEstimatorBase}\PYG{o}{.}\PYG{n}{h}
\PYG{n}{template}\PYG{o}{\PYGZlt{}}\PYG{n}{typename} \PYG{n}{IT}\PYG{o}{\PYGZgt{}}
\PYG{n}{inline} \PYG{n}{void} \PYG{n}{takeBlockAverage}\PYG{p}{(}\PYG{n}{IT} \PYG{n}{first}\PYG{p}{,} \PYG{n}{IT} \PYG{n}{first\PYGZus{}sq}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{first} \PYG{o}{+}\PYG{o}{=} \PYG{n}{FirstIndex}\PYG{p}{;}
  \PYG{n}{first\PYGZus{}sq} \PYG{o}{+}\PYG{o}{=} \PYG{n}{FirstIndex}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{scalars}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{o}{*}\PYG{n}{first}\PYG{o}{+}\PYG{o}{+} \PYG{o}{=} \PYG{n}{scalars}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{o}{*}\PYG{n}{first\PYGZus{}sq}\PYG{o}{+}\PYG{o}{+} \PYG{o}{=} \PYG{n}{scalars}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mean2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{scalars\PYGZus{}saved}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{scalars}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/}\PYG{n}{save} \PYG{n}{current} \PYG{n}{block}
    \PYG{n}{scalars}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

At the collect stage, \sphinxcode{\sphinxupquote{calarEstimatorBase::scalars}} must be populated with ensemble\sphinxhyphen{}averaged data. Two derived classes of \sphinxcode{\sphinxupquote{ScalarEstimatorBase}} are crucial: \sphinxcode{\sphinxupquote{LocalEnergyEstimator}} will carry \sphinxcode{\sphinxupquote{Properties}}, where as \sphinxcode{\sphinxupquote{CollectablesEstimator}} will carry \sphinxcode{\sphinxupquote{Collectables}}.


\subsubsection{Unload ensemble stage}
\label{\detokenize{developing:unload-ensemble-stage}}
\sphinxcode{\sphinxupquote{LocalEnergyEstimator::scalars}} are populated by
\sphinxcode{\sphinxupquote{ScalarEstimatorBase::accumulate}}, whereas
\sphinxcode{\sphinxupquote{CollectablesEstimator::scalars}} are populated by
\sphinxcode{\sphinxupquote{CollectablesEstimator::}} \sphinxcode{\sphinxupquote{accumulate\_all}}. Both accumulate methods
are triggered by \sphinxcode{\sphinxupquote{EstimatorManagerBase::accumulate}}. One confusing
aspect about the unload stage is that
\sphinxcode{\sphinxupquote{EstimatorManagerBase::accumulate}} has a master and a slave call
signature. A slave estimator such as \sphinxcode{\sphinxupquote{QMCUpdateBase::Estimators}}
should unload a subset of walkers. Thus, the slave estimator should call
\sphinxcode{\sphinxupquote{accumulate(W,it,it\_end)}}. However, the master estimator, such as
\sphinxcode{\sphinxupquote{SimpleFixedNodeBranch::myEstimator}}, should unload data from the
entire walker ensemble. This is achieved by calling \sphinxcode{\sphinxupquote{accumulate(W)}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{void} \PYG{n}{EstimatorManagerBase}\PYG{p}{:}\PYG{p}{:}\PYG{n}{accumulate}\PYG{p}{(}\PYG{n}{MCWalkerConfiguration}\PYG{o}{\PYGZam{}} \PYG{n}{W}\PYG{p}{)}
\PYG{p}{\PYGZob{}} \PYG{o}{/}\PYG{o}{/} \PYG{n}{intended} \PYG{n}{to} \PYG{n}{be} \PYG{n}{called} \PYG{n}{by} \PYG{n}{master} \PYG{n}{estimator} \PYG{n}{only}
  \PYG{n}{BlockWeight} \PYG{o}{+}\PYG{o}{=} \PYG{n}{W}\PYG{o}{.}\PYG{n}{getActiveWalkers}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{RealType} \PYG{n}{norm}\PYG{o}{=}\PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{n}{W}\PYG{o}{.}\PYG{n}{getGlobalNumWalkers}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}} \PYG{n}{Estimators}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{Estimators}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{accumulate}\PYG{p}{(}\PYG{n}{W}\PYG{p}{,}\PYG{n}{W}\PYG{o}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{W}\PYG{o}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{norm}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{if}\PYG{p}{(}\PYG{n}{Collectables}\PYG{p}{)}\PYG{o}{/}\PYG{o}{/}\PYG{n}{collectables} \PYG{n}{are} \PYG{n}{normalized} \PYG{n}{by} \PYG{n}{QMC} \PYG{n}{drivers}
    \PYG{n}{Collectables}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{accumulate\PYGZus{}all}\PYG{p}{(}\PYG{n}{W}\PYG{o}{.}\PYG{n}{Collectables}\PYG{p}{,}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{void} \PYG{n}{EstimatorManagerBase}\PYG{p}{:}\PYG{p}{:}\PYG{n}{accumulate}\PYG{p}{(}\PYG{n}{MCWalkerConfiguration}\PYG{o}{\PYGZam{}} \PYG{n}{W}
 \PYG{p}{,} \PYG{n}{MCWalkerConfiguration}\PYG{p}{:}\PYG{p}{:}\PYG{n}{iterator} \PYG{n}{it}
 \PYG{p}{,} \PYG{n}{MCWalkerConfiguration}\PYG{p}{:}\PYG{p}{:}\PYG{n}{iterator} \PYG{n}{it\PYGZus{}end}\PYG{p}{)}
\PYG{p}{\PYGZob{}} \PYG{o}{/}\PYG{o}{/} \PYG{n}{intended} \PYG{n}{to} \PYG{n}{be} \PYG{n}{called} \PYG{n}{slaveEstimator} \PYG{n}{only}
  \PYG{n}{BlockWeight} \PYG{o}{+}\PYG{o}{=} \PYG{n}{it\PYGZus{}end}\PYG{o}{\PYGZhy{}}\PYG{n}{it}\PYG{p}{;}
  \PYG{n}{RealType} \PYG{n}{norm}\PYG{o}{=}\PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{n}{W}\PYG{o}{.}\PYG{n}{getGlobalNumWalkers}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}} \PYG{n}{Estimators}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{Estimators}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{accumulate}\PYG{p}{(}\PYG{n}{W}\PYG{p}{,}\PYG{n}{it}\PYG{p}{,}\PYG{n}{it\PYGZus{}end}\PYG{p}{,}\PYG{n}{norm}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{if}\PYG{p}{(}\PYG{n}{Collectables}\PYG{p}{)}
    \PYG{n}{Collectables}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{accumulate\PYGZus{}all}\PYG{p}{(}\PYG{n}{W}\PYG{o}{.}\PYG{n}{Collectables}\PYG{p}{,}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{LocalEnergyEstimator}\PYG{o}{.}\PYG{n}{h}
\PYG{n}{inline} \PYG{n}{void} \PYG{n}{accumulate}\PYG{p}{(}\PYG{n}{const} \PYG{n}{Walker\PYGZus{}t}\PYG{o}{\PYGZam{}} \PYG{n}{awalker}\PYG{p}{,} \PYG{n}{RealType} \PYG{n}{wgt}\PYG{p}{)}
\PYG{p}{\PYGZob{}} \PYG{o}{/}\PYG{o}{/} \PYG{n}{ensemble} \PYG{n}{average} \PYG{n}{W}\PYG{o}{.}\PYG{n}{Properties}
  \PYG{o}{/}\PYG{o}{/} \PYG{n}{expect} \PYG{n}{ePtr} \PYG{n}{to} \PYG{n}{be} \PYG{n}{W}\PYG{o}{.}\PYG{n}{Properties}\PYG{p}{;} \PYG{n}{expect} \PYG{n}{wgt} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{GlobalNumberOfWalkers}
  \PYG{n}{const} \PYG{n}{RealType}\PYG{o}{*} \PYG{n}{restrict} \PYG{n}{ePtr} \PYG{o}{=} \PYG{n}{awalker}\PYG{o}{.}\PYG{n}{getPropertyBase}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{RealType} \PYG{n}{wwght}\PYG{o}{=} \PYG{n}{wgt}\PYG{o}{*} \PYG{n}{awalker}\PYG{o}{.}\PYG{n}{Weight}\PYG{p}{;}
  \PYG{n}{scalars}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{(}\PYG{n}{ePtr}\PYG{p}{[}\PYG{n}{WP}\PYG{p}{:}\PYG{p}{:}\PYG{n}{LOCALENERGY}\PYG{p}{]}\PYG{p}{,}\PYG{n}{wwght}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{scalars}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{(}\PYG{n}{ePtr}\PYG{p}{[}\PYG{n}{WP}\PYG{p}{:}\PYG{p}{:}\PYG{n}{LOCALENERGY}\PYG{p}{]}\PYG{o}{*}\PYG{n}{ePtr}\PYG{p}{[}\PYG{n}{WP}\PYG{p}{:}\PYG{p}{:}\PYG{n}{LOCALENERGY}\PYG{p}{]}\PYG{p}{,}\PYG{n}{wwght}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{scalars}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{(}\PYG{n}{ePtr}\PYG{p}{[}\PYG{n}{LOCALPOTENTIAL}\PYG{p}{]}\PYG{p}{,}\PYG{n}{wwght}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{target}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{source}\PYG{o}{=}\PYG{n}{FirstHamiltonian}\PYG{p}{;} \PYG{n}{target}\PYG{o}{\PYGZlt{}}\PYG{n}{scalars}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{target}\PYG{p}{,} \PYG{o}{+}\PYG{o}{+}\PYG{n}{source}\PYG{p}{)}
    \PYG{n}{scalars}\PYG{p}{[}\PYG{n}{target}\PYG{p}{]}\PYG{p}{(}\PYG{n}{ePtr}\PYG{p}{[}\PYG{n}{source}\PYG{p}{]}\PYG{p}{,}\PYG{n}{wwght}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{CollectablesEstimator}\PYG{o}{.}\PYG{n}{h}
\PYG{n}{inline} \PYG{n}{void} \PYG{n}{accumulate\PYGZus{}all}\PYG{p}{(}\PYG{n}{const} \PYG{n}{MCWalkerConfiguration}\PYG{p}{:}\PYG{p}{:}\PYG{n}{Buffer\PYGZus{}t}\PYG{o}{\PYGZam{}} \PYG{n}{data}\PYG{p}{,} \PYG{n}{RealType} \PYG{n}{wgt}\PYG{p}{)}
\PYG{p}{\PYGZob{}} \PYG{o}{/}\PYG{o}{/} \PYG{n}{ensemble} \PYG{n}{average} \PYG{n}{W}\PYG{o}{.}\PYG{n}{Collectables}
  \PYG{o}{/}\PYG{o}{/} \PYG{n}{expect} \PYG{n}{data} \PYG{n}{to} \PYG{n}{be} \PYG{n}{W}\PYG{o}{.}\PYG{n}{Collectables}\PYG{p}{;} \PYG{n}{expect} \PYG{n}{wgt} \PYG{o}{=} \PYG{l+m+mf}{1.0}
  \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{data}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{n}{scalars}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{wgt}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

At the unload ensemble stage, the data structures \sphinxcode{\sphinxupquote{Properties}} and \sphinxcode{\sphinxupquote{Collectables}} must be populated by appropriately normalized values so that the ensemble average can be correctly taken. \sphinxcode{\sphinxupquote{QMCDriver}} is responsible for the correct loading of data onto the walker ensemble.


\subsubsection{Load ensemble stage}
\label{\detokenize{developing:load-ensemble-stage}}
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{Properties}} in the MC ensemble of walkers \sphinxcode{\sphinxupquote{QMCDriver::W}} is
populated by \sphinxcode{\sphinxupquote{QMCHamiltonian}}
\item[] \sphinxcode{\sphinxupquote{::saveProperties}}. The master \sphinxcode{\sphinxupquote{QMCHamiltonian::LocalEnergy}},
\sphinxcode{\sphinxupquote{::KineticEnergy}}, and \sphinxcode{\sphinxupquote{::Observables}} must be properly populated
at the end of the evaluate stage.
\end{DUlineblock}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{QMCHamiltonian}\PYG{o}{.}\PYG{n}{h}
  \PYG{n}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{IT}\PYG{o}{\PYGZgt{}}
  \PYG{n}{inline}
  \PYG{n}{void} \PYG{n}{saveProperty}\PYG{p}{(}\PYG{n}{IT} \PYG{n}{first}\PYG{p}{)}
  \PYG{p}{\PYGZob{}} \PYG{o}{/}\PYG{o}{/} \PYG{n}{expect} \PYG{n}{first} \PYG{n}{to} \PYG{n}{be} \PYG{n}{W}\PYG{o}{.}\PYG{n}{Properties}
    \PYG{n}{first}\PYG{p}{[}\PYG{n}{LOCALPOTENTIAL}\PYG{p}{]}\PYG{o}{=} \PYG{n}{LocalEnergy}\PYG{o}{\PYGZhy{}}\PYG{n}{KineticEnergy}\PYG{p}{;}
    \PYG{n}{copy}\PYG{p}{(}\PYG{n}{Observables}\PYG{o}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{Observables}\PYG{o}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{first}\PYG{o}{+}\PYG{n}{myIndex}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{Collectables}}’s load stage is combined with its evaluate stage.


\subsubsection{Evaluate stage}
\label{\detokenize{developing:evaluate-stage}}
\begin{DUlineblock}{0em}
\item[] The master \sphinxcode{\sphinxupquote{QMCHamiltonian::Observables}} is populated by slave
\sphinxcode{\sphinxupquote{OperatorBase}} \sphinxcode{\sphinxupquote{::setObservables}}. However, the call signature
must be \sphinxcode{\sphinxupquote{OperatorBase::setObservables}} \sphinxcode{\sphinxupquote{(QMCHamiltonian::}}
\item[] \sphinxcode{\sphinxupquote{Observables)}}. This call signature is enforced by
\sphinxcode{\sphinxupquote{QMCHamiltonian::evaluate}} and \sphinxcode{\sphinxupquote{QMCHamiltonian::}}
\item[] \sphinxcode{\sphinxupquote{auxHevaluate}}.
\end{DUlineblock}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{QMCHamiltonian}\PYG{o}{.}\PYG{n}{cpp}
\PYG{n}{QMCHamiltonian}\PYG{p}{:}\PYG{p}{:}\PYG{n}{Return\PYGZus{}t}
\PYG{n}{QMCHamiltonian}\PYG{p}{:}\PYG{p}{:}\PYG{n}{evaluate}\PYG{p}{(}\PYG{n}{ParticleSet}\PYG{o}{\PYGZam{}} \PYG{n}{P}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{LocalEnergy} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{H}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{myTimers}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{LocalEnergy} \PYG{o}{+}\PYG{o}{=} \PYG{n}{H}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{evaluate}\PYG{p}{(}\PYG{n}{P}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{H}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setObservables}\PYG{p}{(}\PYG{n}{Observables}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{\PYGZsh{}if !defined(REMOVE\PYGZus{}TRACEMANAGER)}
    \PYG{n}{H}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{collect\PYGZus{}scalar\PYGZus{}traces}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{\PYGZsh{}endif}
    \PYG{n}{myTimers}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{stop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{H}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setParticlePropertyList}\PYG{p}{(}\PYG{n}{P}\PYG{o}{.}\PYG{n}{PropertyList}\PYG{p}{,}\PYG{n}{myIndex}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{n}{KineticEnergy}\PYG{o}{=}\PYG{n}{H}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Value}\PYG{p}{;}
  \PYG{n}{P}\PYG{o}{.}\PYG{n}{PropertyList}\PYG{p}{[}\PYG{n}{WP}\PYG{p}{:}\PYG{p}{:}\PYG{n}{LOCALENERGY}\PYG{p}{]}\PYG{o}{=}\PYG{n}{LocalEnergy}\PYG{p}{;}
  \PYG{n}{P}\PYG{o}{.}\PYG{n}{PropertyList}\PYG{p}{[}\PYG{n}{LOCALPOTENTIAL}\PYG{p}{]}\PYG{o}{=}\PYG{n}{LocalEnergy}\PYG{o}{\PYGZhy{}}\PYG{n}{KineticEnergy}\PYG{p}{;}
  \PYG{o}{/}\PYG{o}{/} \PYG{n}{auxHevaluate}\PYG{p}{(}\PYG{n}{P}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{return} \PYG{n}{LocalEnergy}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{QMCHamiltonian}\PYG{o}{.}\PYG{n}{cpp}
\PYG{n}{void} \PYG{n}{QMCHamiltonian}\PYG{p}{:}\PYG{p}{:}\PYG{n}{auxHevaluate}\PYG{p}{(}\PYG{n}{ParticleSet}\PYG{o}{\PYGZam{}} \PYG{n}{P}\PYG{p}{,} \PYG{n}{Walker\PYGZus{}t}\PYG{o}{\PYGZam{}} \PYG{n}{ThisWalker}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+c1}{\PYGZsh{}if !defined(REMOVE\PYGZus{}TRACEMANAGER)}
  \PYG{n}{collect\PYGZus{}walker\PYGZus{}traces}\PYG{p}{(}\PYG{n}{ThisWalker}\PYG{p}{,}\PYG{n}{P}\PYG{o}{.}\PYG{n}{current\PYGZus{}step}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{\PYGZsh{}endif}
  \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{auxH}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{auxH}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setHistories}\PYG{p}{(}\PYG{n}{ThisWalker}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{RealType} \PYG{n}{sink} \PYG{o}{=} \PYG{n}{auxH}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{evaluate}\PYG{p}{(}\PYG{n}{P}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{auxH}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setObservables}\PYG{p}{(}\PYG{n}{Observables}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{\PYGZsh{}if !defined(REMOVE\PYGZus{}TRACEMANAGER)}
    \PYG{n}{auxH}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{collect\PYGZus{}scalar\PYGZus{}traces}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{\PYGZsh{}endif}
    \PYG{n}{auxH}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setParticlePropertyList}\PYG{p}{(}\PYG{n}{P}\PYG{o}{.}\PYG{n}{PropertyList}\PYG{p}{,}\PYG{n}{myIndex}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Estimator use cases}
\label{\detokenize{developing:estimator-use-cases}}

\subsubsection{VMCSingleOMP pseudo code}
\label{\detokenize{developing:vmcsingleomp-pseudo-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{VMCSingleOMP}\PYG{p}{:}\PYG{p}{:}\PYG{n}{run}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{masterEstimator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{start}\PYG{p}{(}\PYG{n}{nBlocks}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{ip}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ip}\PYG{o}{\PYGZlt{}}\PYG{n}{NumThreads}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{ip}\PYG{p}{)}
    \PYG{n}{Movers}\PYG{p}{[}\PYG{n}{ip}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{startRun}\PYG{p}{(}\PYG{n}{nBlocks}\PYG{p}{,}\PYG{n}{false}\PYG{p}{)}\PYG{p}{;}  \PYG{o}{/}\PYG{o}{/} \PYG{n}{slaveEstimator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{start}\PYG{p}{(}\PYG{n}{blocks}\PYG{p}{,} \PYG{n}{record}\PYG{p}{)}

  \PYG{n}{do} \PYG{o}{/}\PYG{o}{/} \PYG{n}{block}
  \PYG{p}{\PYGZob{}}
    \PYG{c+c1}{\PYGZsh{}pragma omp parallel}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{Movers}\PYG{p}{[}\PYG{n}{ip}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{startBlock}\PYG{p}{(}\PYG{n}{nSteps}\PYG{p}{)}\PYG{p}{;}  \PYG{o}{/}\PYG{o}{/} \PYG{n}{slaveEstimator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{startBlock}\PYG{p}{(}\PYG{n}{steps}\PYG{p}{)}
      \PYG{n}{RealType} \PYG{n}{cnorm} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{n}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{RealType}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{wPerNode}\PYG{p}{[}\PYG{n}{ip}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{wPerNode}\PYG{p}{[}\PYG{n}{ip}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{do} \PYG{o}{/}\PYG{o}{/} \PYG{n}{step}
      \PYG{p}{\PYGZob{}}
        \PYG{n}{wClones}\PYG{p}{[}\PYG{n}{ip}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{resetCollectables}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Movers}\PYG{p}{[}\PYG{n}{ip}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{advanceWalkers}\PYG{p}{(}\PYG{n}{wit}\PYG{p}{,} \PYG{n}{wit\PYGZus{}end}\PYG{p}{,} \PYG{n}{recompute}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{wClones}\PYG{p}{[}\PYG{n}{ip}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Collectables} \PYG{o}{*}\PYG{o}{=} \PYG{n}{cnorm}\PYG{p}{;}
        \PYG{n}{Movers}\PYG{p}{[}\PYG{n}{ip}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{accumulate}\PYG{p}{(}\PYG{n}{wit}\PYG{p}{,} \PYG{n}{wit\PYGZus{}end}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}} \PYG{o}{/}\PYG{o}{/} \PYG{n}{end} \PYG{n}{step}
      \PYG{n}{Movers}\PYG{p}{[}\PYG{n}{ip}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{stopBlock}\PYG{p}{(}\PYG{n}{false}\PYG{p}{)}\PYG{p}{;}  \PYG{o}{/}\PYG{o}{/} \PYG{n}{slaveEstimator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{stopBlock}\PYG{p}{(}\PYG{n}{acc}\PYG{p}{,} \PYG{n}{false}\PYG{p}{)}
    \PYG{p}{\PYGZcb{}} \PYG{o}{/}\PYG{o}{/} \PYG{n}{end} \PYG{n}{omp}
    \PYG{n}{masterEstimator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{stopBlock}\PYG{p}{(}\PYG{n}{estimatorClones}\PYG{p}{)}\PYG{p}{;}  \PYG{o}{/}\PYG{o}{/} \PYG{n}{write} \PYG{n}{files}
  \PYG{p}{\PYGZcb{}} \PYG{o}{/}\PYG{o}{/} \PYG{n}{end} \PYG{n}{block}
  \PYG{n}{masterEstimator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{stop}\PYG{p}{(}\PYG{n}{estimatorClones}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{DMCOMP  pseudo code}
\label{\detokenize{developing:dmcomp-pseudo-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{DMCOMP}\PYG{p}{:}\PYG{p}{:}\PYG{n}{run}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{masterEstimator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setCollectionMode}\PYG{p}{(}\PYG{n}{true}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{masterEstimator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{start}\PYG{p}{(}\PYG{n}{nBlocks}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{ip}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ip}\PYG{o}{\PYGZlt{}}\PYG{n}{NumThreads}\PYG{p}{;} \PYG{n}{ip}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{Movers}\PYG{p}{[}\PYG{n}{ip}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{startRun}\PYG{p}{(}\PYG{n}{nBlocks}\PYG{p}{,}\PYG{n}{false}\PYG{p}{)}\PYG{p}{;}  \PYG{o}{/}\PYG{o}{/} \PYG{n}{slaveEstimator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{start}\PYG{p}{(}\PYG{n}{blocks}\PYG{p}{,} \PYG{n}{record}\PYG{p}{)}

  \PYG{n}{do} \PYG{o}{/}\PYG{o}{/} \PYG{n}{block}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{masterEstimator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{startBlock}\PYG{p}{(}\PYG{n}{nSteps}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{ip}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ip}\PYG{o}{\PYGZlt{}}\PYG{n}{NumThreads}\PYG{p}{;} \PYG{n}{ip}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
      \PYG{n}{Movers}\PYG{p}{[}\PYG{n}{ip}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{startBlock}\PYG{p}{(}\PYG{n}{nSteps}\PYG{p}{)}\PYG{p}{;}  \PYG{o}{/}\PYG{o}{/} \PYG{n}{slaveEstimator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{startBlock}\PYG{p}{(}\PYG{n}{steps}\PYG{p}{)}

    \PYG{n}{do} \PYG{o}{/}\PYG{o}{/} \PYG{n}{step}
    \PYG{p}{\PYGZob{}}
      \PYG{c+c1}{\PYGZsh{}pragma omp parallel}
      \PYG{p}{\PYGZob{}}
      \PYG{n}{wClones}\PYG{p}{[}\PYG{n}{ip}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{resetCollectables}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
      \PYG{o}{/}\PYG{o}{/} \PYG{n}{advanceWalkers}
      \PYG{p}{\PYGZcb{}} \PYG{o}{/}\PYG{o}{/} \PYG{n}{end} \PYG{n}{omp}

      \PYG{o}{/}\PYG{o}{/}\PYG{n}{branchEngine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{branch}
      \PYG{p}{\PYGZob{}} \PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{WalkerControlMPI}\PYG{o}{.}\PYG{n}{cpp}\PYG{p}{:}\PYG{p}{:}\PYG{n}{branch}
      \PYG{n}{wgt\PYGZus{}inv}\PYG{o}{=}\PYG{n}{WalkerController}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{NumContexts}\PYG{o}{/}\PYG{n}{WalkerController}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{EnsembleProperty}\PYG{o}{.}\PYG{n}{Weight}\PYG{p}{;}
      \PYG{n}{walkers}\PYG{o}{.}\PYG{n}{Collectables} \PYG{o}{*}\PYG{o}{=} \PYG{n}{wgt\PYGZus{}inv}\PYG{p}{;}
      \PYG{n}{slaveEstimator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{accumulate}\PYG{p}{(}\PYG{n}{walkers}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{n}{masterEstimator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{stopBlock}\PYG{p}{(}\PYG{n}{acc}\PYG{p}{)}  \PYG{o}{/}\PYG{o}{/} \PYG{n}{write} \PYG{n}{files}
    \PYG{p}{\PYGZcb{}}  \PYG{o}{/}\PYG{o}{/} \PYG{n}{end} \PYG{k}{for} \PYG{n}{step}
  \PYG{p}{\PYGZcb{}}  \PYG{o}{/}\PYG{o}{/} \PYG{n}{end} \PYG{k}{for} \PYG{n}{block}

  \PYG{n}{masterEstimator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{stop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Summary}
\label{\detokenize{developing:summary}}
Two ensemble\sphinxhyphen{}level data structures, \sphinxcode{\sphinxupquote{ParticleSet::Properties}} and
\sphinxcode{\sphinxupquote{::Collectables}}, serve as intermediaries between evaluate classes and
output classes to \sphinxcode{\sphinxupquote{scalar.dat}} and \sphinxcode{\sphinxupquote{stat.h5}}. \sphinxcode{\sphinxupquote{Properties}} appears
in both \sphinxcode{\sphinxupquote{scalar.dat}} and \sphinxcode{\sphinxupquote{stat.h5}}, whereas \sphinxcode{\sphinxupquote{Collectables}} appears
only in \sphinxcode{\sphinxupquote{stat.h5}}. \sphinxcode{\sphinxupquote{Properties}} is overwritten by
\sphinxcode{\sphinxupquote{QMCHamiltonian::Observables}} at the end of each step.
\sphinxcode{\sphinxupquote{QMCHamiltonian::Observables}} is filled upon call to
\sphinxcode{\sphinxupquote{QMCHamiltonian::evaluate}} and \sphinxcode{\sphinxupquote{::auxHevaluate}}. \sphinxcode{\sphinxupquote{Collectables}} is
zeroed at the beginning of each step and accumulated upon call to
\sphinxcode{\sphinxupquote{::auxHevaluate}}.

\begin{DUlineblock}{0em}
\item[] Data are output to \sphinxcode{\sphinxupquote{scalar.dat}} in four stages: evaluate, load,
unload, and collect. In the evaluate stage,
\sphinxcode{\sphinxupquote{QMCHamiltonian::Observables}} is populated by a list of
\sphinxcode{\sphinxupquote{OperatorBase}}. In the load stage, \sphinxcode{\sphinxupquote{QMCHamiltonian::Observables}}
is transfered to \sphinxcode{\sphinxupquote{Properties}} by \sphinxcode{\sphinxupquote{QMCDriver}}. In the unload stage,
\sphinxcode{\sphinxupquote{Properties}} is copied to \sphinxcode{\sphinxupquote{LocalEnergyEstimator::scalars}}. In the
collect stage, \sphinxcode{\sphinxupquote{LocalEnergyEstimator::scalars}} is block\sphinxhyphen{}averaged to
\sphinxcode{\sphinxupquote{EstimatorManagerBase}}
\item[] \sphinxcode{\sphinxupquote{::AverageCache}} and dumped to file. For \sphinxcode{\sphinxupquote{Collectables}}, the
evaluate and load stages are combined in a call to
\sphinxcode{\sphinxupquote{QMCHamiltonian::auxHevaluate}}. In the unload stage,
\sphinxcode{\sphinxupquote{Collectables}} is copied to \sphinxcode{\sphinxupquote{CollectablesEstimator::scalars}}. In
the collect stage, \sphinxcode{\sphinxupquote{CollectablesEstimator}}
\item[] \sphinxcode{\sphinxupquote{::scalars}} is block\sphinxhyphen{}averaged to
\sphinxcode{\sphinxupquote{EstimatorManagerBase::AverageCache}} and dumped to file.
\end{DUlineblock}


\subsection{Appendix: dmc.dat}
\label{\detokenize{developing:appendix-dmc-dat}}
\begin{DUlineblock}{0em}
\item[] There is an additional data structure,
\sphinxcode{\sphinxupquote{ParticleSet::EnsembleProperty}}, that is managed by
\sphinxcode{\sphinxupquote{WalkerControlBase::EnsembleProperty}} and directly dumped to
\sphinxcode{\sphinxupquote{dmc.dat}} via its own averaging procedure. \sphinxcode{\sphinxupquote{dmc.dat}} is written by
\sphinxcode{\sphinxupquote{WalkerControlBase::measureProperties}}, which is called by
\sphinxcode{\sphinxupquote{WalkerControlBase::branch}}, which is called by
\sphinxcode{\sphinxupquote{SimpleFixedNodeBranch}}
\item[] \sphinxcode{\sphinxupquote{::branch}}, for example.
\end{DUlineblock}


\section{Slater\sphinxhyphen{}backflow wavefunction implementation details}
\label{\detokenize{developing:slater-backflow-wavefunction-implementation-details}}
For simplicity, consider \(N\) identical fermions of the same spin
(e.g., up electrons) at spatial locations
\(\{\mathbf{r}_1,\mathbf{r}_2,\dots,\mathbf{r}_{N}\}\). Then the
Slater determinant can be written as
\begin{equation}\label{equation:developing:eq245}
\begin{split} S=\det M\:,\end{split}
\end{equation}
where each entry in the determinant is an SPO evaluated at a particle
position
\begin{equation}\label{equation:developing:eq246}
\begin{split} \begin{aligned}
 M_{ij} = \phi_i(\mathbf{r}_j)\:.\end{aligned}\end{split}
\end{equation}
When backflow transformation is applied to the determinant, the particle
coordinates \(\mathbf{r}_i\) that go into the SPOs are replaced by
quasi\sphinxhyphen{}particle coordinates \(\mathbf{x}_i\):
\begin{equation}\label{equation:developing:eq247}
\begin{split} \begin{aligned}
 M_{ij} = \phi_i(\mathbf{x}_j)\:, \end{aligned}\end{split}
\end{equation}
where
\begin{equation}\label{equation:developing:eq248}
\begin{split} \begin{aligned}
 \mathbf{x}_i=\mathbf{r}_i+\sum\limits_{j=1,j\neq i}^N\eta(r_{ij})(\mathbf{r}_i-\mathbf{r}_j)\:. \end{aligned}\end{split}
\end{equation}
\(r_{ij}=\vert\mathbf{r}_i-\mathbf{r}_j\vert\). The integers i,j
label the particle/quasi\sphinxhyphen{}particle. There is a one\sphinxhyphen{}to\sphinxhyphen{}one correspondence
between the particles and the quasi\sphinxhyphen{}particles, which is simplest when
\(\eta=0\).


\subsection{Value}
\label{\detokenize{developing:value}}
The evaluation of the Slater\sphinxhyphen{}backflow wavefunction is almost identical
to that of a Slater wavefunction. The only difference is that the
quasi\sphinxhyphen{}particle coordinates are used to evaluate the SPOs. The actual
value of the determinant is stored during the inversion of the matrix
\(M\) (\sphinxcode{\sphinxupquote{cgetrf}}\(\rightarrow\)\sphinxcode{\sphinxupquote{cgetri}}). Suppose
\(M=LU\), then \(S=\prod\limits_{i=1}^N L_{ii} U_{ii}\).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{DiracDeterminantWithBackflow}\PYG{p}{:}\PYG{p}{:}\PYG{n}{evaluateLog}\PYG{p}{(}\PYG{n}{P}\PYG{p}{,}\PYG{n}{G}\PYG{p}{,}\PYG{n}{L}\PYG{p}{)}
\PYG{n}{Phi}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{evaluate}\PYG{p}{(}\PYG{n}{BFTrans}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{QP}\PYG{p}{,} \PYG{n}{FirstIndex}\PYG{p}{,} \PYG{n}{LastIndex}\PYG{p}{,} \PYG{n}{psiM}\PYG{p}{,}\PYG{n}{dpsiM}\PYG{p}{,}\PYG{n}{grad\PYGZus{}grad\PYGZus{}psiM}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{psiMinv} \PYG{o}{=} \PYG{n}{psiM}\PYG{p}{;}
\PYG{n}{LogValue}\PYG{o}{=}\PYG{n}{InvertWithLog}\PYG{p}{(}\PYG{n}{psiMinv}\PYG{o}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{NumPtcls}\PYG{p}{,}\PYG{n}{NumOrbitals}
  \PYG{p}{,}\PYG{n}{WorkSpace}\PYG{o}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{Pivot}\PYG{o}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{PhaseValue}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

QMCPACK represents the complex value of the wavefunction in polar
coordinates \(S=e^Ue^{i\theta}\). Specifically, \sphinxcode{\sphinxupquote{LogValue}}
\(U\) and \sphinxcode{\sphinxupquote{PhaseValue}} \(\theta\) are handled separately. In
the following, we will consider derivatives of the log value only.


\subsection{Gradient}
\label{\detokenize{developing:gradient}}
To evaluate particle gradient of the log value of the Slater\sphinxhyphen{}backflow
wavefunction, we can use the \(\log\det\) identity in
\eqref{equation:developing:eq249}. This identity maps the derivative of
\(\log\det M\) with respect to a real variable \(p\) to a trace
over \(M^{-1}dM\):
\begin{equation}\label{equation:developing:eq249}
\begin{split} \begin{aligned}
 \frac{\partial}{\partial p}\log\det M = \text{tr}\left( M^{-1} \frac{\partial M}{\partial p} \right) .\end{aligned}\end{split}
\end{equation}
Following Kwon, Ceperley, and
Martin \sphinxcite{developing:kwon1993backflow}, the particle gradient
\begin{equation}\label{equation:developing:eq250}
\begin{split} \begin{aligned}
 G_i^\alpha \equiv \frac{\partial}{\partial r_i^\alpha} \log\det M = \sum\limits_{j=1}^N \sum\limits_{\beta=1}^3 F_{jj}^\beta A_{jj}^{\alpha\beta}\:, \end{aligned}\end{split}
\end{equation}
where the quasi\sphinxhyphen{}particle gradient matrix
\begin{equation}\label{equation:developing:eq251}
\begin{split} \begin{aligned}
 A_{ij}^{\alpha\beta} \equiv \frac{\partial x_j^\beta}{\partial r_i^\alpha}\:,\end{aligned}\end{split}
\end{equation}
and the intermediate matrix
\begin{equation}\label{equation:developing:eq252}
\begin{split} \begin{aligned}
 F_{ij}^\alpha\equiv\sum\limits_k M^{-1}_{ik} dM_{kj}^\alpha\:,\end{aligned}\end{split}
\end{equation}
with the SPO derivatives (w.r. to quasi\sphinxhyphen{}particle coordinates)
\begin{equation}\label{equation:developing:eq253}
\begin{split} \begin{aligned}
 dM_{ij}^\alpha \equiv \frac{\partial M_{ij}}{\partial x_j^\alpha}\:.\end{aligned}\end{split}
\end{equation}
Notice that we have made the name change of \(\phi\rightarrow M\)
from the notations of ref. \sphinxcite{developing:kwon1993backflow}. This
name change is intended to help the reader associate M with the QMCPACK
variable \sphinxcode{\sphinxupquote{psiM}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{DiracDeterminantWithBackflow}\PYG{p}{:}\PYG{p}{:}\PYG{n}{evaluateLog}\PYG{p}{(}\PYG{n}{P}\PYG{p}{,}\PYG{n}{G}\PYG{p}{,}\PYG{n}{L}\PYG{p}{)}
\PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{num}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{o}{/}\PYG{o}{/} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{above} \PYG{n}{formula}
\PYG{p}{\PYGZob{}}
  \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j}\PYG{o}{\PYGZlt{}}\PYG{n}{NumPtcls}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{k}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k}\PYG{o}{\PYGZlt{}}\PYG{n}{OHMMS\PYGZus{}DIM}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{o}{/}\PYG{o}{/} \PYG{n}{alpha} \PYG{o+ow}{in} \PYG{n}{above} \PYG{n}{formula}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{myG}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dot}\PYG{p}{(}\PYG{n}{BFTrans}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Amat}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{FirstIndex}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}\PYG{p}{,}\PYG{n}{Fmat}\PYG{p}{(}\PYG{n}{j}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\eqref{equation:developing:eq250} is still relatively simple to understand. The
\(A\) matrix maps changes in particle coordinates
\(d\mathbf{r}\) to changes in quasi\sphinxhyphen{}particle coordinates
\(d\mathbf{x}\). Dotting A into F propagates \(d\mathbf{x}\) to
\(dM\). Thus \(F\cdot A\) is the term inside the trace operator
of \eqref{equation:developing:eq249}. Finally, performing the trace completes the
evaluation of the derivative.


\subsection{Laplacian}
\label{\detokenize{developing:laplacian}}
The particle Laplacian is given in
\sphinxcite{developing:kwon1993backflow} as
\begin{equation}\label{equation:developing:eq254}
\begin{split} \begin{aligned}
 L_i \equiv \sum\limits_{\beta} \frac{\partial^2}{\partial (r_i^\beta)^2} \log\det M = \sum\limits_{j\alpha} B_{ij}^\alpha F_{jj}^\alpha - \sum\limits_{jk}\sum\limits_{\alpha\beta\gamma} A_{ij}^{\alpha\beta}A_{ik}^{\alpha\gamma}\times\left(F_{kj}^\alpha F_{jk}^\gamma -\delta_{jk}\sum\limits_m M^{-1}_{jm} d2M_{mj}^{\beta\gamma}\right), \end{aligned}\end{split}
\end{equation}
where the quasi\sphinxhyphen{}particle Laplacian matrix
\begin{equation}\label{equation:developing:eq255}
\begin{split} \begin{aligned}
 B_{ij}^{\alpha} \equiv \sum\limits_\beta \frac{\partial^2 x_j^\alpha}{\partial (r_i^\beta)^2}\:,\end{aligned}\end{split}
\end{equation}
with the second derivatives of the single\sphinxhyphen{}particles orbitals being
\begin{equation}\label{equation:developing:eq256}
\begin{split} \begin{aligned}
 d2M_{ij}^{\alpha\beta} \equiv \frac{\partial^2 M_{ij}}{\partial x_j^\alpha\partial x_j^\beta}\:.\end{aligned}\end{split}
\end{equation}
Schematically, \(L_i\) has contributions from three terms of the
form \(BF, AAFF, and tr(AA,Md2M)\), respectively.
\(A, B, M ,d2M,\) and \(F\) can be calculated and stored before
the calculations of \(L_i\). The first \(BF\) term can be
directly calculated in a loop over quasi\sphinxhyphen{}particle coordinates
\(j\alpha\).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{DiracDeterminantWithBackflow}\PYG{p}{:}\PYG{p}{:}\PYG{n}{evaluateLog}\PYG{p}{(}\PYG{n}{P}\PYG{p}{,}\PYG{n}{G}\PYG{p}{,}\PYG{n}{L}\PYG{p}{)}
\PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j}\PYG{o}{\PYGZlt{}}\PYG{n}{NumPtcls}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
  \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{a}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{a}\PYG{o}{\PYGZlt{}}\PYG{n}{OHMMS\PYGZus{}DIM}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{myL}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{o}{+}\PYG{o}{=} \PYG{n}{BFTrans}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Bmat\PYGZus{}full}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{FirstIndex}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Fmat}\PYG{p}{(}\PYG{n}{j}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

Notice that \(B_{ij}^\alpha\) is stored in \sphinxcode{\sphinxupquote{Bmat\_full}}, NOT
\sphinxcode{\sphinxupquote{Bmat}}.

The remaining two terms both involve \(AA\). Thus, it is best to
define a temporary tensor \(AA\):
\begin{equation}\label{equation:developing:eq257}
\begin{split} \begin{aligned}
 {}_iAA_{jk}^{\beta\gamma} \equiv \sum\limits_\alpha A_{ij}^{\alpha\beta} A_{ij}^{\alpha\gamma}\:,\end{aligned}\end{split}
\end{equation}
which we will overwrite for each particle \(i\). Similarly, define
\(FF\):
\begin{equation}\label{equation:developing:eq258}
\begin{split} \begin{aligned}
 FF_{jk}^{\alpha\gamma} \equiv F_{kj}^\alpha F_{jk}^\gamma\:,\end{aligned}\end{split}
\end{equation}
which is simply the outer product of \(F\otimes F\). Then the
\(AAFF\) term can be calculated by fully contracting \(AA\) with
\(FF\).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{In} \PYG{n}{DiracDeterminantWithBackflow}\PYG{p}{:}\PYG{p}{:}\PYG{n}{evaluateLog}\PYG{p}{(}\PYG{n}{P}\PYG{p}{,}\PYG{n}{G}\PYG{p}{,}\PYG{n}{L}\PYG{p}{)}
\PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j}\PYG{o}{\PYGZlt{}}\PYG{n}{NumPtcls}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
  \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{k}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k}\PYG{o}{\PYGZlt{}}\PYG{n}{NumPtcls}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{num}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{Tensor}\PYG{o}{\PYGZlt{}}\PYG{n}{RealType}\PYG{p}{,}\PYG{n}{OHMMS\PYGZus{}DIM}\PYG{o}{\PYGZgt{}} \PYG{n}{AA} \PYG{o}{=} \PYG{n}{dot}\PYG{p}{(}\PYG{n}{transpose}\PYG{p}{(}\PYG{n}{BFTrans}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Amat}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{FirstIndex}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{n}{BFTrans}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Amat}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{FirstIndex}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{HessType} \PYG{n}{FF} \PYG{o}{=} \PYG{n}{outerProduct}\PYG{p}{(}\PYG{n}{Fmat}\PYG{p}{(}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{,}\PYG{n}{Fmat}\PYG{p}{(}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{myL}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{traceAtB}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{,}\PYG{n}{FF}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Finally, define the SPO derivative term:
\begin{equation}\label{equation:developing:eq259}
\begin{split} \begin{aligned}
 Md2M_j^{\beta\gamma} \equiv \sum\limits_m M^{-1}_{jm} d2M_{mj}^\beta\:,\end{aligned}\end{split}
\end{equation}
then the last term is given by the contraction of \(Md2M\) (\sphinxcode{\sphinxupquote{q\_j}})
with the diagonal of \(AA\).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j}\PYG{o}{\PYGZlt{}}\PYG{n}{NumPtcls}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{HessType} \PYG{n}{q\PYGZus{}j}\PYG{p}{;}
  \PYG{n}{q\PYGZus{}j}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{k}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k}\PYG{o}{\PYGZlt{}}\PYG{n}{NumPtcls}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{q\PYGZus{}j} \PYG{o}{+}\PYG{o}{=} \PYG{n}{psiMinv}\PYG{p}{(}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{o}{*}\PYG{n}{grad\PYGZus{}grad\PYGZus{}psiM}\PYG{p}{(}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{num}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{Tensor}\PYG{o}{\PYGZlt{}}\PYG{n}{RealType}\PYG{p}{,}\PYG{n}{OHMMS\PYGZus{}DIM}\PYG{o}{\PYGZgt{}} \PYG{n}{AA} \PYG{o}{=} \PYG{n}{dot}\PYG{p}{(}
      \PYG{n}{transpose}\PYG{p}{(}\PYG{n}{BFTrans}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Amat}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{FirstIndex}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
      \PYG{n}{BFTrans}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Amat}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{FirstIndex}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
    \PYG{p}{)}\PYG{p}{;}
    \PYG{n}{myL}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{o}{+}\PYG{o}{=} \PYG{n}{traceAtB}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{,}\PYG{n}{q\PYGZus{}j}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Wavefunction parameter derivative}
\label{\detokenize{developing:wavefunction-parameter-derivative}}
To use the robust linear optimization method of
\sphinxcite{developing:toulouse2007linear}, the trial wavefunction
needs to know its contributions to the overlap and hamiltonian matrices.
In particular, we need derivatives of these matrices with respect to
wavefunction parameters. As a consequence, the wavefunction \(\psi\)
needs to be able to evaluate
\(\frac{\partial}{\partial p} \ln \psi\) and
\(\frac{\partial}{\partial p} \frac{\mathcal{H}\psi}{\psi}\), where
\(p\) is a parameter.

When 2\sphinxhyphen{}body backflow is considered, a wavefunction parameter \(p\)
enters the \(\eta\) function only (equation \eqref{equation:developing:eq248}).
\(\mathbf{r}\), \(\phi\), and \(M\) do not explicitly
dependent on \(p\). Derivative of the log value is almost identical
to particle gradient. Namely, \eqref{equation:developing:eq250} applies upon the
substitution \(r_i^\alpha\rightarrow p\).
\begin{equation}\label{equation:developing:eq260}
\begin{split} \begin{aligned}
 \frac{\partial}{\partial p} \ln\det M = \sum\limits_{j=1}^N \sum\limits_{\beta=1}^3 F_{jj}^\beta \left({}_pC_{j}^{\beta}\right)\:,\end{aligned}\end{split}
\end{equation}
where the quasi\sphinxhyphen{}particle derivatives are stored in \sphinxcode{\sphinxupquote{Cmat}}
\begin{equation}\label{equation:developing:eq261}
\begin{split} \begin{aligned}
 {}_pC_{i}^{\alpha} \equiv \frac{\partial}{\partial p} x_{i}^{\alpha}\:.\end{aligned}\end{split}
\end{equation}
The change in local kinetic energy is a lot more difficult to calculate
\begin{equation}\label{equation:developing:eq262}
\begin{split} \begin{aligned}
 \frac{\partial T_{\text{local}}}{\partial p} = \frac{\partial}{\partial p} \left\{ \left( \sum\limits_{i=1}^N \frac{1}{2m_i} \nabla^2_i \right) \ln \det M \right\} = \sum\limits_{i=1}^N \frac{1}{2m_i} \frac{\partial}{\partial p} L_i\:, \end{aligned}\end{split}
\end{equation}
where \(L_i\) is the particle Laplacian defined in
\eqref{equation:developing:eq254} To evaluate \eqref{equation:developing:eq262}, we need to
calculate parameter derivatives of all three terms defined in the
Laplacian evaluation. Namely \((B)(F)\), \((AA)(FF)\), and
\(\text{tr}(AA,Md2M)\), where we have put parentheses around previously
identified data structures. After \(\frac{\partial}{\partial p}\)
hits, each of the three terms will split into two terms by the product
rule. Each smaller term will contain a contraction of two data
structures. Therefore, we will need to calculate the parameter
derivatives of each data structure defined in the Laplacian evaluation:
\begin{equation}\label{equation:developing:eq263}
\begin{split} \begin{aligned}
 {}_pX_{ij}^{\alpha\beta} \equiv \frac{\partial}{\partial p} A_{ij}^{\alpha\beta}\:, \\
 {}_pY_{ij}^{\alpha} \equiv \frac{\partial}{\partial p} B_{ij}^{\alpha}\:, \\
 {}_pdF_{ij}^{\alpha} \equiv \frac{\partial}{\partial p} F_{ij}^{\alpha}\:, \\
 {}_{pi}{AA'}_{jk}^{\beta\gamma} \equiv \frac{\partial}{\partial p}  {}_iAA_{jk}^{\beta\gamma}\:, \\
 {}_p {FF'}_{jk}^{\alpha\gamma} \equiv \frac{\partial}{\partial p} FF_{jk}^{\alpha\gamma}\:, \\
 {}_p {Md2M'}_{j}^{\beta\gamma} \equiv \frac{\partial}{\partial p} Md2M_j^{\beta\gamma}\:.\end{aligned}\end{split}
\end{equation}
X and Y are stored as \sphinxcode{\sphinxupquote{Xmat}} and \sphinxcode{\sphinxupquote{Ymat\_full}} (NOT \sphinxcode{\sphinxupquote{Ymat}}) in the
code. dF is \sphinxcode{\sphinxupquote{dFa}}. \(AA'\) is not fully stored; intermediate
values are stored in \sphinxcode{\sphinxupquote{Aij\_sum}} and \sphinxcode{\sphinxupquote{a\_j\_sum}}. \(FF'\) is
calculated on the fly as \(dF\otimes F+F\otimes dF\). \(Md2M'\)
is not stored; intermediate values are stored in \sphinxcode{\sphinxupquote{q\_j\_prime}}.


\section{Particles and distance tables}
\label{\detokenize{developing:particles-and-distance-tables}}\label{\detokenize{developing:distance-tables}}

\subsection{ParticleSets}
\label{\detokenize{developing:particlesets}}
The \sphinxcode{\sphinxupquote{ParticleSet}} class stores particle positions and attributes
(charge, mass, etc).

The \sphinxcode{\sphinxupquote{R}} member stores positions. For calculations, the \sphinxcode{\sphinxupquote{R}} variable
needs to be transferred to the structure\sphinxhyphen{}of\sphinxhyphen{}arrays (SoA) storage in
\sphinxcode{\sphinxupquote{RSoA}}. This is done by the \sphinxcode{\sphinxupquote{update}} method. In the future the
interface may change to use functions to set and retrieve positions so
the SoA transformation of the particle data can happen automatically.

A particular distance table is retrieved with \sphinxcode{\sphinxupquote{getDistTable}}. Use
\sphinxcode{\sphinxupquote{addTable}} to add a \sphinxcode{\sphinxupquote{ParticleSet}} and return the index of the
distance table. If the table already exists the index of the existing
table will be returned.

The mass and charge of each particle is stored in \sphinxcode{\sphinxupquote{Mass}} and \sphinxcode{\sphinxupquote{Z}}.
The flag, \sphinxcode{\sphinxupquote{SameMass}}, indicates if all the particles have the same
mass (true for electrons).


\subsubsection{Groups}
\label{\detokenize{developing:groups}}
Particles can belong to different groups. For electrons, the groups are
up and down spins. For ions, the groups are the atomic element. The
group type for each particle can be accessed through the \sphinxcode{\sphinxupquote{GroupID}}
member. The number of groups is returned from \sphinxcode{\sphinxupquote{groups()}}. The total
number particles is accessed with \sphinxcode{\sphinxupquote{getTotalNum()}}. The number of
particles in a group is \sphinxcode{\sphinxupquote{groupsize(int igroup)}}.

The particle indices for each group are found with \sphinxcode{\sphinxupquote{first(int igroup)}}
and \sphinxcode{\sphinxupquote{last(int igroup)}}. These functions only work correctly if the
particles are packed according to group. The flag, \sphinxcode{\sphinxupquote{IsGrouped}},
indicates if the particles are grouped or not. The particles will not be
grouped if the elements are not grouped together in the input file. This
ordering is usually the responsibility of the converters.

Code can be written to only handle the grouped case, but put an assert
or failure check if the particles are not grouped. Otherwise the code
will give wrong answers and it can be time\sphinxhyphen{}consuming to debug.


\subsection{Distance tables}
\label{\detokenize{developing:id7}}
Distance tables store distances between particles. There are symmetric
(AA) tables for distance between like particles (electron\sphinxhyphen{}electron or
ion\sphinxhyphen{}ion) and asymmetric (BA) tables for distance between unlike
particles (electron\sphinxhyphen{}ion)

The \sphinxcode{\sphinxupquote{Distances}} and \sphinxcode{\sphinxupquote{Displacements}} members contain the data. The
indexing order is target index first, then source. For electron\sphinxhyphen{}ion
tables, the sources are the ions and the targets are the electrons.


\subsection{Looping over particles}
\label{\detokenize{developing:looping-over-particles}}
Some sample code on how to loop over all the particles in an electron\sphinxhyphen{}ion distance table:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{d\PYGZus{}table} \PYG{o+ow}{is} \PYG{n}{an} \PYG{n}{electron}\PYG{o}{\PYGZhy{}}\PYG{n}{ion} \PYG{n}{distance} \PYG{n}{table}

\PYG{k}{for} \PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{jat} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{d\PYGZus{}table}\PYG{o}{.}\PYG{n}{targets}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{jat}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{o}{/}\PYG{o}{/} \PYG{n}{Loop} \PYG{n}{over} \PYG{n}{electrons}
  \PYG{k}{for} \PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{iat} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{d\PYGZus{}table}\PYG{o}{.}\PYG{n}{sources}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{iat}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{o}{/}\PYG{o}{/} \PYG{n}{Loop} \PYG{n}{over} \PYG{n}{ions}
     \PYG{n}{d\PYGZus{}table}\PYG{o}{.}\PYG{n}{Distances}\PYG{p}{[}\PYG{n}{jat}\PYG{p}{]}\PYG{p}{[}\PYG{n}{iat}\PYG{p}{]}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Interactions sometimes depend on the type of group of the particles. The
code can loop over all particles and use \sphinxcode{\sphinxupquote{GroupID{[}idx{]}}} to choose the
interaction. Alternately, the code can loop over the number of groups
and then loop from the first to last index for those groups. This method
can attain higher performance by effectively hoisting tests for group ID
out of the loop.

An example of the first approach is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{P} \PYG{o+ow}{is} \PYG{n}{a} \PYG{n}{ParticleSet}

\PYG{k}{for} \PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{iat} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iat} \PYG{o}{\PYGZlt{}} \PYG{n}{P}\PYG{o}{.}\PYG{n}{getTotalNum}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{iat}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{n+nb}{int} \PYG{n}{group\PYGZus{}idx} \PYG{o}{=} \PYG{n}{P}\PYG{o}{.}\PYG{n}{GroupID}\PYG{p}{[}\PYG{n}{iat}\PYG{p}{]}\PYG{p}{;}
  \PYG{o}{/}\PYG{o}{/} \PYG{n}{Code} \PYG{n}{that} \PYG{n}{depends} \PYG{n}{on} \PYG{n}{the} \PYG{n}{group} \PYG{n}{index}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

An example of the second approach is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{P} \PYG{o+ow}{is} \PYG{n}{a} \PYG{n}{ParticleSet}
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{P}\PYG{o}{.}\PYG{n}{IsGrouped} \PYG{o}{==} \PYG{n}{true}\PYG{p}{)}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{ensure} \PYG{n}{particles} \PYG{n}{are} \PYG{n}{grouped}

\PYG{k}{for} \PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{ig} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ig} \PYG{o}{\PYGZlt{}} \PYG{n}{P}\PYG{o}{.}\PYG{n}{groups}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{ig}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{o}{/}\PYG{o}{/} \PYG{n}{loop} \PYG{n}{over} \PYG{n}{groups}
  \PYG{k}{for} \PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{iat} \PYG{o}{=} \PYG{n}{P}\PYG{o}{.}\PYG{n}{first}\PYG{p}{(}\PYG{n}{ig}\PYG{p}{)}\PYG{p}{;} \PYG{n}{iat} \PYG{o}{\PYGZlt{}} \PYG{n}{P}\PYG{o}{.}\PYG{n}{last}\PYG{p}{(}\PYG{n}{ig}\PYG{p}{)}\PYG{p}{;} \PYG{n}{iat}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{o}{/}\PYG{o}{/} \PYG{n}{loop} \PYG{n}{over} \PYG{n}{elements} \PYG{o+ow}{in} \PYG{n}{each} \PYG{n}{group}
     \PYG{o}{/}\PYG{o}{/} \PYG{n}{Code} \PYG{n}{that} \PYG{n}{depends} \PYG{n}{on} \PYG{n}{group}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Adding a wavefunction}
\label{\detokenize{developing:adding-a-wavefunction}}
The total wavefunction is stored in \sphinxcode{\sphinxupquote{TrialWaveFunction}} as a product
of all the components. Each component derives from
\sphinxcode{\sphinxupquote{WaveFunctionComponent}}. The code contains an example of a
wavefunction component for a Helium atom using a simple form and is
described in {\hyperref[\detokenize{developing:helium-wavefunction-example}]{\sphinxcrossref{\DUrole{std,std-ref}{Helium Wavefunction Example}}}}


\subsection{Mathematical preliminaries}
\label{\detokenize{developing:mathematical-preliminaries}}
The wavefunction evaluation functions compute the log of the
wavefunction, the gradient and the Laplacian of the log of the
wavefunction. Expanded, the gradient and Laplacian are
\begin{equation}\label{equation:developing:eq264}
\begin{split} \begin{aligned}
 G &=& \nabla \log(\psi) = \frac{\nabla \psi}{\psi} \\
 L &=& {\nabla ^2} \log(\psi) = \frac{{\nabla ^2}\psi}{\psi} - \frac{\nabla \psi}{\psi} \cdot \frac{\nabla \psi}{\psi} \\
                 &=& \frac{{\nabla ^2} \psi}{\psi} - G \cdot G\end{aligned}\end{split}
\end{equation}
However, the local energy formula needs \(\frac{{\nabla ^2} \psi}{\psi}\).
The conversion from the Laplacian of the log of the wavefunction to the
local energy value is performed in
\sphinxcode{\sphinxupquote{QMCHamiltonians/BareKineticEnergy.h}} (i.e. \(L + G \cdot G\).)


\subsection{Wavefunction evaluation}
\label{\detokenize{developing:wavefunction-evaluation}}
The process for creating a new wavefunction component class is to derive
from WaveFunctionComponent and implement a number pure virtual
functions. To start most of them can be empty.

The following four functions evaluate the wavefunction values and
spatial derivatives:

\sphinxcode{\sphinxupquote{evaluateLog}} Computes the log of the wavefunction and the gradient
and Laplacian (of the log of the wavefunction) for all particles. The
input is the\sphinxcode{\sphinxupquote{ParticleSet}}(\sphinxcode{\sphinxupquote{P}}) (of the electrons). The return
value is the log of wavefunction, and the gradient is in \sphinxcode{\sphinxupquote{G}} and
Laplacian in \sphinxcode{\sphinxupquote{L}}.

\sphinxcode{\sphinxupquote{ratio}} Computes the wavefunction ratio (not the log) for a single
particle move (\(\psi_{new}/\psi_{old}\)). The inputs are the
\sphinxcode{\sphinxupquote{ParticleSet}}(\sphinxcode{\sphinxupquote{P}}) and the particle index (\sphinxcode{\sphinxupquote{iat}}).

\sphinxcode{\sphinxupquote{evalGrad}} Computes the gradient for a given particle. The inputs are
the \sphinxcode{\sphinxupquote{ParticleSet}}(\sphinxcode{\sphinxupquote{P}}) and the particle index (\sphinxcode{\sphinxupquote{iat}}).

\sphinxcode{\sphinxupquote{ratioGrad}} Computes the wavefunction ratio and the gradient at the
new position for a single particle move. The inputs are the
\sphinxcode{\sphinxupquote{ParticleSet}}(\sphinxcode{\sphinxupquote{P}}) and the particle index (\sphinxcode{\sphinxupquote{iat}}). The output
gradient is in \sphinxcode{\sphinxupquote{grad\_iat}};

The \sphinxcode{\sphinxupquote{updateBuffer}} function needs to be implemented, but to start it
can simply call \sphinxcode{\sphinxupquote{evaluateLog}}.

The \sphinxcode{\sphinxupquote{put}} function should be implemented to read parameter specifics
from the input XML file.


\subsection{Function use}
\label{\detokenize{developing:function-use}}
For debugging it can be helpful to know the under what conditions the
various routines are called.

The VMC and DMC loops initialize the walkers by calling \sphinxcode{\sphinxupquote{evaluateLog}}.
For all\sphinxhyphen{}electron moves, each timestep advance calls \sphinxcode{\sphinxupquote{evaluateLog}}. If
the \sphinxcode{\sphinxupquote{use\_drift}} parameter is no, then only the wavefunction value is
used for sampling. The gradient and Laplacian are used for computing the
local energy.

For particle\sphinxhyphen{}by\sphinxhyphen{}particle moves, each timestep advance
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
calls \sphinxcode{\sphinxupquote{evalGrad}}

\item {} 
computes a trial move

\item {} 
calls \sphinxcode{\sphinxupquote{ratioGrad}} for the wavefunction ratio and the gradient at
the trial position. (If the \sphinxcode{\sphinxupquote{use\_drift}} parameter is no, the
\sphinxcode{\sphinxupquote{ratio}} function is called instead.)

\end{enumerate}

The following example shows part of an input block for VMC with
all\sphinxhyphen{}electron moves and drift.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{vmc}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alle}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{use\PYGZus{}drift}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{yes}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Particle distances}
\label{\detokenize{developing:particle-distances}}
The \sphinxcode{\sphinxupquote{ParticleSet}} parameter in these functions refers to the
electrons. The distance tables that store the inter\sphinxhyphen{}particle distances
are stored as an array.

To get the electron\sphinxhyphen{}ion distances, add the ion \sphinxcode{\sphinxupquote{ParticleSet}} using
\sphinxcode{\sphinxupquote{addTable}} and save the returned index. Use that index to get the
ion\sphinxhyphen{}electron distance table.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{const} \PYG{n+nb}{int} \PYG{n}{ei\PYGZus{}id} \PYG{o}{=} \PYG{n}{elecs}\PYG{o}{.}\PYG{n}{addTable}\PYG{p}{(}\PYG{n}{ions}\PYG{p}{,} \PYG{n}{DT\PYGZus{}SOA}\PYG{p}{)}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{constructor} \PYG{n}{only}
\PYG{n}{const} \PYG{n}{auto}\PYG{o}{\PYGZam{}} \PYG{n}{ei\PYGZus{}table} \PYG{o}{=} \PYG{n}{elecs}\PYG{o}{.}\PYG{n}{getDistTable}\PYG{p}{(}\PYG{n}{ei\PYGZus{}id}\PYG{p}{)}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{when} \PYG{n}{consuming} \PYG{n}{a} \PYG{n}{distance} \PYG{n}{table}
\end{sphinxVerbatim}

Getting the electron\sphinxhyphen{}electron distances is very similar, just add the
electron \sphinxcode{\sphinxupquote{ParticleSet}} using \sphinxcode{\sphinxupquote{addTable}}.

Only the lower triangle for the electron\sphinxhyphen{}electron table should be used.
It is the only part of the distance table valid throughout the run.
During particle\sphinxhyphen{}by\sphinxhyphen{}particle move, there are extra restrictions. When a
move of electron iel is proposed, only the lower triangle parts
{[}0,iel){[}0,iel) {[}iel, Nelec){[}iel, Nelec) and the row {[}iel{]}{[}0:Nelec) are
valid. In fact, the current implementation of distance based two and
three body Jastrow factors in QMCPACK only needs the row {[}iel{]}{[}0:Nelec).

In \sphinxcode{\sphinxupquote{ratioGrad}}, the new distances are stored in the \sphinxcode{\sphinxupquote{Temp\_r}} and
\sphinxcode{\sphinxupquote{Temp\_dr}} members of the distance tables.


\subsection{Setup}
\label{\detokenize{developing:setup}}
A builder processes XML input, creates the wavefunction, and adds it to
\sphinxcode{\sphinxupquote{targetPsi}}. Builders derive from \sphinxcode{\sphinxupquote{WaveFunctionComponentBuilder}}.

The new builder hooks into the XML processing in
\sphinxcode{\sphinxupquote{WaveFunctionFactory.cpp}} in the \sphinxcode{\sphinxupquote{build}} function.


\subsection{Caching values}
\label{\detokenize{developing:caching-values}}
The \sphinxcode{\sphinxupquote{acceptMove}} and \sphinxcode{\sphinxupquote{restore}} methods are called on accepted and
rejected moves for the component to update cached values.


\subsection{Threading}
\label{\detokenize{developing:threading}}
The \sphinxcode{\sphinxupquote{makeClone}} function needs to be implemented to work correctly
with OpenMP threading. There will be one copy of the component created
for each thread. If there is no extra storage, calling the copy
constructor will be sufficient. If there are cached values, the clone
call may need to create space.


\subsection{Parameter optimization}
\label{\detokenize{developing:parameter-optimization}}
The \sphinxcode{\sphinxupquote{checkInVariables}}, \sphinxcode{\sphinxupquote{checkOutVariables}}, and \sphinxcode{\sphinxupquote{resetParameters}}
functions manage the variational parameters. Optimizable variables also
need to be registered when the XML is processed.

Variational parameter derivatives are computed in the
\sphinxcode{\sphinxupquote{evaluateDerivatives}} function. The first output value is an array
with parameter derivatives of log of the wavefunction. The second output
values is an array with parameter derivatives of the Laplacian divided
by the wavefunction (and not the Laplacian of the log of the
wavefunction) The kinetic energy term contains a \(-1/2m\) factor.
The \(1/m\) factor is applied in \sphinxcode{\sphinxupquote{TrialWaveFunction.cpp}}, but the
\(-1/2\) is not and must be accounted for in this function.


\subsection{Helium Wavefunction Example}
\label{\detokenize{developing:helium-wavefunction-example}}\label{\detokenize{developing:id8}}
The code contains an example of a wavefunction component for a Helium atom using STO orbitals and a Pade Jastrow.

to
The wavefunction is
\begin{equation}\label{equation:developing:eq265}
\begin{split}\psi = \frac{1}{\sqrt{\pi}} \exp(-Z r_1) \exp(-Z r_2) \exp(A / (1 + B r_{12}))\end{split}
\end{equation}
where \(Z = 2\) is the nuclear charge, \(A=1/2\) is the
electron\sphinxhyphen{}electron cusp, and \(B\) is a variational parameter. The
electron\sphinxhyphen{}ion distances are \(r_1\) and \(r_2\), and
\(r_{12}\) is the electron\sphinxhyphen{}electron distance. The wavefunction is
the same as the one expressed with built\sphinxhyphen{}in components in
\sphinxcode{\sphinxupquote{examples/molecules/He/he\_simple\_opt.xml}}.

The code is in \sphinxcode{\sphinxupquote{src/QMCWaveFunctions/ExampleHeComponent.cpp}}. The
builder is in \sphinxcode{\sphinxupquote{src/QMCWaveFunctions/ExampleHeBuilder.cpp}}. The input
file is in \sphinxcode{\sphinxupquote{examples/molecules/He/he\_example\_wf.xml}}. A unit test
compares results from the wavefunction evaluation functions for
consistency in \sphinxcode{\sphinxupquote{src/QMCWaveFunctions/tests/test\_example\_he.cpp}}.

The recommended approach for creating a new wavefunction component is to
copy the example and the unit test. Implement the evaluation functions
and ensure the unit test passes.


\section{Linear Algebra}
\label{\detokenize{developing:linear-algebra}}
Like in many methods which solve the Schrödinger equation, linear
algebra plays a critical role in QMC algorithms and thus is crucial to
the performance of QMCPACK. There are a few components in QMCPACK use
BLAS/LAPACK with their own characteristics.


\subsection{Real space QMC}
\label{\detokenize{developing:real-space-qmc}}

\subsubsection{Single particle orbitals}
\label{\detokenize{developing:single-particle-orbitals}}
Spline evaluation as commonly used in solid\sphinxhyphen{}state simulations does not use any dense linear algebra library calls.
LCAO evaluation as commonly used in molecular calculations relies on BLAS2 GEMV to compute SPOs from a basis set.


\subsubsection{Slater determinants}
\label{\detokenize{developing:slater-determinants}}
Slater determinants are calculated on \(N \times N\) Slater
matrices. \(N\) is the number of electrons for a given spin. In the
actually implementation, operations on the inverse matrix of Slater
matrix for each walker dominate the computation. To initialize it,
DGETRF and DGETRI from LAPACK are called. The inverse matrix can be
stored out of place. During random walking, inverse matrices are updated
by either Sherman\sphinxhyphen{}Morrison rank\sphinxhyphen{}1 update or delayed update. Update
algorithms heavily relies on BLAS. All the BLAS operations require
S,C,D,Z cases.

Sherman\sphinxhyphen{}Morrison rank\sphinxhyphen{}1 update uses BLAS2 GEMV and GER on
\(N \times N\) matrices.

Delayed rank\sphinxhyphen{}K update uses
\begin{itemize}
\item {} 
BLAS1 SCOPY on \(N\) array.

\item {} 
BLAS2 GEMV, GER on \(k \times N\) and \(k \times k\)
matrices. \(k\) ranges from 1 to \(K\) when updates are
delayed and accumulated.

\item {} 
BLAS3 GEMM at the final update.
\begin{itemize}
\item {} 
’T’, ’N’, K, N, N

\item {} 
’N’, ’N’, N, K, K

\item {} 
’N’, ’N’, N, N, K

\end{itemize}

\end{itemize}

The optimal K depends on the hardware but it usually ranges from 32 to
256.

QMCPACK solves systems with a few to thousands of electrons. To make all
the BLAS/LAPACK operation efficient on accelerators. Batching is needed
and optimized for \(N < 2000\). Non\sphinxhyphen{}batched functions needs to be
optimized for \(N > 500\). Note: 2000 and 500 are only rough
estimates.


\subsubsection{Wavefunction optimizer}
\label{\detokenize{developing:wavefunction-optimizer}}
to be added.


\subsection{Auxiliary field QMC}
\label{\detokenize{developing:auxiliary-field-qmc}}
The AFQMC implementation in QMCPACK relies heavily on linear algebra operations from BLAS/LAPACK. The performance of the code is netirely dependent on the performance of these libraries. See below for a detailed list of the main routines used from BLAS/LAPACK. Since the AFQMC code can work with both single and double precision builds, all 4 versions of these routines (S,C,D,Z) are generally needed, for this reason we omit the data type label.
\begin{itemize}
\item {} 
BLAS1: SCAL, COPY, DOT, AXPY

\item {} 
BLAS2: GEMV, GER

\item {} 
BLAS3: GEMM

\item {} 
LAPACK: GETRF, GETRI, GELQF, UNGLQ, ORGLQ, GESVD, HEEVR, HEGVX

\end{itemize}

While the dimensions of the matrix operations will depend entirely on
the details of the calculation, typical matrix dimensions range from the
100s, for small system sizes, to over 20000 for the largest calculations
attempted so far. For builds with GPU accelerators, we make use of
batched and strided implementations of these routines. Batched
implementations of GEMM, GETRF, GETRI, GELQF and UNGLQ are particularly
important for the performance of the GPU build on small to medium size
problems. Batched implementations of DOT, AXPY and GEMV would also be
quite useful, but they are not yet generally available. On GPU builds,
the code uses batched implementations of these routines when available
by default.




\chapter{Appendices}
\label{\detokenize{appendices:appendices}}\label{\detokenize{appendices:id1}}\label{\detokenize{appendices::doc}}

\section{Appendix A: Derivation of twist averaging efficiency}
\label{\detokenize{appendices:appendix-a-derivation-of-twist-averaging-efficiency}}\label{\detokenize{appendices:appendix-a}}
In this appendix we derive the relative statistical efficiency of twist
averaging with an irreducible (weighted) set of k\sphinxhyphen{}points versus using
uniform weights over an unreduced set of k\sphinxhyphen{}points (e.g., a full
Monkhorst\sphinxhyphen{}Pack mesh).

Consider the weighted average of a set of statistical variables
\(\{x_m\}\) with weights \(\{w_m\}\):
\begin{equation}\label{equation:appendices:eq266}
\begin{split} \begin{aligned}
   x_{TA} = \frac{\sum_mw_mx_m}{\sum_mw_m}\:.\end{aligned}\end{split}
\end{equation}
If produced by a finite QMC run at a set of twist angles/k\sphinxhyphen{}points
\(\{k_m\}\), each variable mean \(\langle{x_m}\rangle\) has a statistical
error bar \(\sigma_m\), and we can also obtain the statistical error
bar of the mean of the twist\sphinxhyphen{}averaged quantity \(\langle{x_{TA}\rangle}\):
\begin{equation}\label{equation:appendices:eq267}
\begin{split} \begin{aligned}
   \sigma_{TA} = \frac{\left(\sum_mw_m^2\sigma_m^2\right)^{1/2}}{\sum_mw_m}\:.\end{aligned}\end{split}
\end{equation}
The error bar of each individual twist \(\sigma_m\) is related to
the autocorrelation time \(\kappa_m\), intrinsic variance
\(v_m\), and the number of postequilibration MC steps
\(N_{step}\) in the following way:
\begin{equation}\label{equation:appendices:eq268}
\begin{split} \begin{aligned}
   \sigma_m^2=\frac{\kappa_mv_m}{N_{step}}\:.\end{aligned}\end{split}
\end{equation}
In the setting of twist averaging, the autocorrelation time and variance
for different twist angles are often very similar across twists, and we
have
\begin{equation}\label{equation:appendices:eq269}
\begin{split} \begin{aligned}
   \sigma_m^2=\sigma^2=\frac{\kappa v}{N_{step}}\:.\end{aligned}\end{split}
\end{equation}
If we define the total weight as \(W\), that is,
\(W\equiv\sum_{m=1}^Mw_m\), for the weighted case with \(M\)
irreducible twists, the error bar is
\begin{equation}\label{equation:appendices:eq270}
\begin{split} \begin{aligned}
   \sigma_{TA}^{weighted}=\frac{\left(\sum_{m=1}^Mw_m^2\right)^{1/2}}{W}\sigma\:.\end{aligned}\end{split}
\end{equation}
For uniform weighting with \(w_m=1\), the number of twists is
\(W\) and we have
\begin{equation}\label{equation:appendices:eq271}
\begin{split} \begin{aligned}
   \sigma_{TA}^{uniform}=\frac{1}{\sqrt{W}}\sigma\:.\end{aligned}\end{split}
\end{equation}
We are interested in comparing the efficiency of choosing weights
uniformly or based on the irreducible multiplicity of each twist angle
for a given target error bar \(\sigma_{target}\). The number of MC
steps required to reach this target for uniform weighting is
\begin{equation}\label{equation:appendices:eq272}
\begin{split} \begin{aligned}
   N_{step}^{uniform} = \frac{1}{W}\frac{\kappa v}{\sigma_{target}^2}\:,\end{aligned}\end{split}
\end{equation}
while for nonuniform weighting we have
\begin{equation}\label{equation:appendices:eq273}
\begin{split} \begin{aligned}
   N_{step}^{weighted} &= \frac{\sum_{m=1}^Mw_m^2}{W^2}\frac{\kappa v}{\sigma_{target}^2} \nonumber\:,\\
                   &=\frac{\sum_{m=1}^Mw_m^2}{W}N_{step}^{uniform}\:.\end{aligned}\end{split}
\end{equation}
The MC efficiency is defined as
\begin{equation}\label{equation:appendices:eq274}
\begin{split} \begin{aligned}
   \xi = \frac{1}{\sigma^2t}\:,\end{aligned}\end{split}
\end{equation}
where \(\sigma\) is the error bar and \(t\) is the total CPU
time required for the MC run.

The main advantage made possible by irreducible twist weighting is to
reduce the equilibration time overhead by having fewer twists and,
hence, fewer MC runs to equilibrate. In the context of twist averaging,
the total CPU time for a run can be considered to be
\begin{equation}\label{equation:appendices:eq275}
\begin{split} \begin{aligned}
   t=N_{twist}(N_{eq}+N_{step})t_{step}\:,\end{aligned}\end{split}
\end{equation}
where \(N_{twist}\) is the number of twists, \(N_{eq}\) is the
number of MC steps required to reach equilibrium, \(N_{step}\) is
the number of MC steps included in the statistical averaging as before,
and \(t_{step}\) is the wall clock time required to complete a
single MC step. For uniform weighting \(N_{twist}=W\); while for
irreducible weighting \(N_{twist}=M\).

We can now calculate the relative efficiency (\(\eta\)) of
irreducible vs. uniform twist weighting with the aim of obtaining a
target error bar \(\sigma_{target}\):
\begin{equation}\label{equation:appendices:eq276}
\begin{split} \begin{aligned}
   \eta &= \frac{\xi_{TA}^{weighted}}{\xi_{TA}^{uniform}} \nonumber\:, \\
        &= \frac{\sigma_{target}^2t_{TA}^{uniform}}{\sigma_{target}^2t_{TA}^{weighted}} \nonumber\:, \\
        &= \frac{W(N_{eq}+N_{step}^{uniform})}{M(N_{eq}+N_{step}^{weighted})} \nonumber\:, \\
        &= \frac{W(N_{eq}+N_{step}^{uniform})}{M(N_{eq}+\frac{\sum_{m=1}^Mw_m^2}{W}N_{step}^{uniform})} \nonumber\:, \\
        &= \frac{W}{M}\frac{1+f}{1+\frac{\sum_{m=1}^Mw_m^2}{W}f}\:.\end{aligned}\end{split}
\end{equation}
In this last expression, \(f\) is the ratio of the number of usable
MC steps to the number that must be discarded during equilibration
(\(f=N_{step}^{uniform}/N_{eq}\)); and as before,
\(W=\sum_mw_m\), which is the number of twist angles in the uniform
weighting case. It is important to recall that
\(N_{step}^{uniform}\) in \(f\) is defined relative to uniform
weighting and is the number of MC steps required to reach a target
accuracy in the case of uniform twist weights.

The formula for \(\eta\) in the preceding can be easily changed with
the help of \eqref{equation:appendices:eq273} to reflect the number of MC
steps obtained in an irreducibly weighted run instead. A good exercise
is to consider runs that have already completed with either uniform or
irreducible weighting and calculate the expected efficiency change had
the opposite type of weighting been used.

The break even point \((\eta=1)\) can be found at a usable step
fraction of
\begin{equation}\label{equation:appendices:eq277}
\begin{split} \begin{aligned}
   f=\frac{W-M}{M\frac{\sum_{m=1}^Mw_m^2}{W}-W}\:.\end{aligned}\end{split}
\end{equation}
The relative efficiency \((\eta)\) is useful to consider in view of
certain scenarios. An important case is where the number of required
sampling steps is no larger than the number of equilibration steps
(i.e., \(f\approx 1\)). For a very simple case with eight uniform
twists with irreducible multiplicities of \(w_m\in\{1,3,3,1\}\)
(\(W=8\), \(M=4\)), the relative efficiency of irreducible vs.
uniform weighting is
\(\eta=\frac{8}{4}\frac{2}{1+20/8}\approx 1.14\). In this case,
irreducible weighting is about \(14\)\% more efficient than uniform
weighting.

Another interesting case is one in which the number of sampling steps
you can reach with uniform twists before wall clock time runs out is
small relative to the number of equilibration steps
(\(f\rightarrow 0\)). In this limit, \(\eta\approx W/M\). For
our eight\sphinxhyphen{}uniform\sphinxhyphen{}twist example, this would result in a relative
efficiency of \(\eta=8/4=2\), making irreducible weighting twice as
efficient.

A final case of interest is one in which the equilibration time is short
relative to the available sampling time \((f\rightarrow\infty)\),
giving \(\eta\approx W^2/(M\sum_{m=1}^Mw_m^2)\). Again, for our
simple example we find \(\eta=8^2/(4\times 20)\approx 0.8\), with
uniform weighting being \(25\)\% more efficient than irreducible
weighting. For this example, the crossover point for irreducible
weighting being more efficient than uniform weighting is \(f<2\),
that is, when the available sampling period is less than twice the
length of the equilibration period. The expected efficiency ratio and
crossover point should be checked for the particular case under
consideration to inform the choice between twist averaging methods.


\section{Appendix B: QMCPACK papers}
\label{\detokenize{appendices:appendix-b-qmcpack-papers}}\label{\detokenize{appendices:appendixb}}
The following is a list of all papers, theses, and book chapters
known to use QMCPACK. Please let the developers know if your paper
is missing, you know of other works, or an entry is incorrect. We
list papers whether or not they cite QMCPACK directly. This list
will be placed on the \sphinxurl{http://www.qmcpack.org} website.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{QMCPACK} \PYG{n}{website}\PYG{p}{:} \PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{www}\PYG{o}{.}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{org}

\PYG{n}{Releases} \PYG{o}{\PYGZam{}} \PYG{n}{source} \PYG{n}{code}\PYG{p}{:} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}

\PYG{n}{Google} \PYG{n}{Group}\PYG{p}{:} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{groups}\PYG{o}{.}\PYG{n}{google}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{forum}\PYG{o}{/}\PYG{c+c1}{\PYGZsh{}!forum/qmcpack}
\end{sphinxVerbatim}

\begin{sphinxthebibliography}{MDAzeved}
\bibitem[MLC+17]{features:ipcc-sc17}
Amrita Mathuriya, Ye Luo, Raymond C. Clay, III, Anouar Benali, Luke Shulenburger, and Jeongnim Kim. Embracing a new era of highly efficient and productive quantum monte carlo simulations. In \sphinxstyleemphasis{Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis}, SC ‘17, 38:1\textendash{}38:12. New York, NY, USA, 2017. ACM. URL: \sphinxurl{http://doi.acm.org/10.1145/3126908.3126952}, \sphinxhref{https://doi.org/10.1145/3126908.3126952}{doi:10.1145/3126908.3126952}.
\bibitem[EKCS12]{running:eslerkimceperleyshulenburger2012}
Kenneth P. Esler, Jeongnim Kim, David M. Ceperley, and Luke Shulenburger. Accelerating quantum monte carlo simulations of real materials on gpu clusters. \sphinxstyleemphasis{Computing in Science and Engineering}, 14(1):40\textendash{}51, 2012. \sphinxhref{https://doi.org/http://doi.ieeecomputersociety.org/10.1109/MCSE.2010.122}{doi:http://doi.ieeecomputersociety.org/10.1109/MCSE.2010.122}.
\bibitem[NC95]{simulationcell:natoli1995}
Vincent Natoli and David M. Ceperley. An optimized method for treating long\sphinxhyphen{}range potentials. \sphinxstyleemphasis{Journal of Computational Physics}, 117(1):171 \textendash{} 178, 1995. URL: \sphinxurl{http://www.sciencedirect.com/science/article/pii/S0021999185710546}, \sphinxhref{https://doi.org/http://dx.doi.org/10.1006/jcph.1995.1054}{doi:http://dx.doi.org/10.1006/jcph.1995.1054}.
\bibitem[AlfeG04]{intro_wavefunction:blips4qmc}
D. Alfè and M. J. Gillan. An efficient localized basis set for quantum Monte Carlo calculations on condensed matter. \sphinxstyleemphasis{Physical Review B}, 70(16):161101, 2004.
\bibitem[BN17]{intro_wavefunction:blunt-charge-transfer-2017}
N. S. Blunt and Eric Neuscamman. Charge\sphinxhyphen{}transfer excited states: Seeking a balanced and efficient wave function ansatz in variational Monte Carlo. \sphinxstyleemphasis{The Journal of Chemical Physics}, 147(19):194101, November 2017. \sphinxhref{https://doi.org/10.1063/1.4998197}{doi:10.1063/1.4998197}.
\bibitem[Cep78]{intro_wavefunction:ceperley1978}
D. Ceperley. Ground state of the fermion one\sphinxhyphen{}component plasma: a monte carlo study in two and three dimensions. \sphinxstyleemphasis{Phys. Rev. B}, 18:3126\textendash{}3138, October 1978. URL: \sphinxurl{https://link.aps.org/doi/10.1103/PhysRevB.18.3126}, \sphinxhref{https://doi.org/10.1103/PhysRevB.18.3126}{doi:10.1103/PhysRevB.18.3126}.
\bibitem[DTN04]{intro_wavefunction:drummond2004}
N. D. Drummond, M. D. Towler, and R. J. Needs. Jastrow correlation factor for atoms, molecules, and solids. \sphinxstyleemphasis{Physical Review B \sphinxhyphen{} Condensed Matter and Materials Physics}, 70(23):1\textendash{}11, 2004. \sphinxhref{https://doi.org/10.1103/PhysRevB.70.235119}{doi:10.1103/PhysRevB.70.235119}.
\bibitem[EG13]{intro_wavefunction:caffarel2013}
M. Caffarel E. Giner, A. Scemama. Using perturbatively selected configuration interaction in quantum monte carlo calculations. \sphinxstyleemphasis{Canadian Journal of Chemistry}, 91:9, 2013.
\bibitem[EKCS12]{intro_wavefunction:eslerkimceperleyshulenburger2012}
Kenneth P. Esler, Jeongnim Kim, David M. Ceperley, and Luke Shulenburger. Accelerating quantum monte carlo simulations of real materials on gpu clusters. \sphinxstyleemphasis{Computing in Science and Engineering}, 14(1):40\textendash{}51, 2012. \sphinxhref{https://doi.org/http://doi.ieeecomputersociety.org/10.1109/MCSE.2010.122}{doi:http://doi.ieeecomputersociety.org/10.1109/MCSE.2010.122}.
\bibitem[FWL90]{intro_wavefunction:fahy1990}
S. Fahy, X. W. Wang, and Steven G. Louie. Variational quantum Monte Carlo nonlocal pseudopotential approach to solids: Formulation and application to diamond, graphite, and silicon. \sphinxstyleemphasis{Physical Review B}, 42(6):3503\textendash{}3522, 1990. \sphinxhref{https://doi.org/10.1103/PhysRevB.42.3503}{doi:10.1103/PhysRevB.42.3503}.
\bibitem[Gas61]{intro_wavefunction:gaskell1961}
T Gaskell. The collective treatment of a fermi gas: ii. \sphinxstyleemphasis{Proceedings of the Physical Society}, 77(6):1182, 1961. URL: \sphinxurl{http://stacks.iop.org/0370-1328/77/i=6/a=312}.
\bibitem[Gas62]{intro_wavefunction:gaskell1962}
T Gaskell. The collective treatment of many\sphinxhyphen{}body systems: iii. \sphinxstyleemphasis{Proceedings of the Physical Society}, 80(5):1091, 1962. URL: \sphinxurl{http://stacks.iop.org/0370-1328/80/i=5/a=307}.
\bibitem[Kat51]{intro_wavefunction:kato}
T Kato. Fundamental properties of hamiltonian operators of the schrodinger type. \sphinxstyleemphasis{Transactions of the American Mathematical Society}, 70:195\textendash{}211, 1951.
\bibitem[LEKS18]{intro_wavefunction:luo2018hyb}
Ye Luo, Kenneth P. Esler, Paul R. C. Kent, and Luke Shulenburger. An efficient hybrid orbital representation for quantum monte carlo calculations. \sphinxstyleemphasis{The Journal of Chemical Physics}, 149(8):084107, 2018.
\bibitem[LK18]{intro_wavefunction:luo2018delayedupdate}
Ye Luo and Jeongnim Kim. An highly efficient delayed update algorithm for evaluating slater determinants in quantum monte carlo. \sphinxstyleemphasis{in preparation}, ():, 2018.
\bibitem[MDAzevedoL+17]{intro_wavefunction:mcdaniel2017}
T. McDaniel, E. F. D’Azevedo, Y. W. Li, K. Wong, and P. R. C. Kent. Delayed slater determinant update algorithms for high efficiency quantum monte carlo. \sphinxstyleemphasis{The Journal of Chemical Physics}, 147(17):174107, November 2017. \sphinxhref{https://doi.org/10.1063/1.4998616}{doi:10.1063/1.4998616}.
\bibitem[NC95]{intro_wavefunction:natoli1995}
Vincent Natoli and David M. Ceperley. An optimized method for treating long\sphinxhyphen{}range potentials. \sphinxstyleemphasis{Journal of Computational Physics}, 117(1):171 \textendash{} 178, 1995. URL: \sphinxurl{http://www.sciencedirect.com/science/article/pii/S0021999185710546}, \sphinxhref{https://doi.org/http://dx.doi.org/10.1006/jcph.1995.1054}{doi:http://dx.doi.org/10.1006/jcph.1995.1054}.
\bibitem[Sce17]{intro_wavefunction:qp}
A. Scemamma. Quantum package. https://github.com/LCPQ/quantum\_package, 2013\textendash{}2017.
\bibitem[SBB+93]{intro_wavefunction:schmidt93}
Michael W. Schmidt, Kim K. Baldridge, Jerry A. Boatz, Steven T. Elbert, Mark S. Gordon, Jan H. Jensen, Shiro Koseki, Nikita Matsunaga, Kiet A. Nguyen, Shujun Su, Theresa L. Windus, Michel Dupuis, and John A. Montgomery. General atomic and molecular electronic structure system. \sphinxstyleemphasis{Journal of Computational Chemistry}, 14(11):1347\textendash{}1363, 1993. URL: \sphinxurl{http://dx.doi.org/10.1002/jcc.540141112}, \sphinxhref{https://doi.org/10.1002/jcc.540141112}{doi:10.1002/jcc.540141112}.
\bibitem[CCMH06]{hamiltonianobservable:chiesa2006}
Simone Chiesa, David M. Ceperley, Richard M. Martin, and Markus Holzmann. Finite\sphinxhyphen{}size error in many\sphinxhyphen{}body simulations with long\sphinxhyphen{}range interactions. \sphinxstyleemphasis{Phys. Rev. Lett.}, 97:076404, August 2006. \sphinxhref{https://doi.org/10.1103/PhysRevLett.97.076404}{doi:10.1103/PhysRevLett.97.076404}.
\bibitem[KKR14]{hamiltonianobservable:krogel2014}
Jaron T. Krogel, Jeongnim Kim, and Fernando A. Reboredo. Energy density matrix formalism for interacting quantum systems: quantum monte carlo study. \sphinxstyleemphasis{Phys. Rev. B}, 90:035125, July 2014. \sphinxhref{https://doi.org/10.1103/PhysRevB.90.035125}{doi:10.1103/PhysRevB.90.035125}.
\bibitem[KYKC13]{hamiltonianobservable:krogel2013}
Jaron T. Krogel, Min Yu, Jeongnim Kim, and David M. Ceperley. Quantum energy density: improved efficiency for quantum monte carlo calculations. \sphinxstyleemphasis{Phys. Rev. B}, 88:035137, July 2013. \sphinxhref{https://doi.org/10.1103/PhysRevB.88.035137}{doi:10.1103/PhysRevB.88.035137}.
\bibitem[MSC91]{hamiltonianobservable:mitas1991}
Lubos Mitas, Eric L. Shirley, and David M. Ceperley. Nonlocal pseudopotentials and diffusion monte carlo. \sphinxstyleemphasis{The Journal of Chemical Physics}, 95(5):3467\textendash{}3475, 1991. \sphinxhref{https://doi.org/10.1063/1.460849}{doi:10.1063/1.460849}.
\bibitem[NC95]{hamiltonianobservable:natoli1995}
Vincent Natoli and David M. Ceperley. An optimized method for treating long\sphinxhyphen{}range potentials. \sphinxstyleemphasis{Journal of Computational Physics}, 117(1):171\textendash{}178, 1995. URL: \sphinxurl{http://www.sciencedirect.com/science/article/pii/S0021999185710546}, \sphinxhref{https://doi.org/10.1006/jcph.1995.1054}{doi:10.1006/jcph.1995.1054}.
\bibitem[ZBMAlfe19]{hamiltonianobservable:zen2019dla}
Andrea Zen, Jan Gerit Brandenburg, Angelos Michaelides, and Dario Alfè. A new scheme for fixed node diffusion quantum monte carlo with pseudopotentials: improving reproducibility and reducing the trial\sphinxhyphen{}wave\sphinxhyphen{}function bias. \sphinxstyleemphasis{The Journal of Chemical Physics}, 151(13):134105, October 2019. \sphinxhref{https://doi.org/10.1063/1.5119729}{doi:10.1063/1.5119729}.
\bibitem[Cas06]{methods:casula2006}
Michele Casula. Beyond the locality approximation in the standard diffusion Monte Carlo method. \sphinxstyleemphasis{Physical Review B \sphinxhyphen{} Condensed Matter and Materials Physics}, 74:1\textendash{}4, 2006. \sphinxhref{https://arxiv.org/abs/0610246}{arXiv:0610246}, \sphinxhref{https://doi.org/10.1103/PhysRevB.74.161102}{doi:10.1103/PhysRevB.74.161102}.
\bibitem[CMSF10]{methods:casula2010}
Michele Casula, Saverio Moroni, Sandro Sorella, and Claudia Filippi. Size\sphinxhyphen{}consistent variational approaches to nonlocal pseudopotentials: Standard and lattice regularized diffusion Monte Carlo methods revisited. \sphinxstyleemphasis{Journal of Chemical Physics}, 2010. \sphinxhref{https://arxiv.org/abs/1002.0356}{arXiv:1002.0356}, \sphinxhref{https://doi.org/10.1063/1.3380831}{doi:10.1063/1.3380831}.
\bibitem[DRV88]{methods:depasqualereliable1988}
Michael F. DePasquale, Stuart M. Rothstein, and Jan Vrbik. Reliable diffusion quantum monte carlo. \sphinxstyleemphasis{The Journal of Chemical Physics}, 89(6):3629\textendash{}3637, September 1988. \sphinxhref{https://doi.org/10.1063/1.454883}{doi:10.1063/1.454883}.
\bibitem[ON19]{methods:otis2019}
Leon Otis and Eric Neuscamman. Complementary first and second derivative methods for ansatz optimization in variational monte carlo. \sphinxstyleemphasis{Phys. Chem. Chem. Phys.}, 21:14491, 2019.
\bibitem[UNR93]{methods:umrigar1993}
C J Umrigar, M P Nightingale, and K J Runge. A diffusion Monte Carlo algorithm with very small timestep errors A diffusion Monte Carlo algorithm with very small time\sphinxhyphen{}step errors. \sphinxstyleemphasis{The Journal of Chemical Physics}, 99(4):2865, 1993. \sphinxhref{https://doi.org/10.1063/1.465195}{doi:10.1063/1.465195}.
\bibitem[ZBKlimevs+18]{methods:zenfast2018}
Andrea Zen, Jan Gerit Brandenburg, Jiř’ı Klimeš, Alexandre Tkatchenko, Dario Alfè, and Angelos Michaelides. Fast and accurate quantum monte carlo for molecular crystals. \sphinxstyleemphasis{Proceedings of the National Academy of Sciences}, 115(8):1724\textendash{}1729, February 2018. \sphinxhref{https://doi.org/10.1073/pnas.1715434115}{doi:10.1073/pnas.1715434115}.
\bibitem[ZSG+16]{methods:zenboosting2016}
Andrea Zen, Sandro Sorella, Michael J. Gillan, Angelos Michaelides, and Dario Alfè. Boosting the accuracy and speed of quantum monte carlo: size consistency and time step. \sphinxstyleemphasis{Physical Review B}, June 2016. \sphinxhref{https://doi.org/10.1103/physrevb.93.241118}{doi:10.1103/physrevb.93.241118}.
\bibitem[ZN16]{methods:zhao-2016-dir-tar}
Luning Zhao and Eric Neuscamman. An efficient variational principle for the direct optimization of excited states. \sphinxstyleemphasis{J. Chem. Theory. Comput.}, 12:3436, 2016.
\bibitem[ZN17]{methods:zhao-2017-blocked-lm}
Luning Zhao and Eric Neuscamman. A blocked linear method for optimizing large parameter sets in variational monte carlo. \sphinxstyleemphasis{J. Chem. Theory. Comput.}, 2017. \sphinxhref{https://doi.org/10.1021/acs.jctc.7b00119}{doi:10.1021/acs.jctc.7b00119}.
\bibitem[SBB+18]{LCAO:sun2018}
Qiming Sun, Timothy C. Berkelbach, Nick S. Blunt, George H. Booth, Sheng Guo, Zhendong Li, Junzi Liu, James D. McClain, Elvira R. Sayfutyarova, Sandeep Sharma, Sebastian Wouters, and Garnet Kin\sphinxhyphen{}Lic Chan. Pyscf: the python\sphinxhyphen{}based simulations of chemistry framework. \sphinxstyleemphasis{Wiley Interdisciplinary Reviews: Computational Molecular Science}, 8(1):n/a\textendash{}n/a, 2018. \sphinxhref{https://doi.org/10.1002/wcms.1340}{doi:10.1002/wcms.1340}.
\bibitem[DMC67]{sCI:diner1967}
S. Diner, J. P. Malrieu, and P. Claverie. The use of perturbation methods for the study of the effects of configuration interaction. \sphinxstyleemphasis{Theoretica chimica acta}, 8(5):390\textendash{}403, 1967. \sphinxhref{https://doi.org/10.1007/BF00529454}{doi:10.1007/BF00529454}.
\bibitem[EG13]{sCI:caffarel2013}
M. Caffarel E. Giner, A. Scemama. Using perturbatively selected configuration interaction in quantum monte carlo calculations. \sphinxstyleemphasis{Canadian Journal of Chemistry}, 91:9, 2013.
\bibitem[GGMS17]{sCI:garniron2017-1}
Yann Garniron, Emmanuel Giner, Jean\sphinxhyphen{}Paul Malrieu, and Anthony Scemama. Alternative definition of excitation amplitudes in multi\sphinxhyphen{}reference state\sphinxhyphen{}specific coupled cluster. \sphinxstyleemphasis{The Journal of Chemical Physics}, 146(15):154107, 2017. \sphinxhref{https://arxiv.org/abs/https://doi.org/10.1063/1.4980034}{arXiv:https://doi.org/10.1063/1.4980034}, \sphinxhref{https://doi.org/10.1063/1.4980034}{doi:10.1063/1.4980034}.
\bibitem[GSLC17]{sCI:garniron2017-2}
Yann Garniron, Anthony Scemama, Pierre\sphinxhyphen{}François Loos, and Michel Caffarel. Hybrid stochastic\sphinxhyphen{}deterministic calculation of the second\sphinxhyphen{}order perturbative contribution of multireference perturbation theory. \sphinxstyleemphasis{The Journal of Chemical Physics}, 147(3):034101, 2017. \sphinxhref{https://arxiv.org/abs/https://doi.org/10.1063/1.4992127}{arXiv:https://doi.org/10.1063/1.4992127}, \sphinxhref{https://doi.org/10.1063/1.4992127}{doi:10.1063/1.4992127}.
\bibitem[Nes55]{sCI:nesbet1955}
R. K. Nesbet. Configuration interaction in orbital theories. \sphinxstyleemphasis{Proceedings of the Royal Society of London A: Mathematical, Physical and Engineering Sciences}, 230(1182):312\textendash{}321, 1955. URL: \sphinxurl{http://rspa.royalsocietypublishing.org/content/230/1182/312}, \sphinxhref{https://arxiv.org/abs/http://rspa.royalsocietypublishing.org/content/230/1182/312.full.pdf}{arXiv:http://rspa.royalsocietypublishing.org/content/230/1182/312.full.pdf}, \sphinxhref{https://doi.org/10.1098/rspa.1955.0134}{doi:10.1098/rspa.1955.0134}.
\bibitem[SAGC16]{sCI:scemama2016}
Anthony Scemama, Thomas Applencourt, Emmanuel Giner, and Michel Caffarel. Quantum monte carlo with very large multideterminant wavefunctions. \sphinxstyleemphasis{Journal of Computational Chemistry}, 37(20):1866\textendash{}1875, 2016. \sphinxhref{https://doi.org/10.1002/jcc.24382}{doi:10.1002/jcc.24382}.
\bibitem[SGCL0]{sCI:scemama2018}
Anthony Scemama, Yann Garniron, Michel Caffarel, and Pierre\sphinxhyphen{}Francois Loos. Deterministic construction of nodal surfaces within quantum monte carlo: the case of fes. \sphinxstyleemphasis{Journal of Chemical Theory and Computation}, 0(ja):null, 0. \sphinxhref{https://arxiv.org/abs/http://dx.doi.org/10.1021/acs.jctc.7b01250}{arXiv:http://dx.doi.org/10.1021/acs.jctc.7b01250}, \sphinxhref{https://doi.org/10.1021/acs.jctc.7b01250}{doi:10.1021/acs.jctc.7b01250}.
\bibitem[Sce17]{sCI:qp}
A. Scemamma. Quantum package. https://github.com/LCPQ/quantum\_package, 2013\textendash{}2017.
\bibitem[ADVFerre+09]{afqmc:aquilantemolcas2009}
Francesco Aquilante, Luca De Vico, Nicolas Ferré, Giovanni Ghigo, Per\sphinxhyphen{}åke Malmqvist, Pavel Neogrády, Thomas Bondo Pedersen, Michal Pitoňák, Markus Reiher, Björn O. Roos, Luis Serrano\sphinxhyphen{}Andrés, Miroslav Urban, Valera Veryazov, and Roland Lindh. MOLCAS 7: The Next Generation. \sphinxstyleemphasis{J. Comput. Chem.}, 31(1):224, 2009. URL: \sphinxurl{https://onlinelibrary.wiley.com/doi/abs/10.1002/jcc.21318}.
\bibitem[BL77]{afqmc:beebecholesky1977}
Nelson H. F. Beebe and Jan Linderberg. Simplifications in the generation and transformation of two\sphinxhyphen{}electron integrals in molecular calculations. \sphinxstyleemphasis{Int. J. Quantum Chem.}, 12(4):683, 1977. URL: \sphinxurl{https://onlinelibrary.wiley.com/doi/abs/10.1002/qua.560120408}.
\bibitem[HPMartinez12]{afqmc:hohensteinthci2012}
Edward G. Hohenstein, Robert M. Parrish, and Todd J. Martínez. Tensor hypercontraction density fitting. I. Quartic scaling second\sphinxhyphen{} and third\sphinxhyphen{}order Møller\sphinxhyphen{}Plesset perturbation theory. \sphinxstyleemphasis{The Journal of Chemical Physics}, 137(4):044103, 2012. URL: \sphinxurl{https://doi.org/10.1063/1.4732310}, \sphinxhref{https://doi.org/10.1063/1.4732310}{doi:10.1063/1.4732310}.
\bibitem[HPSMartinez12]{afqmc:hohensteinthciii2012}
Edward G. Hohenstein, Robert M. Parrish, C. David Sherrill, and Todd J. Martínez. Communication: Tensor hypercontraction. III. Least\sphinxhyphen{}squares tensor hypercontraction for the determination of correlated wavefunctions. \sphinxstyleemphasis{The Journal of Chemical Physics}, 137(22):221101, 2012. URL: \sphinxurl{https://doi.org/10.1063/1.4768241}, \sphinxhref{https://doi.org/10.1063/1.4768241}{doi:10.1063/1.4768241}.
\bibitem[KdMerasP03]{afqmc:kochcholesky2003}
Henrik Koch, Alfredo Sánchez de Merás, and Thomas Bondo Pedersen. Reduced scaling in electronic structure calculations using Cholesky decompositions. \sphinxstyleemphasis{The Journal of Chemical Physics}, 118(21):9481, 2003. URL: \sphinxurl{https://doi.org/10.1063/1.1578621}.
\bibitem[MZM20]{afqmc:malonegpu2020}
Fionn D Malone, Shuai Zhang, and Miguel A Morales. Accelerating auxiliary\sphinxhyphen{}field quantum monte carlo simulations of solids with graphical processing unit. \sphinxstyleemphasis{arXiv preprint arXiv:2003.09468}, 2020.
\bibitem[MZM19]{afqmc:maloneisdf2019}
Fionn D. Malone, Shuai Zhang, and Miguel A. Morales. Overcoming the Memory Bottleneck in Auxiliary Field Quantum Monte Carlo Simulations with Interpolative Separable Density Fitting. \sphinxstyleemphasis{J. Chem. Theory. Comput.}, 15(1):256, 2019. URL: \sphinxurl{https://doi.org/10.1021/acs.jctc.8b00944}, \sphinxhref{https://doi.org/10.1021/acs.jctc.8b00944}{doi:10.1021/acs.jctc.8b00944}.
\bibitem[MZC19]{afqmc:mottakpoint2019}
Mario Motta, Shiwei Zhang, and Garnet Kin\sphinxhyphen{}Lic Chan. Hamiltonian symmetries in auxiliary\sphinxhyphen{}field quantum Monte Carlo calculations for electronic structure. \sphinxstyleemphasis{Physical Review B}, 100:045127, July 2019. URL: \sphinxurl{https://link.aps.org/doi/10.1103/PhysRevB.100.045127}, \sphinxhref{https://doi.org/10.1103/PhysRevB.100.045127}{doi:10.1103/PhysRevB.100.045127}.
\bibitem[PHMartinezS12]{afqmc:parrishthcii2012}
Robert M. Parrish, Edward G. Hohenstein, Todd J. Martínez, and C. David Sherrill. Tensor hypercontraction. II. Least\sphinxhyphen{}squares renormalization. \sphinxstyleemphasis{The Journal of Chemical Physics}, 137(22):224106, 2012. URL: \sphinxurl{https://doi.org/10.1063/1.4768233}, \sphinxhref{https://doi.org/10.1063/1.4768233}{doi:10.1063/1.4768233}.
\bibitem[PKVZ11]{afqmc:purwantoca2011}
Wirawan Purwanto, Henry Krakauer, Yudistira Virgus, and Shiwei Zhang. Assessing weak hydrogen binding on Ca+ centers: An accurate many\sphinxhyphen{}body study with large basis sets. \sphinxstyleemphasis{The Journal of Chemical Physics}, 135(16):164105, 2011. URL: \sphinxurl{https://doi.org/10.1063/1.3654002}, \sphinxhref{https://doi.org/10.1063/1.3654002}{doi:10.1063/1.3654002}.
\bibitem[PZ04]{afqmc:physreve-70-056702}
Wirawan Purwanto and Shiwei Zhang. Quantum monte carlo method for the ground state of many\sphinxhyphen{}boson systems. \sphinxstyleemphasis{Phys. Rev. E}, 70:056702, November 2004. \sphinxhref{https://doi.org/10.1103/PhysRevE.70.056702}{doi:10.1103/PhysRevE.70.056702}.
\bibitem[PZK13]{afqmc:purwantodownfolding2013}
Wirawan Purwanto, Shiwei Zhang, and Henry Krakauer. Frozen\sphinxhyphen{}Orbital and Downfolding Calculations with Auxiliary\sphinxhyphen{}Field Quantum Monte Carlo. \sphinxstyleemphasis{Journal of Chemical Theory and Computation}, 9(11):4825\textendash{}4833, 2013. URL: \sphinxurl{https://doi.org/10.1021/ct4006486}.
\bibitem[Zha13]{afqmc:afqmc-review}
Shiwei Zhang. Auxiliary\sphinxhyphen{}field quantum monte carlo for correlated electron systems. \sphinxstyleemphasis{Modeling and Simulation}, 3:, 2013. URL: \sphinxurl{http://hdl.handle.net/2128/5389}, \sphinxhref{https://doi.org/}{doi:}.
\bibitem[ZK03]{afqmc:physrevlett-90-136401}
Shiwei Zhang and Henry Krakauer. Quantum monte carlo method using phase\sphinxhyphen{}free random walks with slater determinants. \sphinxstyleemphasis{Phys. Rev. Lett.}, 90:136401, April 2003. \sphinxhref{https://doi.org/10.1103/PhysRevLett.90.136401}{doi:10.1103/PhysRevLett.90.136401}.
\bibitem[Kro16]{lab_qmc_basics:krogel2016nexus}
Jaron T. Krogel. Nexus: a modular workflow management system for quantum simulation codes. \sphinxstyleemphasis{Computer Physics Communications}, 198:154\textendash{}168, 2016. URL: \sphinxurl{http://www.sciencedirect.com/science/article/pii/S0010465515002982}, \sphinxhref{https://doi.org/10.1016/j.cpc.2015.08.012}{doi:10.1016/j.cpc.2015.08.012}.
\bibitem[HPK+17]{lab_excited:hinuma2017}
Yoyo Hinuma, Giovanni Pizzi, Yu Kumagai, Fumiyasu Oba, and Isao Tanaka. Band structure diagram paths based on crystallography. \sphinxstyleemphasis{Computational Materials Science}, 128:140\textendash{}184, 2017. URL: \sphinxurl{http://www.sciencedirect.com/science/article/pii/S0927025616305110}, \sphinxhref{https://doi.org/10.1016/j.commatsci.2016.10.015}{doi:10.1016/j.commatsci.2016.10.015}.
\bibitem[Kok99]{lab_excited:kokalj1999}
Anton Kokalj. XCrySDen—a new program for displaying crystalline structures and electron densities. \sphinxstyleemphasis{Journal of Molecular Graphics and Modelling}, 17(3):176\textendash{}179, 1999. URL: \sphinxurl{http://www.sciencedirect.com/science/article/pii/S1093326399000285}, \sphinxhref{https://doi.org/10.1016/S1093-3263(99)00028-5}{doi:10.1016/S1093\sphinxhyphen{}3263(99)00028\sphinxhyphen{}5}.
\bibitem[ORJ+13]{lab_excited:ong2013}
Shyue Ping Ong, William Davidson Richards, Anubhav Jain, Geoffroy Hautier, Michael Kocher, Shreyas Cholia, Dan Gunter, Vincent L. Chevrier, Kristin A. Persson, and Gerbrand Ceder. Python Materials Genomics (pymatgen): A robust, open\sphinxhyphen{}source python library for materials analysis. \sphinxstyleemphasis{Computational Materials Science}, 68:314\textendash{}319, 2013. URL: \sphinxurl{http://www.sciencedirect.com/science/article/pii/S0927025612006295}, \sphinxhref{https://doi.org/10.1016/j.commatsci.2012.10.028}{doi:10.1016/j.commatsci.2012.10.028}.
\bibitem[ORR02]{lab_excited:onida2002a}
Giovanni Onida, Lucia Reining, and Angel Rubio. Electronic excitations: density\sphinxhyphen{}functional versus many\sphinxhyphen{}body Green’s\sphinxhyphen{}function approaches. \sphinxstyleemphasis{Reviews of Modern Physics}, 74(2):601\textendash{}659, 2002. \sphinxhref{https://doi.org/10.1103/RevModPhys.74.601}{doi:10.1103/RevModPhys.74.601}.
\bibitem[BFD07]{additional_tools:burkatzki07}
M. Burkatzki, C. Filippi, and M. Dolg. Energy\sphinxhyphen{}consistent pseudopotentials for quantum monte carlo calculations. \sphinxstyleemphasis{The Journal of Chemical Physics}, 126(23):\textendash{}, 2007. \sphinxhref{https://doi.org/10.1063/1.2741534}{doi:10.1063/1.2741534}.
\bibitem[BFD08]{additional_tools:burkatzki08}
M. Burkatzki, Claudia Filippi, and M. Dolg. Energy\sphinxhyphen{}consistent small\sphinxhyphen{}core pseudopotentials for 3d\sphinxhyphen{}transition metals adapted to quantum monte carlo calculations. \sphinxstyleemphasis{The Journal of Chemical Physics}, 129(16):\textendash{}, 2008. \sphinxhref{https://doi.org/10.1063/1.2987872}{doi:10.1063/1.2987872}.
\bibitem[FOK+04]{additional_tools:fedorov2004}
Dmitri G. Fedorov, Ryan M. Olson, Kazuo Kitaura, Mark S. Gordon, and Shiro Koseki. A new hierarchical parallelization scheme: generalized distributed data interface (gddi), and an application to the fragment molecular orbital method (fmo). \sphinxstyleemphasis{Journal of Computational Chemistry}, 25(6):872\textendash{}880, 2004. \sphinxhref{https://doi.org/10.1002/jcc.20018}{doi:10.1002/jcc.20018}.
\bibitem[MTDN05]{additional_tools:ma2005}
A. Ma, M. D. Towler, N. D. Drummond, and R. J. Needs. Scheme for adding electron\textendash{}nucleus cusps to gaussian orbitals. \sphinxstyleemphasis{The Journal of Chemical Physics}, 122(22):224322, 2005. \sphinxhref{https://arxiv.org/abs/https://doi.org/10.1063/1.1940588}{arXiv:https://doi.org/10.1063/1.1940588}, \sphinxhref{https://doi.org/10.1063/1.1940588}{doi:10.1063/1.1940588}.
\bibitem[Sce17]{additional_tools:qp}
A. Scemamma. Quantum package. https://github.com/LCPQ/quantum\_package, 2013\textendash{}2017.
\bibitem[SBB+93]{additional_tools:schmidt93}
Michael W. Schmidt, Kim K. Baldridge, Jerry A. Boatz, Steven T. Elbert, Mark S. Gordon, Jan H. Jensen, Shiro Koseki, Nikita Matsunaga, Kiet A. Nguyen, Shujun Su, Theresa L. Windus, Michel Dupuis, and John A. Montgomery. General atomic and molecular electronic structure system. \sphinxstyleemphasis{Journal of Computational Chemistry}, 14(11):1347\textendash{}1363, 1993. \sphinxhref{https://doi.org/10.1002/jcc.540141112}{doi:10.1002/jcc.540141112}.
\bibitem[SBB+18]{additional_tools:sun2018}
Qiming Sun, Timothy C. Berkelbach, Nick S. Blunt, George H. Booth, Sheng Guo, Zhendong Li, Junzi Liu, James D. McClain, Elvira R. Sayfutyarova, Sandeep Sharma, Sebastian Wouters, and Garnet Kin\sphinxhyphen{}Lic Chan. Pyscf: the python\sphinxhyphen{}based simulations of chemistry framework. \sphinxstyleemphasis{Wiley Interdisciplinary Reviews: Computational Molecular Science}, 8(1):n/a\textendash{}n/a, 2018. \sphinxhref{https://doi.org/10.1002/wcms.1340}{doi:10.1002/wcms.1340}.
\bibitem[NC95]{design_features:natoli1995}
Vincent Natoli and David M. Ceperley. An optimized method for treating long\sphinxhyphen{}range potentials. \sphinxstyleemphasis{Journal of Computational Physics}, 117(1):171\textendash{}178, 1995. URL: \sphinxurl{http://www.sciencedirect.com/science/article/pii/S0021999185710546}, \sphinxhref{https://doi.org/10.1006/jcph.1995.1054}{doi:10.1006/jcph.1995.1054}.
\bibitem[KCM93]{developing:kwon1993backflow}
Yongkyung Kwon, D. M. Ceperley, and Richard M. Martin. Effects of three\sphinxhyphen{}body and backflow correlations in the two\sphinxhyphen{}dimensional electron gas. \sphinxstyleemphasis{Phys. Rev. B}, 48:12037\textendash{}12046, October 1993. \sphinxhref{https://doi.org/10.1103/PhysRevB.48.12037}{doi:10.1103/PhysRevB.48.12037}.
\bibitem[TU07]{developing:toulouse2007linear}
Julien Toulouse and C. J. Umrigar. Optimization of quantum monte carlo wave functions by energy minimization. \sphinxstyleemphasis{The Journal of Chemical Physics}, 126(8):084102, 2007. \sphinxhref{https://arxiv.org/abs/http://dx.doi.org/10.1063/1.2437215}{arXiv:http://dx.doi.org/10.1063/1.2437215}, \sphinxhref{https://doi.org/10.1063/1.2437215}{doi:10.1063/1.2437215}.
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
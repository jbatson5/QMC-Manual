%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{QMC Manual}
\date{Jun 08, 2020}
\release{0.0.1}
\author{QMCPACK Developers}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxhref{https://qmcpack.org/}{\sphinxincludegraphics[width=0.800\linewidth]{{QMCPACK_logo}.png}}


\chapter{Introduction}
\label{\detokenize{introduction:introduction}}\label{\detokenize{introduction:id1}}\label{\detokenize{introduction::doc}}
QMCPACK is an open\sphinxhyphen{}source, high\sphinxhyphen{}performance electronic structure code
that implements numerous Quantum Monte Carlo (QMC) algorithms. Its main
applications are electronic structure calculations of molecular,
periodic 2D, and periodic 3D solid\sphinxhyphen{}state systems. Variational Monte
Carlo (VMC), diffusion Monte Carlo (DMC), and a number of other advanced
QMC algorithms are implemented. By directly solving the Schrodinger
equation, QMC methods offer greater accuracy than methods such as
density functional theory but at a trade\sphinxhyphen{}off of much greater
computational expense. Distinct from many other correlated many\sphinxhyphen{}body
methods, QMC methods are readily applicable to both bulk (periodic) and
isolated molecular systems.

QMCPACK is written in C++ and is designed with the modularity afforded
by object\sphinxhyphen{}oriented programming. It makes extensive use of template
metaprogramming to achieve high computational efficiency. Because of the
modular architecture, the addition of new wavefunctions, algorithms, and
observables is relatively straightforward. For parallelization, QMCPACK
uses a fully hybrid (OpenMP,CUDA)/MPI approach to optimize memory usage
and to take advantage of the growing number of cores per SMP node or
graphical processing units (GPUs) and accelerators. High parallel and
computational efficiencies are achievable on the largest supercomputers.
Finally, QMCPACK uses standard file formats for input and output in XML
and HDF5 to facilitate data exchange.

This manual currently serves as an introduction to the essential
features of QMCPACK and as a guide to installing and running it. Over
time this manual will be expanded to include a fuller introduction to
QMC methods in general and to include more of the specialized features
in QMCPACK.


\section{Quickstart and a first QMCPACK calculation}
\label{\detokenize{introduction:quickstart-and-a-first-qmcpack-calculation}}
In case you are keen to get started, this section describes how to
quickly build and run QMCPACK on a standard UNIX or Linux\sphinxhyphen{}like system.
The autoconfiguring build system usually works without much fuss on
these systems. If C++, MPI, BLAS/LAPACK, FFTW, HDF5, and CMake are
already installed, QMCPACK can be built and run within five minutes. For
supercomputers, cross\sphinxhyphen{}compilation systems, and other computer clusters,
the build system might require hints on the locations of libraries and
which versions to use, typical of any code; see
{\hyperref[\detokenize{installation:obtaininginstalling}]{\sphinxcrossref{\DUrole{std,std-ref}{Obtaining, installing, and validating QMCPACK}}}}.
{\hyperref[\detokenize{installation:installexamples}]{\sphinxcrossref{\DUrole{std,std-ref}{Installation instructions for common workstations and supercomputers}}}} includes
complete examples of installations for common workstations and
supercomputers that you can reuse.

To build QMCPACK:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Download the latest QMCPACK distribution from \sphinxurl{http://www.qmcpack.org}.

\item {} 
Untar the archive (e.g., \sphinxcode{\sphinxupquote{tar xvf qmcpack\_v1.3.tar.gz}}).

\item {} 
Check the instructions in the README file.

\item {} 
Run CMake in a suitable build directory to configure QMCPACK for your
system: \sphinxcode{\sphinxupquote{cd qmcpack/build; cmake ..}}

\item {} 
If CMake is unable to find all needed libraries, see
{\hyperref[\detokenize{installation:obtaininginstalling}]{\sphinxcrossref{\DUrole{std,std-ref}{Obtaining, installing, and validating QMCPACK}}}} for
instructions and specific build instructions for common systems.

\item {} 
Build QMCPACK: \sphinxcode{\sphinxupquote{make}} or \sphinxcode{\sphinxupquote{make \sphinxhyphen{}j 16}}; use the latter for a faster parallel build on a
system using, for example, 16 processes.

\item {} 
The QMCPACK executable is \sphinxcode{\sphinxupquote{bin/qmcpack}}.

\end{enumerate}

QMCPACK is distributed with examples illustrating different
capabilities. Most of the examples are designed to run quickly with
modest resources. We’ll run a short diffusion Monte Carlo calculation of
a water molecule:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Go to the appropriate example directory: \sphinxcode{\sphinxupquote{cd ../examples/molecules/H2O.}}

\item {} 
\begin{DUlineblock}{0em}
\item[] (Optional) Put the QMCPACK binary on your path: \sphinxcode{\sphinxupquote{export PATH=\textbackslash{}\$PATH:location\sphinxhyphen{}of\sphinxhyphen{}qmcpack/build/bin}}
\end{DUlineblock}

\item {} 
Run QMCPACK: \sphinxcode{\sphinxupquote{../../../build/bin/qmcpack simple\sphinxhyphen{}H2O.xml}} or \sphinxcode{\sphinxupquote{qmcpack simple\sphinxhyphen{}H2O.xml}} if you followed the step above.

\item {} 
The run will output to the screen and generate a number of files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}ls H2O*
H2O.HF.wfs.xml      H2O.s001.scalar.dat H2O.s002.cont.xml
H2O.s002.qmc.xml    H2O.s002.stat.h5    H2O.s001.qmc.xml
H2O.s001.stat.h5    H2O.s002.dmc.dat    H2O.s002.scalar.dat
\end{sphinxVerbatim}

\item {} 
Partially summarized results are in the standard text files with the
suffixes scalar.dat and dmc.dat. They are viewable with any standard
editor.

\end{enumerate}

If you have Python and matplotlib installed, you can use the analysis
utility to produce statistics and plots of the data. See
\DUrole{xref,std,std-ref}{analyzing} for information on
analyzing QMCPACK data.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
export PATH=\PYGZdl{}PATH:location\PYGZhy{}of\PYGZhy{}qmcpack/nexus/bin
export PYTHONPATH=\PYGZdl{}PYTHONPATH:location\PYGZhy{}of\PYGZhy{}qmcpack/nexus/library
qmca H2O.s002.scalar.dat         \PYGZsh{} For statistical analysis of the DMC data
qmca \PYGZhy{}t \PYGZhy{}q e H2O.s002.scalar.dat \PYGZsh{} Graphical plot of DMC energy
\end{sphinxVerbatim}

The last command will produce a graph as per
\hyperref[\detokenize{introduction:fig1}]{Fig.\@ \ref{\detokenize{introduction:fig1}}}. This
shows the average energy of the DMC walkers at each timestep. In a real
simulation we would have to check equilibration, convergence with walker
population, time step, etc.

Congratulations, you have completed a DMC calculation with QMCPACK!

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{quick_qmca_dmc_trace}.png}
\caption{Trace of walker energies produced by the qmca tool for a simple water
molecule example.}\label{\detokenize{introduction:id3}}\label{\detokenize{introduction:fig1}}\end{figure}


\section{Authors and History}
\label{\detokenize{introduction:authors-and-history}}\label{\detokenize{introduction:history}}
QMCPACK was initially written by Jeongnim Kim while in the group of
Professor David Ceperley at the University of Illinois at
Urbana\sphinxhyphen{}Champaign, with later contributations being made at Oak Ridge
National Laboratory (ORNL). Over the years, many others have
contributed, particularly students and researchers in the groups of
Professor David Ceperley and Professor Richard M. Martin, as well as
staff at Lawrence Livermore National Laboratory, Sandia National
Laboratories, Argonne National Laboratory, and ORNL.

Additional developers, contributors, and advisors include Anouar Benali,
Mark A. Berrill, David M. Ceperley, Simone Chiesa, Raymond C. III Clay,
Bryan Clark, Kris T. Delaney, Kenneth P. Esler, Paul R. C. Kent, Jaron
T. Krogel, Ying Wai Li, Ye Luo, Jeremy McMinis, Miguel A. Morales,
William D. Parker, Nichols A. Romero, Luke Shulenburger, Norman M.
Tubman, and Jordan E. Vincent.

If you should be added to this list, please let us know.

Development of QMCPACK has been supported financially by several grants,
including the following:
\begin{itemize}
\item {} 
“Network for ab initio many\sphinxhyphen{}body methods: development, education and
training” supported through the Predictive Theory and Modeling for
Materials and Chemical Science program by the U.S. Department of
Energy Office of Science, Basic Energy Sciences

\item {} 
“QMC Endstation,” supported by Accelerating Delivery of Petascale
Computing Environment at the DOE Leadership Computing Facility at
ORNL

\item {} 
PetaApps, supported by the US National Science Foundation

\item {} 
Materials Computation Center (MCC), supported by the US National
Science Foundation

\end{itemize}


\section{Support and Contacting the Developers}
\label{\detokenize{introduction:support-and-contacting-the-developers}}\label{\detokenize{introduction:support}}
Questions about installing, applying, or extending QMCPACK can be posted
on the QMCPACK Google group at
\sphinxurl{https://groups.google.com/forum/\#!forum/qmcpack}. You may also email any
of the developers, but we recommend checking the group first. Particular
attention is given to any problem reports.


\section{Performance}
\label{\detokenize{introduction:performance}}\label{\detokenize{introduction:id2}}
QMCPACK implements modern Monte Carlo (MC) algorithms, is highly
parallel, and is written using very efficient code for high per\sphinxhyphen{}CPU or
on\sphinxhyphen{}node performance. In particular, the code is highly vectorizable,
giving high performance on modern central processing units (CPUs) and
GPUs. We believe QMCPACK delivers performance either comparable to or
better than other QMC codes when similar calculations are run,
particularly for the most common QMC methods and for large systems. If
you find a calculation where this is not the case, or you simply find
performance slower than expected, please post on the Google group or
contact one of the developers. These reports are valuable. If your
calculation is sufficiently mainstream we will optimize QMCPACK to
improve the performance.


\section{Open Source License}
\label{\detokenize{introduction:open-source-license}}\label{\detokenize{introduction:license}}
QMCPACK is distributed under the University of Illinois at
Urbana\sphinxhyphen{}Champaign/National Center for Supercomputing Applications
(UIUC/NCSA) Open Source License.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
          University of Illinois/NCSA Open Source License

Copyright (c) 2003, University of Illinois Board of Trustees.
All rights reserved.

Developed by:
  Jeongnim Kim
  Condensed Matter Physics,
  National Center for Supercomputing Applications, University of Illinois
  Materials computation Center, University of Illinois
  http://www.mcc.uiuc.edu/qmc/

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software\PYGZsq{}\PYGZsq{}), to deal with the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimers.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimers in
          the documentation and/or other materials provided with the
          distribution.
        * Neither the names of the NCSA, the MCC, the University of Illinois,
          nor the names of its contributors may be used to endorse or promote
          products derived from this Software without specific prior written
          permission.

THE SOFTWARE IS PROVIDED \PYGZdq{}AS IS\PYGZdq{}, WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS WITH THE SOFTWARE.
\end{sphinxVerbatim}

Copyright is generally believed to remain with the authors of the
individual sections of code. See the various notations in the source
code as well as the code history.


\section{Contributing to QMCPACK}
\label{\detokenize{introduction:contributing-to-qmcpack}}\label{\detokenize{introduction:contributing}}
QMCPACK is fully open source, and we welcome contributions. If you are
planning a development, early discussions are encouraged. Please post on
the QMCPACK Google group or contact the developers. We can tell you
whether anyone else is working on a similar feature or whether any
related work has been done in the past. Credit for your contribution can
be obtained, for example, through citation of a paper or by becoming one
of the authors on the next version of the standard QMCPACK reference
citation.

A guide to developing for QMCPACK, including instructions on how to work
with GitHub and make pull requests (contributions) to the main source
are listed on the QMCPACK GitHub wiki:
\sphinxurl{https://github.com/QMCPACK/qmcpack/wiki}.

Contributions are made under the same license as QMCPACK, the UIUC/NCSA
open source license. If this is problematic, please discuss with a
developer.

Please note the following guidelines for contributions:
\begin{itemize}
\item {} 
Additions should be fully synchronized with the latest release
version and ideally the latest develop branch on github. Merging of
code developed on older versions is error prone.

\item {} 
Code should be cleanly formatted, commented, portable, and accessible
to other programmers. That is, if you need to use any clever tricks,
add a comment to note this, why the trick is needed, how it works,
etc. Although we like high performance, ease of maintenance and
accessibility are also considerations.

\item {} 
Comment your code. You are not only writing it for the compiler for
also for other humans! (We know this is a repeat of the previous
point, but it is important enough to repeat.)

\item {} 
Write a brief description of the method, algorithms, and inputs and
outputs suitable for inclusion in this manual.

\item {} 
Develop some short tests that exercise the functionality that can be
used for validation and for examples. We can help with this and their
integration into the test system.

\end{itemize}


\section{QMCPACK Roadmap}
\label{\detokenize{introduction:qmcpack-roadmap}}\label{\detokenize{introduction:roadmap}}
A general outline of the QMCPACK roadmap is given in the following sections. Suggestions for improvements are welcome, particularly those
that would facilitate new scientific applications. For example, if an
interface to a particular quantum chemical or density functional code
would help, this would be given strong consideration.


\subsection{Code}
\label{\detokenize{introduction:code}}
We will continue to improve the accessibility and usability of QMCPACK
through combinations of more convenient input parameters, improved
workflow, integration with more quantum chemical and density functional
codes, and a wider range of examples.

In terms of methodological development, we expect to significantly
increase the range of QMC algorithms in QMCPACK in the near future.

Computationally, we are porting QMCPACK to the next generation of
supercomputer systems. The internal changes required to run efficiently
on these systems are expected to benefit \sphinxstyleemphasis{all} platforms due to improved
vectorization, cache utilization, and memory performance.


\subsection{Documentation}
\label{\detokenize{introduction:documentation}}
This manual describes the core features of QMCPACK that are required for
routine research calculations, i.e., the VMC and DMC methods, how to
obtain and optimize trial wavefunctions, and simple observables. Over
time this manual will be expanded to include a broader introduction to
QMC methods and to describe more features of the code.

Because of its history as a research code, QMCPACK contains a variety of
additional QMC methods, trial wavefunction forms, potentials, etc.,
that, although not critical, might be very useful for specialized
calculations or particular material or chemical systems. These “secret
features” (every code has these) are not actually secret but simply lack
descriptions, example inputs, and tests. You are encouraged to browse
and read the source code to find them. New descriptions will be added
over time but can also be prioritized and added on request (e.g., if a
specialized Jastrow factor would help or a historical Jastrow form is
needed for benchmarking).


\chapter{Features of QMCPACK}
\label{\detokenize{features:features-of-qmcpack}}\label{\detokenize{features:chap-features}}\label{\detokenize{features::doc}}

\section{Production\sphinxhyphen{}level features}
\label{\detokenize{features:production-level-features}}
The following list contains the main production\sphinxhyphen{}level features of
QMCPACK. If you do not see a specific feature that you are interested
in, see the remainder of this manual and ask whether that specific
feature is available or can be quickly brought to the full production
level.
\begin{itemize}
\item {} 
Variational Monte Carlo (VMC)

\item {} 
Diffusion Monte Carlo (DMC)

\item {} 
Reptation Monte Carlo

\item {} 
Single and multideterminant Slater Jastrow wavefunctions

\item {} 
Wavefunction updates using optimized multideterminant algorithm of
Clark et al.

\item {} 
Backflow wavefunctions

\item {} 
One, two, and three\sphinxhyphen{}body Jastrow factors

\item {} 
Excited state calculations via flexible occupancy assignment of
Slater determinants

\item {} 
All electron and nonlocal pseudopotential calculations

\item {} 
Casula T\sphinxhyphen{}moves for variational evaluation of nonlocal
pseudopotentials (non\sphinxhyphen{}size\sphinxhyphen{}consistent and size\sphinxhyphen{}consistent variants)

\item {} 
Wavefunction optimization using the “linear method” of Umrigar and
coworkers, with arbitrary mix of variance and energy in the objective
function

\item {} 
Blocked, low memory adaptive shift optimizer of Zhao and Neuscamman

\item {} 
Gaussian, Slater, plane\sphinxhyphen{}wave, and real\sphinxhyphen{}space spline basis sets for
orbitals

\item {} 
Interface and conversion utilities for plane\sphinxhyphen{}wave wavefunctions from
Quantum Espresso (Plane\sphinxhyphen{}Wave Self\sphinxhyphen{}Consistent Field package {[}PWSCF{]})

\item {} 
Interface and conversion utilities for Gaussian\sphinxhyphen{}basis wavefunctions
from GAMESS

\item {} 
Easy extension and interfacing to other electronic structure codes
via standardized XML and HDF5 inputs

\item {} 
MPI parallelism

\item {} 
Fully threaded using OpenMP

\item {} 
GPU (NVIDIA CUDA) implementation (limited functionality)

\item {} 
HDF5 input/output for large data

\item {} 
Nexus: advanced workflow tool to automate all aspects of QMC
calculation from initial DFT calculations through to final analysis

\item {} 
Analysis tools for minimal environments (Perl only) through to
Python\sphinxhyphen{}based environments with graphs produced via matplotlib
(included with Nexus)

\end{itemize}


\section{SoA optimizations and improved algorithms}
\label{\detokenize{features:soa-optimizations-and-improved-algorithms}}
The Structure\sphinxhyphen{}of\sphinxhyphen{}Arrays (SoA) optimizations
\sphinxcite{features:ipcc-sc17} are a set of improved data layouts
facilitating vectorization on modern CPUs with wide SIMD units. \sphinxstylestrong{For
many calculations and architectures, the SoA implementation more than
doubles the speed of the code.} This so\sphinxhyphen{}called SoA implementation
replaces the older, less efficient Array\sphinxhyphen{}of\sphinxhyphen{}Structures (AoS) code and
can be enabled or disabled at compile time. The memory footprint is also
reduced in the SoA implementation by better algorithms, enabling more
systems to be run.

The SoA build was made the default for QMCPACK v3.7.0. As described in {\hyperref[\detokenize{installation:cmakeoptions}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration Options}}}}, the SoA
implementation can be disabled by configuring with \sphinxcode{\sphinxupquote{\sphinxhyphen{}DENABLE\_SOA=0}}.

The SoA code path currently does \sphinxstyleemphasis{not} support:
\begin{itemize}
\item {} 
Backflow wavefunctions

\item {} 
Many observables

\end{itemize}

The code should abort with a message referring to AoS vs SoA features if
any unsupported feature is invoked. In this case the AoS build should be
used by configuring with \sphinxcode{\sphinxupquote{\sphinxhyphen{}DENABLE\_SOA=0}}. In addition, please inform the developers via
GitHub or Google Groups so that porting these features can be
prioritized.

Core features are heavily tested in both SoA and AoS versions. If using
untested and noncore features in the SoA code, please compare the AoS
and SoA results carefully.


\section{Supported GPU features}
\label{\detokenize{features:supported-gpu-features}}
The GPU implementation supports multiple GPUs per node, with MPI tasks
assigned in a round\sphinxhyphen{}robin order to the GPUs. Currently, for large runs,
1 MPI task should be used per GPU per node. For smaller calculations,
use of multiple MPI tasks per GPU might yield improved performance.
Supported GPU features:
\begin{itemize}
\item {} 
VMC, wavefunction optimization, DMC.

\item {} 
Periodic and open boundary conditions. Mixed boundary conditions are
not yet supported.

\item {} 
Wavefunctions:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Single Slater determinants with 3D B\sphinxhyphen{}spline orbitals.
Twist\sphinxhyphen{}averaged boundary conditions and complex wavefunctions are
fully supported. Gaussian type orbitals are not yet supported.

\item {} 
Hybrid mixed basis representation in which orbitals are
represented as 1D splines times spherical harmonics in spherical
regions (muffin tins) around atoms and 3D B\sphinxhyphen{}splines in the
interstitial region.

\item {} 
One\sphinxhyphen{}body and two\sphinxhyphen{}body Jastrows represented as 1D B\sphinxhyphen{}splines.
Three\sphinxhyphen{}body Jastrow functions are not yet supported.

\end{enumerate}

\item {} 
Semilocal (nonlocal and local) pseudopotentials, Coulomb interaction
(electron\sphinxhyphen{}electron, electron\sphinxhyphen{}ion), and model periodic Coulomb (MPC)
interaction.

\end{itemize}


\section{Beta test features}
\label{\detokenize{features:beta-test-features}}
This section describes developmental features in QMCPACK that might be
ready for production but that require additional testing, features, or
documentation to be ready for general use. We describe them here because
they offer significant benefits and are well tested in specific cases.


\subsection{Auxiliary\sphinxhyphen{}Field Quantum Monte Carlo}
\label{\detokenize{features:auxiliary-field-quantum-monte-carlo}}
The orbital\sphinxhyphen{}space Auxiliary\sphinxhyphen{}Field Quantum Monte Carlo (AFMQC) method is
now available in QMCPACK. The main input for the code is the matrix
elements of the Hamiltonian in a given single particle basis set, which
must be produced from mean\sphinxhyphen{}field calculations such as Hartree\sphinxhyphen{}Fock or
density functional theory. The code and many features are in
development. Check the latest version of QMCPACK for an up\sphinxhyphen{}to\sphinxhyphen{}date
description of available features. A partial list of the current
capabilities of the code follows. For a detailed description of the
available features, see  \DUrole{xref,std,std-ref}{afqmc}.
\begin{itemize}
\item {} 
Phaseless AFQMC algorithm of Zhang et al. (S. Zhang and H. Krakauer.
2003. “Quantum Monte Carlo Method using Phase\sphinxhyphen{}Free Random Walks with
Slater Determinants.” \sphinxstyleemphasis{PRL} 90: 136401).

\item {} 
“Hybrid” and “local energy” propagation schemes.

\item {} 
Hamiltonian matrix elements from (1) Molpro’s FCIDUMP format (which
can be produced by Molpro, PySCF, and VASP) and (2) internal HDF5
format produced by PySCF (see AFQMC section below).

\item {} 
AFQMC calculations with RHF (closed\sphinxhyphen{}shell doubly occupied), ROHF
(open\sphinxhyphen{}shell doubly occupied), and UHF (spin polarized broken
symmetry) symmetry.

\item {} 
Single and multideterminant trial wavefunctions. Multideterminant
expansions with either orthogonal or nonorthogonal determinants.

\item {} 
Fast update scheme for orthogonal multideterminant expansions.

\item {} 
Distributed propagation algorithms for large systems. Enables
calculations where data structures do not fit on a single node.

\item {} 
Complex implementation for PBC calculations with complex integrals.

\item {} 
Sparse representation of large matrices for reduced memory usage.

\item {} 
Mixed and back\sphinxhyphen{}propagated estimators.

\item {} 
Specialized implementation for solids with k\sphinxhyphen{}point symmetry (e.g.
primitive unit cells with kpoints).

\item {} 
Efficient GPU implementation (currently limited to solids with
k\sphinxhyphen{}point symmetry).

\end{itemize}


\subsection{Sharing of spline data across multiple GPUs}
\label{\detokenize{features:sharing-of-spline-data-across-multiple-gpus}}
Sharing of GPU spline data enables distribution of the data across
multiple GPUs on a given computational node. For example, on a
two\sphinxhyphen{}GPU\sphinxhyphen{}per\sphinxhyphen{}node system, each GPU would have half of the orbitals. This
allows use of larger overall spline tables than would fit in the memory
of individual GPUs and potentially up to the total GPU memory on a node.
To obtain high performance, large electron counts or a high\sphinxhyphen{}performing
CPU\sphinxhyphen{}GPU interconnect is required.

To use this feature, the following needs to be done:
\begin{itemize}
\item {} 
The CUDA Multi\sphinxhyphen{}Process Service (MPS) needs to be used (e.g., on OLCF
Summit/SummitDev use “\sphinxhyphen{}alloc\_flags gpumps” for bsub). If MPI is not
detected, sharing will be disabled.

\item {} 
CUDA\_VISIBLE\_DEVICES needs to be properly set to control each rank’s
visible CUDA devices (e.g., on OLCF Summit/SummitDev create a
resource set containing all GPUs with the respective number of ranks
with “jsrun \textendash{}task\sphinxhyphen{}per\sphinxhyphen{}rs Ngpus \sphinxhyphen{}g Ngpus”).

\item {} 
In the determinant set definition of the \textless{}wavefunction\textgreater{} section, the
“gpusharing” parameter needs to be set (i.e., \textless{}determinantset
gpusharing=“yes”\textgreater{}). See
{\hyperref[\detokenize{intro_wavefunction:spo-spline}]{\sphinxcrossref{\DUrole{std,std-ref}{Spline basis sets}}}}.

\end{itemize}




\chapter{Obtaining, installing, and validating QMCPACK}
\label{\detokenize{installation:obtaining-installing-and-validating-qmcpack}}\label{\detokenize{installation:obtaininginstalling}}\label{\detokenize{installation::doc}}
This chapter describes how to obtain, build, and validate QMCPACK. This
process is designed to be as simple as possible and should be no harder
than building a modern plane\sphinxhyphen{}wave density functional theory code such as
Quantum ESPRESSO, QBox, or VASP. Parallel builds enable a complete
compilation in under 2 minutes on a fast multicore system. If you are
unfamiliar with building codes we suggest working with your system
administrator to install QMCPACK.


\section{Installation steps}
\label{\detokenize{installation:installation-steps}}
To install QMCPACK, follow the steps below. Full details of each step
are given in the referenced sections.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Download the source code from {\hyperref[\detokenize{installation:obrelease}]{\sphinxcrossref{\DUrole{std,std-ref}{Obtaining the latest release version}}}}
or {\hyperref[\detokenize{installation:obdevelopment}]{\sphinxcrossref{\DUrole{std,std-ref}{Obtaining the latest development version}}}}.

\item {} 
Verify that you have the required compilers, libraries, and tools
installed ({\hyperref[\detokenize{installation:prerequisites}]{\sphinxcrossref{\DUrole{std,std-ref}{Prerequisites}}}}).

\item {} 
If you will use Quantum ESPRESSO, download and patch it. The patch
adds the pw2qmcpack utility
({\hyperref[\detokenize{installation:buildqe}]{\sphinxcrossref{\DUrole{std,std-ref}{Installing and patching Quantum ESPRESSO}}}}).

\item {} 
Run the cmake configure step and build with make
({\hyperref[\detokenize{installation:cmake}]{\sphinxcrossref{\DUrole{std,std-ref}{Building with CMake}}}} and {\hyperref[\detokenize{installation:cmakequick}]{\sphinxcrossref{\DUrole{std,std-ref}{Quick build instructions (try first)}}}}). Examples for
common systems are given in
{\hyperref[\detokenize{installation:installexamples}]{\sphinxcrossref{\DUrole{std,std-ref}{Installation instructions for common workstations and supercomputers}}}}.

\item {} 
Run the tests to verify QMCPACK
({\hyperref[\detokenize{installation:testing}]{\sphinxcrossref{\DUrole{std,std-ref}{Testing and validation of QMCPACK}}}}).

\item {} 
Build the ppconvert utility in QMCPACK
({\hyperref[\detokenize{installation:buildppconvert}]{\sphinxcrossref{\DUrole{std,std-ref}{Building ppconvert, a pseudopotential format converter}}}}).

\end{enumerate}

Hints for high performance are in
{\hyperref[\detokenize{installation:buildperformance}]{\sphinxcrossref{\DUrole{std,std-ref}{How to build the fastest executable version of QMCPACK}}}}.
Troubleshooting suggestions are in
{\hyperref[\detokenize{installation:troubleshoot}]{\sphinxcrossref{\DUrole{std,std-ref}{Troubleshooting the installation}}}}.

Note that there are two different QMCPACK executables that can be
produced: the general one, which is the default, and the “complex”
version, which supports periodic calculations at arbitrary twist angles
and k\sphinxhyphen{}points. This second version is enabled via a cmake configuration
parameter (see {\hyperref[\detokenize{installation:cmakeoptions}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration Options}}}}).
The general version supports only wavefunctions that can be made real.
If you run a calculation that needs the complex version, QMCPACK will
stop and inform you.


\section{Obtaining the latest release version}
\label{\detokenize{installation:obtaining-the-latest-release-version}}\label{\detokenize{installation:obrelease}}
Major releases of QMCPACK are distributed from \sphinxurl{http://www.qmcpack.org}.
Because these versions undergo the most testing, we encourage using them
for all production calculations unless there are specific reasons not to
do so.

Releases are usually compressed tar files that indicate the version
number, date, and often the source code revision control number
corresponding to the release. To obtain the latest release:
\begin{itemize}
\item {} 
Download the latest QMCPACK distribution from \sphinxurl{http://www.qmcpack.org}.

\item {} 
Untar the archive (e.g., \sphinxcode{\sphinxupquote{tar xvf qmcpack\_v1.3.tar.gz}}).

\end{itemize}

Releases can also be obtained from the ‘master’ branch of the QMCPACK
git repository, similar to obtaining the development version
({\hyperref[\detokenize{installation:obdevelopment}]{\sphinxcrossref{\DUrole{std,std-ref}{Obtaining the latest development version}}}}).


\section{Obtaining the latest development version}
\label{\detokenize{installation:obtaining-the-latest-development-version}}\label{\detokenize{installation:obdevelopment}}
The most recent development version of QMCPACK can be obtained
anonymously via

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{git} \PYG{n}{clone} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git}
\end{sphinxVerbatim}

Once checked out, updates can be made via the standard \sphinxcode{\sphinxupquote{git pull}}.

The ‘develop’ branch of the git repository contains the day\sphinxhyphen{}to\sphinxhyphen{}day
development source with the latest updates, bug fixes, etc. This version
might be useful for updates to the build system to support new machines,
for support of the latest versions of Quantum ESPRESSO, or for updates
to the documentation. Note that the development version might not be
fully consistent with the online documentation. We attempt to keep the
development version fully working. However, please be sure to run tests
and compare with previous release versions before using for any serious
calculations. We try to keep bugs out, but occasionally they crawl in!
Reports of any breakages are appreciated.


\section{Prerequisites}
\label{\detokenize{installation:prerequisites}}\label{\detokenize{installation:id1}}
The following items are required to build QMCPACK. For workstations,
these are available via the standard package manager. On shared
supercomputers this software is usually installed by default and is
often accessed via a modules environment—check your system
documentation.

\sphinxstylestrong{Use of the latest versions of all compilers and libraries is strongly
encouraged} but not absolutely essential. Generally, newer versions are
faster; see {\hyperref[\detokenize{installation:buildperformance}]{\sphinxcrossref{\DUrole{std,std-ref}{How to build the fastest executable version of QMCPACK}}}}
for performance suggestions.
\begin{itemize}
\item {} 
C/C++ compilers such as GNU, Clang, Intel, and IBM XL. C++ compilers
are required to support the C++ 14 standard. Use of recent (“current
year version”) compilers is strongly encouraged.

\item {} 
An MPI library such as OpenMPI (\sphinxurl{http://open-mpi.org}) or a
vendor\sphinxhyphen{}optimized MPI.

\item {} 
BLAS/LAPACK, numerical, and linear algebra libraries. Use
platform\sphinxhyphen{}optimized libraries where available, such as Intel MKL.
ATLAS or other optimized open source libraries can also be used
(\sphinxurl{http://math-atlas.sourceforge.net}).

\item {} 
CMake, build utility (\sphinxurl{http://www.cmake.org}).

\item {} 
Libxml2, XML parser (\sphinxurl{http://xmlsoft.org}).

\item {} 
HDF5, portable I/O library (\sphinxurl{http://www.hdfgroup.org/HDF5/}). Good
performance at large scale requires parallel version \(>=\) 1.10.

\item {} 
BOOST, peer\sphinxhyphen{}reviewed portable C++ source libraries
(\sphinxurl{http://www.boost.org}). Minimum version is 1.61.0.

\item {} 
FFTW, FFT library (\sphinxurl{http://www.fftw.org/}).

\end{itemize}

To build the GPU accelerated version of QMCPACK, an installation of
NVIDIA CUDA development tools is required. Ensure that this is
compatible with the C and C++ compiler versions you plan to use.
Supported versions are included in the NVIDIA release notes.

Many of the utilities provided with QMCPACK use Python (v2). The numpy
and matplotlib libraries are required for full functionality.

Note that the standalone einspline library used by previous versions of
QMCPACK is no longer required. A more optimized version is included
inside. The standalone version should \sphinxstyleemphasis{not} be on any standard search
paths because conflicts between the old and new include files can
result.


\section{C++ 14 standard library}
\label{\detokenize{installation:c-14-standard-library}}
The C++ standard consists of language features—which are implemented in
the compiler—and library features—which are implemented in the standard
library. GCC includes its own standard library and headers, but many
compilers do not and instead reuse those from an existing GCC install.
Depending on setup and installation, some of these compilers might not
default to using a GCC with C++ 14 headers (e.g., GCC 4.8 is common as a
base system compiler, but its standard library only supports C++ 11).

The symptom of having header files that do not support the C++ 14
standard is usually compile errors involving standard include header
files. Look for the GCC library version, which should be present in the
path to the include file in the error message, and ensure that it is 5.0
or greater. To avoid these errors occurring at compile time, QMCPACK
tests for a C++ 14 standard library during configuration and will halt
with an error if one is not found.

At sites that use modules, running is often sufficient to load a newer
GCC and resolve the issue.


\subsection{Intel compiler}
\label{\detokenize{installation:intel-compiler}}
The Intel compiler version must be 18 or newer. The version 17 compiler
cannot compile some of the C++ 14 constructs in the code.

If a newer GCC is needed, the \sphinxcode{\sphinxupquote{\sphinxhyphen{}cxxlib}} option can be used to point to a different
GCC installation. (Alternately, the \sphinxcode{\sphinxupquote{\sphinxhyphen{}gcc\sphinxhyphen{}name}} or \sphinxcode{\sphinxupquote{\sphinxhyphen{}gxx\sphinxhyphen{}name}} options can be used.) Be sure to
pass this flag to the C compiler in addition to the C++ compiler. This
is necessary because CMake extracts some library paths from the C
compiler, and those paths usually also contain to the C++ library. The
symptom of this problem is C++ 14 standard library functions not found
at link time.


\section{Building with CMake}
\label{\detokenize{installation:building-with-cmake}}\label{\detokenize{installation:cmake}}
The build system for QMCPACK is based on CMake. It will autoconfigure
based on the detected compilers and libraries. The most recent version
of CMake has the best detection for the greatest variety of systems. The
minimum required version of CMake is 3.6, which is the oldest version to
support correct application of C++ 14 flags for the Intel compiler. Most
computer installations have a sufficiently recent CMake, though it might
not be the default.

If no appropriate version CMake is available, building it from source is
straightforward. Download a version from \sphinxurl{https://cmake.org/download/} and
unpack the files. Run \sphinxcode{\sphinxupquote{./bootstrap}} from the CMake directory, and then run \sphinxcode{\sphinxupquote{make}} when that
finishes. The resulting CMake executable will be in the directory. The
executable can be run directly from that location.

Previously, QMCPACK made extensive use of toolchains, but the build
system has since been updated to eliminate the use of toolchain files
for most cases. The build system is verified to work with GNU, Intel,
and IBM XLC compilers. Specific compile options can be specified either
through specific environment or CMake variables. When the libraries are
installed in standard locations (e.g., /usr, /usr/local), there is no
need to set environment or CMake variables for the packages.


\subsection{Quick build instructions (try first)}
\label{\detokenize{installation:quick-build-instructions-try-first}}\label{\detokenize{installation:cmakequick}}
If you are feeling lucky and are on a standard UNIX\sphinxhyphen{}like system such as
a Linux workstation, the following might quickly give a working QMCPACK:

The safest quick build option is to specify the C and C++ compilers
through their MPI wrappers. Here we use Intel MPI and Intel compilers.
Move to the build directory, run CMake, and make

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{build}
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}C\PYGZus{}COMPILER}\PYG{o}{=}\PYG{n}{mpiicc} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}CXX\PYGZus{}COMPILER}\PYG{o}{=}\PYG{n}{mpiicpc} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{l+m+mi}{8}
\end{sphinxVerbatim}

You can increase the “8” to the number of cores on your system for
faster builds. Substitute mpicc and mpicxx or other wrapped compiler names to suit
your system. For example, with OpenMPI use

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{build}
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}C\PYGZus{}COMPILER}\PYG{o}{=}\PYG{n}{mpicc} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}CXX\PYGZus{}COMPILER}\PYG{o}{=}\PYG{n}{mpicxx} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{l+m+mi}{8}
\end{sphinxVerbatim}

If you are feeling particularly lucky, you can skip the compiler specification:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{build}
\PYG{n}{cmake} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{l+m+mi}{8}
\end{sphinxVerbatim}

The complexities of modern computer hardware and software systems are
such that you should check that the autoconfiguration system has made
good choices and picked optimized libraries and compiler settings
before doing significant production. That is, check the following details. We
give examples for a number of common systems in {\hyperref[\detokenize{installation:installexamples}]{\sphinxcrossref{\DUrole{std,std-ref}{Installation instructions for common workstations and supercomputers}}}}.


\subsection{Environment variables}
\label{\detokenize{installation:environment-variables}}\label{\detokenize{installation:envvar}}
A number of environment variables affect the build.  In particular
they can control the default paths for libraries, the default
compilers, etc.  The list of environment variables is given below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CXX}              \PYG{n}{C}\PYG{o}{+}\PYG{o}{+} \PYG{n}{compiler}
\PYG{n}{CC}               \PYG{n}{C} \PYG{n}{Compiler}
\PYG{n}{MKL\PYGZus{}ROOT}         \PYG{n}{Path} \PYG{k}{for} \PYG{n}{MKL}
\PYG{n}{HDF5\PYGZus{}ROOT}        \PYG{n}{Path} \PYG{k}{for} \PYG{n}{HDF5}
\PYG{n}{BOOST\PYGZus{}ROOT}       \PYG{n}{Path} \PYG{k}{for} \PYG{n}{Boost}
\PYG{n}{FFTW\PYGZus{}HOME}        \PYG{n}{Path} \PYG{k}{for} \PYG{n}{FFTW}
\end{sphinxVerbatim}


\subsection{Configuration Options}
\label{\detokenize{installation:configuration-options}}\label{\detokenize{installation:cmakeoptions}}
In addition to reading the environment variables, CMake provides a
number of optional variables that can be set to control the build and
configure steps.  When passed to CMake, these variables will take
precedent over the environment and default variables.  To set them,
add \sphinxhyphen{}D FLAG=VALUE to the configure line between the CMake command and
the path to the source directory.
\begin{itemize}
\item {} 
Key QMCPACK build options

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{QMC\PYGZus{}CUDA}              \PYG{n}{Enable} \PYG{n}{CUDA} \PYG{o+ow}{and} \PYG{n}{GPU} \PYG{n}{acceleration} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{yes}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{no}\PYG{p}{)}
\PYG{n}{QMC\PYGZus{}COMPLEX}           \PYG{n}{Build} \PYG{n}{the} \PYG{n+nb}{complex} \PYG{p}{(}\PYG{n}{general} \PYG{n}{twist}\PYG{o}{/}\PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{n}{point}\PYG{p}{)} \PYG{n}{version} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{yes}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{no}\PYG{p}{)}
\PYG{n}{QMC\PYGZus{}MIXED\PYGZus{}PRECISION}   \PYG{n}{Build} \PYG{n}{the} \PYG{n}{mixed} \PYG{n}{precision} \PYG{p}{(}\PYG{n}{mixing} \PYG{n}{double}\PYG{o}{/}\PYG{n+nb}{float}\PYG{p}{)} \PYG{n}{version}
                      \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{yes} \PYG{p}{(}\PYG{n}{GPU} \PYG{n}{default}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{no} \PYG{p}{(}\PYG{n}{CPU} \PYG{n}{default}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}
                      \PYG{n}{The} \PYG{n}{CPU} \PYG{n}{support} \PYG{o+ow}{is} \PYG{n}{experimental}\PYG{o}{.}
                      \PYG{n}{Use} \PYG{n+nb}{float} \PYG{o+ow}{and} \PYG{n}{double} \PYG{k}{for} \PYG{n}{base} \PYG{o+ow}{and} \PYG{n}{full} \PYG{n}{precision}\PYG{o}{.}
                      \PYG{n}{The} \PYG{n}{GPU} \PYG{n}{support} \PYG{o+ow}{is} \PYG{n}{quite} \PYG{n}{mature}\PYG{o}{.}
                      \PYG{n}{Use} \PYG{n}{always} \PYG{n}{double} \PYG{k}{for} \PYG{n}{host} \PYG{n}{side} \PYG{n}{base} \PYG{o+ow}{and} \PYG{n}{full} \PYG{n}{precision}
                      \PYG{o+ow}{and} \PYG{n}{use} \PYG{n+nb}{float} \PYG{o+ow}{and} \PYG{n}{double} \PYG{k}{for} \PYG{n}{CUDA} \PYG{n}{base} \PYG{o+ow}{and} \PYG{n}{full} \PYG{n}{precision}\PYG{o}{.}
\PYG{n}{ENABLE\PYGZus{}SOA}            \PYG{n}{Enable} \PYG{n}{data} \PYG{n}{layout} \PYG{o+ow}{and} \PYG{n}{algorithm} \PYG{n}{optimizations} \PYG{n}{using}
                      \PYG{n}{Structure}\PYG{o}{\PYGZhy{}}\PYG{n}{of}\PYG{o}{\PYGZhy{}}\PYG{n}{Array} \PYG{p}{(}\PYG{n}{SoA}\PYG{p}{)} \PYG{n}{datatypes} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{yes} \PYG{p}{(}\PYG{n}{default}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{no}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{ENABLE\PYGZus{}TIMERS}         \PYG{n}{Enable} \PYG{n}{fine}\PYG{o}{\PYGZhy{}}\PYG{n}{grained} \PYG{n}{timers} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{yes}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{no} \PYG{p}{(}\PYG{n}{default}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}
                      \PYG{n}{Timers} \PYG{n}{are} \PYG{n}{off} \PYG{n}{by} \PYG{n}{default} \PYG{n}{to} \PYG{n}{avoid} \PYG{n}{potential} \PYG{n}{slowdown} \PYG{o+ow}{in} \PYG{n}{small}
                      \PYG{n}{systems}\PYG{o}{.} \PYG{n}{For} \PYG{n}{large} \PYG{n}{systems} \PYG{p}{(}\PYG{l+m+mi}{100}\PYG{o}{+} \PYG{n}{electrons}\PYG{p}{)} \PYG{n}{there} \PYG{o+ow}{is} \PYG{n}{no} \PYG{n}{risk}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
General build options

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CMAKE\PYGZus{}BUILD\PYGZus{}TYPE}     \PYG{n}{A} \PYG{n}{variable} \PYG{n}{which} \PYG{n}{controls} \PYG{n}{the} \PYG{n+nb}{type} \PYG{n}{of} \PYG{n}{build}
                     \PYG{p}{(}\PYG{n}{defaults} \PYG{n}{to} \PYG{n}{Release}\PYG{p}{)}\PYG{o}{.} \PYG{n}{Possible} \PYG{n}{values} \PYG{n}{are}\PYG{p}{:}
                     \PYG{k+kc}{None} \PYG{p}{(}\PYG{n}{Do} \PYG{o+ow}{not} \PYG{n+nb}{set} \PYG{n}{debug}\PYG{o}{/}\PYG{n}{optmize} \PYG{n}{flags}\PYG{p}{,} \PYG{n}{use}
                     \PYG{n}{CMAKE\PYGZus{}C\PYGZus{}FLAGS} \PYG{o+ow}{or} \PYG{n}{CMAKE\PYGZus{}CXX\PYGZus{}FLAGS}\PYG{p}{)}
                     \PYG{n}{Debug} \PYG{p}{(}\PYG{n}{create} \PYG{n}{a} \PYG{n}{debug} \PYG{n}{build}\PYG{p}{)}
                     \PYG{n}{Release} \PYG{p}{(}\PYG{n}{create} \PYG{n}{a} \PYG{n}{release}\PYG{o}{/}\PYG{n}{optimized} \PYG{n}{build}\PYG{p}{)}
                     \PYG{n}{RelWithDebInfo} \PYG{p}{(}\PYG{n}{create} \PYG{n}{a} \PYG{n}{release}\PYG{o}{/}\PYG{n}{optimized} \PYG{n}{build} \PYG{k}{with} \PYG{n}{debug} \PYG{n}{info}\PYG{p}{)}
                     \PYG{n}{MinSizeRel} \PYG{p}{(}\PYG{n}{create} \PYG{n}{an} \PYG{n}{executable} \PYG{n}{optimized} \PYG{k}{for} \PYG{n}{size}\PYG{p}{)}
\PYG{n}{CMAKE\PYGZus{}C\PYGZus{}COMPILER}     \PYG{n}{Set} \PYG{n}{the} \PYG{n}{C} \PYG{n}{compiler}
\PYG{n}{CMAKE\PYGZus{}CXX\PYGZus{}COMPILER}   \PYG{n}{Set} \PYG{n}{the} \PYG{n}{C}\PYG{o}{+}\PYG{o}{+} \PYG{n}{compiler}
\PYG{n}{CMAKE\PYGZus{}C\PYGZus{}FLAGS}        \PYG{n}{Set} \PYG{n}{the} \PYG{n}{C} \PYG{n}{flags}\PYG{o}{.}  \PYG{n}{Note}\PYG{p}{:} \PYG{n}{to} \PYG{n}{prevent} \PYG{n}{default}
                     \PYG{n}{debug}\PYG{o}{/}\PYG{n}{release} \PYG{n}{flags} \PYG{k+kn}{from} \PYG{n+nn}{being} \PYG{n}{used}\PYG{p}{,} \PYG{n+nb}{set} \PYG{n}{the} \PYG{n}{CMAKE\PYGZus{}BUILD\PYGZus{}TYPE}\PYG{o}{=}\PYG{k+kc}{None}
                     \PYG{n}{Also} \PYG{n}{supported}\PYG{p}{:} \PYG{n}{CMAKE\PYGZus{}C\PYGZus{}FLAGS\PYGZus{}DEBUG}\PYG{p}{,}
                     \PYG{n}{CMAKE\PYGZus{}C\PYGZus{}FLAGS\PYGZus{}RELEASE}\PYG{p}{,} \PYG{o+ow}{and} \PYG{n}{CMAKE\PYGZus{}C\PYGZus{}FLAGS\PYGZus{}RELWITHDEBINFO}
\PYG{n}{CMAKE\PYGZus{}CXX\PYGZus{}FLAGS}      \PYG{n}{Set} \PYG{n}{the} \PYG{n}{C}\PYG{o}{+}\PYG{o}{+} \PYG{n}{flags}\PYG{o}{.}  \PYG{n}{Note}\PYG{p}{:} \PYG{n}{to} \PYG{n}{prevent} \PYG{n}{default}
                     \PYG{n}{debug}\PYG{o}{/}\PYG{n}{release} \PYG{n}{flags} \PYG{k+kn}{from} \PYG{n+nn}{being} \PYG{n}{used}\PYG{p}{,} \PYG{n+nb}{set} \PYG{n}{the} \PYG{n}{CMAKE\PYGZus{}BUILD\PYGZus{}TYPE}\PYG{o}{=}\PYG{k+kc}{None}
                     \PYG{n}{Also} \PYG{n}{supported}\PYG{p}{:} \PYG{n}{CMAKE\PYGZus{}CXX\PYGZus{}FLAGS\PYGZus{}DEBUG}\PYG{p}{,}
                     \PYG{n}{CMAKE\PYGZus{}CXX\PYGZus{}FLAGS\PYGZus{}RELEASE}\PYG{p}{,} \PYG{o+ow}{and} \PYG{n}{CMAKE\PYGZus{}CXX\PYGZus{}FLAGS\PYGZus{}RELWITHDEBINFO}
\PYG{n}{CMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX} \PYG{n}{Set} \PYG{n}{the} \PYG{n}{install} \PYG{n}{location} \PYG{p}{(}\PYG{k}{if} \PYG{n}{using} \PYG{n}{the} \PYG{n}{optional} \PYG{n}{install} \PYG{n}{step}\PYG{p}{)}
\PYG{n}{INSTALL\PYGZus{}NEXUS}        \PYG{n}{Install} \PYG{n}{Nexus} \PYG{n}{alongside} \PYG{n}{QMCPACK} \PYG{p}{(}\PYG{k}{if} \PYG{n}{using} \PYG{n}{the} \PYG{n}{optional} \PYG{n}{install} \PYG{n}{step}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Additional QMCPACK build options

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{QE\PYGZus{}BIN}                    \PYG{n}{Location} \PYG{n}{of} \PYG{n}{Quantum} \PYG{n}{Espresso} \PYG{n}{binaries} \PYG{n}{including} \PYG{n}{pw2qmcpack}\PYG{o}{.}\PYG{n}{x}
\PYG{n}{QMC\PYGZus{}DATA}                  \PYG{n}{Specify} \PYG{n}{data} \PYG{n}{directory} \PYG{k}{for} \PYG{n}{QMCPACK} \PYG{n}{performance} \PYG{o+ow}{and} \PYG{n}{integration} \PYG{n}{tests}
\PYG{n}{QMC\PYGZus{}INCLUDE}               \PYG{n}{Add} \PYG{n}{extra} \PYG{n}{include} \PYG{n}{paths}
\PYG{n}{QMC\PYGZus{}EXTRA\PYGZus{}LIBS}            \PYG{n}{Add} \PYG{n}{extra} \PYG{n}{link} \PYG{n}{libraries}
\PYG{n}{QMC\PYGZus{}BUILD\PYGZus{}STATIC}          \PYG{n}{Add} \PYG{o}{\PYGZhy{}}\PYG{n}{static} \PYG{n}{flags} \PYG{n}{to} \PYG{n}{build}
\PYG{n}{QMC\PYGZus{}SYMLINK\PYGZus{}TEST\PYGZus{}FILES}    \PYG{n}{Set} \PYG{n}{to} \PYG{n}{zero} \PYG{n}{to} \PYG{n}{require} \PYG{n}{test} \PYG{n}{files} \PYG{n}{to} \PYG{n}{be} \PYG{n}{copied}\PYG{o}{.} \PYG{n}{Avoids} \PYG{n}{space}
                          \PYG{n}{saving} \PYG{n}{default} \PYG{n}{use} \PYG{n}{of} \PYG{n}{symbolic} \PYG{n}{links} \PYG{k}{for} \PYG{n}{test} \PYG{n}{files}\PYG{o}{.} \PYG{n}{Useful}
                          \PYG{k}{if} \PYG{n}{the} \PYG{n}{build} \PYG{o+ow}{is} \PYG{n}{on} \PYG{n}{a} \PYG{n}{separate} \PYG{n}{filesystem} \PYG{k+kn}{from} \PYG{n+nn}{the} \PYG{n}{source}\PYG{p}{,} \PYG{k}{as}
                          \PYG{n}{required} \PYG{n}{on} \PYG{n}{some} \PYG{n}{HPC} \PYG{n}{systems}\PYG{o}{.}
\PYG{n}{QMC\PYGZus{}VERBOSE\PYGZus{}CONFIGURATION} \PYG{n}{Print} \PYG{n}{additional} \PYG{n}{information} \PYG{n}{during} \PYG{n}{cmake} \PYG{n}{configuration}
                          \PYG{n}{including} \PYG{n}{details} \PYG{n}{of} \PYG{n}{which} \PYG{n}{tests} \PYG{n}{are} \PYG{n}{enabled}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
Intel MKL related

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ENABLE\PYGZus{}MKL}          \PYG{n}{Enable} \PYG{n}{Intel} \PYG{n}{MKL} \PYG{n}{libraries} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{yes} \PYG{p}{(}\PYG{n}{default} \PYG{k}{for} \PYG{n}{intel} \PYG{n}{compiler}\PYG{p}{)}\PYG{p}{,}
                                              \PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{no} \PYG{p}{(}\PYG{n}{default} \PYG{n}{otherwise}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{MKL\PYGZus{}ROOT}            \PYG{n}{Path} \PYG{n}{to} \PYG{n}{MKL} \PYG{n}{libraries} \PYG{p}{(}\PYG{n}{only} \PYG{n}{necessary} \PYG{k}{for} \PYG{n}{non} \PYG{n}{intel} \PYG{n}{compilers}
                    \PYG{o+ow}{or} \PYG{n}{intel} \PYG{n}{without} \PYG{n}{standard} \PYG{n}{environment} \PYG{n}{variables}\PYG{o}{.}\PYG{p}{)}
                    \PYG{n}{One} \PYG{n}{of} \PYG{n}{the} \PYG{n}{above} \PYG{n}{environment} \PYG{n}{variables} \PYG{n}{can} \PYG{n}{be} \PYG{n}{used}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
libxml2 related

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{LIBXML2\PYGZus{}INCLUDE\PYGZus{}DIR}   \PYG{n}{Include} \PYG{n}{directory} \PYG{k}{for} \PYG{n}{libxml2}

\PYG{n}{LIBXML2\PYGZus{}LIBRARY}       \PYG{n}{Libxml2} \PYG{n}{library}
\end{sphinxVerbatim}

\item {} 
HDF5 related

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{HDF5\PYGZus{}PREFER\PYGZus{}PARALLEL} \PYG{l+m+mi}{1}\PYG{p}{(}\PYG{n}{default} \PYG{k}{for} \PYG{n}{MPI} \PYG{n}{build}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{enables}\PYG{o}{/}\PYG{n}{disable} \PYG{n}{parallel} \PYG{n}{HDF5} \PYG{n}{library} \PYG{n}{searching}\PYG{o}{.}
\PYG{n}{ENABLE\PYGZus{}PHDF5}         \PYG{l+m+mi}{1}\PYG{p}{(}\PYG{n}{default} \PYG{k}{for} \PYG{n}{parallel} \PYG{n}{HDF5} \PYG{n}{library}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{enables}\PYG{o}{/}\PYG{n}{disable} \PYG{n}{parallel} \PYG{n}{collective} \PYG{n}{I}\PYG{o}{/}\PYG{n}{O}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
FFTW related

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{FFTW\PYGZus{}INCLUDE\PYGZus{}DIRS}   \PYG{n}{Specify} \PYG{n}{include} \PYG{n}{directories} \PYG{k}{for} \PYG{n}{FFTW}
\PYG{n}{FFTW\PYGZus{}LIBRARY\PYGZus{}DIRS}   \PYG{n}{Specify} \PYG{n}{library} \PYG{n}{directories} \PYG{k}{for} \PYG{n}{FFTW}
\end{sphinxVerbatim}

\item {} 
CTest related

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MPIEXEC\PYGZus{}EXECUTABLE}     \PYG{n}{Specify} \PYG{n}{the} \PYG{n}{mpi} \PYG{n}{wrapper}\PYG{p}{,} \PYG{n}{e}\PYG{o}{.}\PYG{n}{g}\PYG{o}{.} \PYG{n}{srun}\PYG{p}{,} \PYG{n}{aprun}\PYG{p}{,} \PYG{n}{mpirun}\PYG{p}{,} \PYG{n}{etc}\PYG{o}{.}
\PYG{n}{MPIEXEC\PYGZus{}NUMPROC\PYGZus{}FLAG}   \PYG{n}{Specify} \PYG{n}{the} \PYG{n}{number} \PYG{n}{of} \PYG{n}{mpi} \PYG{n}{processes} \PYG{n}{flag}\PYG{p}{,}
                       \PYG{n}{e}\PYG{o}{.}\PYG{n}{g}\PYG{o}{.} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}np}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{etc}\PYG{o}{.}
\PYG{n}{MPIEXEC\PYGZus{}PREFLAGS}       \PYG{n}{Flags} \PYG{n}{to} \PYG{k}{pass} \PYG{n}{to} \PYG{n}{MPIEXEC\PYGZus{}EXECUTABLE} \PYG{n}{directly} \PYG{n}{before} \PYG{n}{the} \PYG{n}{executable} \PYG{n}{to} \PYG{n}{run}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
LLVM/Clang Developer Options

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{LLVM\PYGZus{}SANITIZE\PYGZus{}ADDRES}  \PYG{n}{link} \PYG{k}{with} \PYG{n}{the} \PYG{n}{Clang} \PYG{n}{address} \PYG{n}{sanitizer} \PYG{n}{library}
\PYG{n}{LLVM\PYGZus{}SANITIZE\PYGZus{}MEMORY}  \PYG{n}{link} \PYG{k}{with} \PYG{n}{the} \PYG{n}{Clang} \PYG{n}{memory} \PYG{n}{sanitizer} \PYG{n}{library}
\end{sphinxVerbatim}

\end{itemize}

\sphinxhref{https://clang.llvm.org/docs/AddressSanitizer.html}{Clang address sanitizer library}

\sphinxhref{https://clang.llvm.org/docs/MemorySanitizer.html}{Clang memory sanitizer library}

See \DUrole{xref,std,std-ref}{LLVM\sphinxhyphen{}Sanitizer\sphinxhyphen{}Libraries} for more information.


\subsection{Installation from CMake}
\label{\detokenize{installation:installation-from-cmake}}
Installation is optional. The QMCPACK executable can be run from the \sphinxcode{\sphinxupquote{bin}} directory in the build location.
If the install step is desired, run the \sphinxcode{\sphinxupquote{make install}} command to install the QMCPACK executable, the converter,
and some additional executables.
Also installed is the \sphinxcode{\sphinxupquote{qmcpack.settings}} file that records options used to compile QMCPACK.
Specify the \sphinxcode{\sphinxupquote{CMAKE\_INSTALL\_PREFIX}} CMake variable during configuration to set the install location.


\subsection{Role of QMC\_DATA}
\label{\detokenize{installation:role-of-qmc-data}}
QMCPACK includes a variety of optional performance and integration
tests that use research quality wavefunctions to obtain meaningful
performance and to more thoroughly test the code. The necessarily
large input files are stored in the location pointed to by QMC\_DATA (e.g., scratch or long\sphinxhyphen{}lived project space on a supercomputer). These
files are not included in the source code distribution to minimize
size. The tests are activated if CMake detects the files when
configured. See tests/performance/NiO/README,
tests/solids/NiO\_afqmc/README, tests/performance/C\sphinxhyphen{}graphite/README, and tests/performance/C\sphinxhyphen{}molecule/README
for details of the current tests and input files and to download them.

Currently the files must be downloaded via \sphinxurl{https://anl.box.com/s/yxz1ic4kxtdtgpva5hcmlom9ixfl3v3c}.

The layout of current complete set of files is given below. If a file is missing, the appropriate performance test is skipped.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{C}\PYG{o}{\PYGZhy{}}\PYG{n}{graphite}\PYG{o}{/}\PYG{n}{lda}\PYG{o}{.}\PYG{n}{pwscf}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{C}\PYG{o}{\PYGZhy{}}\PYG{n}{molecule}\PYG{o}{/}\PYG{n}{C12}\PYG{o}{\PYGZhy{}}\PYG{n}{e48}\PYG{o}{\PYGZhy{}}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{C}\PYG{o}{\PYGZhy{}}\PYG{n}{molecule}\PYG{o}{/}\PYG{n}{C12}\PYG{o}{\PYGZhy{}}\PYG{n}{e72}\PYG{o}{\PYGZhy{}}\PYG{n}{ae}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{C}\PYG{o}{\PYGZhy{}}\PYG{n}{molecule}\PYG{o}{/}\PYG{n}{C18}\PYG{o}{\PYGZhy{}}\PYG{n}{e108}\PYG{o}{\PYGZhy{}}\PYG{n}{ae}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{C}\PYG{o}{\PYGZhy{}}\PYG{n}{molecule}\PYG{o}{/}\PYG{n}{C18}\PYG{o}{\PYGZhy{}}\PYG{n}{e72}\PYG{o}{\PYGZhy{}}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{C}\PYG{o}{\PYGZhy{}}\PYG{n}{molecule}\PYG{o}{/}\PYG{n}{C24}\PYG{o}{\PYGZhy{}}\PYG{n}{e144}\PYG{o}{\PYGZhy{}}\PYG{n}{ae}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{C}\PYG{o}{\PYGZhy{}}\PYG{n}{molecule}\PYG{o}{/}\PYG{n}{C24}\PYG{o}{\PYGZhy{}}\PYG{n}{e96}\PYG{o}{\PYGZhy{}}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{C}\PYG{o}{\PYGZhy{}}\PYG{n}{molecule}\PYG{o}{/}\PYG{n}{C30}\PYG{o}{\PYGZhy{}}\PYG{n}{e120}\PYG{o}{\PYGZhy{}}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{C}\PYG{o}{\PYGZhy{}}\PYG{n}{molecule}\PYG{o}{/}\PYG{n}{C30}\PYG{o}{\PYGZhy{}}\PYG{n}{e180}\PYG{o}{\PYGZhy{}}\PYG{n}{ae}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{C}\PYG{o}{\PYGZhy{}}\PYG{n}{molecule}\PYG{o}{/}\PYG{n}{C60}\PYG{o}{\PYGZhy{}}\PYG{n}{e240}\PYG{o}{\PYGZhy{}}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{\PYGZhy{}}\PYG{n}{fcc}\PYG{o}{\PYGZhy{}}\PYG{n}{supertwist111}\PYG{o}{\PYGZhy{}}\PYG{n}{supershift000}\PYG{o}{\PYGZhy{}}\PYG{n}{S1}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{\PYGZhy{}}\PYG{n}{fcc}\PYG{o}{\PYGZhy{}}\PYG{n}{supertwist111}\PYG{o}{\PYGZhy{}}\PYG{n}{supershift000}\PYG{o}{\PYGZhy{}}\PYG{n}{S2}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{\PYGZhy{}}\PYG{n}{fcc}\PYG{o}{\PYGZhy{}}\PYG{n}{supertwist111}\PYG{o}{\PYGZhy{}}\PYG{n}{supershift000}\PYG{o}{\PYGZhy{}}\PYG{n}{S4}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{\PYGZhy{}}\PYG{n}{fcc}\PYG{o}{\PYGZhy{}}\PYG{n}{supertwist111}\PYG{o}{\PYGZhy{}}\PYG{n}{supershift000}\PYG{o}{\PYGZhy{}}\PYG{n}{S8}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{\PYGZhy{}}\PYG{n}{fcc}\PYG{o}{\PYGZhy{}}\PYG{n}{supertwist111}\PYG{o}{\PYGZhy{}}\PYG{n}{supershift000}\PYG{o}{\PYGZhy{}}\PYG{n}{S16}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{\PYGZhy{}}\PYG{n}{fcc}\PYG{o}{\PYGZhy{}}\PYG{n}{supertwist111}\PYG{o}{\PYGZhy{}}\PYG{n}{supershift000}\PYG{o}{\PYGZhy{}}\PYG{n}{S32}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{\PYGZhy{}}\PYG{n}{fcc}\PYG{o}{\PYGZhy{}}\PYG{n}{supertwist111}\PYG{o}{\PYGZhy{}}\PYG{n}{supershift000}\PYG{o}{\PYGZhy{}}\PYG{n}{S64}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{\PYGZhy{}}\PYG{n}{fcc}\PYG{o}{\PYGZhy{}}\PYG{n}{supertwist111}\PYG{o}{\PYGZhy{}}\PYG{n}{supershift000}\PYG{o}{\PYGZhy{}}\PYG{n}{S128}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{\PYGZhy{}}\PYG{n}{fcc}\PYG{o}{\PYGZhy{}}\PYG{n}{supertwist111}\PYG{o}{\PYGZhy{}}\PYG{n}{supershift000}\PYG{o}{\PYGZhy{}}\PYG{n}{S256}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO\PYGZus{}afm\PYGZus{}fcidump}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO\PYGZus{}afm\PYGZus{}wfn}\PYG{o}{.}\PYG{n}{dat}
\PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{/}\PYG{n}{NiO}\PYG{o}{/}\PYG{n}{NiO\PYGZus{}nm\PYGZus{}choldump}\PYG{o}{.}\PYG{n}{h5}
\end{sphinxVerbatim}


\subsection{Configure and build using CMake and make}
\label{\detokenize{installation:configure-and-build-using-cmake-and-make}}
To configure and build QMCPACK, move to build directory, run CMake, and make

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{build}
\PYG{n}{cmake} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{l+m+mi}{8}
\end{sphinxVerbatim}

As you will have gathered, CMake encourages “out of source” builds,
where all the files for a specific build configuration reside in their
own directory separate from the source files. This allows multiple
builds to be created from the same source files, which is very useful
when the file system is shared between different systems. You can also
build versions with different settings (e.g., QMC\_COMPLEX) and
different compiler settings. The build directory does not have to be
called build—use something descriptive such as build\_machinename or
build\_complex. The “..” in the CMake line refers to the directory
containing CMakeLists.txt. Update the “..” for other build
directory locations.


\subsection{Example configure and build}
\label{\detokenize{installation:example-configure-and-build}}\begin{itemize}
\item {} 
Set the environments (the examples below assume bash, Intel compilers, and MKL library)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{export} \PYG{n}{CXX}\PYG{o}{=}\PYG{n}{icpc}
\PYG{n}{export} \PYG{n}{CC}\PYG{o}{=}\PYG{n}{icc}
\PYG{n}{export} \PYG{n}{MKL\PYGZus{}ROOT}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{n}{mkl}\PYG{o}{/}\PYG{l+m+mf}{10.0}\PYG{o}{.}\PYG{l+m+mf}{3.020}
\PYG{n}{export} \PYG{n}{HDF5\PYGZus{}ROOT}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}
\PYG{n}{export} \PYG{n}{BOOST\PYGZus{}ROOT}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n}{boost}
\PYG{n}{export} \PYG{n}{FFTW\PYGZus{}HOME}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n}{fftw}
\end{sphinxVerbatim}

\item {} 
Move to build directory, run CMake, and make

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{build}
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{n}{CMAKE\PYGZus{}BUILD\PYGZus{}TYPE}\PYG{o}{=}\PYG{n}{Release} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{l+m+mi}{8}
\end{sphinxVerbatim}

\end{itemize}


\subsection{Build scripts}
\label{\detokenize{installation:build-scripts}}
We recommended creating a helper script that contains the
configure line for CMake.  This is particularly useful when avoiding
environment variables, packages are installed in custom locations,
or the configure line is long or complex.  In this case it is also
recommended to add “rm \sphinxhyphen{}rf CMake*” before the configure line to remove
existing CMake configure files to ensure a fresh configure each time
the script is called. Deleting all the files in the build
directory is also acceptable. If you do so we recommend adding some sanity
checks in case the script is run from the wrong directory (e.g.,
checking for the existence of some QMCPACK files).

Some build script examples for different systems are given in the
config directory. For example, on Cray systems these scripts might
load the appropriate modules to set the appropriate programming
environment, specific library versions, etc.

An example script build.sh is given below. It is much more complex
than usually needed for comprehensiveness:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{export} \PYG{n}{CXX}\PYG{o}{=}\PYG{n}{mpic}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{export} \PYG{n}{CC}\PYG{o}{=}\PYG{n}{mpicc}
\PYG{n}{export} \PYG{n}{ACML\PYGZus{}HOME}\PYG{o}{=}\PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{acml}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.3}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{gfortran64}
\PYG{n}{export} \PYG{n}{HDF5\PYGZus{}ROOT}\PYG{o}{=}\PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{hdf5}
\PYG{n}{export} \PYG{n}{BOOST\PYGZus{}ROOT}\PYG{o}{=}\PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{boost}

\PYG{n}{rm} \PYG{o}{\PYGZhy{}}\PYG{n}{rf} \PYG{n}{CMake}\PYG{o}{*}

\PYG{n}{cmake}                                                \PYGZbs{}
  \PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{n}{CMAKE\PYGZus{}BUILD\PYGZus{}TYPE}\PYG{o}{=}\PYG{n}{Debug}                         \PYGZbs{}
  \PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{n}{LIBXML2\PYGZus{}INCLUDE\PYGZus{}DIR}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{include}\PYG{o}{/}\PYG{n}{libxml2}      \PYGZbs{}
  \PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{n}{LIBXML2\PYGZus{}LIBRARY}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{lib}\PYG{o}{/}\PYG{n}{x86\PYGZus{}64}\PYG{o}{\PYGZhy{}}\PYG{n}{linux}\PYG{o}{\PYGZhy{}}\PYG{n}{gnu}\PYG{o}{/}\PYG{n}{libxml2}\PYG{o}{.}\PYG{n}{so} \PYGZbs{}
  \PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{n}{FFTW\PYGZus{}INCLUDE\PYGZus{}DIRS}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{include}                 \PYGZbs{}
  \PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{n}{FFTW\PYGZus{}LIBRARY\PYGZus{}DIRS}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{lib}\PYG{o}{/}\PYG{n}{x86\PYGZus{}64}\PYG{o}{\PYGZhy{}}\PYG{n}{linux}\PYG{o}{\PYGZhy{}}\PYG{n}{gnu}    \PYGZbs{}
  \PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{n}{QMC\PYGZus{}EXTRA\PYGZus{}LIBS}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}ldl \PYGZdl{}}\PYG{l+s+si}{\PYGZob{}ACML\PYGZus{}HOME\PYGZcb{}}\PYG{l+s+s2}{/lib/libacml.a \PYGZhy{}lgfortran}\PYG{l+s+s2}{\PYGZdq{}} \PYGZbs{}
  \PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{n}{QMC\PYGZus{}DATA}\PYG{o}{=}\PYG{o}{/}\PYG{n}{projects}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZhy{}}\PYG{n}{data}            \PYGZbs{}
  \PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}


\subsection{Using vendor\sphinxhyphen{}optimized numerical libraries (e.g., Intel MKL)}
\label{\detokenize{installation:using-vendor-optimized-numerical-libraries-e-g-intel-mkl}}
Although QMC does not make extensive use of linear algebra, use of
vendor\sphinxhyphen{}optimized libraries is strongly recommended for highest
performance. BLAS routines are used in the Slater determinant update, the VMC wavefunction optimizer,
and to apply orbital coefficients in local basis calculations. Vectorized
math functions are also beneficial (e.g., for the phase factor
computation in solid\sphinxhyphen{}state calculations). CMake is generally successful
in finding these libraries, but specific combinations can require
additional hints, as described in the following:


\subsubsection{Using Intel MKL with non\sphinxhyphen{}Intel compilers}
\label{\detokenize{installation:using-intel-mkl-with-non-intel-compilers}}
To use Intel MKL with, e.g. an MPICH wrapped gcc:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cmake \PYGZbs{}
  \PYGZhy{}DCMAKE\PYGZus{}C\PYGZus{}COMPILER=mpicc \PYGZhy{}DCMAKE\PYGZus{}CXX\PYGZus{}COMPILER=mpicxx \PYGZbs{}
  \PYGZhy{}DENABLE\PYGZus{}MKL=1 \PYGZhy{}DMKL\PYGZus{}ROOT=\PYGZdl{}MKLROOT/lib \PYGZbs{}
  ..
\end{sphinxVerbatim}

MKLROOT is the directory containing the MKL binary, examples, and lib
directories (etc.) and is often /opt/intel/mkl.


\subsubsection{Serial or multithreaded library}
\label{\detokenize{installation:serial-or-multithreaded-library}}\label{\detokenize{installation:threadedlibrary}}
Vendors might provide both serial and multithreaded versions of their libraries.
Using the right version is critical to QMCPACK performance.
QMCPACK makes calls from both inside and outside threaded regions.
When being called from outside an OpenMP parallel region, the multithreaded version is preferred for the possibility of using all the available cores.
When being called from every thread inside an OpenMP parallel region, the serial version is preferred for not oversubscribing the cores.
Fortunately, nowadays the multithreaded versions of many vendor libraries (MKL, ESSL) are OpenMP aware.
They use only one thread when being called inside an OpenMP parallel region.
This behavior meets exactly both QMCPACK needs and thus is preferred.
If the multithreaded version does not provide this feature of dynamically adjusting the number of threads,
the serial version is preferred. In addition, thread safety is required no matter which version is used.


\subsection{Cross compiling}
\label{\detokenize{installation:cross-compiling}}
Cross compiling is often difficult but is required on supercomputers
with distinct host and compute processor generations or architectures.
QMCPACK tried to do its best with CMake to facilitate cross compiling.
\begin{itemize}
\item {} 
On a machine using a Cray programming environment, we rely on
compiler wrappers provided by Cray to correctly set architecture\sphinxhyphen{}specific
flags. The CMake configure log should indicate that a
Cray machine was detected.

\item {} 
If not on a Cray machine, by default we assume building for
the host architecture (e.g., \sphinxhyphen{}xHost is added for the Intel compiler
and \sphinxhyphen{}march=native is added for GNU/Clang compilers).

\item {} 
If \sphinxhyphen{}x/\sphinxhyphen{}ax or \sphinxhyphen{}march is specified by the user in CMAKE\_C\_FLAGS and CMAKE\_CXX\_FLAGS,
we respect the user’s intention and do not add any architecture\sphinxhyphen{}specific flags.

\end{itemize}

The general strategy for cross compiling should therefore be to
manually set CMAKE\_C\_FLAGS and CMAKE\_CXX\_FLAGS for the target
architecture. Using \sphinxcode{\sphinxupquote{make VERBOSE=1}} is a useful way to check the
final compilation options.  If on a Cray machine, selection of the
appropriate programming environment should be sufficient.


\section{Installation instructions for common workstations and supercomputers}
\label{\detokenize{installation:installation-instructions-for-common-workstations-and-supercomputers}}\label{\detokenize{installation:installexamples}}
This section describes how to build QMCPACK on various common systems
including multiple Linux distributions, Apple OS X, and various
supercomputers. The examples should serve as good starting points for
building QMCPACK on similar machines. For example, the software
environment on modern Crays is very consistent. Note that updates to
operating systems and system software might require small modifications
to these recipes. See {\hyperref[\detokenize{installation:buildperformance}]{\sphinxcrossref{\DUrole{std,std-ref}{How to build the fastest executable version of QMCPACK}}}} for key
points to check to obtain highest performance and
{\hyperref[\detokenize{installation:troubleshoot}]{\sphinxcrossref{\DUrole{std,std-ref}{Troubleshooting the installation}}}} for troubleshooting hints.


\subsection{Installing on Ubuntu Linux or other apt\sphinxhyphen{}get\textendash{}based distributions}
\label{\detokenize{installation:installing-on-ubuntu-linux-or-other-apt-get-based-distributions}}\label{\detokenize{installation:buildubuntu}}
The following is designed to obtain a working QMCPACK build on, for example, a
student laptop, starting from a basic Linux installation with none of
the developer tools installed. Fortunately, all the required packages
are available in the default repositories making for a quick
installation. Note that for convenience we use a generic BLAS. For
production, a platform\sphinxhyphen{}optimized BLAS should be used.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{cmake} \PYG{n}{g}\PYG{o}{+}\PYG{o}{+} \PYG{n}{openmpi}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{bin} \PYG{n}{libopenmpi}\PYG{o}{\PYGZhy{}}\PYG{n}{dev} \PYG{n}{libboost}\PYG{o}{\PYGZhy{}}\PYG{n}{dev}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{libatlas}\PYG{o}{\PYGZhy{}}\PYG{n}{base}\PYG{o}{\PYGZhy{}}\PYG{n}{dev} \PYG{n}{liblapack}\PYG{o}{\PYGZhy{}}\PYG{n}{dev} \PYG{n}{libhdf5}\PYG{o}{\PYGZhy{}}\PYG{n}{dev} \PYG{n}{libxml2}\PYG{o}{\PYGZhy{}}\PYG{n}{dev} \PYG{n}{fftw3}\PYG{o}{\PYGZhy{}}\PYG{n}{dev}
\PYG{n}{export} \PYG{n}{CXX}\PYG{o}{=}\PYG{n}{mpiCC}
\PYG{n}{cd} \PYG{n}{build}
\PYG{n}{cmake} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{l+m+mi}{8}
\PYG{n}{ls} \PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{qmcpack}
\end{sphinxVerbatim}

For qmca and other tools to function, we install some Python libraries:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{python}\PYG{o}{\PYGZhy{}}\PYG{n}{numpy} \PYG{n}{python}\PYG{o}{\PYGZhy{}}\PYG{n}{matplotlib}
\end{sphinxVerbatim}


\subsection{Installing on CentOS Linux or other yum\sphinxhyphen{}based distributions}
\label{\detokenize{installation:installing-on-centos-linux-or-other-yum-based-distributions}}
The following is designed to obtain a working QMCPACK build on, for example, a
student laptop, starting from a basic Linux installation with none of
the developer tools installed. CentOS 7 (Red Hat compatible) is using
gcc 4.8.2. The installation is complicated only by the need to install
another repository to obtain HDF5 packages that are not available by
default. Note that for convenience we use a generic BLAS. For
production, a platform\sphinxhyphen{}optimized BLAS should be used.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{yum} \PYG{n}{install} \PYG{n}{make} \PYG{n}{cmake} \PYG{n}{gcc} \PYG{n}{gcc}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{+}\PYG{o}{+} \PYG{n}{openmpi} \PYG{n}{openmpi}\PYG{o}{\PYGZhy{}}\PYG{n}{devel} \PYG{n}{fftw} \PYG{n}{fftw}\PYG{o}{\PYGZhy{}}\PYG{n}{devel} \PYGZbs{}
                  \PYG{n}{boost} \PYG{n}{boost}\PYG{o}{\PYGZhy{}}\PYG{n}{devel} \PYG{n}{libxml2} \PYG{n}{libxml2}\PYG{o}{\PYGZhy{}}\PYG{n}{devel}
\PYG{n}{sudo} \PYG{n}{yum} \PYG{n}{install} \PYG{n}{blas}\PYG{o}{\PYGZhy{}}\PYG{n}{devel} \PYG{n}{lapack}\PYG{o}{\PYGZhy{}}\PYG{n}{devel} \PYG{n}{atlas}\PYG{o}{\PYGZhy{}}\PYG{n}{devel}
\PYG{n}{module} \PYG{n}{load} \PYG{n}{mpi}
\end{sphinxVerbatim}

To set up repoforge as a source for the HDF5 package, go to
\sphinxurl{http://repoforge.org/use}. Install the appropriate up\sphinxhyphen{}to\sphinxhyphen{}date
release package for your operating system. By default, CentOS Firefox will offer
to run the installer. The CentOS 6.5 settings were still usable for HDF5 on
CentOS 7 in 2016, but use CentOS 7 versions when they become
available.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{yum} \PYG{n}{install} \PYG{n}{hdf5} \PYG{n}{hdf5}\PYG{o}{\PYGZhy{}}\PYG{n}{devel}
\end{sphinxVerbatim}

To build QMCPACK:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{module} \PYG{n}{load} \PYG{n}{mpi}\PYG{o}{/}\PYG{n}{openmpi}\PYG{o}{\PYGZhy{}}\PYG{n}{x86\PYGZus{}64}
\PYG{n}{which} \PYG{n}{mpirun}
\PYG{c+c1}{\PYGZsh{} Sanity check; should print something like   /usr/lib64/openmpi/bin/mpirun}
\PYG{n}{export} \PYG{n}{CXX}\PYG{o}{=}\PYG{n}{mpiCC}
\PYG{n}{cd} \PYG{n}{build}
\PYG{n}{cmake} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{l+m+mi}{8}
\PYG{n}{ls} \PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{qmcpack}
\end{sphinxVerbatim}


\subsection{Installing on Mac OS X using Macports}
\label{\detokenize{installation:installing-on-mac-os-x-using-macports}}
These instructions assume a fresh installation of macports
and use the gcc 6.1 compiler. Older versions are fine, but it is vital to ensure that
matching compilers and libraries are used for all
packages and to force use of what is installed in /opt/local.  Performance should be very reasonable.
Note that we use the Apple\sphinxhyphen{}provided Accelerate framework for
optimized BLAS.

Follow the Macports install instructions at \sphinxurl{https://www.macports.org/}.
\begin{itemize}
\item {} 
Install Xcode and the Xcode Command Line Tools.

\item {} 
Agree to Xcode license in Terminal: sudo xcodebuild \sphinxhyphen{}license.

\item {} 
Install MacPorts for your version of OS X.

\end{itemize}

Install the required tools:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{port} \PYG{n}{install} \PYG{n}{gcc6}
\PYG{n}{sudo} \PYG{n}{port} \PYG{n}{select} \PYG{n}{gcc} \PYG{n}{mp}\PYG{o}{\PYGZhy{}}\PYG{n}{gcc6}
\PYG{n}{sudo} \PYG{n}{port} \PYG{n}{install} \PYG{n}{openmpi}\PYG{o}{\PYGZhy{}}\PYG{n}{devel}\PYG{o}{\PYGZhy{}}\PYG{n}{gcc6}
\PYG{n}{sudo} \PYG{n}{port} \PYG{n}{select} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set} \PYG{n}{mpi} \PYG{n}{openmpi}\PYG{o}{\PYGZhy{}}\PYG{n}{devel}\PYG{o}{\PYGZhy{}}\PYG{n}{gcc61}\PYG{o}{\PYGZhy{}}\PYG{n}{fortran}

\PYG{n}{sudo} \PYG{n}{port} \PYG{n}{install} \PYG{n}{fftw}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{o}{+}\PYG{n}{gcc6}
\PYG{n}{sudo} \PYG{n}{port} \PYG{n}{install} \PYG{n}{libxml2}
\PYG{n}{sudo} \PYG{n}{port} \PYG{n}{install} \PYG{n}{cmake}
\PYG{n}{sudo} \PYG{n}{post} \PYG{n}{install} \PYG{n}{boost} \PYG{o}{+}\PYG{n}{gcc6}
\PYG{n}{sudo} \PYG{n}{port} \PYG{n}{install} \PYG{n}{hdf5} \PYG{o}{+}\PYG{n}{gcc6}

\PYG{n}{sudo} \PYG{n}{port} \PYG{n}{select} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set} \PYG{n}{python} \PYG{n}{python27}
\PYG{n}{sudo} \PYG{n}{port} \PYG{n}{install} \PYG{n}{py27}\PYG{o}{\PYGZhy{}}\PYG{n}{numpy} \PYG{o}{+}\PYG{n}{gcc6}
\PYG{n}{sudo} \PYG{n}{port} \PYG{n}{install} \PYG{n}{py27}\PYG{o}{\PYGZhy{}}\PYG{n}{matplotlib}  \PYG{c+c1}{\PYGZsh{}For graphical plots with qmca}
\end{sphinxVerbatim}

QMCPACK build:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{build}
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}C\PYGZus{}COMPILER}\PYG{o}{=}\PYG{n}{mpicc} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}CXX\PYGZus{}COMPILER}\PYG{o}{=}\PYG{n}{mpiCXX} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{l+m+mi}{6} \PYG{c+c1}{\PYGZsh{} Adjust for available core count}
\PYG{n}{ls} \PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{qmcpack}
\end{sphinxVerbatim}

Cmake should pickup the versions of HDF5 and libxml (etc.) installed in
/opt/local by macports. If you have other copies of these libraries
installed and wish to force use of a specific version, use the
environment variables detailed in {\hyperref[\detokenize{installation:envvar}]{\sphinxcrossref{\DUrole{std,std-ref}{Environment variables}}}}.

This recipe was verified on July 1, 2016, on a Mac running OS X 10.11.5
“El Capitain.”


\subsection{Installing on Mac OS X using Homebrew (brew)}
\label{\detokenize{installation:installing-on-mac-os-x-using-homebrew-brew}}
Homebrew is a package manager for OS X that provides a convenient
route to install all the QMCPACK dependencies. The
following recipe will install the latest available versions of each
package. This was successfully tested under OS X 10.12 “Sierra” in December 2017. Note that it is necessary to build the MPI software from
source to use the brew\sphinxhyphen{}provided gcc instead of Apple CLANG.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Install Homebrew from \sphinxurl{http://brew.sh/}:

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{ruby} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}(curl \PYGZhy{}fsSL}
  \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{raw}\PYG{o}{.}\PYG{n}{githubusercontent}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{Homebrew}\PYG{o}{/}\PYG{n}{install}\PYG{o}{/}\PYG{n}{master}\PYG{o}{/}\PYG{n}{install}\PYG{p}{)}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Install the prerequisites:

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{brew} \PYG{n}{install} \PYG{n}{gcc} \PYG{c+c1}{\PYGZsh{} installs gcc 7.2.0 on 2017\PYGZhy{}12\PYGZhy{}19}
\PYG{n}{export} \PYG{n}{HOMEBREW\PYGZus{}CXX}\PYG{o}{=}\PYG{n}{g}\PYG{o}{+}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7}
\PYG{n}{export} \PYG{n}{HOMEBREW\PYGZus{}CC}\PYG{o}{=}\PYG{n}{gcc}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7}
\PYG{n}{brew} \PYG{n}{install} \PYG{n}{mpich2} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{build}\PYG{o}{\PYGZhy{}}\PYG{n}{from}\PYG{o}{\PYGZhy{}}\PYG{n}{source}
\PYG{c+c1}{\PYGZsh{} Build from source required to use homebrew compiled compilers as}
\PYG{c+c1}{\PYGZsh{} opposed to Apple CLANG. Check \PYGZdq{}mpicc \PYGZhy{}v\PYGZdq{} indicates Homebrew gcc}
\PYG{n}{brew} \PYG{n}{install} \PYG{n}{cmake}
\PYG{n}{brew} \PYG{n}{install} \PYG{n}{fftw}
\PYG{n}{brew} \PYG{n}{install} \PYG{n}{boost}
\PYG{n}{brew} \PYG{n}{install} \PYG{n}{homebrew}\PYG{o}{/}\PYG{n}{science}\PYG{o}{/}\PYG{n}{hdf5}
\PYG{c+c1}{\PYGZsh{}Note: Libxml2 is not required via brew since OS X already includes it.}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Configure and build QMCPACK:

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}C\PYGZus{}COMPILER}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{mpicc} \PYGZbs{}
      \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}CXX\PYGZus{}COMPILER}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{mpicxx} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{l+m+mi}{12}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Run the short tests. When MPICH is used for the first time, OSX will request approval of the network connection for each executable.

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ctest} \PYG{o}{\PYGZhy{}}\PYG{n}{R} \PYG{n}{short} \PYG{o}{\PYGZhy{}}\PYG{n}{LE} \PYG{n}{unstable}
\end{sphinxVerbatim}
\end{quote}


\subsection{Installing on ALCF Theta, Cray XC40}
\label{\detokenize{installation:installing-on-alcf-theta-cray-xc40}}
Theta is a 9.65 petaflops system manufactured by Cray with 3,624 compute nodes.
Each node features a second\sphinxhyphen{}generation Intel Xeon Phi 7230 processor and 192 GB DDR4 RAM.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{export} \PYG{n}{CRAYPE\PYGZus{}LINK\PYGZus{}TYPE}\PYG{o}{=}\PYG{n}{dynamic}
\PYG{c+c1}{\PYGZsh{} Do not use cmake 3.9.1, it causes trouble with parallel HDF5.}
\PYG{n}{module} \PYG{n}{load} \PYG{n}{cmake}\PYG{o}{/}\PYG{l+m+mf}{3.11}\PYG{o}{.}\PYG{l+m+mi}{4}
\PYG{n}{module} \PYG{n}{unload} \PYG{n}{cray}\PYG{o}{\PYGZhy{}}\PYG{n}{libsci}
\PYG{n}{module} \PYG{n}{load} \PYG{n}{cray}\PYG{o}{\PYGZhy{}}\PYG{n}{hdf5}\PYG{o}{\PYGZhy{}}\PYG{n}{parallel}
\PYG{n}{module} \PYG{n}{load} \PYG{n}{gcc}   \PYG{c+c1}{\PYGZsh{} Make C++ 14 standard library available to the Intel compiler}
\PYG{n}{export} \PYG{n}{BOOST\PYGZus{}ROOT}\PYG{o}{=}\PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{libraries}\PYG{o}{/}\PYG{n}{boost}\PYG{o}{/}\PYG{l+m+mf}{1.64}\PYG{o}{.}\PYG{l+m+mi}{0}\PYG{o}{/}\PYG{n}{intel}
\PYG{n}{cmake} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{l+m+mi}{24}
\PYG{n}{ls} \PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{qmcpack}
\end{sphinxVerbatim}


\subsection{Installing on ORNL OLCF Summit}
\label{\detokenize{installation:installing-on-ornl-olcf-summit}}
Summit is an IBM system at the ORNL OLCF built with IBM Power System AC922
nodes. They have two IBM Power 9 processors and six NVIDIA Volta V100
accelerators.


\subsubsection{Building QMCPACK}
\label{\detokenize{installation:building-qmcpack}}
Note that these build instructions are preliminary as the
software environment is subject to change. As of December 2018, the
IBM XL compiler does not support C++14, so we currently use the
gnu compiler.

For ease of reproducibility we provide build scripts for Summit.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{qmcpack}
\PYG{o}{.}\PYG{o}{/}\PYG{n}{config}\PYG{o}{/}\PYG{n}{build\PYGZus{}olcf\PYGZus{}summit}\PYG{o}{.}\PYG{n}{sh}
\PYG{n}{ls} \PYG{n+nb}{bin}
\end{sphinxVerbatim}


\subsubsection{Building Quantum Espresso}
\label{\detokenize{installation:building-quantum-espresso}}
We provide a build script for the v6.4.1 release of Quantum Espresso (QE).
The following can be used to build a CPU version of QE on Summit,
placing the script in the external\_codes/quantum\_espresso directory.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{external\PYGZus{}codes}\PYG{o}{/}\PYG{n}{quantum\PYGZus{}espresso}
\PYG{o}{.}\PYG{o}{/}\PYG{n}{build\PYGZus{}qe\PYGZus{}olcf\PYGZus{}summit}\PYG{o}{.}\PYG{n}{sh}
\end{sphinxVerbatim}

Note that performance is
not yet optimized although vendor libraries are
used. Alternatively, the wavefunction files can be generated on
another system and the converted HDF5 files copied over.


\subsection{Installing on NERSC Cori, Haswell Partition, Cray XC40}
\label{\detokenize{installation:installing-on-nersc-cori-haswell-partition-cray-xc40}}
Cori is a Cray XC40 that includes 16\sphinxhyphen{}core Intel “Haswell” nodes
installed at NERSC. In the following example, the source code is
cloned in \$HOME/qmc/git\_QMCPACK and QMCPACK is built in the scratch
space.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mkdir \PYGZdl{}HOME/qmc
mkdir \PYGZdl{}HOME/qmc/git\PYGZus{}QMCPACK
cd \PYGZdl{}HOME/qmc\PYGZus{}git\PYGZus{}QMCPACK
git clone https://github.com/QMCPACK/qmcpack.git
cd qmcpack
git checkout v3.7.0 \PYGZsh{} Edit for desired version
export CRAYPE\PYGZus{}LINK\PYGZus{}TYPE=dynamic
module unload cray\PYGZhy{}libsci
module load boost/1.70.0
module load cray\PYGZhy{}hdf5\PYGZhy{}parallel
module load cmake/3.14.0
module load gcc/7.3.0 \PYGZsh{} Make C++ 14 standard library available to the Intel compiler
cd \PYGZdl{}SCRATCH
mkdir build\PYGZus{}cori\PYGZus{}hsw
cd build\PYGZus{}cori\PYGZus{}hsw
cmake \PYGZhy{}DQMC\PYGZus{}SYMLINK\PYGZus{}TEST\PYGZus{}FILES=0 \PYGZdl{}HOME/qmc/git\PYGZus{}QMCPACK/qmcpack/
nice make \PYGZhy{}j 8
ls \PYGZhy{}l bin/qmcpack
\end{sphinxVerbatim}

When the preceding was tested on May 16, 2019, the following module and
software versions were present:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{build\PYGZus{}cori\PYGZus{}hsw}\PYG{o}{\PYGZgt{}} \PYG{n}{module} \PYG{n+nb}{list}
\PYG{n}{Currently} \PYG{n}{Loaded} \PYG{n}{Modulefiles}\PYG{p}{:}
\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{modules}\PYG{o}{/}\PYG{l+m+mf}{3.2}\PYG{o}{.}\PYG{l+m+mf}{10.6}                                   \PYG{l+m+mi}{14}\PYG{p}{)} \PYG{n}{alps}\PYG{o}{/}\PYG{l+m+mf}{6.6}\PYG{o}{.}\PYG{l+m+mi}{43}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mf}{7.1\PYGZus{}5}\PYG{o}{.}\PYG{l+m+mi}{45}\PYG{n}{\PYGZus{}\PYGZus{}ga796da32}\PYG{o}{.}\PYG{n}{ari}
\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{n}{nsg}\PYG{o}{/}\PYG{l+m+mf}{1.2}\PYG{o}{.}\PYG{l+m+mi}{0}                                          \PYG{l+m+mi}{15}\PYG{p}{)} \PYG{n}{rca}\PYG{o}{/}\PYG{l+m+mf}{2.2}\PYG{o}{.}\PYG{l+m+mi}{18}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mf}{7.1\PYGZus{}5}\PYG{o}{.}\PYG{l+m+mi}{47}\PYG{n}{\PYGZus{}\PYGZus{}g2aa4f39}\PYG{o}{.}\PYG{n}{ari}
\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mf}{18.0}\PYG{o}{.}\PYG{l+m+mf}{1.163}                                   \PYG{l+m+mi}{16}\PYG{p}{)} \PYG{n}{atp}\PYG{o}{/}\PYG{l+m+mf}{2.1}\PYG{o}{.}\PYG{l+m+mi}{3}
\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{n}{craype}\PYG{o}{\PYGZhy{}}\PYG{n}{network}\PYG{o}{\PYGZhy{}}\PYG{n}{aries}                               \PYG{l+m+mi}{17}\PYG{p}{)} \PYG{n}{PrgEnv}\PYG{o}{\PYGZhy{}}\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mi}{4}
\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{n}{craype}\PYG{o}{/}\PYG{l+m+mf}{2.5}\PYG{o}{.}\PYG{l+m+mi}{15}                                      \PYG{l+m+mi}{18}\PYG{p}{)} \PYG{n}{craype}\PYG{o}{\PYGZhy{}}\PYG{n}{haswell}
\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{n}{udreg}\PYG{o}{/}\PYG{l+m+mf}{2.3}\PYG{o}{.}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mf}{7.1\PYGZus{}5}\PYG{o}{.}\PYG{l+m+mi}{13}\PYG{n}{\PYGZus{}\PYGZus{}g5196236}\PYG{o}{.}\PYG{n}{ari}             \PYG{l+m+mi}{19}\PYG{p}{)} \PYG{n}{cray}\PYG{o}{\PYGZhy{}}\PYG{n}{mpich}\PYG{o}{/}\PYG{l+m+mf}{7.7}\PYG{o}{.}\PYG{l+m+mi}{3}
\PYG{l+m+mi}{7}\PYG{p}{)} \PYG{n}{ugni}\PYG{o}{/}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mf}{14.0}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mf}{7.1\PYGZus{}3}\PYG{o}{.}\PYG{l+m+mi}{13}\PYG{n}{\PYGZus{}\PYGZus{}gea11d3d}\PYG{o}{.}\PYG{n}{ari}           \PYG{l+m+mi}{20}\PYG{p}{)} \PYG{n}{gcc}\PYG{o}{/}\PYG{l+m+mf}{7.3}\PYG{o}{.}\PYG{l+m+mi}{0}
\PYG{l+m+mi}{8}\PYG{p}{)} \PYG{n}{pmi}\PYG{o}{/}\PYG{l+m+mf}{5.0}\PYG{o}{.}\PYG{l+m+mi}{14}                                         \PYG{l+m+mi}{21}\PYG{p}{)} \PYG{n}{altd}\PYG{o}{/}\PYG{l+m+mf}{2.0}
\PYG{l+m+mi}{9}\PYG{p}{)} \PYG{n}{dmapp}\PYG{o}{/}\PYG{l+m+mf}{7.1}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mf}{7.1\PYGZus{}5}\PYG{o}{.}\PYG{l+m+mi}{45}\PYG{n}{\PYGZus{}\PYGZus{}g5a674e0}\PYG{o}{.}\PYG{n}{ari}             \PYG{l+m+mi}{22}\PYG{p}{)} \PYG{n}{darshan}\PYG{o}{/}\PYG{l+m+mf}{3.1}\PYG{o}{.}\PYG{l+m+mi}{4}
\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{n}{gni}\PYG{o}{\PYGZhy{}}\PYG{n}{headers}\PYG{o}{/}\PYG{l+m+mf}{5.0}\PYG{o}{.}\PYG{l+m+mf}{12.0}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mf}{7.1\PYGZus{}3}\PYG{o}{.}\PYG{l+m+mi}{11}\PYG{n}{\PYGZus{}\PYGZus{}g3b1768f}\PYG{o}{.}\PYG{n}{ari}   \PYG{l+m+mi}{23}\PYG{p}{)} \PYG{n}{boost}\PYG{o}{/}\PYG{l+m+mf}{1.70}\PYG{o}{.}\PYG{l+m+mi}{0}
\PYG{l+m+mi}{11}\PYG{p}{)} \PYG{n}{xpmem}\PYG{o}{/}\PYG{l+m+mf}{2.2}\PYG{o}{.}\PYG{l+m+mi}{15}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mf}{7.1\PYGZus{}5}\PYG{o}{.}\PYG{l+m+mi}{11}\PYG{n}{\PYGZus{}\PYGZus{}g7549d06}\PYG{o}{.}\PYG{n}{ari}           \PYG{l+m+mi}{24}\PYG{p}{)} \PYG{n}{cray}\PYG{o}{\PYGZhy{}}\PYG{n}{hdf5}\PYG{o}{\PYGZhy{}}\PYG{n}{parallel}\PYG{o}{/}\PYG{l+m+mf}{1.10}\PYG{o}{.}\PYG{l+m+mf}{2.0}
\PYG{l+m+mi}{12}\PYG{p}{)} \PYG{n}{job}\PYG{o}{/}\PYG{l+m+mf}{2.2}\PYG{o}{.}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mf}{7.1\PYGZus{}5}\PYG{o}{.}\PYG{l+m+mi}{43}\PYG{n}{\PYGZus{}\PYGZus{}g6c4e934}\PYG{o}{.}\PYG{n}{ari}              \PYG{l+m+mi}{25}\PYG{p}{)} \PYG{n}{cmake}\PYG{o}{/}\PYG{l+m+mf}{3.14}\PYG{o}{.}\PYG{l+m+mi}{0}
\PYG{l+m+mi}{13}\PYG{p}{)} \PYG{n}{dvs}\PYG{o}{/}\PYG{l+m+mf}{2.7\PYGZus{}2}\PYG{o}{.}\PYG{l+m+mf}{2.118}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mf}{7.1\PYGZus{}10}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{n}{\PYGZus{}\PYGZus{}g58b37a2}
\end{sphinxVerbatim}

The following slurm job file can be used to run the tests:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{}!/bin/bash
\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}qos=debug
\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}time=00:10:00
\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}nodes=1
\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}tasks\PYGZhy{}per\PYGZhy{}node=32
\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}constraint=haswell
echo \PYGZhy{}\PYGZhy{}\PYGZhy{} Start `date`
echo \PYGZhy{}\PYGZhy{}\PYGZhy{} Working directory: `pwd`
ctest \PYGZhy{}VV \PYGZhy{}R deterministic
echo \PYGZhy{}\PYGZhy{}\PYGZhy{} End `date`
\end{sphinxVerbatim}


\subsection{Installing on NERSC Cori, Xeon Phi KNL partition, Cray XC40}
\label{\detokenize{installation:installing-on-nersc-cori-xeon-phi-knl-partition-cray-xc40}}
Cori is a Cray XC40 that includes Intel Xeon Phi Knight’s Landing (KNL) nodes. The following build recipe ensures that the code
generation is appropriate for the KNL nodes. The source is assumed to
be in \$HOME/qmc/git\_QMCPACK/qmcpack as per the Haswell example.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
export CRAYPE\PYGZus{}LINK\PYGZus{}TYPE=dynamic
module swap craype\PYGZhy{}haswell craype\PYGZhy{}mic\PYGZhy{}knl \PYGZsh{} Only difference between Haswell and KNL recipes
module unload cray\PYGZhy{}libsci
module load boost/1.70.0
module load cray\PYGZhy{}hdf5\PYGZhy{}parallel
module load cmake/3.14.0
module load gcc/7.3.0 \PYGZsh{} Make C++ 14 standard library available to the Intel compiler
cd \PYGZdl{}SCRATCH
mkdir build\PYGZus{}cori\PYGZus{}knl
cd build\PYGZus{}cori\PYGZus{}knl
cmake \PYGZhy{}DQMC\PYGZus{}SYMLINK\PYGZus{}TEST\PYGZus{}FILES=0 \PYGZdl{}HOME/git\PYGZus{}QMCPACK/qmcpack/
nice make \PYGZhy{}j 8
ls \PYGZhy{}l bin/qmcpack
\end{sphinxVerbatim}

When the preceding was tested on May 16, 2019, the following module and
software versions were present:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{build\PYGZus{}cori\PYGZus{}knl}\PYG{o}{\PYGZgt{}} \PYG{n}{module} \PYG{n+nb}{list}
  \PYG{n}{Currently} \PYG{n}{Loaded} \PYG{n}{Modulefiles}\PYG{p}{:}
  \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{modules}\PYG{o}{/}\PYG{l+m+mf}{3.2}\PYG{o}{.}\PYG{l+m+mf}{10.6}                                  \PYG{l+m+mi}{14}\PYG{p}{)} \PYG{n}{alps}\PYG{o}{/}\PYG{l+m+mf}{6.6}\PYG{o}{.}\PYG{l+m+mi}{43}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mf}{7.1\PYGZus{}5}\PYG{o}{.}\PYG{l+m+mi}{45}\PYG{n}{\PYGZus{}\PYGZus{}ga796da32}\PYG{o}{.}\PYG{n}{ari}
  \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{n}{nsg}\PYG{o}{/}\PYG{l+m+mf}{1.2}\PYG{o}{.}\PYG{l+m+mi}{0}                                         \PYG{l+m+mi}{15}\PYG{p}{)} \PYG{n}{rca}\PYG{o}{/}\PYG{l+m+mf}{2.2}\PYG{o}{.}\PYG{l+m+mi}{18}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mf}{7.1\PYGZus{}5}\PYG{o}{.}\PYG{l+m+mi}{47}\PYG{n}{\PYGZus{}\PYGZus{}g2aa4f39}\PYG{o}{.}\PYG{n}{ari}
  \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mf}{18.0}\PYG{o}{.}\PYG{l+m+mf}{1.163}                                  \PYG{l+m+mi}{16}\PYG{p}{)} \PYG{n}{atp}\PYG{o}{/}\PYG{l+m+mf}{2.1}\PYG{o}{.}\PYG{l+m+mi}{3}
  \PYG{l+m+mi}{4}\PYG{p}{)} \PYG{n}{craype}\PYG{o}{\PYGZhy{}}\PYG{n}{network}\PYG{o}{\PYGZhy{}}\PYG{n}{aries}                              \PYG{l+m+mi}{17}\PYG{p}{)} \PYG{n}{PrgEnv}\PYG{o}{\PYGZhy{}}\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mi}{4}
  \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{n}{craype}\PYG{o}{/}\PYG{l+m+mf}{2.5}\PYG{o}{.}\PYG{l+m+mi}{15}                                     \PYG{l+m+mi}{18}\PYG{p}{)} \PYG{n}{craype}\PYG{o}{\PYGZhy{}}\PYG{n}{mic}\PYG{o}{\PYGZhy{}}\PYG{n}{knl}
  \PYG{l+m+mi}{6}\PYG{p}{)} \PYG{n}{udreg}\PYG{o}{/}\PYG{l+m+mf}{2.3}\PYG{o}{.}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mf}{7.1\PYGZus{}5}\PYG{o}{.}\PYG{l+m+mi}{13}\PYG{n}{\PYGZus{}\PYGZus{}g5196236}\PYG{o}{.}\PYG{n}{ari}            \PYG{l+m+mi}{19}\PYG{p}{)} \PYG{n}{cray}\PYG{o}{\PYGZhy{}}\PYG{n}{mpich}\PYG{o}{/}\PYG{l+m+mf}{7.7}\PYG{o}{.}\PYG{l+m+mi}{3}
  \PYG{l+m+mi}{7}\PYG{p}{)} \PYG{n}{ugni}\PYG{o}{/}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mf}{14.0}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mf}{7.1\PYGZus{}3}\PYG{o}{.}\PYG{l+m+mi}{13}\PYG{n}{\PYGZus{}\PYGZus{}gea11d3d}\PYG{o}{.}\PYG{n}{ari}          \PYG{l+m+mi}{20}\PYG{p}{)} \PYG{n}{gcc}\PYG{o}{/}\PYG{l+m+mf}{7.3}\PYG{o}{.}\PYG{l+m+mi}{0}
  \PYG{l+m+mi}{8}\PYG{p}{)} \PYG{n}{pmi}\PYG{o}{/}\PYG{l+m+mf}{5.0}\PYG{o}{.}\PYG{l+m+mi}{14}                                        \PYG{l+m+mi}{21}\PYG{p}{)} \PYG{n}{altd}\PYG{o}{/}\PYG{l+m+mf}{2.0}
  \PYG{l+m+mi}{9}\PYG{p}{)} \PYG{n}{dmapp}\PYG{o}{/}\PYG{l+m+mf}{7.1}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mf}{7.1\PYGZus{}5}\PYG{o}{.}\PYG{l+m+mi}{45}\PYG{n}{\PYGZus{}\PYGZus{}g5a674e0}\PYG{o}{.}\PYG{n}{ari}            \PYG{l+m+mi}{22}\PYG{p}{)} \PYG{n}{darshan}\PYG{o}{/}\PYG{l+m+mf}{3.1}\PYG{o}{.}\PYG{l+m+mi}{4}
  \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{n}{gni}\PYG{o}{\PYGZhy{}}\PYG{n}{headers}\PYG{o}{/}\PYG{l+m+mf}{5.0}\PYG{o}{.}\PYG{l+m+mf}{12.0}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mf}{7.1\PYGZus{}3}\PYG{o}{.}\PYG{l+m+mi}{11}\PYG{n}{\PYGZus{}\PYGZus{}g3b1768f}\PYG{o}{.}\PYG{n}{ari}  \PYG{l+m+mi}{23}\PYG{p}{)} \PYG{n}{boost}\PYG{o}{/}\PYG{l+m+mf}{1.70}\PYG{o}{.}\PYG{l+m+mi}{0}
  \PYG{l+m+mi}{11}\PYG{p}{)} \PYG{n}{xpmem}\PYG{o}{/}\PYG{l+m+mf}{2.2}\PYG{o}{.}\PYG{l+m+mi}{15}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mf}{7.1\PYGZus{}5}\PYG{o}{.}\PYG{l+m+mi}{11}\PYG{n}{\PYGZus{}\PYGZus{}g7549d06}\PYG{o}{.}\PYG{n}{ari}          \PYG{l+m+mi}{24}\PYG{p}{)} \PYG{n}{cray}\PYG{o}{\PYGZhy{}}\PYG{n}{hdf5}\PYG{o}{\PYGZhy{}}\PYG{n}{parallel}\PYG{o}{/}\PYG{l+m+mf}{1.10}\PYG{o}{.}\PYG{l+m+mf}{2.0}
  \PYG{l+m+mi}{12}\PYG{p}{)} \PYG{n}{job}\PYG{o}{/}\PYG{l+m+mf}{2.2}\PYG{o}{.}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mf}{7.1\PYGZus{}5}\PYG{o}{.}\PYG{l+m+mi}{43}\PYG{n}{\PYGZus{}\PYGZus{}g6c4e934}\PYG{o}{.}\PYG{n}{ari}             \PYG{l+m+mi}{25}\PYG{p}{)} \PYG{n}{cmake}\PYG{o}{/}\PYG{l+m+mf}{3.14}\PYG{o}{.}\PYG{l+m+mi}{0}
  \PYG{l+m+mi}{13}\PYG{p}{)} \PYG{n}{dvs}\PYG{o}{/}\PYG{l+m+mf}{2.7\PYGZus{}2}\PYG{o}{.}\PYG{l+m+mf}{2.118}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0}\PYG{o}{.}\PYG{l+m+mf}{7.1\PYGZus{}10}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{n}{\PYGZus{}\PYGZus{}g58b37a2}
\end{sphinxVerbatim}


\subsection{Installing on systems with ARMv8\sphinxhyphen{}based processors}
\label{\detokenize{installation:installing-on-systems-with-armv8-based-processors}}
The following build recipe was verified using the ‘Arm Compiler for HPC’ on the ANL JLSE Comanche system with Cavium ThunderX2 processors on November 6, 2018.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} load armclang compiler}
\PYG{n}{module} \PYG{n}{load} \PYG{n}{Generic}\PYG{o}{\PYGZhy{}}\PYG{n}{AArch64}\PYG{o}{/}\PYG{n}{RHEL}\PYG{o}{/}\PYG{l+m+mi}{7}\PYG{o}{/}\PYG{n}{arm}\PYG{o}{\PYGZhy{}}\PYG{n}{hpc}\PYG{o}{\PYGZhy{}}\PYG{n}{compiler}\PYG{o}{/}\PYG{l+m+mf}{18.4}
\PYG{c+c1}{\PYGZsh{} load Arm performance libraries}
\PYG{n}{module} \PYG{n}{load} \PYG{n}{ThunderX2CN99}\PYG{o}{/}\PYG{n}{RHEL}\PYG{o}{/}\PYG{l+m+mi}{7}\PYG{o}{/}\PYG{n}{arm}\PYG{o}{\PYGZhy{}}\PYG{n}{hpc}\PYG{o}{\PYGZhy{}}\PYG{n}{compiler}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{18.4}\PYG{o}{/}\PYG{n}{armpl}\PYG{o}{/}\PYG{l+m+mf}{18.4}\PYG{o}{.}\PYG{l+m+mi}{0}
\PYG{c+c1}{\PYGZsh{} define path to pre\PYGZhy{}installed packages}
\PYG{n}{export} \PYG{n}{HDF5\PYGZus{}ROOT}\PYG{o}{=}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{path}\PYG{o}{/}\PYG{n}{to}\PYG{o}{/}\PYG{n}{hdf5}\PYG{o}{/}\PYG{n}{install}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{n}{export} \PYG{n}{BOOST\PYGZus{}ROOT}\PYG{o}{=}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{path}\PYG{o}{/}\PYG{n}{to}\PYG{o}{/}\PYG{n}{boost}\PYG{o}{/}\PYG{n}{install}\PYG{o}{\PYGZgt{}} \PYG{c+c1}{\PYGZsh{} header\PYGZhy{}only, no need to build}
\end{sphinxVerbatim}

Then using the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mkdir} \PYG{n}{build\PYGZus{}armclang}
\PYG{n}{cd} \PYG{n}{build\PYGZus{}armclang}
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}C\PYGZus{}COMPILER}\PYG{o}{=}\PYG{n}{armclang} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}CXX\PYGZus{}COMPILER}\PYG{o}{=}\PYG{n}{armclang}\PYG{o}{+}\PYG{o}{+} \PYG{o}{\PYGZhy{}}\PYG{n}{DQMC\PYGZus{}MPI}\PYG{o}{=}\PYG{l+m+mi}{0} \PYGZbs{}
    \PYG{o}{\PYGZhy{}}\PYG{n}{DLAPACK\PYGZus{}LIBRARIES}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}L\PYGZdl{}ARMPL\PYGZus{}DIR/lib \PYGZhy{}larmpl\PYGZus{}mp}\PYG{l+s+s2}{\PYGZdq{}} \PYGZbs{}
    \PYG{o}{\PYGZhy{}}\PYG{n}{DFFTW\PYGZus{}INCLUDE\PYGZus{}DIR}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}ARMPL\PYGZus{}DIR/include}\PYG{l+s+s2}{\PYGZdq{}} \PYGZbs{}
    \PYG{o}{\PYGZhy{}}\PYG{n}{DFFTW\PYGZus{}LIBRARIES}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}ARMPL\PYGZus{}DIR/lib/libarmpl\PYGZus{}mp.a}\PYG{l+s+s2}{\PYGZdq{}} \PYGZbs{}
    \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{l+m+mi}{56}
\end{sphinxVerbatim}

Note that armclang is recognized as an {\color{red}\bfseries{}\textasciigrave{}}unknown’ compiler by CMake v3.13* and below. In this case, we need to force it as clang to apply necessary flags. To do so, pass the following additionals option to CMake:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}C\PYGZus{}COMPILER\PYGZus{}ID}\PYG{o}{=}\PYG{n}{Clang} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}CXX\PYGZus{}COMPILER\PYGZus{}ID}\PYG{o}{=}\PYG{n}{Clang} \PYGZbs{}
\PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}CXX\PYGZus{}COMPILER\PYGZus{}VERSION}\PYG{o}{=}\PYG{l+m+mf}{5.0} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}CXX\PYGZus{}STANDARD\PYGZus{}COMPUTED\PYGZus{}DEFAULT}\PYG{o}{=}\PYG{l+m+mi}{98} \PYGZbs{}
\end{sphinxVerbatim}


\subsection{Installing on Windows}
\label{\detokenize{installation:installing-on-windows}}
Install the Windows Subsystem for Linux and Bash on Windows.
Open a bash shell and follow the install directions for Ubuntu in {\hyperref[\detokenize{installation:buildubuntu}]{\sphinxcrossref{\DUrole{std,std-ref}{Installing on Ubuntu Linux or other apt\sphinxhyphen{}get\textendash{}based distributions}}}}.


\section{Installing via Spack}
\label{\detokenize{installation:installing-via-spack}}
Spack is a package manager for scientific software.
One of the primary goals of Spack is to reduce the barrier for users to install scientific
software. Spack is intended to work on everything from laptop
computers to high\sphinxhyphen{}end supercomputers. More information about Spack can
be found at \sphinxurl{https://spack.readthedocs.io/en/latest}. The major
advantage of installation with Spack is that all dependencies are
automatically built, potentially including all the compilers and libraries, and
different versions of QMCPACK can easily coexist with each other.
The QMCPACK Spack package also knows how to automatically build
and patch QE. In principle, QMCPACK can be installed with
a single Spack command.


\subsection{Known limitations}
\label{\detokenize{installation:known-limitations}}
The QMCPACK Spack package inherits the limitations of the underlying
Spack infrastructure and its dependencies. The main limitation is that
installation can fail when building a dependency such as HDF5, MPICH,
etc. For \sphinxcode{\sphinxupquote{spack install qmcpack}} to succeed, it is very
important to leverage preinstalled packages on your computer or
supercomputer. The other frequently encountered challenge is that the
compiler configuration is nonintuitive.  This is especially the case
with the Intel compiler. If you encounter any difficulties, we
recommend testing the Spack compiler configuration on a simpler
packages, e.g. HDF5.

Here are some additional limitations of the QMCPACK Spack package that
will be resolved in future releases:
\begin{itemize}
\item {} 
CUDA support in Spack still has some limitations.  It will
catch only some compiler\sphinxhyphen{}CUDA conflicts.

\item {} 
The Intel compiler must find a recent and compatible GCC
compiler in its path or one must be explicity set with the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}gcc\sphinxhyphen{}name}} and \sphinxcode{\sphinxupquote{\sphinxhyphen{}gxx\sphinxhyphen{}name}} flags.

\end{itemize}


\subsection{Setting up the Spack environment}
\label{\detokenize{installation:setting-up-the-spack-environment}}
Begin by cloning Spack from GitHub and configuring your shell as described at
\sphinxurl{https://spack.readthedocs.io/en/latest/getting\_started.html}.

The goal of the next several steps is to set up the Spack environment
for building. First, we highly recommend limiting the number of build jobs to
a reasonable value for your machine. This can be
accomplished by modifying your \sphinxcode{\sphinxupquote{\textasciitilde{}/.spack/config.yaml}} file as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{config}\PYG{p}{:}
  \PYG{n}{build\PYGZus{}jobs}\PYG{p}{:} \PYG{l+m+mi}{16}
\end{sphinxVerbatim}

Make sure any existing compilers are properly detected. For many
architectures, compilers are properly detected with no additional
effort.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{spack} \PYG{n}{compilers}
\PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{Available} \PYG{n}{compilers}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{gcc} \PYG{n}{sierra}\PYG{o}{\PYGZhy{}}\PYG{n}{x86\PYGZus{}64} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{n}{gcc}\PYG{o}{@}\PYG{l+m+mf}{7.2}\PYG{o}{.}\PYG{l+m+mi}{0}  \PYG{n}{gcc}\PYG{o}{@}\PYG{l+m+mf}{6.4}\PYG{o}{.}\PYG{l+m+mi}{0}  \PYG{n}{gcc}\PYG{o}{@}\PYG{l+m+mf}{5.5}\PYG{o}{.}\PYG{l+m+mi}{0}  \PYG{n}{gcc}\PYG{o}{@}\PYG{l+m+mf}{4.9}\PYG{o}{.}\PYG{l+m+mi}{4}  \PYG{n}{gcc}\PYG{o}{@}\PYG{l+m+mf}{4.8}\PYG{o}{.}\PYG{l+m+mi}{5}  \PYG{n}{gcc}\PYG{o}{@}\PYG{l+m+mf}{4.7}\PYG{o}{.}\PYG{l+m+mi}{4}  \PYG{n}{gcc}\PYG{o}{@}\PYG{l+m+mf}{4.6}\PYG{o}{.}\PYG{l+m+mi}{4}
\end{sphinxVerbatim}

However, if your compiler is not automatically detected, it is straightforward
to add one:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{spack} \PYG{n}{compiler} \PYG{n}{add} \PYG{o}{\PYGZlt{}}\PYG{n}{path}\PYG{o}{\PYGZhy{}}\PYG{n}{to}\PYG{o}{\PYGZhy{}}\PYG{n}{compiler}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

The Intel compiler, and other commerical compilers like PGI, typically
require extra environment variables to work properly. If you have an
module environment set\sphinxhyphen{}up by your system administrators, it is
recommended that you set the module name in
\sphinxcode{\sphinxupquote{\textasciitilde{}/.spack/linux/compilers.yaml}}. Here is an example for the
Intel compiler:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}} \PYG{n}{compiler}\PYG{p}{:}
  \PYG{n}{environment}\PYG{p}{:}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
  \PYG{n}{extra\PYGZus{}rpaths}\PYG{p}{:}  \PYG{p}{[}\PYG{p}{]}
  \PYG{n}{flags}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
  \PYG{n}{modules}\PYG{p}{:}
  \PYG{o}{\PYGZhy{}} \PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mf}{18.0}\PYG{o}{.}\PYG{l+m+mi}{3}
  \PYG{n}{operating\PYGZus{}system}\PYG{p}{:} \PYG{n}{ubuntu14}\PYG{o}{.}\PYG{l+m+mi}{04}
  \PYG{n}{paths}\PYG{p}{:}
    \PYG{n}{cc}\PYG{p}{:} \PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{com}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mi}{18}\PYG{o}{/}\PYG{n}{u3}\PYG{o}{/}\PYG{n}{compilers\PYGZus{}and\PYGZus{}libraries\PYGZus{}2018}\PYG{o}{.}\PYG{l+m+mf}{3.222}\PYG{o}{/}\PYG{n}{linux}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{intel64}\PYG{o}{/}\PYG{n}{icc}
    \PYG{n}{cxx}\PYG{p}{:} \PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{com}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mi}{18}\PYG{o}{/}\PYG{n}{u3}\PYG{o}{/}\PYG{n}{compilers\PYGZus{}and\PYGZus{}libraries\PYGZus{}2018}\PYG{o}{.}\PYG{l+m+mf}{3.222}\PYG{o}{/}\PYG{n}{linux}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{intel64}\PYG{o}{/}\PYG{n}{icpc}
    \PYG{n}{f77}\PYG{p}{:} \PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{com}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mi}{18}\PYG{o}{/}\PYG{n}{u3}\PYG{o}{/}\PYG{n}{compilers\PYGZus{}and\PYGZus{}libraries\PYGZus{}2018}\PYG{o}{.}\PYG{l+m+mf}{3.222}\PYG{o}{/}\PYG{n}{linux}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{intel64}\PYG{o}{/}\PYG{n}{ifort}
    \PYG{n}{fc}\PYG{p}{:} \PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{com}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mi}{18}\PYG{o}{/}\PYG{n}{u3}\PYG{o}{/}\PYG{n}{compilers\PYGZus{}and\PYGZus{}libraries\PYGZus{}2018}\PYG{o}{.}\PYG{l+m+mf}{3.222}\PYG{o}{/}\PYG{n}{linux}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{intel64}\PYG{o}{/}\PYG{n}{ifort}
  \PYG{n}{spec}\PYG{p}{:} \PYG{n}{intel}\PYG{o}{@}\PYG{l+m+mf}{18.0}\PYG{o}{.}\PYG{l+m+mi}{3}
  \PYG{n}{target}\PYG{p}{:} \PYG{n}{x86\PYGZus{}64}
\end{sphinxVerbatim}

If a module is not available, you will have to set\sphinxhyphen{}up the environment variables manually:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}} \PYG{n}{compiler}\PYG{p}{:}
  \PYG{n}{environment}\PYG{p}{:}
    \PYG{n+nb}{set}\PYG{p}{:}
      \PYG{n}{INTEL\PYGZus{}LICENSE\PYGZus{}FILE}\PYG{p}{:} \PYG{n}{server}\PYG{n+nd}{@national}\PYG{o}{\PYGZhy{}}\PYG{n}{lab}\PYG{o}{.}\PYG{n}{doe}\PYG{o}{.}\PYG{n}{gov}
  \PYG{n}{extra\PYGZus{}rpaths}\PYG{p}{:}
  \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/soft/com/packages/intel/18/u3/compilers\PYGZus{}and\PYGZus{}libraries\PYGZus{}2018.3.222/linux/compiler/lib/intel64}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/soft/apps/packages/gcc/gcc\PYGZhy{}6.2.0/lib64}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
  \PYG{n}{flags}\PYG{p}{:}
    \PYG{n}{cflags}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{n}{gcc}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{=}\PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{apps}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{/}\PYG{n}{gcc}\PYG{o}{/}\PYG{n}{gcc}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.2}\PYG{o}{.}\PYG{l+m+mi}{0}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{gcc}
    \PYG{n}{fflags}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{n}{gcc}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{=}\PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{apps}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{/}\PYG{n}{gcc}\PYG{o}{/}\PYG{n}{gcc}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.2}\PYG{o}{.}\PYG{l+m+mi}{0}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{gcc}
    \PYG{n}{cxxflags}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{n}{gxx}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{=}\PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{apps}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{/}\PYG{n}{gcc}\PYG{o}{/}\PYG{n}{gcc}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.2}\PYG{o}{.}\PYG{l+m+mi}{0}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{g}\PYG{o}{+}\PYG{o}{+}
  \PYG{n}{modules}\PYG{p}{:} \PYG{p}{[}\PYG{p}{]}
  \PYG{n}{operating\PYGZus{}system}\PYG{p}{:} \PYG{n}{ubuntu14}\PYG{o}{.}\PYG{l+m+mi}{04}
  \PYG{n}{paths}\PYG{p}{:}
    \PYG{n}{cc}\PYG{p}{:} \PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{com}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mi}{18}\PYG{o}{/}\PYG{n}{u3}\PYG{o}{/}\PYG{n}{compilers\PYGZus{}and\PYGZus{}libraries\PYGZus{}2018}\PYG{o}{.}\PYG{l+m+mf}{3.222}\PYG{o}{/}\PYG{n}{linux}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{intel64}\PYG{o}{/}\PYG{n}{icc}
    \PYG{n}{cxx}\PYG{p}{:} \PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{com}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mi}{18}\PYG{o}{/}\PYG{n}{u3}\PYG{o}{/}\PYG{n}{compilers\PYGZus{}and\PYGZus{}libraries\PYGZus{}2018}\PYG{o}{.}\PYG{l+m+mf}{3.222}\PYG{o}{/}\PYG{n}{linux}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{intel64}\PYG{o}{/}\PYG{n}{icpc}
    \PYG{n}{f77}\PYG{p}{:} \PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{com}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mi}{18}\PYG{o}{/}\PYG{n}{u3}\PYG{o}{/}\PYG{n}{compilers\PYGZus{}and\PYGZus{}libraries\PYGZus{}2018}\PYG{o}{.}\PYG{l+m+mf}{3.222}\PYG{o}{/}\PYG{n}{linux}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{intel64}\PYG{o}{/}\PYG{n}{ifort}
    \PYG{n}{fc}\PYG{p}{:} \PYG{o}{/}\PYG{n}{soft}\PYG{o}{/}\PYG{n}{com}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mi}{18}\PYG{o}{/}\PYG{n}{u3}\PYG{o}{/}\PYG{n}{compilers\PYGZus{}and\PYGZus{}libraries\PYGZus{}2018}\PYG{o}{.}\PYG{l+m+mf}{3.222}\PYG{o}{/}\PYG{n}{linux}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{intel64}\PYG{o}{/}\PYG{n}{ifort}
  \PYG{n}{spec}\PYG{p}{:} \PYG{n}{intel}\PYG{o}{@}\PYG{l+m+mf}{18.0}\PYG{o}{.}\PYG{l+m+mi}{3}
  \PYG{n}{target}\PYG{p}{:} \PYG{n}{x86\PYGZus{}64}
\end{sphinxVerbatim}

This last step is the most troublesome. Pre\sphinxhyphen{}installed packages are not
automatically detected. If vendor optimized libraries are already
installed, you will need to manually add them to your
\sphinxcode{\sphinxupquote{\textasciitilde{}/.spack/packages.yaml}}. For example, this works on Mac OS X
for the Intel MKL package.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{cat} \PYGZbs{}\PYG{o}{\PYGZti{}}\PYG{o}{/}\PYG{o}{.}\PYG{n}{spack}\PYG{o}{/}\PYG{n}{packages}\PYG{o}{.}\PYG{n}{yaml}
\PYG{n}{packages}\PYG{p}{:}
  \PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{n}{mkl}\PYG{p}{:}
      \PYG{n}{paths}\PYG{p}{:}
          \PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{n}{mkl}\PYG{o}{@}\PYG{l+m+mf}{2018.0}\PYG{o}{.}\PYG{l+m+mi}{128}\PYG{p}{:} \PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{n}{compilers\PYGZus{}and\PYGZus{}libraries\PYGZus{}2018}\PYG{o}{.}\PYG{l+m+mf}{0.104}\PYG{o}{/}\PYG{n}{mac}\PYG{o}{/}\PYG{n}{mkl}
      \PYG{n}{buildable}\PYG{p}{:} \PYG{k+kc}{False}
\end{sphinxVerbatim}

Some trial\sphinxhyphen{}and\sphinxhyphen{}error might be involved to set the directories
correctly. If you do not include enough of the tree path, Spack will
not be able to register the package in its database. More information
about system packages can be found at
\sphinxurl{http://spack.readthedocs.io/en/latest/getting\_started.html\#system-packages}.

Beginning with QMCPACK v3.9.0, Python 3.x is required. However,
installing Python with a compiler besides GCC is tricky. We recommend
leveraging your local Python installation by adding an entry in
\sphinxcode{\sphinxupquote{\textasciitilde{}/.spack/packages.yaml}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{packages}\PYG{p}{:}
  \PYG{n}{python}\PYG{p}{:}
     \PYG{n}{modules}\PYG{p}{:}
       \PYG{n}{python}\PYG{o}{@}\PYG{l+m+mf}{3.7}\PYG{o}{.}\PYG{l+m+mi}{4}\PYG{p}{:} \PYG{n}{anaconda3}\PYG{o}{/}\PYG{l+m+mf}{2019.10}
\end{sphinxVerbatim}

Or if a module is not available

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{packages}\PYG{p}{:}
  \PYG{n}{python}\PYG{p}{:}
     \PYG{n}{paths}\PYG{p}{:}
        \PYG{n}{python}\PYG{o}{@}\PYG{l+m+mf}{3.7}\PYG{o}{.}\PYG{l+m+mi}{4}\PYG{p}{:} \PYG{o}{/}\PYG{n}{nfs}\PYG{o}{/}\PYG{n}{gce}\PYG{o}{/}\PYG{n}{software}\PYG{o}{/}\PYG{n}{custom}\PYG{o}{/}\PYG{n}{linux}\PYG{o}{\PYGZhy{}}\PYG{n}{ubuntu18}\PYG{o}{.}\PYG{l+m+mi}{04}\PYG{o}{\PYGZhy{}}\PYG{n}{x86\PYGZus{}64}\PYG{o}{/}\PYG{n}{anaconda3}\PYG{o}{/}\PYG{l+m+mf}{2019.10}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{python}
   \PYG{n}{buildable}\PYG{p}{:} \PYG{k+kc}{False}
\end{sphinxVerbatim}


\subsection{Building QMCPACK}
\label{\detokenize{installation:id4}}
The QMCPACK Spack package has a number of variants to support different compile time
options and different versions of the application. A full list can be displayed by typing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your} \PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{spack} \PYG{n}{info} \PYG{n}{qmcpack}
\PYG{n}{CMakePackage}\PYG{p}{:}   \PYG{n}{qmcpack}

\PYG{n}{Description}\PYG{p}{:}
  \PYG{n}{QMCPACK}\PYG{p}{,} \PYG{o+ow}{is} \PYG{n}{a} \PYG{n}{modern} \PYG{n}{high}\PYG{o}{\PYGZhy{}}\PYG{n}{performance} \PYG{n+nb}{open}\PYG{o}{\PYGZhy{}}\PYG{n}{source} \PYG{n}{Quantum} \PYG{n}{Monte} \PYG{n}{Carlo}
  \PYG{p}{(}\PYG{n}{QMC}\PYG{p}{)} \PYG{n}{simulation} \PYG{n}{code}\PYG{o}{.}

\PYG{n}{Homepage}\PYG{p}{:} \PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{www}\PYG{o}{.}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{org}\PYG{o}{/}

\PYG{n}{Tags}\PYG{p}{:}
  \PYG{n}{ecp}  \PYG{n}{ecp}\PYG{o}{\PYGZhy{}}\PYG{n}{apps}

\PYG{n}{Preferred} \PYG{n}{version}\PYG{p}{:}
  \PYG{l+m+mf}{3.9}\PYG{o}{.}\PYG{l+m+mi}{1}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{9.1}

\PYG{n}{Safe} \PYG{n}{versions}\PYG{p}{:}
  \PYG{n}{develop}  \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git}
  \PYG{l+m+mf}{3.9}\PYG{o}{.}\PYG{l+m+mi}{1}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{9.1}
  \PYG{l+m+mf}{3.9}\PYG{o}{.}\PYG{l+m+mi}{0}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{9.0}
  \PYG{l+m+mf}{3.8}\PYG{o}{.}\PYG{l+m+mi}{0}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{8.0}
  \PYG{l+m+mf}{3.7}\PYG{o}{.}\PYG{l+m+mi}{0}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{7.0}
  \PYG{l+m+mf}{3.6}\PYG{o}{.}\PYG{l+m+mi}{0}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{6.0}
  \PYG{l+m+mf}{3.5}\PYG{o}{.}\PYG{l+m+mi}{0}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{5.0}
  \PYG{l+m+mf}{3.4}\PYG{o}{.}\PYG{l+m+mi}{0}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{4.0}
  \PYG{l+m+mf}{3.3}\PYG{o}{.}\PYG{l+m+mi}{0}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{3.0}
  \PYG{l+m+mf}{3.2}\PYG{o}{.}\PYG{l+m+mi}{0}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{2.0}
  \PYG{l+m+mf}{3.1}\PYG{o}{.}\PYG{l+m+mi}{1}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{1.1}
  \PYG{l+m+mf}{3.1}\PYG{o}{.}\PYG{l+m+mi}{0}      \PYG{p}{[}\PYG{n}{git}\PYG{p}{]} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}\PYG{o}{/}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{git} \PYG{n}{at} \PYG{n}{tag} \PYG{n}{v3}\PYG{o}{.}\PYG{l+m+mf}{1.0}

\PYG{n}{Variants}\PYG{p}{:}
  \PYG{n}{Name} \PYG{p}{[}\PYG{n}{Default}\PYG{p}{]}          \PYG{n}{Allowed} \PYG{n}{values}          \PYG{n}{Description}


  \PYG{n}{build\PYGZus{}type} \PYG{p}{[}\PYG{n}{Release}\PYG{p}{]}    \PYG{n}{Debug}\PYG{p}{,} \PYG{n}{Release}\PYG{p}{,}         \PYG{n}{The} \PYG{n}{build} \PYG{n+nb}{type} \PYG{n}{to} \PYG{n}{build}
                          \PYG{n}{RelWithDebInfo}
  \PYG{n}{afqmc} \PYG{p}{[}\PYG{n}{off}\PYG{p}{]}             \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Install} \PYG{k}{with} \PYG{n}{AFQMC} \PYG{n}{support}\PYG{o}{.}
                                                  \PYG{n}{NOTE} \PYG{n}{that} \PYG{k}{if} \PYG{n}{used} \PYG{o+ow}{in}
                                                  \PYG{n}{combination} \PYG{k}{with} \PYG{n}{CUDA}\PYG{p}{,} \PYG{n}{only}
                                                  \PYG{n}{AFQMC} \PYG{n}{will} \PYG{n}{have} \PYG{n}{CUDA}\PYG{o}{.}
  \PYG{n+nb}{complex} \PYG{p}{[}\PYG{n}{off}\PYG{p}{]}           \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Build} \PYG{n}{the} \PYG{n+nb}{complex} \PYG{p}{(}\PYG{n}{general}
                                                  \PYG{n}{twist}\PYG{o}{/}\PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{n}{point}\PYG{p}{)} \PYG{n}{version}
  \PYG{n}{cuda} \PYG{p}{[}\PYG{n}{off}\PYG{p}{]}              \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Build} \PYG{k}{with} \PYG{n}{CUDA}
  \PYG{n}{cuda\PYGZus{}arch} \PYG{p}{[}\PYG{n}{none}\PYG{p}{]}        \PYG{n}{none}\PYG{p}{,} \PYG{l+m+mi}{53}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{62}\PYG{p}{,}       \PYG{n}{CUDA} \PYG{n}{architecture}
                          \PYG{l+m+mi}{60}\PYG{p}{,} \PYG{l+m+mi}{61}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{75}\PYG{p}{,} \PYG{l+m+mi}{70}\PYG{p}{,}
                          \PYG{l+m+mi}{72}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{52}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{35}
  \PYG{n}{da} \PYG{p}{[}\PYG{n}{off}\PYG{p}{]}                \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Install} \PYG{k}{with} \PYG{n}{support} \PYG{k}{for} \PYG{n}{basic}
                                                  \PYG{n}{data} \PYG{n}{analysis} \PYG{n}{tools}
  \PYG{n}{gui} \PYG{p}{[}\PYG{n}{off}\PYG{p}{]}               \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Install} \PYG{k}{with} \PYG{n}{Matplotlib} \PYG{p}{(}\PYG{n}{long}
                                                  \PYG{n}{installation} \PYG{n}{time}\PYG{p}{)}
  \PYG{n}{mixed} \PYG{p}{[}\PYG{n}{off}\PYG{p}{]}             \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Build} \PYG{n}{the} \PYG{n}{mixed} \PYG{n}{precision}
                                                  \PYG{p}{(}\PYG{n}{mixture} \PYG{n}{of} \PYG{n}{single} \PYG{o+ow}{and} \PYG{n}{double}
                                                  \PYG{n}{precision}\PYG{p}{)} \PYG{n}{version} \PYG{k}{for} \PYG{n}{gpu} \PYG{o+ow}{and}
                                                  \PYG{n}{cpu}
  \PYG{n}{mpi} \PYG{p}{[}\PYG{n}{on}\PYG{p}{]}                \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Build} \PYG{k}{with} \PYG{n}{MPI} \PYG{n}{support}
  \PYG{n}{phdf5} \PYG{p}{[}\PYG{n}{on}\PYG{p}{]}              \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Build} \PYG{k}{with} \PYG{n}{parallel} \PYG{n}{collective}
                                                  \PYG{n}{I}\PYG{o}{/}\PYG{n}{O}
  \PYG{n}{ppconvert} \PYG{p}{[}\PYG{n}{off}\PYG{p}{]}         \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Install} \PYG{k}{with} \PYG{n}{pseudopotential}
                                                  \PYG{n}{converter}\PYG{o}{.}
  \PYG{n}{qe} \PYG{p}{[}\PYG{n}{on}\PYG{p}{]}                 \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Install} \PYG{k}{with} \PYG{n}{patched} \PYG{n}{Quantum}
                                                  \PYG{n}{Espresso} \PYG{l+m+mf}{6.4}\PYG{o}{.}\PYG{l+m+mi}{0}
  \PYG{n}{soa} \PYG{p}{[}\PYG{n}{on}\PYG{p}{]}                \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Build} \PYG{k}{with} \PYG{n}{Structure}\PYG{o}{\PYGZhy{}}\PYG{n}{of}\PYG{o}{\PYGZhy{}}\PYG{n}{Array}
                                                  \PYG{n}{instead} \PYG{n}{of} \PYG{n}{Array}\PYG{o}{\PYGZhy{}}\PYG{n}{of}\PYG{o}{\PYGZhy{}}\PYG{n}{Structure}
                                                  \PYG{n}{code}\PYG{o}{.} \PYG{n}{Only} \PYG{k}{for} \PYG{n}{CPU} \PYG{n}{codeand}
                                                  \PYG{n}{only} \PYG{o+ow}{in} \PYG{n}{mixed} \PYG{n}{precision}
  \PYG{n}{timers} \PYG{p}{[}\PYG{n}{off}\PYG{p}{]}            \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}             \PYG{n}{Build} \PYG{k}{with} \PYG{n}{support} \PYG{k}{for} \PYG{n}{timers}

\PYG{n}{Installation} \PYG{n}{Phases}\PYG{p}{:}
  \PYG{n}{cmake}    \PYG{n}{build}    \PYG{n}{install}

\PYG{n}{Build} \PYG{n}{Dependencies}\PYG{p}{:}
  \PYG{n}{blas}  \PYG{n}{boost}  \PYG{n}{cmake}  \PYG{n}{cuda}  \PYG{n}{fftw}\PYG{o}{\PYGZhy{}}\PYG{n}{api}  \PYG{n}{hdf5}  \PYG{n}{lapack}  \PYG{n}{libxml2}  \PYG{n}{mpi}  \PYG{n}{python}

\PYG{n}{Link} \PYG{n}{Dependencies}\PYG{p}{:}
  \PYG{n}{blas}  \PYG{n}{boost}  \PYG{n}{cuda}  \PYG{n}{fftw}\PYG{o}{\PYGZhy{}}\PYG{n}{api}  \PYG{n}{hdf5}  \PYG{n}{lapack}  \PYG{n}{libxml2}  \PYG{n}{mpi}  \PYG{n}{python}

\PYG{n}{Run} \PYG{n}{Dependencies}\PYG{p}{:}
  \PYG{n}{py}\PYG{o}{\PYGZhy{}}\PYG{n}{matplotlib}  \PYG{n}{py}\PYG{o}{\PYGZhy{}}\PYG{n}{numpy}  \PYG{n}{quantum}\PYG{o}{\PYGZhy{}}\PYG{n}{espresso}

\PYG{n}{Virtual} \PYG{n}{Packages}\PYG{p}{:}
  \PYG{k+kc}{None}
\end{sphinxVerbatim}

For example, to install the complex\sphinxhyphen{}valued version of QMCPACK in mixed\sphinxhyphen{}precision use:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{spack} \PYG{n}{install} \PYG{n}{qmcpack}\PYG{o}{+}\PYG{n}{mixed}\PYG{o}{+}\PYG{n+nb}{complex}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc}\PYG{o}{@}\PYG{l+m+mf}{7.2}\PYG{o}{.}\PYG{l+m+mi}{0} \PYG{o}{\PYGZca{}}\PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{n}{mkl}
\end{sphinxVerbatim}

where

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{n}{gcc}\PYG{o}{@}\PYG{l+m+mf}{7.2}\PYG{o}{.}\PYG{l+m+mi}{0}
\end{sphinxVerbatim}

specifies the compiler version to be used and

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZca{}}\PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{n}{mkl}
\end{sphinxVerbatim}

specifies that the Intel MKL should be used as the BLAS and LAPACK
provider. The \sphinxcode{\sphinxupquote{\textasciicircum{}}} symbol indicates the the package to the right of the
symbol should be used to fulfill the dependency needed by the installation.

It is also possible to run the QMCPACK regression tests as part of the
installation process, for example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{spack} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{test}\PYG{o}{=}\PYG{n}{root} \PYG{n}{qmcpack}\PYG{o}{+}\PYG{n}{mixed}\PYG{o}{+}\PYG{n+nb}{complex}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc}\PYG{o}{@}\PYG{l+m+mf}{7.2}\PYG{o}{.}\PYG{l+m+mi}{0} \PYG{o}{\PYGZca{}}\PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{n}{mkl}
\end{sphinxVerbatim}

will run the unit and short tests. The current behavior of the QMCPACK
Spack package is to complete the install as long as all the unit tests
pass. If the short tests fail, a warning is issued at the command prompt.

For CUDA, you will need to specify and extra \sphinxcode{\sphinxupquote{cuda\_arch}}
parameter otherwise, it will default to \sphinxcode{\sphinxupquote{cuda\_arch=61}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{spack} \PYG{n}{install} \PYG{n}{qmcpack}\PYG{o}{+}\PYG{n}{cuda}\PYG{o}{\PYGZpc{}}\PYG{n}{intel}\PYG{o}{@}\PYG{l+m+mf}{18.0}\PYG{o}{.}\PYG{l+m+mi}{3} \PYG{n}{cuda\PYGZus{}arch}\PYG{o}{=}\PYG{l+m+mi}{61} \PYG{o}{\PYGZca{}}\PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{n}{mkl}
\end{sphinxVerbatim}

Due to limitations in the Spack CUDA package, if your compiler and
CUDA combination conflict, you will need to set a
specific verison of CUDA that is compatible with your compiler on the
command line. For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{spack} \PYG{n}{install} \PYG{n}{qmcpack}\PYG{o}{+}\PYG{n}{cuda}\PYG{o}{\PYGZpc{}}\PYG{n}{intel}\PYG{o}{@}\PYG{l+m+mf}{18.0}\PYG{o}{.}\PYG{l+m+mi}{3} \PYG{n}{cuda\PYGZus{}arch}\PYG{o}{=}\PYG{l+m+mi}{61} \PYG{o}{\PYGZca{}}\PYG{n}{cuda}\PYG{o}{@}\PYG{l+m+mf}{10.0}\PYG{o}{.}\PYG{l+m+mi}{130} \PYG{o}{\PYGZca{}}\PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{n}{mkl}
\end{sphinxVerbatim}


\subsection{Loading QMCPACK into your environment}
\label{\detokenize{installation:loading-qmcpack-into-your-environment}}
If you already have modules set\sphinxhyphen{}up in your enviroment, the Spack
modules will be detected automatically. Otherwise, Spack will not
automatically find the additional packages. A few additional steps are
needed.  Please see the main Spack documentation for additional details: \sphinxurl{https://spack.readthedocs.io/en/latest/module\_file\_support.html}.


\subsection{Dependencies that need to be compiled with GCC}
\label{\detokenize{installation:dependencies-that-need-to-be-compiled-with-gcc}}
Failing to compile a QMCPACK dependency is the most common reason that
a Spack build fails. We recommend that you compile the following
dependencies with GCC:

For MPI, using MPICH as the provider, try:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{spack} \PYG{n}{install} \PYG{n}{qmcpack}\PYG{o}{\PYGZpc{}}\PYG{n}{intel}\PYG{o}{@}\PYG{l+m+mf}{18.0}\PYG{o}{.}\PYG{l+m+mi}{3} \PYG{o}{\PYGZca{}}\PYG{n}{boost}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc} \PYG{o}{\PYGZca{}}\PYG{n}{pkgconf}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc} \PYG{o}{\PYGZca{}}\PYG{n}{perl}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc} \PYG{o}{\PYGZca{}}\PYG{n}{libpciaccess}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc} \PYG{o}{\PYGZca{}}\PYG{n}{cmake}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc} \PYG{o}{\PYGZca{}}\PYG{n}{findutils}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc} \PYG{o}{\PYGZca{}}\PYG{n}{m4}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc}
\end{sphinxVerbatim}

For serial,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{spack} \PYG{n}{install} \PYG{n}{qmcpack}\PYG{o}{\PYGZti{}}\PYG{n}{mpi}\PYG{o}{\PYGZpc{}}\PYG{n}{intel}\PYG{o}{@}\PYG{l+m+mf}{18.0}\PYG{o}{.}\PYG{l+m+mi}{3} \PYG{o}{\PYGZca{}}\PYG{n}{boost}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc} \PYG{o}{\PYGZca{}}\PYG{n}{pkgconf}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc} \PYG{o}{\PYGZca{}}\PYG{n}{perl}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc} \PYG{o}{\PYGZca{}}\PYG{n}{cmake}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc}
\end{sphinxVerbatim}


\subsection{Installing QMCPACK with Spack on Linux}
\label{\detokenize{installation:installing-qmcpack-with-spack-on-linux}}
Spack works robustly on the standard flavors of Linux (Ubuntu, CentOS,
Ubuntu, etc.) using GCC, Clang, PGI, and Intel compilers.


\subsection{Installing QMCPACK with Spack on Mac OS X}
\label{\detokenize{installation:installing-qmcpack-with-spack-on-mac-os-x}}
Spack works on Mac OS X but requires installation of a few packages
using Homebrew. You will need to install at minimum the GCC compilers,
CMake, and pkg\sphinxhyphen{}config. The Intel compiler for Mac on OS X is not well
supported by Spack packages and will most likely lead to a compile
time failure in one of QMCPACK’s dependencies.


\subsection{Installing QMCPACK with Spack on Cray Supercomputers}
\label{\detokenize{installation:installing-qmcpack-with-spack-on-cray-supercomputers}}
Spack now works with the Cray environment. To leverage the installed
Cray environment, both a \sphinxcode{\sphinxupquote{compilers.yaml}} and
\sphinxcode{\sphinxupquote{packages.yaml}} file should be provided by the supercomputing
facility. Additionally, Spack packages compiled by the facility can be
reused by chaining Spack installations
\sphinxurl{https://spack.readthedocs.io/en/latest/chain.html}.

Instructions for DOE supercomputing facilities that support Spack directly will be forthcoming.


\subsection{Installing Quantum\sphinxhyphen{}Espresso with Spack}
\label{\detokenize{installation:installing-quantum-espresso-with-spack}}
More information about the QE Spack package can be obtained directly
from Spack

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{spack} \PYG{n}{info} \PYG{n}{quantum}\PYG{o}{\PYGZhy{}}\PYG{n}{espresso}
\end{sphinxVerbatim}

There are many variants available for QE, most, but not all, are
compatible with QMCPACK patch. Here is a minimalistic example of the
Spack installation command that needs to be invoked:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{spack} \PYG{n}{install} \PYG{n}{quantum}\PYG{o}{\PYGZhy{}}\PYG{n}{espresso}\PYG{o}{+}\PYG{n}{qmcpack}\PYG{o}{\PYGZti{}}\PYG{n}{patch}\PYG{o}{@}\PYG{l+m+mf}{6.4}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc} \PYG{n}{hdf5}\PYG{o}{=}\PYG{n}{parallel}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{\textasciitilde{}}} decorator means deactivate the \sphinxcode{\sphinxupquote{patch}}
variant. This refers not to the QMCPACK patch, but to the upstream
patching that is present for some versions of QE. These upstream QE
patches fix specific critical autoconf/configure fixes. Unfortunately,
some of these QE upstream patches are incompatible with the QMCPACK
patch. Note that the Spack package will prevent you from installing
incompatible variants and will emit an error message explaining the
nature of the incompatibility.

A serial (no MPI) installation is also available, but the Spack installation command
is non\sphinxhyphen{}intuitive for Spack newcomers:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{laptop}\PYG{o}{\PYGZgt{}} \PYG{n}{spack} \PYG{n}{install} \PYG{n}{quantum}\PYG{o}{\PYGZhy{}}\PYG{n}{espresso}\PYG{o}{+}\PYG{n}{qmcpack}\PYG{o}{\PYGZti{}}\PYG{n}{patch}\PYG{o}{\PYGZti{}}\PYG{n}{mpi}\PYG{o}{\PYGZti{}}\PYG{n}{scalapack}\PYG{o}{@}\PYG{l+m+mf}{6.4}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{o}{\PYGZpc{}}\PYG{n}{gcc} \PYG{n}{hdf5}\PYG{o}{=}\PYG{n}{serial}
\end{sphinxVerbatim}

QE Spack package is well tested with GCC and Intel compilers, but will not work
with the PGI compiler or in a cross\sphinxhyphen{}compile environment.


\subsection{Reporting Bugs}
\label{\detokenize{installation:reporting-bugs}}
Bugs with the QMCPACK Spack package should be filed at the main GitHub
Spack repo \sphinxurl{https://github.com/spack/spack/issues}.

In the GitHub issue, include \sphinxcode{\sphinxupquote{@naromero77}} to get the attention
of our developer.


\section{Testing and validation of QMCPACK}
\label{\detokenize{installation:testing-and-validation-of-qmcpack}}\label{\detokenize{installation:testing}}
We \sphinxstylestrong{strongly encourage} running the included tests each time
QMCPACK is built. A range of unit and integration tests ensure that
the code behaves as expected and that results are consistent with
known\sphinxhyphen{}good mean\sphinxhyphen{}field, quantum chemical, and historical QMC results.

The tests include the following:
\begin{itemize}
\item {} 
Unit tests: to check fundamental behavior. These should always pass.

\item {} 
Stochastic integration tests: to check computed results from
the Monte Carlo methods. These might fail statistically, but rarely
because of the use of three sigma level statistics. These tests are
further split into “short” tests, which have just sufficient
length to have valid statistics, and “long” tests, to check
behavior to higher statistical accuracy.

\item {} 
Converter tests: to check conversion of trial wavefunctions
from codes such as QE and GAMESS to QMCPACK’s
formats. These should always pass.

\item {} 
Workflow tests: in the case of QE, we test the
entire cycle of DFT calculation, trial wavefunction conversion, and
a subsequent VMC run.

\item {} 
Performance: to help performance monitoring. Only the timing of
these runs is relevant.

\end{itemize}

The test types are differentiated by prefixes in their names, for example, \sphinxcode{\sphinxupquote{short\sphinxhyphen{}LiH\_dimer\_ae\_vmc\_hf\_noj\_16\sphinxhyphen{}1}} indicates a short VMC test
for the LiH dime.

QMCPACK also includes tests for developmental features and features
that are unsupported on certain platforms. To indicate these, tests
that are unstable are labeled with the CTest label
“unstable.” For example, they are unreliable, unsupported, or known to fail
from partial implementation or bugs.

When installing QMCPACK you should run at least the unit tests:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ctest} \PYG{o}{\PYGZhy{}}\PYG{n}{R} \PYG{n}{unit}
\end{sphinxVerbatim}

These tests take only a few seconds to run. All should pass. A
failure here could indicate a major problem with the installation.

A wider range of deterministic integration
tests are being developed. The goal is to test much more of QMCPACK than the unit tests
do and to do so in a manner that is reproducible
across platforms. All of these should eventually pass 100\% reliably
and quickly. At present, some fail on some platforms and for certain
build types.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ctest} \PYG{o}{\PYGZhy{}}\PYG{n}{R} \PYG{n}{deterministic} \PYG{o}{\PYGZhy{}}\PYG{n}{LE} \PYG{n}{unstable}
\end{sphinxVerbatim}

If time allows, the “short” stochastic tests should also be run.
The short tests take a few minutes each on a 16\sphinxhyphen{}core machine—about 1 hour total depending on the platform. You can run these tests using the following command in the
build directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ctest} \PYG{o}{\PYGZhy{}}\PYG{n}{R} \PYG{n}{short} \PYG{o}{\PYGZhy{}}\PYG{n}{LE} \PYG{n}{unstable}  \PYG{c+c1}{\PYGZsh{} Run the tests with \PYGZdq{}short\PYGZdq{} in their name.}
                             \PYG{c+c1}{\PYGZsh{} Exclude any known unstable tests.}
\end{sphinxVerbatim}

The output should be similar to the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Test} \PYG{n}{project} \PYG{n}{build\PYGZus{}gcc}
    \PYG{n}{Start}  \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{n}{short}\PYG{o}{\PYGZhy{}}\PYG{n}{LiH\PYGZus{}dimer\PYGZus{}ae}\PYG{o}{\PYGZhy{}}\PYG{n}{vmc\PYGZus{}hf\PYGZus{}noj}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{16}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{44} \PYG{n}{Test}  \PYG{c+c1}{\PYGZsh{}1: short\PYGZhy{}LiH\PYGZus{}dimer\PYGZus{}ae\PYGZhy{}vmc\PYGZus{}hf\PYGZus{}noj\PYGZhy{}16\PYGZhy{}1 ..............  Passed   11.20 sec}
    \PYG{n}{Start}  \PYG{l+m+mi}{2}\PYG{p}{:} \PYG{n}{short}\PYG{o}{\PYGZhy{}}\PYG{n}{LiH\PYGZus{}dimer\PYGZus{}ae}\PYG{o}{\PYGZhy{}}\PYG{n}{vmc\PYGZus{}hf\PYGZus{}noj}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{16}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{kinetic}
\PYG{l+m+mi}{2}\PYG{o}{/}\PYG{l+m+mi}{44} \PYG{n}{Test}  \PYG{c+c1}{\PYGZsh{}2: short\PYGZhy{}LiH\PYGZus{}dimer\PYGZus{}ae\PYGZhy{}vmc\PYGZus{}hf\PYGZus{}noj\PYGZhy{}16\PYGZhy{}1\PYGZhy{}kinetic ......  Passed    0.13 sec}
\PYG{o}{.}\PYG{o}{.}
\PYG{l+m+mi}{42}\PYG{o}{/}\PYG{l+m+mi}{44} \PYG{n}{Test} \PYG{c+c1}{\PYGZsh{}42: short\PYGZhy{}monoO\PYGZus{}1x1x1\PYGZus{}pp\PYGZhy{}vmc\PYGZus{}sdj\PYGZhy{}1\PYGZhy{}16 ...............  Passed   10.02 sec}
    \PYG{n}{Start} \PYG{l+m+mi}{43}\PYG{p}{:} \PYG{n}{short}\PYG{o}{\PYGZhy{}}\PYG{n}{monoO\PYGZus{}1x1x1\PYGZus{}pp}\PYG{o}{\PYGZhy{}}\PYG{n}{vmc\PYGZus{}sdj}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{16}\PYG{o}{\PYGZhy{}}\PYG{n}{totenergy}
\PYG{l+m+mi}{43}\PYG{o}{/}\PYG{l+m+mi}{44} \PYG{n}{Test} \PYG{c+c1}{\PYGZsh{}43: short\PYGZhy{}monoO\PYGZus{}1x1x1\PYGZus{}pp\PYGZhy{}vmc\PYGZus{}sdj\PYGZhy{}1\PYGZhy{}16\PYGZhy{}totenergy .....  Passed    0.08 sec}
    \PYG{n}{Start} \PYG{l+m+mi}{44}\PYG{p}{:} \PYG{n}{short}\PYG{o}{\PYGZhy{}}\PYG{n}{monoO\PYGZus{}1x1x1\PYGZus{}pp}\PYG{o}{\PYGZhy{}}\PYG{n}{vmc\PYGZus{}sdj}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{16}\PYG{o}{\PYGZhy{}}\PYG{n}{samples}
\PYG{l+m+mi}{44}\PYG{o}{/}\PYG{l+m+mi}{44} \PYG{n}{Test} \PYG{c+c1}{\PYGZsh{}44: short\PYGZhy{}monoO\PYGZus{}1x1x1\PYGZus{}pp\PYGZhy{}vmc\PYGZus{}sdj\PYGZhy{}1\PYGZhy{}16\PYGZhy{}samples .......  Passed    0.08 sec}

\PYG{l+m+mi}{100}\PYG{o}{\PYGZpc{}} \PYG{n}{tests} \PYG{n}{passed}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{n}{tests} \PYG{n}{failed} \PYG{n}{out} \PYG{n}{of} \PYG{l+m+mi}{44}

\PYG{n}{Total} \PYG{n}{Test} \PYG{n}{time} \PYG{p}{(}\PYG{n}{real}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{167.14} \PYG{n}{sec}
\end{sphinxVerbatim}

Note that the number of tests run varies between the
standard, complex, and GPU compilations. These tests should pass with three sigma reliability. That is, they should nearly always pass, and when rerunning a failed test it should usually pass. Overly frequent failures suggest a problem that should be addressed before any scientific production.

The  full set of tests consist of significantly longer versions of the short
tests, as well as tests of the conversion utilities. The runs require
several hours each for improved statistics and a much more
stringent test of the code. To run all the tests, simply run CTest in the build
directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ctest} \PYG{o}{\PYGZhy{}}\PYG{n}{LE} \PYG{n}{unstable}           \PYG{c+c1}{\PYGZsh{} Run all the stable tests. This will take several hours.}
\end{sphinxVerbatim}

You can also run verbose tests, which direct the QMCPACK
output to the standard output:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ctest} \PYG{o}{\PYGZhy{}}\PYG{n}{V} \PYG{o}{\PYGZhy{}}\PYG{n}{R} \PYG{n}{short}   \PYG{c+c1}{\PYGZsh{} Verbose short tests}
\end{sphinxVerbatim}

The test system includes specific tests for the complex version of the code.

The input data files for the tests are located in the \sphinxcode{\sphinxupquote{tests}} directory.
The system\sphinxhyphen{}level test directories are grouped into \sphinxcode{\sphinxupquote{heg}}, \sphinxcode{\sphinxupquote{molecules}}, and \sphinxcode{\sphinxupquote{solids}}, with particular physical systems under each (for example \sphinxcode{\sphinxupquote{molecules/H4\_ae}} %
\begin{footnote}[1]\sphinxAtStartFootnote
The suffix “ae” is short for “all\sphinxhyphen{}electron,” and “pp” is short for “pseudopotential.”
%
\end{footnote} ).
Under each physical system directory there might be tests for multiple QMC methods or parameter variations.
The numerical comparisons and test definitions are in the \sphinxcode{\sphinxupquote{CMakeLists.txt}} file in each physical system directory.

If \sphinxstyleemphasis{all} the QMC tests fail it is likely
that the appropriate mpiexec (or mpirun, aprun, srun, jsrun) is not being
called or found. If the QMC runs appear to work but all the other
tests fail, it is possible that Python is not working on your system. We suggest checking some of the test console output in \sphinxcode{\sphinxupquote{build/Testing/Temporary/LastTest.log}}
or the output files under \sphinxcode{\sphinxupquote{build/tests/}}.

Note that because most of the tests are very small, consisting of only a few
electrons, the performance is not representative of larger
calculations. For example, although the calculations might fit in cache,
there will be essentially no vectorization because of the small electron
counts. \sphinxstylestrong{These tests should therefore not be used for any benchmarking or
performance analysis}. Example runs that can be used for testing performance are described in
{\hyperref[\detokenize{installation:perftests}]{\sphinxcrossref{\DUrole{std,std-ref}{Performance tests}}}}.


\subsection{Deterministic and unit tests}
\label{\detokenize{installation:deterministic-and-unit-tests}}
QMCPACK has a set of deterministic tests, predominantly unit tests.
All of these tests can be run with the following command (in the build directory):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ctest} \PYG{o}{\PYGZhy{}}\PYG{n}{R} \PYG{n}{deterministic} \PYG{o}{\PYGZhy{}}\PYG{n}{LE} \PYG{n}{unstable}
\end{sphinxVerbatim}

These tests should always pass. Failure could indicate a major problem
with the compiler, compiler settings, or a linked library that would
give incorrect results.

The output should look similar to the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Test} \PYG{n}{project} \PYG{n}{qmcpack}\PYG{o}{/}\PYG{n}{build}
    \PYG{n}{Start}  \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{n}{unit\PYGZus{}test\PYGZus{}numerics}
\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{11} \PYG{n}{Test}  \PYG{c+c1}{\PYGZsh{}1: unit\PYGZus{}test\PYGZus{}numerics ...............   Passed    0.06 sec}
    \PYG{n}{Start}  \PYG{l+m+mi}{2}\PYG{p}{:} \PYG{n}{unit\PYGZus{}test\PYGZus{}utilities}
\PYG{l+m+mi}{2}\PYG{o}{/}\PYG{l+m+mi}{11} \PYG{n}{Test}  \PYG{c+c1}{\PYGZsh{}2: unit\PYGZus{}test\PYGZus{}utilities ..............   Passed    0.02 sec}
    \PYG{n}{Start}  \PYG{l+m+mi}{3}\PYG{p}{:} \PYG{n}{unit\PYGZus{}test\PYGZus{}einspline}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{l+m+mi}{10}\PYG{o}{/}\PYG{l+m+mi}{11} \PYG{n}{Test} \PYG{c+c1}{\PYGZsh{}10: unit\PYGZus{}test\PYGZus{}hamiltonian ............   Passed    1.88 sec}
    \PYG{n}{Start} \PYG{l+m+mi}{11}\PYG{p}{:} \PYG{n}{unit\PYGZus{}test\PYGZus{}drivers}
\PYG{l+m+mi}{11}\PYG{o}{/}\PYG{l+m+mi}{11} \PYG{n}{Test} \PYG{c+c1}{\PYGZsh{}11: unit\PYGZus{}test\PYGZus{}drivers ................   Passed    0.01 sec}

\PYG{l+m+mi}{100}\PYG{o}{\PYGZpc{}} \PYG{n}{tests} \PYG{n}{passed}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{n}{tests} \PYG{n}{failed} \PYG{n}{out} \PYG{n}{of} \PYG{l+m+mi}{11}

\PYG{n}{Label} \PYG{n}{Time} \PYG{n}{Summary}\PYG{p}{:}
\PYG{n}{unit}    \PYG{o}{=}   \PYG{l+m+mf}{2.20} \PYG{n}{sec}

\PYG{n}{Total} \PYG{n}{Test} \PYG{n}{time} \PYG{p}{(}\PYG{n}{real}\PYG{p}{)} \PYG{o}{=}   \PYG{l+m+mf}{2.31} \PYG{n}{sec}
\end{sphinxVerbatim}

Individual unit test executables can be found in \sphinxcode{\sphinxupquote{build/tests/bin}}.
The source for the unit tests is located in the \sphinxcode{\sphinxupquote{tests}} directory under each directory in \sphinxcode{\sphinxupquote{src}} (e.g. \sphinxcode{\sphinxupquote{src/QMCWavefunctions/tests}}).

See \DUrole{xref,std,std-ref}{unit\sphinxhyphen{}testing} for more details about unit tests.


\subsection{Integration tests with Quantum Espresso}
\label{\detokenize{installation:integration-tests-with-quantum-espresso}}\label{\detokenize{installation:integtestqe}}
As described in {\hyperref[\detokenize{installation:buildqe}]{\sphinxcrossref{\DUrole{std,std-ref}{Installing and patching Quantum ESPRESSO}}}}, it is possible to test entire
workflows of trial wavefunction generation, conversion, and eventual
QMC calculation. A patched QE must be installed so that the
pw2qmcpack converter is available.

By adding \sphinxcode{\sphinxupquote{\sphinxhyphen{}D QE\_BIN=your\_QE\_binary\_path}} in the CMake command line when building your QMCPACK,
tests named with the “qe\sphinxhyphen{}” prefix will be included in the test set of your build.
You can test the whole \sphinxcode{\sphinxupquote{pw \textgreater{} pw2qmcpack \textgreater{} qmcpack}} workflow by

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ctest} \PYG{o}{\PYGZhy{}}\PYG{n}{R} \PYG{n}{qe}
\end{sphinxVerbatim}

This provides a very solid test of the entire QMC
toolchain for plane wave\textendash{}generated wavefunctions.


\subsection{Performance tests}
\label{\detokenize{installation:performance-tests}}\label{\detokenize{installation:perftests}}
Performance tests representative of real research runs are included in the
tests/performance directory. They can be used for benchmarking, comparing machine
performance, or assessing optimizations. This is in
contrast to the majority of the conventional integration tests in which the particle
counts are too small to be representative. Care is still needed to
remove initialization, I/O, and compute a representative performance
measure.

The CTest integration is sufficient to run the benchmarks and measure
relative performance from version to version of QMCPACK and to assess
proposed code changes. Performance tests are prefixed with
“performance.” To obtain the highest performance on a particular
platform, you must run the benchmarks in a standalone manner and tune
thread counts, placement, walker count (etc.). This is essential to
fairly compare different machines. Check with the
developers if you are unsure of what is a fair change.

For the largest problem sizes, the initialization of spline orbitals might
take a large portion of overall runtime. When QMCPACK is run at scale,
the initialization is fast because it is fully
parallelized. However, the performance tests usually run on a single node.
Consider running QMCPACK once with \sphinxcode{\sphinxupquote{save\_coefs="yes"}} XML input tag
added to the line of ‘determinantset’ to save the converted spline
coefficients to the disk and load them for later runs in the same folder.
See {\hyperref[\detokenize{intro_wavefunction:spo-spline}]{\sphinxcrossref{\DUrole{std,std-ref}{Spline basis sets}}}} for more information.

The delayed update algorithm in {\hyperref[\detokenize{intro_wavefunction:singledeterminant}]{\sphinxcrossref{\DUrole{std,std-ref}{Single determinant wavefunctons}}}}
significantly changes the performance characteristics of QMCPACK.  A
parameter scan of the maximal number of delays specific to every
architecture and problem size is required to achieve the best
performance.


\subsubsection{NiO performance tests}
\label{\detokenize{installation:nio-performance-tests}}
Follow the instructions in tests/performance/NiO/README to
enable and run the NiO tests.

The NiO tests are for bulk supercells of varying size. The QMC runs consist of short blocks of (1) VMC
without drift (2) VMC with drift term included, and (3) DMC with
constant population. The tests use spline wavefunctions that must be
downloaded as described in the README file because of their large size. You
will need to set \sphinxcode{\sphinxupquote{\sphinxhyphen{}DQMC\_DATA=YOUR\_DATA\_FOLDER \sphinxhyphen{}DENABLE\_TIMERS=1}}
when running CMake as
described in the README file.

Two sets of wavefunction are tested: spline orbitals with one\sphinxhyphen{} and
two\sphinxhyphen{}body Jastrow functions and a more complex form with an additional
three\sphinxhyphen{}body Jastrow function. The Jastrows are the same for each run
and are not reoptimized, as might be done for research purposes.  Runs
in the hundreds of electrons up to low thousands of electrons are representative of
research runs performed in 2017. The largest runs target
future machines and require very large memory.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{System sizes and names for NiO performance tests. GPU performance
  tests are named similarly but have different walker counts.}\label{\detokenize{installation:id6}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Performance test name
&\sphinxstyletheadfamily 
Historical name
&\sphinxstyletheadfamily 
Atoms
&\sphinxstyletheadfamily 
Electrons
&\sphinxstyletheadfamily 
Electrons/spin
\\
\hline
performance\sphinxhyphen{}NiO\sphinxhyphen{}cpu\sphinxhyphen{}a32\sphinxhyphen{}e384
&
S8
&
32
&
384
&
192
\\
\hline
performance\sphinxhyphen{}NiO\sphinxhyphen{}cpu\sphinxhyphen{}a64\sphinxhyphen{}e768
&
S16
&
64
&
768
&
384
\\
\hline
performance\sphinxhyphen{}NiO\sphinxhyphen{}cpu\sphinxhyphen{}a128\sphinxhyphen{}e1536
&
S32
&
128
&
1536
&
768
\\
\hline
performance\sphinxhyphen{}NiO\sphinxhyphen{}cpu\sphinxhyphen{}a256\sphinxhyphen{}e3072
&
S64
&
256
&
3072
&
1536
\\
\hline
performance\sphinxhyphen{}NiO\sphinxhyphen{}cpu\sphinxhyphen{}a512\sphinxhyphen{}e6144
&
S128
&
512
&
6144
&
3072
\\
\hline
performance\sphinxhyphen{}NiO\sphinxhyphen{}cpu\sphinxhyphen{}a1024\sphinxhyphen{}e12288
&
S256
&
1024
&
12288
&
6144
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Troubleshooting tests}
\label{\detokenize{installation:troubleshooting-tests}}
CTest reports briefly pass or fail of tests in printout and also collects all the standard outputs to help investigating how tests fail.
If the CTest execution is completed, look at \sphinxcode{\sphinxupquote{Testing/Temporary/LastTest.log}}.
If you manually stop the testing (ctrl+c), look at \sphinxcode{\sphinxupquote{Testing/Temporary/LastTest.log.tmp}}.
You can locate the failing tests by searching for the key word “Fail.”


\subsection{Slow testing with OpenMPI}
\label{\detokenize{installation:slow-testing-with-openmpi}}
OpenMPI has a default binding policy that makes all the threads run on a single core during testing when there are two or fewer MPI ranks.
This significantly increases testing time. If you are authorized to change the default setting, you can just add “hwloc\_base\_binding\_policy=none” in /etc/openmpi/openmpi\sphinxhyphen{}mca\sphinxhyphen{}params.conf.


\section{Automated testing of QMCPACK}
\label{\detokenize{installation:automated-testing-of-qmcpack}}
The QMCPACK developers run automatic tests of QMCPACK on several
different computer systems,  many on a continuous basis. See the reports at
\sphinxurl{https://cdash.qmcpack.org/CDash/index.php?project=QMCPACK}.
The combinations that are currently tested can be seen on CDash and are also listed in
\sphinxurl{https://github.com/QMCPACK/qmcpack/blob/develop/README.md}. They include GCC, Clang, Intel, and PGI compilers in combinations
with various library versions and different MPI implementations. NVIDIA GPUs are also tested.


\section{Building ppconvert, a pseudopotential format converter}
\label{\detokenize{installation:building-ppconvert-a-pseudopotential-format-converter}}\label{\detokenize{installation:buildppconvert}}
QMCPACK includes a utility—ppconvert—to convert between different
pseudopotential formats. Examples include effective core potential
formats (in Gaussians), the UPF format used by QE, and
the XML format used by QMCPACK itself. The utility also enables the
atomic orbitals to be recomputed via a numerical density functional
calculation if they need to be reconstructed for use in an
electronic structure calculation.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.800\linewidth]{{QMCPACK_CDash_CTest_Results_20160129}.png}
\caption{Example test results for QMCPACK showing data for a
workstation (Intel, GCC, both CPU and GPU builds) and for two ORNL
supercomputers. In this example, four errors were found. This
dashboard is accessible at \sphinxurl{https://cdash.qmcpack.org}}\label{\detokenize{installation:id7}}\label{\detokenize{installation:fig2}}\end{figure}


\section{Installing and patching Quantum ESPRESSO}
\label{\detokenize{installation:installing-and-patching-quantum-espresso}}\label{\detokenize{installation:buildqe}}
For trial wavefunctions obtained in a plane\sphinxhyphen{}wave basis, we mainly
support QE. Note that ABINIT and QBox were supported historically
and could be reactivated.

QE stores wavefunctions in a nonstandard internal
“save” format. To convert these to a conventional HDF5 format file
we have developed a converter—pw2qmcpack—which is an add\sphinxhyphen{}on to the
QE distribution.

To simplify the process of patching QE we have developed
a script that will automatically download and patch the source
code. The patches are specific to each version. For example, to download and
patch QE v6.3:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{external\PYGZus{}codes}\PYG{o}{/}\PYG{n}{quantum\PYGZus{}espresso}
\PYG{o}{.}\PYG{o}{/}\PYG{n}{download\PYGZus{}and\PYGZus{}patch\PYGZus{}qe6}\PYG{o}{.}\PYG{l+m+mf}{3.}\PYG{n}{sh}
\end{sphinxVerbatim}

After running the patch, you must configure QE with
the HDF5 capability enabled in either way:
\begin{itemize}
\item {} 
If your system already has HDF5 installed with Fortran, use the \sphinxhyphen{}\{\}\sphinxhyphen{}with\sphinxhyphen{}hdf5 configuration option.

\end{itemize}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{qe}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.3}
\PYG{o}{.}\PYG{o}{/}\PYG{n}{configure} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{k}{with}\PYG{o}{\PYGZhy{}}\PYG{n}{hdf5}\PYG{o}{=}\PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{local}   \PYG{c+c1}{\PYGZsh{} Specify HDF5 base directory}
\end{sphinxVerbatim}

\sphinxstylestrong{Check} the end of the configure output if HDF5 libraries are found properly.
If not, either install a complete library or use the other scheme. If using a parallel HDF5 library, be sure to use
the same MPI with QE as used to build the parallel HDF5 library.

Currently, HDF5 support in QE itself is preliminary. To enable use of pw2qmcpack
but use the old non\sphinxhyphen{}HDF5 I/O within QE, replace \sphinxcode{\sphinxupquote{\sphinxhyphen{}D\_\_HDF5}} with \sphinxcode{\sphinxupquote{\{\sphinxhyphen{}D\_\_HDF5\_C\}}} in make.inc.
\end{quote}
\begin{itemize}
\item {} 
If your system has HDF5 with C only, manually edit make.inc by adding \sphinxcode{\sphinxupquote{\sphinxhyphen{}D\_\_HDF5\_C}} and \sphinxcode{\sphinxupquote{\sphinxhyphen{}DH5\_USE\_16\_API}}
in \sphinxcode{\sphinxupquote{DFLAGS}} and provide include and library path in \sphinxcode{\sphinxupquote{IFLAGS}} and \sphinxcode{\sphinxupquote{HDF5\_LIB}}.

\end{itemize}

The complete process is described in external\_codes/quantum\_espresso/README.

The tests involving pw.x and pw2qmcpack.x have been integrated into the test suite of QMCPACK.
By adding \sphinxcode{\sphinxupquote{\sphinxhyphen{}D QE\_BIN=your\_QE\_binary\_path}} in the CMake command line when building your QMCPACK,
tests named with the “qe\sphinxhyphen{}” prefix will be included in the test set of your build.
You can test the whole \sphinxcode{\sphinxupquote{pw \textgreater{} pw2qmcpack \textgreater{} qmcpack workflow}} by

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ctest} \PYG{o}{\PYGZhy{}}\PYG{n}{R} \PYG{n}{qe}
\end{sphinxVerbatim}

See {\hyperref[\detokenize{installation:integtestqe}]{\sphinxcrossref{\DUrole{std,std-ref}{Integration tests with Quantum Espresso}}}} and the testing section for more details.


\section{How to build the fastest executable version of QMCPACK}
\label{\detokenize{installation:how-to-build-the-fastest-executable-version-of-qmcpack}}\label{\detokenize{installation:buildperformance}}
To build the fastest version of QMCPACK we recommend the following:
\begin{itemize}
\item {} 
Use the latest C++ compilers available for your
system. Substantial gains have been made optimizing C++ in recent
years.

\item {} 
Use a vendor\sphinxhyphen{}optimized BLAS library such as Intel MKL and AMD ACML. Although
QMC does not make extensive use of linear algebra, it is used in the
VMC wavefunction optimizer to apply the orbital coefficients in local basis
calculations and in the Slater determinant update.

\item {} 
Use a vector math library such as Intel VML.  For periodic
calculations, the calculation of the structure factor and Ewald
potential benefit from vectorized evaluation of sin and
cos. Currently we only autodetect Intel VML, as provided with MKL,
but support for MASSV and AMD LibM is included via \#defines. See,
for example, src/Numerics/e2iphi.h. For
large supercells, this optimization can gain 10\% in performance.

\end{itemize}

Note that greater speedups of QMC calculations can usually be obtained by
carefully choosing the required statistics for each
investigation. That is, do not compute smaller error bars than necessary.


\section{Troubleshooting the installation}
\label{\detokenize{installation:troubleshooting-the-installation}}\label{\detokenize{installation:troubleshoot}}
Some tips to help troubleshoot installations of QMCPACK:
\begin{itemize}
\item {} 
First, build QMCPACK on a workstation you control or on any
system with a simple and up\sphinxhyphen{}to\sphinxhyphen{}date set of development
tools. You can compare the results of CMake and QMCPACK on this
system with any more difficult systems you encounter.

\item {} 
Use up\sphinxhyphen{}to\sphinxhyphen{}date development software, particularly a recent
CMake.

\item {} 
Verify that the compilers and libraries you expect are
being configured. It is common to have multiple versions
installed. The configure system will stop at the first version it
finds, which might not be the most recent. If this occurs, directly specify the appropriate
directories and files ({\hyperref[\detokenize{installation:cmakeoptions}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration Options}}}}). For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}C\PYGZus{}COMPILER}\PYG{o}{=}\PYG{o}{/}\PYG{n}{full}\PYG{o}{/}\PYG{n}{path}\PYG{o}{/}\PYG{n}{to}\PYG{o}{/}\PYG{n}{mpicc} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}CXX\PYGZus{}COMPILER}\PYG{o}{=}\PYG{o}{/}\PYG{n}{full}\PYG{o}{/}\PYG{n}{path}\PYG{o}{/}\PYG{n}{to}\PYG{o}{/}\PYG{n}{mpicxx} \PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
To monitor the compiler and linker settings, use a verbose build, \sphinxcode{\sphinxupquote{make
VERBOSE=1}}. If an individual source file fails to compile you
can experiment by hand using the output of the verbose build to
reconstruct the full compilation line.

\end{itemize}

If you still have problems please post to the QMCPACK Google group with full
details, or contact a developer.


\chapter{Running QMCPACK}
\label{\detokenize{running:running-qmcpack}}\label{\detokenize{running:running}}\label{\detokenize{running::doc}}
QMCPACK requires at least one xml input file, and is invoked via:

\sphinxcode{\sphinxupquote{qmcpack {[}command line options{]} \textless{}XML input file(s)\textgreater{}}}


\section{Command line options}
\label{\detokenize{running:command-line-options}}
QMCPACK offers several command line options that affect how calculations
are performed. If the flag is absent, then the corresponding
option is disabled:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}dryrun}} Validate the input file without performing the simulation. This is a good way to ensure that QMCPACK will do what you think it will.

\item {} 
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}enable\sphinxhyphen{}timers=none|coarse|medium|fine}} Control the timer granularity when the build option \sphinxcode{\sphinxupquote{ENABLE\_TIMERS}} is enabled.

\item {} 
\sphinxcode{\sphinxupquote{help}} Print version information as well as a list of optional
command\sphinxhyphen{}line arguments.

\item {} 
\sphinxcode{\sphinxupquote{noprint}} Do not print extra information on Jastrow or pseudopotential.
If this flag is not present, QMCPACK will create several \sphinxcode{\sphinxupquote{.dat}} files
that contain information about pseudopotentials (one file per PP) and Jastrow
factors (one per Jastrow factor). These file might be useful for visual inspection
of the Jastrow, for example.

\item {} 
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}verbosity=low|high|debug}} Control the output verbosity. The default low verbosity is concise and, for example, does not include all electron or atomic positions for large systems to reduce output size. Use “high” to see this information and more details of initialization, allocations, QMC method settings, etc.

\item {} 
\sphinxcode{\sphinxupquote{version}} Print version information and optional arguments. Same as \sphinxcode{\sphinxupquote{help}}.

\end{itemize}


\section{Input files}
\label{\detokenize{running:input-files}}\label{\detokenize{running:inputs}}
The input is one or more XML file(s), documented in {\hyperref[\detokenize{input_overview:input-overview}]{\sphinxcrossref{\DUrole{std,std-ref}{Input file overview}}}}.


\section{Output files}
\label{\detokenize{running:output-files}}
QMCPACK generates multiple files documented in \DUrole{xref,std,std-ref}{output\sphinxhyphen{}overview}.


\section{Running in parallel with MPI}
\label{\detokenize{running:running-in-parallel-with-mpi}}\label{\detokenize{running:parallelrunning}}
QMCPACK is fully parallelized with MPI. When performing an ensemble job, all
the MPI ranks are first equally divided into groups that perform individual
QMC calculations. Within one calculation, all the walkers are fully distributed
across all the MPI ranks in the group. Since MPI requires distributed memory,
there must be at least one MPI per node. To maximize the efficiency, more facts
should be taken into account. When using MPI+threads on compute nodes with more
than one NUMA domain (e.g., AMD Interlagos CPU on Titan or a node with multiple
CPU sockets), it is recommended to place as many MPI ranks as the number of
NUMA domains if the memory is sufficient (e.g., one MPI task per socket). On clusters with more than one
GPU per node (NVIDIA Tesla K80), it is necessary to use the same number of MPI
ranks as the number of GPUs per node to let each MPI rank take one GPU.


\section{Using OpenMP threads}
\label{\detokenize{running:using-openmp-threads}}\label{\detokenize{running:openmprunning}}
Modern processors integrate multiple identical cores even with
hardware threads on a single die to increase the total performance and
maintain a reasonable power draw. QMCPACK takes advantage of this
compute capability by using threads and the OpenMP programming model
as well as threaded linear algebra libraries. By default, QMCPACK is
always built with OpenMP enabled. When launching calculations, users
should instruct QMCPACK to create the right number of threads per MPI
rank by specifying environment variable OMP\_NUM\_THREADS. Assuming
one MPI rank per socket, the number of threads should typically be the
number of cores on that socket. Even in the GPU\sphinxhyphen{}accelerated version,
using threads significantly reduces the time spent on the calculations
performed by the CPU.


\subsection{Nested OpenMP threads}
\label{\detokenize{running:nested-openmp-threads}}
Nested threading is an advanced feature requiring experienced users to finely tune runtime parameters to reach the best performance.

For small\sphinxhyphen{}to\sphinxhyphen{}medium problem sizes, using one thread per walker or for multiple walkers is most efficient. This is the default in QMCPACK and achieves the shortest time to solution.

For large problems of at least 1,000 electrons, use of nested OpenMP threading can be enabled to reduce the time to solution further, although at some loss of efficiency. In this scheme multiple threads are used in the computations of each walker. This capability is implemented for some of the key computational kernels: the 3D spline orbital evaluation, certain portions of the distance tables, and implicitly the BLAS calls in the determinant update. Use of the batched nonlocal pseudopotential evaluation is also recommended.

Nested threading is enabled by setting \sphinxcode{\sphinxupquote{OMP\_NUM\_THREADS=AA,BB}}, \sphinxcode{\sphinxupquote{OMP\_MAX\_ACTIVE\_LEVELS=2}} and \sphinxcode{\sphinxupquote{OMP\_NESTED=TRUE}} where the additional \sphinxcode{\sphinxupquote{BB}} is the number of second\sphinxhyphen{}level threads.  Choosing the thread affinity is critical to the performance.
QMCPACK provides a tool qmc\sphinxhyphen{}check\sphinxhyphen{}affinity (source file src/QMCTools/check\sphinxhyphen{}affinity.cpp for details), which might help users investigate the affinity. Knowledge of how the operating system logical CPU cores (/prco/cpuinfo) are bound to the hardware is also needed.

For example, on Blue Gene/Q with a Clang compiler, the best way to fully use the 16 cores each with 4 hardware threads is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{OMP\PYGZus{}NESTED}\PYG{o}{=}\PYG{n}{TRUE}
\PYG{n}{OMP\PYGZus{}NUM\PYGZus{}THREADS}\PYG{o}{=}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{4}
\PYG{n}{MAX\PYGZus{}ACTIVE\PYGZus{}LEVELS}\PYG{o}{=}\PYG{l+m+mi}{2}
\PYG{n}{OMP\PYGZus{}PLACES}\PYG{o}{=}\PYG{n}{threads}
\PYG{n}{OMP\PYGZus{}PROC\PYGZus{}BIND}\PYG{o}{=}\PYG{n}{spread}\PYG{p}{,}\PYG{n}{close}
\end{sphinxVerbatim}

On Intel Xeon Phi KNL with an Intel compiler, to use 64 cores without using hardware threads:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{OMP\PYGZus{}NESTED}\PYG{o}{=}\PYG{n}{TRUE}
\PYG{n}{OMP\PYGZus{}WAIT\PYGZus{}POLICY}\PYG{o}{=}\PYG{n}{ACTIVE}
\PYG{n}{OMP\PYGZus{}NUM\PYGZus{}THREADS}\PYG{o}{=}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{4}
\PYG{n}{MAX\PYGZus{}ACTIVE\PYGZus{}LEVELS}\PYG{o}{=}\PYG{l+m+mi}{2}
\PYG{n}{OMP\PYGZus{}PLACES}\PYG{o}{=}\PYG{n}{cores}
\PYG{n}{OMP\PYGZus{}PROC\PYGZus{}BIND}\PYG{o}{=}\PYG{n}{spread}\PYG{p}{,}\PYG{n}{close}
\PYG{n}{KMP\PYGZus{}HOT\PYGZus{}TEAMS\PYGZus{}MODE}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{n}{KMP\PYGZus{}HOT\PYGZus{}TEAMS\PYGZus{}MAX\PYGZus{}LEVEL}\PYG{o}{=}\PYG{l+m+mi}{2}
\end{sphinxVerbatim}

Most multithreaded BLAS/LAPACK libraries do not spawn threads by default
when being called from an OpenMP parallel region. See the explanation in {\hyperref[\detokenize{installation:threadedlibrary}]{\sphinxcrossref{\DUrole{std,std-ref}{Serial or multithreaded library}}}}.
This results in the use of only a single thread in each second\sphinxhyphen{}level thread team for BLAS/LAPACK operations.
Some vendor libraries like MKL support using multiple threads when being called from an OpenMP parallel region.
One way to enable this feature is using environment variables to override the default behavior.
However, this forces all the calls to the library to use the same number of threads.
As a result, small function calls are penalized with heavy overhead and heavy function calls are slow for not being able to use more threads.
Instead, QMCPACK uses the library APIs to turn on nested threading only at selected performance critical calls.
In the case of using a serial library, QMCPACK implements nested threading to distribute the workload wherever necessary.
Users do not need to control the threading behavior of the library.


\subsection{Performance considerations}
\label{\detokenize{running:performance-considerations}}\label{\detokenize{running:cpu-performance}}
As walkers are the basic units of workload in QMC algorithms, they are loosely coupled and distributed across all the threads. For this reason, the best strategy to run QMCPACK efficiently is to feed enough walkers to the available threads.

In a VMC calculation, the code automatically raises the actual number of walkers per MPI rank to the number of available threads
if the user\sphinxhyphen{}specified number of walkers is smaller, see “walkers/mpi=XXX” in the VMC output.

In DMC, for typical small to mid\sphinxhyphen{}sized calculations choose the total number of walkers to be a significant multiple of the total number of
threads (MPI tasks * threads per task). This will ensure a good load balance. e.g., for a calculation on a few nodes with a total
512 threads, using 5120 walkers may keep the load imbalance around 10\%. For the very largest calculations, the target number of
walkers should be chosen to be slightly smaller than a multiple of the total number of available threads across all the MPI ranks.
This will reduce occurrences worse\sphinxhyphen{}case load imbalance e.g. where one thread has two walkers while all the others have one.

To achieve better performance, a mixed\sphinxhyphen{}precision version (experimental) has been developed in the CPU code. The mixed\sphinxhyphen{}precision
CPU code uses a mixed of single precision (SP) and double precision (DP) operations, while the default code use DP exclusively.
This mixed precision version is more aggressive than the GPU CUDA version in using single precision (SP) operations. The Current implementation uses SP on most
calculations, except for matrix inversions and reductions where double precision is required to retain high accuracy. All the
constant spline data in wavefunction, pseudopotentials, and Coulomb potentials are initialized in double precision and later
stored in single precision. The mixed\sphinxhyphen{}precision code is as accurate as the double\sphinxhyphen{}precision code up to a certain system size, and
may have double the throughput.
Cross checking and verification of accuracy is always required but is particularly important above approximately 1,500 electrons.


\subsection{Memory considerations}
\label{\detokenize{running:memory-considerations}}
When using threads, some memory objects are shared by all the threads. Usually these memory objects are read only when the walkers are evolving, for instance the ionic distance table and wavefunction coefficients.
If a wavefunction is represented by B\sphinxhyphen{}splines, the whole table is shared by all the threads. It usually takes a large chunk of memory when a large primitive cell was used in the simulation. Its actual size is reported as “MEMORY increase XXX MB BsplineSetReader” in the output file.
See details about how to reduce it in {\hyperref[\detokenize{intro_wavefunction:spo-spline}]{\sphinxcrossref{\DUrole{std,std-ref}{Spline basis sets}}}}.

The other memory objects that are distinct for each walker during random walks need to be
associated with individual walkers and cannot be shared. This part of memory grows linearly as the number of walkers per MPI rank. Those objects include wavefunction values (Slater determinants) at given electronic configurations and electron\sphinxhyphen{}related distance tables (electron\sphinxhyphen{}electron distance table). Those matrices dominate the \(N^2\) scaling of the memory usage per walker.


\section{Running on GPU machines}
\label{\detokenize{running:running-on-gpu-machines}}\label{\detokenize{running:gpurunning}}
The GPU version for the NVIDIA CUDA platform is fully incorporated into
the main source code. Commonly used functionalities for
solid\sphinxhyphen{}state and molecular systems using B\sphinxhyphen{}spline single\sphinxhyphen{}particle
orbitals are supported. Use of Gaussian basis sets, three\sphinxhyphen{}body
Jastrow functions, and many observables are not yet supported. A detailed description of the GPU
implementation can be found in \sphinxcite{running:eslerkimceperleyshulenburger2012}.

The current GPU implementation assumes one MPI process per GPU. To use
nodes with multiple GPUs, use multiple MPI processes per node.
Vectorization is achieved over walkers, that is, all walkers are
propagated in parallel. In each GPU kernel, loops over electrons,
atomic cores, or orbitals are further vectorized to exploit an
additional level of parallelism and to allow coalesced memory access.


\subsection{Performance considerations}
\label{\detokenize{running:gpu-performance}}\label{\detokenize{running:id2}}
To run with high performance on GPUs it is crucial to perform some
benchmarking runs: the optimum configuration is system size, walker
count, and GPU model dependent. The GPU implementation vectorizes
operations over multiple walkers, so generally the more walkers that
are placed on a GPU, the higher the performance that will be
obtained. Performance also increases with electron count, up until the
memory on the GPU is exhausted. A good strategy is to perform a short
series of VMC runs with walker count increasing in multiples of
two. For systems with 100s of electrons, typically 128\textendash{}256 walkers per
GPU use a sufficient number of GPU threads to operate the GPU
efficiently and to hide memory\sphinxhyphen{}access latency. For smaller systems,
thousands of walkers might be required. For QMC algorithms where the number of
walkers is fixed such as VMC, choosing a walker count the is a multiple of the
number of streaming multiprocessors can be most efficient. For
variable population DMC runs, this exact match is not possible.

To achieve better performance, the current GPU implementation uses
single\sphinxhyphen{}precision operations for most of the calculations. Double
precision is used in matrix inversions and the Coulomb interaction to
retain high accuracy. The mixed\sphinxhyphen{}precision GPU code is as accurate as
the double\sphinxhyphen{}precision CPU code up to a certain system size. Cross
checking and verification of accuracy are encouraged for systems with
more than approximately 1,500 electrons. For typical calculations on
smaller electron counts, the statistical error bars are much larger
then the error introduced by mixed precision.


\subsection{Memory considerations}
\label{\detokenize{running:id3}}
In the GPU implementation, each walker has a buffer in the GPU’s
global memory to store temporary data associated with the
wavefunctions. Therefore, the amount of memory available on a GPU
limits the number of walkers and eventually the system size that it
can process. Additionally, for calculations using B\sphinxhyphen{}splines, this data
is stored on the GPU in a shared read\sphinxhyphen{}only buffer. Often the size of the
B\sphinxhyphen{}spline data limits the calculations that can be run on the GPU.

If the GPU memory is exhausted, first try reducing the number of walkers per GPU.
Coarsening the grids of the B\sphinxhyphen{}splines representation (by decreasing
the value of the mesh factor in the input file) can also lower the memory
usage, at the expense (risk) of obtaining inaccurate results. Proceed
with caution if this option has to be considered.  It is also possible
to distribute the B\sphinxhyphen{}spline coefficients table between the host and GPU
memory, see option Spline\_Size\_Limit\_MB in
{\hyperref[\detokenize{intro_wavefunction:spo-spline}]{\sphinxcrossref{\DUrole{std,std-ref}{Spline basis sets}}}}.




\chapter{Units used in QMCPACK}
\label{\detokenize{units:units-used-in-qmcpack}}\label{\detokenize{units:units}}\label{\detokenize{units::doc}}
Internally, QMCPACK uses atomic units throughout. Unless stated, all inputs and outputs are also in atomic units. For convenience the analysis tools offer conversions to eV, Ry, Angstrom, Bohr, etc.


\chapter{Input file overview}
\label{\detokenize{input_overview:input-file-overview}}\label{\detokenize{input_overview:input-overview}}\label{\detokenize{input_overview::doc}}
This chapter introduces XML as it is used in the QMCPACK input file.  The focus is on the XML file format itself and the general structure of the input file rather than an exhaustive discussion of all keywords and structure elements.

QMCPACK uses XML to represent structured data in its input file.  Instead of text blocks like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{begin} \PYG{n}{project}
  \PYG{n+nb}{id}     \PYG{o}{=} \PYG{n}{vmc}
  \PYG{n}{series} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{end} \PYG{n}{project}

\PYG{n}{begin} \PYG{n}{vmc}
  \PYG{n}{move}     \PYG{o}{=} \PYG{n}{pbyp}
  \PYG{n}{blocks}   \PYG{o}{=} \PYG{l+m+mi}{200}
  \PYG{n}{steps}    \PYG{o}{=}  \PYG{l+m+mi}{10}
  \PYG{n}{timestep} \PYG{o}{=} \PYG{l+m+mf}{0.4}
\PYG{n}{end} \PYG{n}{vmc}
\end{sphinxVerbatim}

QMCPACK input looks like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{project} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{vmc}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{series}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{project}\PYG{o}{\PYGZgt{}}

\PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{vmc}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pbyp}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{200} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{steps}\PYG{l+s+s2}{\PYGZdq{}}   \PYG{o}{\PYGZgt{}}   \PYG{l+m+mi}{10} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mf}{0.4} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

XML elements start with \sphinxcode{\sphinxupquote{\textless{}element\_name\textgreater{}}}, end with \sphinxcode{\sphinxupquote{\textless{}/element\_name\textgreater{}\}}}, and can be nested within each other to denote substructure (the trial wavefunction is composed of a Slater determinant and a Jastrow factor, which are each further composed of \(...\)).  \sphinxcode{\sphinxupquote{id}} and \sphinxcode{\sphinxupquote{series}} are attributes of the \sphinxcode{\sphinxupquote{\textless{}project/\textgreater{}}} element.  XML attributes are generally used to represent simple values, like names, integers, or real values.  Similar functionality is also commonly provided by \sphinxcode{\sphinxupquote{\textless{}parameter/\textgreater{}}} elements like those previously shown.

The overall structure of the input file reflects different aspects of the QMC simulation: the simulation cell, particles, trial wavefunction, Hamiltonian, and QMC run parameters.  A condensed version of the actual input file is shown as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}?xml version=\PYGZdq{}1.0\PYGZdq{}?\PYGZgt{}
\PYGZlt{}simulation\PYGZgt{}

\PYGZlt{}project id=\PYGZdq{}vmc\PYGZdq{} series=\PYGZdq{}0\PYGZdq{}\PYGZgt{}
  ...
\PYGZlt{}/project\PYGZgt{}

\PYGZlt{}qmcsystem\PYGZgt{}

  \PYGZlt{}simulationcell\PYGZgt{}
    ...
  \PYGZlt{}/simulationcell\PYGZgt{}

  \PYGZlt{}particleset name=\PYGZdq{}e\PYGZdq{}\PYGZgt{}
    ...
  \PYGZlt{}/particleset\PYGZgt{}

  \PYGZlt{}particleset name=\PYGZdq{}ion0\PYGZdq{}\PYGZgt{}
    ...
  \PYGZlt{}/particleset\PYGZgt{}

  \PYGZlt{}wavefunction name=\PYGZdq{}psi0\PYGZdq{} ... \PYGZgt{}
    ...
    \PYGZlt{}determinantset\PYGZgt{}
      \PYGZlt{}slaterdeterminant\PYGZgt{}
        ..
      \PYGZlt{}/slaterdeterminant\PYGZgt{}
    \PYGZlt{}/determinantset\PYGZgt{}
    \PYGZlt{}jastrow type=\PYGZdq{}One\PYGZhy{}Body\PYGZdq{} ... \PYGZgt{}
       ...
    \PYGZlt{}/jastrow\PYGZgt{}
    \PYGZlt{}jastrow type=\PYGZdq{}Two\PYGZhy{}Body\PYGZdq{} ... \PYGZgt{}
      ...
    \PYGZlt{}/jastrow\PYGZgt{}
  \PYGZlt{}/wavefunction\PYGZgt{}

  \PYGZlt{}hamiltonian name=\PYGZdq{}h0\PYGZdq{} ... \PYGZgt{}
    \PYGZlt{}pairpot type=\PYGZdq{}coulomb\PYGZdq{} name=\PYGZdq{}ElecElec\PYGZdq{} ... /\PYGZgt{}
    \PYGZlt{}pairpot type=\PYGZdq{}coulomb\PYGZdq{} name=\PYGZdq{}IonIon\PYGZdq{}   ... /\PYGZgt{}
    \PYGZlt{}pairpot type=\PYGZdq{}pseudo\PYGZdq{} name=\PYGZdq{}PseudoPot\PYGZdq{} ... \PYGZgt{}
      ...
    \PYGZlt{}/pairpot\PYGZgt{}
  \PYGZlt{}/hamiltonian\PYGZgt{}

 \PYGZlt{}/qmcsystem\PYGZgt{}

 \PYGZlt{}qmc method=\PYGZdq{}vmc\PYGZdq{} move=\PYGZdq{}pbyp\PYGZdq{}\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}warmupSteps\PYGZdq{}\PYGZgt{}   20 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}blocks\PYGZdq{}     \PYGZgt{}  200 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}steps\PYGZdq{}      \PYGZgt{}   10 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}timestep\PYGZdq{}   \PYGZgt{}  0.4 \PYGZlt{}/parameter\PYGZgt{}
 \PYGZlt{}/qmc\PYGZgt{}

\PYGZlt{}/simulation\PYGZgt{}
\end{sphinxVerbatim}

The omitted portions \sphinxcode{\sphinxupquote{...}} are more fine\sphinxhyphen{}grained inputs such as the axes of the simulation cell, the number of up and down electrons, positions of atomic species, external orbital files, starting Jastrow parameters, and external pseudopotential files.


\section{Project}
\label{\detokenize{input_overview:project}}
The \sphinxcode{\sphinxupquote{\textless{}project\textgreater{}}} tag uses the \sphinxcode{\sphinxupquote{id}} and \sphinxcode{\sphinxupquote{series}} attributes.
The value of \sphinxcode{\sphinxupquote{id}} is the first part of the prefix for output file names.

Output file names also contain the series number, starting at the value given by the
\sphinxcode{\sphinxupquote{series}} tag.  After every \sphinxcode{\sphinxupquote{\textless{}qmc\textgreater{}}} section, the series value will increment, giving each section a unique prefix.

For the input file shown previously, the output files will start with \sphinxcode{\sphinxupquote{vmc.s000}}, for example, \sphinxcode{\sphinxupquote{vmc.s000.scalar.dat}}.
If there were another \sphinxcode{\sphinxupquote{\textless{}qmc\textgreater{}}} section in the input file, the corresponding output files would use the prefix \sphinxcode{\sphinxupquote{vmc.s001}}.


\section{Random number initialization}
\label{\detokenize{input_overview:random-number-initialization}}
The random number generator state is initialized from the \sphinxcode{\sphinxupquote{random}} element using the \sphinxcode{\sphinxupquote{seed}} attribute:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{random} \PYG{n}{seed}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1000}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

If the random element is not present, or the seed value is negative, the seed will be generated from the current time.

To initialize the many independent random number generators (one per thread and MPI process), the seed value is used (modulo 1024) as a starting index into a list of prime numbers.
Entries in this offset list of prime numbers are then used as the seed for the random generator on each thread and process.

If checkpointing is enabled, the random number state is written to an HDF file at the end of each block (suffix: \sphinxcode{\sphinxupquote{.random.h5}}).
This file will be read if the \sphinxcode{\sphinxupquote{mcwalkerset}} tag is present to perform a restart.
For more information, see the \sphinxcode{\sphinxupquote{checkpoint}} element in the QMC methods {\hyperref[\detokenize{methods:qmcmethods}]{\sphinxcrossref{\DUrole{std,std-ref}{Quantum Monte Carlo Methods}}}} and \DUrole{xref,std,std-ref}{checkpoint\sphinxhyphen{}files} on checkpoint and restart files.


\chapter{Specifying the system to be simulated}
\label{\detokenize{simulationcell:specifying-the-system-to-be-simulated}}\label{\detokenize{simulationcell:simulationcell}}\label{\detokenize{simulationcell::doc}}

\section{Specifying the Simulation Cell}
\label{\detokenize{simulationcell:specifying-the-simulation-cell}}
The \sphinxcode{\sphinxupquote{simulationcell}} block specifies the geometry of the cell, how the boundary
conditions should be handled, and how ewald summation should be broken
up.

\sphinxcode{\sphinxupquote{simulationcell}} Element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements:
&
\sphinxcode{\sphinxupquote{qmcsystem}}
\\
\hline
Child elements:
&
None
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Attribute:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{parameter name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{description}
\\
\hline
\sphinxcode{\sphinxupquote{lattice}}
&
9 floats
&
any float
&
Must be specified
&
Specification of lattice vectors.
\\
\hline
\sphinxcode{\sphinxupquote{bconds}}
&
string
&
“p” or “n”
&
“n n n “
&
Boundary conditions for each axis.
\\
\hline
\sphinxcode{\sphinxupquote{vacuum}}
&
float
&
\(\geq 1.0\)
&
1.0
&
Vacuum scale.
\\
\hline
\sphinxcode{\sphinxupquote{LR\_dim\_cutoff}}
&
float
&
float
&
15
&
Ewald breakup distance.
\\
\hline
\sphinxcode{\sphinxupquote{LR\_tol}}
&
float
&
float
&
3e\sphinxhyphen{}4
&
Tolerance in Ha for Ewald ion\sphinxhyphen{}ion energy per atom.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

An example of a block is given below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{simulationcell}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lattice}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{l+m+mf}{3.8}       \PYG{l+m+mf}{0.0}       \PYG{l+m+mf}{0.0}
      \PYG{l+m+mf}{0.0}       \PYG{l+m+mf}{3.8}       \PYG{l+m+mf}{0.0}
      \PYG{l+m+mf}{0.0}       \PYG{l+m+mf}{0.0}       \PYG{l+m+mf}{3.8}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bconds}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
       \PYG{n}{p} \PYG{n}{p} \PYG{n}{p}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LR\PYGZus{}dim\PYGZus{}cutoff}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{20} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{simulationcell}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Here, a cubic cell 3.8 bohr on a side will be used. This simulation will
use periodic boundary conditions, and the maximum \(k\) vector will
be \(20/r_{wigner-seitz}\) of the cell.


\subsection{Lattice}
\label{\detokenize{simulationcell:lattice}}
The cell is specified using 3 lattice vectors.


\subsection{Boundary conditions}
\label{\detokenize{simulationcell:boundary-conditions}}
QMCPACK offers the capability to use a mixture of open and periodic
boundary conditions. The parameter expects a single string of three
characters separated by spaces, \sphinxstyleemphasis{e.g.} “p p p” for purely periodic
boundary conditions. These characters control the behavior of the
\(x\), \(y\), and \(z\), axes, respectively. Non periodic
directions must be placed after the periodic ones. Examples of valid
include:

\sphinxstylestrong{“p p p”} Periodic boundary conditions. Corresponds to a 3D crystal.

\sphinxstylestrong{“p p n”} Slab geometry. Corresponds to a 2D crystal.

\sphinxstylestrong{“p n n”} Wire geometry. Corresponds to a 1D crystal.

\sphinxstylestrong{“n n n”}
Open boundary conditions. Corresponds to an isolated molecule in a vacuum.


\subsection{Vacuum}
\label{\detokenize{simulationcell:vacuum}}
The vacuum option allows adding a vacuum region in slab or wire boundary
conditions (\sphinxcode{\sphinxupquote{bconds= p p n}} or \sphinxcode{\sphinxupquote{bconds= p n n}}, respectively). The main use is to save memory with
spline or plane\sphinxhyphen{}wave basis trial wavefunctions, because no basis
functions are required inside the vacuum region. For example, a large
vacuum region can be added above and below a graphene sheet without
having to generate the trial wavefunction in such a large box or to have
as many splines as would otherwise be required. Note that the trial
wavefunction must still be generated in a large enough box to
sufficiently reduce periodic interactions in the underlying electronic
structure calculation.

With the vacuum option, the box used for Ewald summation increases along
the axis labeled by a factor of \sphinxcode{\sphinxupquote{vacuum}}. Note that all the particles remain in
the original box without altering their positions. i.e. Bond lengths are
not changed by this option. The default value is 1, no change to the
specified axes.

An example of a \sphinxcode{\sphinxupquote{simulationcell}} block using is given below. The size of the box along
the z\sphinxhyphen{}axis increases from 12 to 18 by the vacuum scale of 1.5.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{simulationcell}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lattice}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{l+m+mf}{3.8}       \PYG{l+m+mf}{0.0}       \PYG{l+m+mf}{0.0}
      \PYG{l+m+mf}{0.0}       \PYG{l+m+mf}{3.8}       \PYG{l+m+mf}{0.0}
      \PYG{l+m+mf}{0.0}       \PYG{l+m+mf}{0.0}      \PYG{l+m+mf}{12.0}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bconds}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
       \PYG{n}{p} \PYG{n}{p} \PYG{n}{n}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{vacuum}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1.5} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LR\PYGZus{}dim\PYGZus{}cutoff}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{20} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{simulationcell}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{LR\_dim\_cutoff}
\label{\detokenize{simulationcell:lr-dim-cutoff}}
When using periodic boundary conditions direct calculation of the
Coulomb energy is not well behaved. As a result, QMCPACK uses an
optimized Ewald summation technique to compute the Coulomb
interaction. \sphinxcite{simulationcell:natoli1995}

In the Ewald summation, the energy is broken into short\sphinxhyphen{} and long\sphinxhyphen{}ranged
terms. The short\sphinxhyphen{}ranged term is computed directly in real space, while
the long\sphinxhyphen{}ranged term is computed in reciprocal space. controls where the
short\sphinxhyphen{}ranged term ends and the long\sphinxhyphen{}ranged term begins. The real\sphinxhyphen{}space
cutoff, reciprocal\sphinxhyphen{}space cutoff, and are related via:
\begin{equation*}
\begin{split}\mathrm{LR\_dim\_cutoff} = r_{c} \times k_{c}\end{split}
\end{equation*}
where \(r_{c}\) is the Wigner\sphinxhyphen{}Seitz radius, and \(k_{c}\) is the
length of the maximum \(k\)\sphinxhyphen{}vector used in the long\sphinxhyphen{}ranged term.
Larger values of increase the accuracy of the evaluation. A value of 15
tends to be conservative.


\section{Specifying the particle set}
\label{\detokenize{simulationcell:specifying-the-particle-set}}\label{\detokenize{simulationcell:particleset}}
The \sphinxcode{\sphinxupquote{particleset}} blocks specify the particles in the QMC simulations: their types,
attributes (mass, charge, valence), and positions.


\subsection{Input specification}
\label{\detokenize{simulationcell:input-specification}}
\sphinxcode{\sphinxupquote{particleset}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements
&
\sphinxcode{\sphinxupquote{simulation}}
\\
\hline
Child elements
&
\sphinxcode{\sphinxupquote{group}}, \sphinxcode{\sphinxupquote{attrib}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Attribute:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Datatype
&\sphinxstyletheadfamily 
Values
&\sphinxstyletheadfamily 
Default
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{name/id}}
&
Text
&
\sphinxstyleemphasis{Any}
&
e
&
Name of particle set
\\
\hline
\sphinxcode{\sphinxupquote{size}}\(^o\)
&
Integer
&
\sphinxstyleemphasis{Any}
&
0
&
Number of particles in set
\\
\hline
\sphinxcode{\sphinxupquote{random}}\(^o\)
&
Text
&
Yes/no
&
No
&
Randomize starting positions
\\
\hline
\sphinxcode{\sphinxupquote{randomsrc}}/\sphinxcode{\sphinxupquote{randomsrc}}\(^o\)
&
Text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
\sphinxstyleemphasis{None}
&
Particle set to randomize
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\subsection{Detailed attribute description}
\label{\detokenize{simulationcell:detailed-attribute-description}}

\subsubsection{Required particleset attributes}
\label{\detokenize{simulationcell:required-particleset-attributes}}\begin{itemize}
\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{name/id}}
\item[] Unique name for the particle set. Default is “e” for electrons. “i”
or “ion0” is typically used for ions. For special cases where an
empty particle set is needed, the special name “empty” can be used
to bypass the zero\sphinxhyphen{}size error check.
\end{DUlineblock}

\end{itemize}


\subsubsection{Optional particleset attributes}
\label{\detokenize{simulationcell:optional-particleset-attributes}}\begin{itemize}
\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{size}}
\item[] Number of particles in set.
\end{DUlineblock}

\end{itemize}

\sphinxcode{\sphinxupquote{Group}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements
&
\sphinxcode{\sphinxupquote{particleset}}
\\
\hline
Child elements
&
\sphinxcode{\sphinxupquote{parameter}}, \sphinxcode{\sphinxupquote{attrib}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Attribute:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Datatype
&\sphinxstyletheadfamily 
Values
&\sphinxstyletheadfamily 
Default
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{name}}
&
Text
&
\sphinxstyleemphasis{Any}
&
e
&
Name of particle set
\\
\hline
\sphinxcode{\sphinxupquote{size}}\(^o\)
&
Integer
&
\sphinxstyleemphasis{Any}
&
0
&
Number of particles in set
\\
\hline
\sphinxcode{\sphinxupquote{mass}}\(^o\)
&
Real
&
\sphinxstyleemphasis{Any}
&
1
&
Mass of particles in set
\\
\hline
\sphinxcode{\sphinxupquote{unit}}\(^o\)
&
Text
&
au/amu
&
au
&
Units for mass of particles
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Parameters:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Datatype
&\sphinxstyletheadfamily 
Values
&\sphinxstyletheadfamily 
Default
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{charge}}
&
Real
&
\sphinxstyleemphasis{Any}
&
0
&
Charge of particles in set
\\
\hline
\sphinxcode{\sphinxupquote{valence}}
&
Real
&
\sphinxstyleemphasis{Any}
&
0
&
Valence charge of particles in set
\\
\hline
\sphinxcode{\sphinxupquote{atomicnumber}}
&
Integer
&
\sphinxstyleemphasis{Any}
&
0
&
Atomic number of particles in set
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

\sphinxcode{\sphinxupquote{attrib}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements
&
\sphinxcode{\sphinxupquote{particleset}}, \sphinxcode{\sphinxupquote{group}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Attribute:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{name}}
&
String
&
\sphinxstyleemphasis{Any}
&
\sphinxstyleemphasis{None}
&
Name of attrib
\\
\hline
\sphinxcode{\sphinxupquote{datatype}}
&
String
&
IntArray, realArray, posArray, stringArray
&
\sphinxstyleemphasis{None}
&
Type of data in attrib
\\
\hline
\sphinxcode{\sphinxupquote{size}}\(^o\)
&
String
&
\sphinxstyleemphasis{Any}
&
\sphinxstyleemphasis{None}
&
Size of data in attrib
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}
\begin{itemize}
\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{random}}
\item[] Randomize starting positions of particles. Each component of each
particle’s position is randomized independently in the range of the
simulation cell in that component’s direction.
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{randomsrc}}/\sphinxcode{\sphinxupquote{random\_source}}
\item[] Specify source particle set around which to randomize the initial
positions of this particle set.
\end{DUlineblock}

\end{itemize}


\subsubsection{Required name attributes}
\label{\detokenize{simulationcell:required-name-attributes}}\begin{itemize}
\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{name}}/\sphinxcode{\sphinxupquote{id}}
\item[] Unique name for the particle set group. Typically, element symbols
are used for ions and “u” or “d” for spin\sphinxhyphen{}up and spin\sphinxhyphen{}down electron
groups, respectively.
\end{DUlineblock}

\end{itemize}


\subsubsection{Optional group attributes}
\label{\detokenize{simulationcell:optional-group-attributes}}\begin{itemize}
\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{mass}}
\item[] Mass of particles in set.
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{unit}}
\item[] Units for mass of particles in set (au{[}\(m_e\) = 1{]} or
amu{[}\(\frac{1}{12}m_{\rm ^{12}C}\) = 1{]}).
\end{DUlineblock}

\end{itemize}


\subsection{Example use cases}
\label{\detokenize{simulationcell:example-use-cases}}\phantomsection\label{\detokenize{simulationcell:listing1}}
\begin{center}Particleset elements for ions and electrons randomizing electron start positions.
\end{center}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{particleset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Li}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{3.000000}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{valence}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{3.000000}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{atomicnumber}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{3.000000}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1.000000}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{valence}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1.000000}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{atomicnumber}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1.000000}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{attrib} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{position}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{datatype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{posArray}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{condition}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{l+m+mf}{0.0}   \PYG{l+m+mf}{0.0}   \PYG{l+m+mf}{0.0}
  \PYG{l+m+mf}{0.5}   \PYG{l+m+mf}{0.5}   \PYG{l+m+mf}{0.5}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{attrib}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{attrib} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ionid}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{datatype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{stringArray}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
     \PYG{n}{Li} \PYG{n}{H}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{attrib}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{particleset}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{particleset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{random}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{randomsrc}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{particleset}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\begin{center}Particleset elements for ions and electrons specifying electron start positions.
\end{center}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{particleset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{attrib} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{position}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{datatype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{posArray}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{l+m+mf}{2.9151687332e\PYGZhy{}01} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.5123272502e\PYGZhy{}01} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.2188463918e\PYGZhy{}01}
  \PYG{l+m+mf}{5.8423636048e\PYGZhy{}01}  \PYG{l+m+mf}{4.2730406357e\PYGZhy{}01} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.5964306231e\PYGZhy{}03}
  \PYG{l+m+mf}{3.5228575807e\PYGZhy{}01} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.5027014639e\PYGZhy{}01}  \PYG{l+m+mf}{5.2644808295e\PYGZhy{}01}
     \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.1686250912e\PYGZhy{}01} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.6648002292e+00}  \PYG{l+m+mf}{6.5837023441e\PYGZhy{}01}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{attrib}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{attrib} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{position}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{datatype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{posArray}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{l+m+mf}{3.1443445436e\PYGZhy{}01}  \PYG{l+m+mf}{6.5068682609e\PYGZhy{}01} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.0983449009e\PYGZhy{}02}
     \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.8686061749e\PYGZhy{}01} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{9.3744432997e\PYGZhy{}02} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0456005388e\PYGZhy{}01}
  \PYG{l+m+mf}{2.4978241724e\PYGZhy{}02} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.2862514649e\PYGZhy{}02} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.2266047173e\PYGZhy{}01}
     \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.0352404772e\PYGZhy{}01}  \PYG{l+m+mf}{1.1927734805e+00}  \PYG{l+m+mf}{5.5610824921e\PYGZhy{}01}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{attrib}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{particleset}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{particleset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{O}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{6}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{valence}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{4}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{atomicnumber}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{8}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{valence}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{atomicnumber}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{attrib} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{position}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{datatype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{posArray}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{l+m+mf}{0.0000000000e+00}  \PYG{l+m+mf}{0.0000000000e+00}  \PYG{l+m+mf}{0.0000000000e+00}
    \PYG{l+m+mf}{0.0000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.4308249289e+00}  \PYG{l+m+mf}{1.1078707576e+00}
    \PYG{l+m+mf}{0.0000000000e+00}  \PYG{l+m+mf}{1.4308249289e+00}  \PYG{l+m+mf}{1.1078707576e+00}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{attrib}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{attrib} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ionid}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{datatype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{stringArray}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{O} \PYG{n}{H} \PYG{n}{H}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{attrib}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{particleset}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\begin{center}Particleset elements for ions specifying positions by ion type.
\end{center}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{particleset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{O}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{6}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{valence}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{4}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{atomicnumber}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{8}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{attrib} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{position}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{datatype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{posArray}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{l+m+mf}{0.0000000000e+00}  \PYG{l+m+mf}{0.0000000000e+00}  \PYG{l+m+mf}{0.0000000000e+00}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{attrib}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{valence}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{atomicnumber}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{attrib} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{position}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{datatype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{posArray}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{l+m+mf}{0.0000000000e+00} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.4308249289e+00}  \PYG{l+m+mf}{1.1078707576e+00}
      \PYG{l+m+mf}{0.0000000000e+00}  \PYG{l+m+mf}{1.4308249289e+00}  \PYG{l+m+mf}{1.1078707576e+00}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{attrib}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{particleset}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}




\chapter{Trial wavefunction specificaion}
\label{\detokenize{intro_wavefunction:trial-wavefunction-specificaion}}\label{\detokenize{intro_wavefunction:intro-wavefunction}}\label{\detokenize{intro_wavefunction::doc}}

\section{Introduction}
\label{\detokenize{intro_wavefunction:introduction}}\label{\detokenize{intro_wavefunction:trial-intro}}
This section describes the input blocks associated with the specification of the trial wavefunction in a QMCPACK calculation. These sections are contained within the \sphinxcode{\sphinxupquote{\textless{}wavefunction\textgreater{}}} \(...\)  \sphinxcode{\sphinxupquote{\textless{}/wavefunction\textgreater{}}} xml blocks. \sphinxstylestrong{Users are expected to rely on converters to generate the input blocks described in this section.} The converters and the workflows are designed such that input blocks require minimum modifications from users. Unless the workflow requires modification of wavefunction blocks (e.g., setting the cutoff in a multideterminant calculation), only expert users should directly alter them.

The trial wavefunction in QMCPACK has a general product form:
\begin{equation}\label{equation:intro_wavefunction:eq1}
\begin{split}\Psi_T(\vec{r}) = \prod_k \Theta_k(\vec{r}) ,\end{split}
\end{equation}
where each \(\Theta_k(\vec{r})\) is a function of the electron coordinates
(and possibly ionic coordinates and variational parameters).
For problems involving electrons, the overall trial wavefunction
must be antisymmetric with respect to electron exchange,
so at least one of the functions in the product must be
antisymmetric. Notice that, although QMCPACK allows for the
construction of arbitrary trial wavefunctions based on the
functions implemented in the code
(e.g., slater determinants, jastrow functions),
the user must make sure that a correct wavefunction is
used for the problem at hand. From here on, we assume a
standard trial wavefunction for an electronic structure problem
\begin{equation}\label{equation:intro_wavefunction:eq2}
\begin{split}Psi_T(\vec{r}) =  \textit{A}(\vec{r}) \prod_k \textit{J}_k(\vec{r}),\end{split}
\end{equation}
where \(\textit{A}(\vec{r})\)
is one of the antisymmetric functions: (1) slater determinant, (2) multislater determinant, or (3) pfaffian and \(\textit{J}_k\)
is any of the Jastrow functions (described in {\hyperref[\detokenize{intro_wavefunction:jastrow}]{\sphinxcrossref{\DUrole{std,std-ref}{Jastrow Factors}}}}).  The antisymmetric functions are built from a set of single particle orbitals \sphinxcode{\sphinxupquote{(sposet)}}. QMCPACK implements four different types of \sphinxcode{\sphinxupquote{sposet}}, described in the following section. Each \sphinxcode{\sphinxupquote{sposet}} is designed for a different type of calculation, so their definition and generation varies accordingly.


\section{Single determinant wavefunctons}
\label{\detokenize{intro_wavefunction:single-determinant-wavefunctons}}\label{\detokenize{intro_wavefunction:singledeterminant}}
Placing a single determinant for each spin is the most used ansatz for the antisymmetric part of a trial wavefunction.
The input xml block for \sphinxcode{\sphinxupquote{slaterdeterminant}} is given in {\hyperref[\detokenize{intro_wavefunction:listing-1}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 1}}}}. A list of options is given in
\hyperref[\detokenize{intro_wavefunction:table2}]{Table \ref{\detokenize{intro_wavefunction:table2}}}.

\sphinxcode{\sphinxupquote{slaterdeterminant}} element:


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{intro_wavefunction:table2}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements
&
\sphinxcode{\sphinxupquote{determinantset}}
\\
\hline
Child elements
&
\sphinxcode{\sphinxupquote{determinant}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Attribute:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Datatype
&\sphinxstyletheadfamily 
Values
&\sphinxstyletheadfamily 
Default
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{delay\_rank}}
&
Integer
&
\textgreater{}=0
&
1
&
Number of delayed updates.
\\
\hline
\sphinxcode{\sphinxupquote{optimize}}
&
Text
&
yes/no
&
yes
&
Enable orbital optimization.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{center}Table 2 Options for the \sphinxcode{\sphinxupquote{slaterdeterminant}} xml\sphinxhyphen{}block.
\end{center}\sphinxSetupCaptionForVerbatim{Slaterdeterminant set XML element.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-1}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{slaterdeterminant} \PYG{n}{delay\PYGZus{}rank}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{32}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{determinant} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{updet}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{208}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{occupation} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ground}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{spindataset}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{occupation}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinant}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{determinant} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{downdet}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{208}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{occupation} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ground}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{spindataset}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{occupation}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinant}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{slaterdeterminant}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{delay\_rank}} This option enables delayed updates of the Slater matrix inverse when particle\sphinxhyphen{}by\sphinxhyphen{}particle move is used.
By default or if \sphinxcode{\sphinxupquote{delay\_rank=0}} given in the input file, QMCPACK sets 1 for Slater matrices with a leading dimension \(<192\) and 32 otherwise.
\sphinxcode{\sphinxupquote{delay\_rank=1}} uses the Fahy’s variant \sphinxcite{intro_wavefunction:fahy1990} of the Sherman\sphinxhyphen{}Morrison rank\sphinxhyphen{}1 update, which is mostly using memory bandwidth\sphinxhyphen{}bound BLAS\sphinxhyphen{}2 calls.
With \sphinxcode{\sphinxupquote{delay\_rank\textgreater{}1}}, the delayed update algorithm \sphinxcite{intro_wavefunction:luo2018delayedupdate}\sphinxcite{intro_wavefunction:mcdaniel2017} turns most of the computation to compute bound BLAS\sphinxhyphen{}3 calls.
Tuning this parameter is highly recommended to gain the best performance on medium\sphinxhyphen{}to\sphinxhyphen{}large problem sizes (\(>200\) electrons).
We have seen up to an order of magnitude speedup on large problem sizes.
When studying the performance of QMCPACK, a scan of this parameter is required and we recommend starting from 32.
The best \sphinxcode{\sphinxupquote{delay\_rank}} giving the maximal speedup depends on the problem size.
Usually the larger \sphinxcode{\sphinxupquote{delay\_rank}} corresponds to a larger problem size.
On CPUs, \sphinxcode{\sphinxupquote{delay\_rank}} must be chosen as a multiple of SIMD vector length for good performance of BLAS libraries.
The best \sphinxcode{\sphinxupquote{delay\_rank}} depends on the processor microarchitecture.
GPU support is under development.

\end{itemize}


\section{Single\sphinxhyphen{}particle orbitals}
\label{\detokenize{intro_wavefunction:single-particle-orbitals}}\label{\detokenize{intro_wavefunction:singleparticle}}

\subsection{Spline basis sets}
\label{\detokenize{intro_wavefunction:spline-basis-sets}}\label{\detokenize{intro_wavefunction:spo-spline}}
In this section we describe the use of spline basis sets to expand the \sphinxcode{\sphinxupquote{sposet}}.
Spline basis sets are designed to work seamlessly with plane wave DFT code (e.g.,Quantum ESPRESSO as a trial wavefunction generator).

In QMC algorithms, all the SPOs \(\{\phi(\vec{r})\}\) need to be updated
every time a single electron moves. Evaluating SPOs takes a very large portion of computation time.
In principle, PW basis set can be used to express SPOs directly in QMC, as in DFT.
But it introduces an unfavorable scaling because the basis set size increases linearly as the system size.
For this reason, it is efficient to use a localized basis with compact
support and a good transferability from the plane wave basis.

In particular, 3D tricubic B\sphinxhyphen{}splines provide a basis in which only
64 elements are nonzero at any given point in \sphinxcite{intro_wavefunction:blips4qmc}.
The 1D cubic B\sphinxhyphen{}spline is given by
\begin{equation}\label{equation:intro_wavefunction:eq3}
\begin{split}f(x) = \sum_{i'=i-1}^{i+2} b^{i'\!,3}(x)\,\,  p_{i'},\end{split}
\end{equation}
where \(b^{i}(x)\) is the piecewise cubic polynomial basis functions
and \(i = \text{floor}(\Delta^{-1} x)\) is the index of the first
grid point \(\le x\). Constructing a tensor product in each
Cartesian direction, we can represent a 3D orbital as
\begin{equation}\label{equation:intro_wavefunction:eq4}
\begin{split}\phi_n(x,y,z) =
    \!\!\!\!\sum_{i'=i-1}^{i+2} \!\! b_x^{i'\!,3}(x)
    \!\!\!\!\sum_{j'=j-1}^{j+2} \!\! b_y^{j'\!,3}(y)
    \!\!\!\!\sum_{k'=k-1}^{k+2} \!\! b_z^{k'\!,3}(z) \,\, p_{i', j', k',n}.\end{split}
\end{equation}
This allows the rapid evaluation of each orbital in constant time.
Furthermore, this basis is systematically improvable with a single spacing
parameter so that accuracy is not compromised compared with the plane wave basis.

The use of 3D tricubic B\sphinxhyphen{}splines greatly improves computational efficiency.
The gain in computation time from a plane wave basis set to an equivalent B\sphinxhyphen{}spline basis set
becomes increasingly large as the system size grows.
On the downside, this computational efficiency comes at
the expense of increased memory use, which is easily overcome, however, by the large
aggregate memory available per node through OpenMP/MPI hybrid QMC.

The input xml block for the spline SPOs is given in {\hyperref[\detokenize{intro_wavefunction:listing-2}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 2}}}}. A list of options is given in
\hyperref[\detokenize{intro_wavefunction:table3}]{Table \ref{\detokenize{intro_wavefunction:table3}}}.
\sphinxSetupCaptionForVerbatim{Determinant set XML element.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-2}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{determinantset} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pwscf.h5}\PYG{l+s+s2}{\PYGZdq{}}
                \PYG{n}{tilematrix}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1 1 3 1 2 \PYGZhy{}1 \PYGZhy{}2 1 0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{twistnum}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{gpu}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{meshfactor}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.8}\PYG{l+s+s2}{\PYGZdq{}}
                \PYG{n}{twist}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0  0  0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{precision}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{double}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{slaterdeterminant}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{determinant} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{updet}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{208}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{occupation} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ground}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{spindataset}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{occupation}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinant}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{determinant} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{downdet}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{208}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{occupation} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ground}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{spindataset}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{occupation}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinant}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{slaterdeterminant}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinantset}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{determinantset}} element:


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{intro_wavefunction:table3}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements
&
\sphinxcode{\sphinxupquote{wavefunction}}
\\
\hline
Child elements
&
\sphinxcode{\sphinxupquote{slaterdeterminant}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

attribute:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Datatype
&\sphinxstyletheadfamily 
Values
&\sphinxstyletheadfamily 
Default
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{type}}
&
Text
&
Bspline
&&
Type of \sphinxcode{\sphinxupquote{sposet}}
\\
\hline
\sphinxcode{\sphinxupquote{href}}
&
Text
&&&
Path to hdf5 file from pw2qmcpack.x.
\\
\hline
\sphinxcode{\sphinxupquote{tilematrix}}
&
9 integers
&&&
Tiling matrix used to expand supercell.
\\
\hline
\sphinxcode{\sphinxupquote{twistnum}}
&
Integer
&&&
Index of the super twist.
\\
\hline
\sphinxcode{\sphinxupquote{twist}}
&
3 floats
&&&
Super twist.
\\
\hline
\sphinxcode{\sphinxupquote{meshfactor}}
&
Float
&
\(\le 1.0\)
&&
Grid spacing ratio.
\\
\hline
\sphinxcode{\sphinxupquote{precision}}
&
Text
&
Single/double
&&
Precision of spline coefficients
\\
\hline
\sphinxcode{\sphinxupquote{gpu}}
&
Text
&
Yes/no
&&
GPU switch.
\\
\hline
\sphinxcode{\sphinxupquote{gpusharing}}
&
Text
&
Yes/no
&
No
&
Share B\sphinxhyphen{}spline table across GPUs.
\\
\hline
\sphinxcode{\sphinxupquote{Spline\_Size\_Limit\_MB}}
&
Integer
&&&
Limit B\sphinxhyphen{}spline table size on GPU.
\\
\hline
\sphinxcode{\sphinxupquote{check\_orb\_norm}}
&
Text
&
Yes/no
&
Yes
&
Check norms of orbitals from h5 file.
\\
\hline
\sphinxcode{\sphinxupquote{save\_coefs}}
&
Text
&
Yes/no
&
No
&
Save the spline coefficients to h5 file.
\\
\hline
\sphinxcode{\sphinxupquote{source}}
&
Text
&
Any
&
Ion0
&
Particle set with atomic positions.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{center}Table 3 Options for the \sphinxcode{\sphinxupquote{determinantset}} xml\sphinxhyphen{}block associated with B\sphinxhyphen{}spline single particle orbital sets.
\end{center}
Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{precision}}. Only effective on CPU versions without mixed
precision, “single” is always imposed with mixed precision. Using
single precision not only saves memory use but also speeds up the
B\sphinxhyphen{}spline evaluation. We recommend using single precision since we saw
little chance of really compromising the accuracy of calculation.

\item {} 
\sphinxcode{\sphinxupquote{meshfactor}}. The ratio of actual grid spacing of B\sphinxhyphen{}splines used in
QMC calculation with respect to the original one calculated from h5.
A smaller meshfactor saves memory use but reduces accuracy. The
effects are similar to reducing plane wave cutoff in DFT
calculations. Use with caution!

\item {} 
\sphinxcode{\sphinxupquote{twistnum}}. If positive, it is the index. We recommend not taking
this way since the indexing might show some uncertainty. If negative,
the super twist is referred by \sphinxcode{\sphinxupquote{twist}}.

\item {} 
\sphinxcode{\sphinxupquote{save\_coefs}}. If yes, dump the real\sphinxhyphen{}space B\sphinxhyphen{}spline coefficient
table into an h5 file on the disk. When the orbital transformation
from k space to B\sphinxhyphen{}spline requires more than the available amount of
scratch memory on the compute nodes, users can perform this step on
fat nodes and transfer back the h5 file for QMC calculations.

\item {} 
\sphinxcode{\sphinxupquote{gpusharing}}. If enabled, spline data is shared across multiple
GPUs on a given computational node. For example, on a
two\sphinxhyphen{}GPU\sphinxhyphen{}per\sphinxhyphen{}node system, each GPU would have half of the orbitals.
This enables larger overall spline tables than would normally fit in
the memory of individual GPUs to be used, potentially up to the total
GPU memory on a node. To obtain high performance, large electron
counts or a high\sphinxhyphen{}performing CPU\sphinxhyphen{}GPU interconnect is required. To use
this feature, the following needs to be done:
\begin{quote}
\begin{itemize}
\item {} 
The CUDA Multi\sphinxhyphen{}Process Service (MPS) needs to be used (e.g., on

\end{itemize}

Summit/SummitDev use “\sphinxhyphen{}alloc\_flags gpumps” for bsub). If MPS is not
detected, sharing will be disabled.
\begin{itemize}
\item {} 
CUDA\_VISIBLE\_DEVICES needs to be properly set to control each rank’s

\end{itemize}

visible CUDA devices (e.g., on OLCF Summit/SummitDev one needs to
create a resource set containing all GPUs with the respective number
of ranks with “jsrun \textendash{}task\sphinxhyphen{}per\sphinxhyphen{}rs Ngpus \sphinxhyphen{}g Ngpus”).
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{Spline\_Size\_Limit\_MB}}. Allows distribution of the B\sphinxhyphen{}spline
coefficient table between the host and GPU memory. The compute kernels
access host memory via zero\sphinxhyphen{}copy. Although the performance penalty
introduced by it is significant, it allows large calculations to go
through.

\end{itemize}


\subsection{Gaussian basis tests}
\label{\detokenize{intro_wavefunction:gaussian-basis-tests}}\label{\detokenize{intro_wavefunction:gaussianbasis}}
In this section we describe the use of localized basis sets to expand the \sphinxcode{\sphinxupquote{sposet}}. The general form of a single particle orbital in this case is given by:
\begin{equation}\label{equation:intro_wavefunction:eq5}
\begin{split}\phi_i(\vec{r}) = \sum_k C_{i,k} \ \eta_k(\vec{r}),\end{split}
\end{equation}
where \(\{\eta_k(\vec{r})\}\) is a set of M atom\sphinxhyphen{}centered basis
functions and \(C_{i,k}\) is a coefficient matrix. This should be
used in calculations of finite systems employing an atom\sphinxhyphen{}centered basis
set and is typically generated by the \sphinxstyleemphasis{convert4qmc} converter. Examples
include calculations of molecules using Gaussian basis sets or
Slater\sphinxhyphen{}type basis functions. Initial support for periodic systems is
described in \DUrole{xref,std,std-ref}{LCAO}. Even though this section is called
“Gaussian basis sets” (by far the most common atom\sphinxhyphen{}centered basis set),
QMCPACK works with any atom\sphinxhyphen{}centered basis set based on either spherical
harmonic angular functions or Cartesian angular expansions. The radial
functions in the basis set can be expanded in either Gaussian functions,
Slater\sphinxhyphen{}type functions, or numerical radial functions.

In this section we describe the input sections for the atom\sphinxhyphen{}centered basis set and the \sphinxcode{\sphinxupquote{sposet}} for a single Slater determinant trial wavefunction. The input sections for multideterminant trial wavefunctions are described in {\hyperref[\detokenize{intro_wavefunction:multideterminants}]{\sphinxcrossref{\DUrole{std,std-ref}{Multideterminant wavefunctions}}}}. The basic structure for the input block of a single Slater determinant is given in {\hyperref[\detokenize{intro_wavefunction:listing-3}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 3}}}}.
A list of options for \sphinxcode{\sphinxupquote{determinantset}} associated with this \sphinxcode{\sphinxupquote{sposet}} is given in \hyperref[\detokenize{intro_wavefunction:table4}]{Table \ref{\detokenize{intro_wavefunction:table4}}}.
\sphinxSetupCaptionForVerbatim{Basic input block for a single determinant trial wavefunction using a \sphinxcode{\sphinxupquote{sposet}} expanded on an atom\sphinxhyphen{}centered basis set.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-3}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{o}{\PYGZlt{}}\PYG{n}{wavefunction} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{psi0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{determinantset}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{basisset}\PYG{o}{\PYGZgt{}}
       \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
     \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{basisset}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{slaterdeterminant}\PYG{o}{\PYGZgt{}}
       \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
     \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{slaterdeterminant}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinantset}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{wavefunction}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

The definition of the set of atom\sphinxhyphen{}centered basis functions is given by the \sphinxcode{\sphinxupquote{basisset}} block, and the \sphinxcode{\sphinxupquote{sposet}} is defined within \sphinxcode{\sphinxupquote{slaterdeterminant}}. The \sphinxcode{\sphinxupquote{basisset}} input block is composed from a collection of \sphinxcode{\sphinxupquote{atomicBasisSet}} input blocks, one for each atomic species in the simulation where basis functions are centered. The general structure for \sphinxcode{\sphinxupquote{basisset}} and \sphinxcode{\sphinxupquote{atomicBasisSet}} are given in {\hyperref[\detokenize{intro_wavefunction:listing-4}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 4}}}}, and the corresponding lists of options are given in
\hyperref[\detokenize{intro_wavefunction:table5}]{Table \ref{\detokenize{intro_wavefunction:table5}}} and \hyperref[\detokenize{intro_wavefunction:table6}]{Table \ref{\detokenize{intro_wavefunction:table6}}}.

\sphinxcode{\sphinxupquote{determinantset}} element:


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{intro_wavefunction:table4}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements
&
\sphinxcode{\sphinxupquote{wavefunction}}
\\
\hline
Child elements
&
\sphinxcode{\sphinxupquote{basisset}} , \sphinxcode{\sphinxupquote{slaterdeterminant}} , \sphinxcode{\sphinxupquote{sposet}} , \sphinxcode{\sphinxupquote{multideterminant}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Attribute:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{name/id}}
&
Text
&
\sphinxstyleemphasis{Any}
&
‘’ ‘’
&
Name of determinant set
\\
\hline
\sphinxcode{\sphinxupquote{type}}
&
Text
&
See below
&
‘’ ‘’
&
Type of \sphinxcode{\sphinxupquote{sposet}}
\\
\hline
\sphinxcode{\sphinxupquote{keyword}}
&
Text
&
NMO, GTO, STO
&
NMO
&
Type of orbital set generated
\\
\hline
\sphinxcode{\sphinxupquote{transform}}
&
Text
&
Yes/no
&
Yes
&
Transform to numerical radial functions?
\\
\hline
\sphinxcode{\sphinxupquote{source}}
&
Text
&
\sphinxstyleemphasis{Any}
&
Ion0
&
Particle set with the position of atom centers
\\
\hline
\sphinxcode{\sphinxupquote{cuspCorrection}}
&
Text
&
Yes/no
&
No
&
Apply cusp correction scheme to \sphinxcode{\sphinxupquote{sposet}}?
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{center}Table 4 Options for the \sphinxcode{\sphinxupquote{determinantset}} xml\sphinxhyphen{}block associated with atom\sphinxhyphen{}centered single particle orbital sets.
\end{center}\sphinxSetupCaptionForVerbatim{Basic input block for \sphinxcode{\sphinxupquote{basisset}}.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-4}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{basisset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LCAOBSet}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{atomicBasisSet} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gaussian\PYGZhy{}G2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{angular}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cartesian}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{normalized}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{grid} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{log}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{ri}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1.e\PYGZhy{}6}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rf}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1.e2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{npts}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1001}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{basisGroup} \PYG{n}{rid}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C00}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{n}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{l}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gaussian}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{radfunc} \PYG{n}{exponent}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{5.134400000000e\PYGZhy{}02}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{contraction}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1.399098787100e\PYGZhy{}02}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
      \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{basisGroup}\PYG{o}{\PYGZgt{}}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{atomicBasisSet}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{atomicBasisSet} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gaussian\PYGZhy{}G2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{angular}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cartesian}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gaussian}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{normalized}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{atomicBasisSet}\PYG{o}{\PYGZgt{}}
  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{basisset}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{basisset}} element:


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{intro_wavefunction:table5}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements
&
\sphinxcode{\sphinxupquote{determinantset}}
\\
\hline
Child elements
&
\sphinxcode{\sphinxupquote{atomicBasisSet}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Attribute:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{name}} / \sphinxcode{\sphinxupquote{id}}
&
Text
&
\sphinxstyleemphasis{Any}
&
” “
&
Name of atom\sphinxhyphen{}centered basis set
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{center}Table 5 Options for the \sphinxcode{\sphinxupquote{basisset}} xml\sphinxhyphen{}block associated with atom\sphinxhyphen{}centered single particle orbital sets.
\end{center}
\sphinxcode{\sphinxupquote{AtomicBasisSet}} element:


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{intro_wavefunction:table6}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements
&
\sphinxcode{\sphinxupquote{basisset}}
\\
\hline
Child elements
&
\sphinxcode{\sphinxupquote{grid}} , \sphinxcode{\sphinxupquote{basisGroup}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Attribute:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{name}} / \sphinxcode{\sphinxupquote{id}}
&
Text
&
\sphinxstyleemphasis{Any}
&
” “
&
Name of atomic basis set
\\
\hline
\sphinxcode{\sphinxupquote{angular}}
&
Text
&
See below
&
Default
&
Type of angular functions
\\
\hline
\sphinxcode{\sphinxupquote{expandYlm}}
&
Text
&
See below
&
Yes
&
Expand Ylm shells?
\\
\hline
\sphinxcode{\sphinxupquote{expM}}
&
Text
&
See below
&
Yes
&
Add sign for \((-1)^{m}\)?
\\
\hline
\sphinxcode{\sphinxupquote{elementType/species}}
&
Text
&
\sphinxstyleemphasis{Any}
&
e
&
Atomic species where functions are centered
\\
\hline
\sphinxcode{\sphinxupquote{normalized}}
&
Text
&
Yes/no
&
Yes
&
Are single particle functions normalized?
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{center}Table 6 Options for the \sphinxcode{\sphinxupquote{atomicBasisSet}} xml\sphinxhyphen{}block.
\end{center}
\sphinxcode{\sphinxupquote{basicGroup}} element:


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{intro_wavefunction:table7}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements
&
\sphinxcode{\sphinxupquote{AtomicBasisSet}}
\\
\hline
Child elements
&
\sphinxcode{\sphinxupquote{radfunc}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Attribute:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{rid/id}}
&
Text
&
\sphinxstyleemphasis{Any}
&
‘’ ‘’
&
Name of the basisGroup
\\
\hline
\sphinxcode{\sphinxupquote{type}}
&
Text
&
\sphinxstyleemphasis{Any}
&
‘’ ‘’
&
Type of basisGroup
\\
\hline
\sphinxcode{\sphinxupquote{n/l/m/s}}
&
Integer
&
\sphinxstyleemphasis{Any}
&
0
&
Quantum numbers of basisGroup
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{center}\hyperref[\detokenize{intro_wavefunction:table7}]{Table \ref{\detokenize{intro_wavefunction:table7}}} Options for the \sphinxcode{\sphinxupquote{basisGroup}} xml\sphinxhyphen{}block.
\end{center}\sphinxSetupCaptionForVerbatim{Basic input block for \sphinxcode{\sphinxupquote{slaterdeterminant}} with an atom\sphinxhyphen{}centered \sphinxcode{\sphinxupquote{sposet}}.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-5}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{o}{\PYGZlt{}}\PYG{n}{slaterdeterminant}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{slaterdeterminant}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

element:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements:
&\\
\hline
Child elements:
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Attribute:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{name/id}}
&
Text
&
\sphinxstyleemphasis{Any}
&
‘’ ‘’
&
Name of determinant set
\\
\hline&
Text
&
\sphinxstyleemphasis{Any}
&
‘’ ‘’
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Detailed description of attributes:}
\label{\detokenize{intro_wavefunction:detailed-description-of-attributes}}
In the following, we give a more detailed description of all the options presented in the various xml\sphinxhyphen{}blocks described in this section. Only nontrivial attributes are described. Those with simple yes/no options and whose previous description is enough to explain the intended behavior are not included.

\sphinxcode{\sphinxupquote{determinantset}} attributes:
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{type}}}] \leavevmode
Type of \sphinxcode{\sphinxupquote{sposet}}. For atom\sphinxhyphen{}centered based \sphinxcode{\sphinxupquote{sposets}}, use type=”MolecularOrbital” or type=“MO.”
Other options described elsewhere in this manual are “spline,”
“composite,” “pw,” “heg,” “linearopt,” etc.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{keyword/key}}}] \leavevmode
Type of basis set generated, which does not necessarily match the type of basis set on the input block. The three possible options are: NMO (numerical molecular orbitals), GTO (Gaussian\sphinxhyphen{}type orbitals), and STO (Slater\sphinxhyphen{}type orbitals). The default option is NMO. By default, QMCPACK will generate numerical orbitals from both GTO and STO types and use cubic or quintic spline interpolation to evaluate the radial functions. This is typically more efficient than evaluating the radial functions in the native basis (Gaussians or exponents) and allows for arbitrarily large contractions without any additional cost. To force use of the native expansion (not recommended), use GTO or STO for each type of input basis set.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{transform}}}] \leavevmode
Request (or avoid) a transformation of the radial functions to NMO type. The default and recommended behavior is to transform to numerical radial functions. If \sphinxcode{\sphinxupquote{transform}} is set to \sphinxstyleemphasis{yes}, the option \sphinxcode{\sphinxupquote{keyword}} is ignored.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{cuspCorrection}}}] \leavevmode
Enable (disable) use of the cusp correction algorithm (CASINO REFERENCE) for a \sphinxcode{\sphinxupquote{basisset}} built with GTO functions. The algorithm is implemented as described in (CASINO REFERENCE) and works only with transform=”yes” and an input GTO basis set. No further input is needed.

\end{description}

\end{itemize}

\sphinxcode{\sphinxupquote{atomicBasisSet}} attributes:
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{name/id}}}] \leavevmode
Name of the basis set. Names should be unique.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{angular}}}] \leavevmode
Type of angular functions used in the expansion. In general, two angular basis functions are allowed: “spherical” (for spherical Ylm functions) and “Cartesian” (for functions of the type \(x^{n}y^{m}z^{l}\)).

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{expandYlm}}}] \leavevmode
Determines whether each basis group is expanded across the corresponding shell of m values (for spherical type) or consistent powers (for Cartesian functions). Options:
\begin{itemize}
\item {} 
“No”: Do not expand angular functions across corresponding angular shell.

\item {} 
“Gaussian”: Expand according to Gaussian03 format. This function is compatible only with angular=”spherical.” For a given input (l,m), the resulting order of the angular functions becomes (1,\sphinxhyphen{}1,0) for l=1 and (0,1,\sphinxhyphen{}1,2,\sphinxhyphen{}2,…,l,\sphinxhyphen{}l) for general l.

\item {} 
“Natural”: Expand angular functions according to (\sphinxhyphen{}l,\sphinxhyphen{}l+1,…,l\sphinxhyphen{}1,l).

\item {} 
“Gamess”: Expand according to Gamess’ format for Cartesian functions. Notice that this option is compatible only with angular=”Cartesian.” If angular=”Cartesian” is used, this option is not necessary.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{expM}}}] \leavevmode
Determines whether the sign of the spherical Ylm function associated with m (\(-1^{m}\)) is included in the coefficient matrix or not.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{elementType/species}}}] \leavevmode
Name of the species where basis functions are centered. Only one \sphinxcode{\sphinxupquote{atomicBasisSet}} block is allowed per species. Additional blocks are ignored. The corresponding species must exist in the \sphinxcode{\sphinxupquote{particleset}} given as the \sphinxcode{\sphinxupquote{source}} option to \sphinxcode{\sphinxupquote{determinantset}}. Basis functions for all the atoms of the corresponding species are included in the basis set, based on the order of atoms in the \sphinxcode{\sphinxupquote{particleset}}.

\end{description}

\end{itemize}

\sphinxcode{\sphinxupquote{basisGroup}} attributes:
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{type}}}] \leavevmode
Type of input basis radial function. Note that this refers to the type of radial function in the input xml\sphinxhyphen{}block, which might not match the radial function generated internally and used in the calculation (if \sphinxcode{\sphinxupquote{transform}} is set to “yes”). Also note that different \sphinxcode{\sphinxupquote{basisGroup}} blocks within a given \sphinxcode{\sphinxupquote{atomicBasisSet}} can have different \sphinxcode{\sphinxupquote{types}}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{n/l/m/s}}}] \leavevmode
Quantum numbers of the basis function. Note that if
\sphinxcode{\sphinxupquote{expandYlm}} is set to \sphinxstyleemphasis{“yes”} in \sphinxcode{\sphinxupquote{atomicBasisSet}}, a
full shell of basis functions with the appropriate values of
\sphinxstyleemphasis{“m”} will be defined for the corresponding value of
\sphinxstyleemphasis{“l.”} Otherwise a single basis function will be given for the
specific combination of \sphinxstyleemphasis{“(l,m).”}

\end{description}

\end{itemize}

\sphinxcode{\sphinxupquote{radfunc}} attributes for \sphinxcode{\sphinxupquote{type}} = \sphinxstyleemphasis{“Gaussian”}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{TBDoc}}

\end{itemize}

\sphinxcode{\sphinxupquote{slaterdeterminant}} attributes:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{TBDoc}}

\end{itemize}


\subsection{Hybrid orbital representation}
\label{\detokenize{intro_wavefunction:hybrid-orbital-representation}}\label{\detokenize{intro_wavefunction:spo-hybrid}}
The hybrid representation of the single particle orbitals combines a localized atomic basis set around atomic cores and B\sphinxhyphen{}splines in the interstitial regions to reduce memory use while retaining high evaluation speed and either retaining or increasing overall accuracy. Full details are provided in \sphinxcite{intro_wavefunction:luo2018hyb}, and \sphinxstylestrong{users of this feature are kindly requested to cite this paper}.
In practice, we have seen that using a meshfactor=0.5 is often possible and achieves huge memory savings.
\hyperref[\detokenize{intro_wavefunction:fig3}]{Fig.\@ \ref{\detokenize{intro_wavefunction:fig3}}} illustrates how the regions are assigned.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{hybrid_new}.jpg}
\caption{Regular and hybrid orbital representation. Regular B\sphinxhyphen{}spline representation (left panel) contains only one region and a sufficiently fine mesh to resolve orbitals near the nucleus. The hybrid orbital representation (right panel) contains near nucleus regions (A) where spherical harmonics and radial functions are used, buffers or interpolation regions (B), and an interstitial region (C) where a coarse B\sphinxhyphen{}spline mesh is used.}\label{\detokenize{intro_wavefunction:id29}}\label{\detokenize{intro_wavefunction:fig3}}\end{figure}

Orbitals within region A are computed as
\begin{equation*}
\begin{split}\phi^A_n({\bf r})=R_{n,l,m}(r)Y_{l,m}(\hat{r})\end{split}
\end{equation*}
Orbitals in region C are computed as the regular B\sphinxhyphen{}spline basis described in {\hyperref[\detokenize{intro_wavefunction:spo-spline}]{\sphinxcrossref{\DUrole{std,std-ref}{Spline basis sets}}}} above. The region B interpolates between A and C as
\begin{equation}\label{equation:intro_wavefunction:eq6}
\begin{split}\phi^B_n({\bf r}) = S(r) \phi^A_n({\bf r}) + (1-S(r))\phi^C_n(r)\end{split}
\end{equation}\begin{equation}\label{equation:intro_wavefunction:eq7}
\begin{split}(S(r) = \frac{1}{2}-\frac{1}{2} tanh \left[\alpha\left(\frac{r-r_{\rm A/B}}{r_{\rm B/C}-r_{\rm A/B}}-\frac{1}{2}\right)\right]\end{split}
\end{equation}
To enable hybrid orbital representation, the input XML needs to see the tag \sphinxcode{\sphinxupquote{hybridrep="yes"}} shown in {\hyperref[\detokenize{intro_wavefunction:listing-6}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 6}}}}.
\sphinxSetupCaptionForVerbatim{Hybrid orbital representation input example.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-6}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{determinantset} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pwscf.h5}\PYG{l+s+s2}{\PYGZdq{}}
              \PYG{n}{tilematrix}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1 1 3 1 2 \PYGZhy{}1 \PYGZhy{}2 1 0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{twistnum}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{gpu}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{meshfactor}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.8}\PYG{l+s+s2}{\PYGZdq{}}
              \PYG{n}{twist}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0  0  0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{precision}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{single}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{hybridrep}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinantset}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Second, the information describing the atomic regions is required in the particle set, shown in {\hyperref[\detokenize{intro_wavefunction:listing-7}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 7}}}}.
\sphinxSetupCaptionForVerbatim{particleset elements for ions with information needed by hybrid orbital representation.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-7}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ni}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}          \PYG{l+m+mi}{18} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{valence}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}         \PYG{l+m+mi}{18} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{atomicnumber}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZgt{}}   \PYG{l+m+mi}{28} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cutoff\PYGZus{}radius}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1.6} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{inner\PYGZus{}cutoff}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZgt{}}  \PYG{l+m+mf}{1.3} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lmax}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZgt{}}            \PYG{l+m+mi}{5} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spline\PYGZus{}radius}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1.8} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spline\PYGZus{}npoints}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{91} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

The parameters specific to hybrid representation are listed as

\sphinxcode{\sphinxupquote{attrib}} element

Attribute:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{cutoff\_radius}}
&
Real
&
\textgreater{}=0.0
&
\sphinxstyleemphasis{None}
&
Cutoff radius for B/C boundary
\\
\hline
\sphinxcode{\sphinxupquote{lmax}}
&
Integer
&
\textgreater{}=0
&
\sphinxstyleemphasis{None}
&
Largest angular channel
\\
\hline
\sphinxcode{\sphinxupquote{inner\_cutoff}}
&
Real
&
\textgreater{}=0.0
&
Dep.
&
Cutoff radius for A/B boundary
\\
\hline
\sphinxcode{\sphinxupquote{spline\_radius}}
&
Real
&
\textgreater{}0.0
&
Dep.
&
Radial function radius used in spine
\\
\hline
\sphinxcode{\sphinxupquote{spline\_npoints}}
&
Integer
&
\textgreater{}0
&
Dep.
&
Number of spline knots
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{cutoff\_radius}}  is required for every species. If a species is intended to not be covered by atomic regions, setting the value 0.0 will put default values for all the reset parameters. A good value is usually a bit larger than the core radius listed in the pseudopotential file. After a parametric scan, pick the one from the flat energy region with the smallest variance.

\item {} 
\sphinxcode{\sphinxupquote{lmax}} is required if \sphinxcode{\sphinxupquote{cutoff\_radius}} \(>\) 0.0. This value usually needs to be at least the highest angular momentum plus 2.

\item {} 
\sphinxcode{\sphinxupquote{inner\_cutoff}} is optional and set as \sphinxcode{\sphinxupquote{cutoff\_radius}} \(-0.3\) by default, which is fine in most cases.

\item {} 
\sphinxcode{\sphinxupquote{spline\_radius}} and \sphinxcode{\sphinxupquote{spline\_npoints}} are optional. By default, they are calculated based on \sphinxcode{\sphinxupquote{cutoff\_radius}} and a grid displacement 0.02 bohr.
If users prefer inputing them, it is required that \sphinxcode{\sphinxupquote{cutoff\_radius}} \textless{}=  \sphinxcode{\sphinxupquote{spline\_radius}} \(-\) 2 \(\times\) \sphinxcode{\sphinxupquote{spline\_radius}}/(\sphinxcode{\sphinxupquote{spline\_npoints}} \(-\) 1).

\end{itemize}

In addition, the hybrid orbital representation allows extra optimization to speed up the nonlocal pseudopotential evaluation using the batched algorithm listed in {\hyperref[\detokenize{hamiltonianobservable:nlpp}]{\sphinxcrossref{\DUrole{std,std-ref}{Pseudopotentials}}}}.


\subsection{Plane\sphinxhyphen{}wave basis sets}
\label{\detokenize{intro_wavefunction:plane-wave-basis-sets}}\label{\detokenize{intro_wavefunction:pwbasis}}

\subsection{Homogeneous electron gas}
\label{\detokenize{intro_wavefunction:homogeneous-electron-gas}}\label{\detokenize{intro_wavefunction:hegbasis}}
The interacting Fermi liquid has its own special \sphinxcode{\sphinxupquote{determinantset}} for filling up a
Fermi surface.  The shell number can be specified separately for both spin\sphinxhyphen{}up and spin\sphinxhyphen{}down.
This determines how many electrons to include of each time; only closed shells are currently
implemented.  The shells are filled according to the rules of a square box; if other lattice
vectors are used, the electrons might not fill up a complete shell.

This following example can also be used for Helium simulations by specifying the
proper pair interaction in the Hamiltonian section.
\sphinxSetupCaptionForVerbatim{2D Fermi liquid example: particle specification}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-8}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{qmcsystem}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{simulationcell} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{global}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{rs}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{pol}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{condition}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{74}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{6.5}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bconds}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{p} \PYG{n}{p} \PYG{n}{p}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LR\PYGZus{}dim\PYGZus{}cutoff}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{15}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{simulationcell}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{particleset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{random}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{37}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mass}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{37}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mass}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{particleset}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmcsystem}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{2D Fermi liquid example (Slater Jastrow wavefunction)}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-9}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{qmcsystem}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{wavefunction} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{psi0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{determinantset} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{electron\PYGZhy{}gas}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{shell}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{7}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{shell2}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{7}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{randomize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{true}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{determinantset}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{J2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Two\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{function}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{print}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{speciesA}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{speciesB}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{cusp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{uu}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{speciesA}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{speciesB}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{cusp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ud}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\section{Jastrow Factors}
\label{\detokenize{intro_wavefunction:jastrow-factors}}\label{\detokenize{intro_wavefunction:jastrow}}
Jastrow factors are among the simplest and most effective ways of including
dynamical correlation in the trial many body wavefunction.  The resulting many body
wavefunction is expressed as the product of an antisymmetric (in the case
of Fermions) or symmetric (for Bosons) part and a correlating Jastrow factor
like so:
\begin{equation}\label{equation:intro_wavefunction:eq8}
\begin{split}\Psi(\vec{R}) = \mathcal{A}(\vec{R}) \exp\left[J(\vec{R})\right]\end{split}
\end{equation}
In this section we will detail the types and forms of Jastrow factor used
in QMCPACK.  Note that each type of Jastrow factor needs to be specified using
its own individual \sphinxcode{\sphinxupquote{jastrow}} XML element.  For this reason, we have repeated the
specification of the \sphinxcode{\sphinxupquote{jastrow}} tag in each section, with specialization for the
options available for that given type of Jastrow.


\subsection{One\sphinxhyphen{}body Jastrow functions}
\label{\detokenize{intro_wavefunction:one-body-jastrow-functions}}\label{\detokenize{intro_wavefunction:onebodyjastrow}}
The one\sphinxhyphen{}body Jastrow factor is a form that allows for the direct inclusion
of correlations between particles that are included in the wavefunction with
particles that are not explicitly part of it.  The most common example of
this are correlations between electrons and ions.

The Jastrow function is specified within a \sphinxcode{\sphinxupquote{wavefunction}} element
and must contain one or more \sphinxcode{\sphinxupquote{correlation}} elements specifying
additional parameters as well as the actual coefficients.
{\hyperref[\detokenize{intro_wavefunction:bjsplineexamples}]{\sphinxcrossref{\DUrole{std,std-ref}{Example use cases}}}} gives examples of the typical nesting of
\sphinxcode{\sphinxupquote{jastrow}}, \sphinxcode{\sphinxupquote{correlation}}, and \sphinxcode{\sphinxupquote{coefficient}} elements.


\subsubsection{Input Specification}
\label{\detokenize{intro_wavefunction:input-specification}}
Jastrow element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

\sphinxstylestrong{name}
&
\sphinxstylestrong{datatype}
&
\sphinxstylestrong{values}
&
\sphinxstylestrong{defaults}
&
\sphinxstylestrong{description}
\\
\hline
name
&
text
&&
(required)
&
Unique name
for this
Jastrow
function
\\
\hline
type
&
text
&
One\sphinxhyphen{}body
&
(required)
&
Define a
one\sphinxhyphen{}body
function
\\
\hline
function
&
text
&
Bspline
&
(required)
&
BSpline
Jastrow
\\
\hline&
text
&
pade2
&&
Pade form
\\
\hline&
text
&
…
&&
…
\\
\hline
source
&
text
&
name
&
(required)
&
Name of
attribute of
classical
particle set
\\
\hline
print
&
text
&
yes / no
&
yes
&
Jastrow
factor
printed in
external
file?
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

elements
&&&&\\
\hline&
Correlation
&&&\\
\hline
Contents
&&&&\\
\hline&
(None)
&&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

To be more concrete, the one\sphinxhyphen{}body Jastrow factors used to describe correlations
between electrons and ions take the form below:
\begin{equation}\label{equation:intro_wavefunction:eq9}
\begin{split}J1=\sum_I^{ion0}\sum_i^e u_{ab}(|r_i-R_I|)\end{split}
\end{equation}
where I runs over all of the ions in the calculation, i runs over the
electrons and \(u_{ab}\) describes the functional form of the
correlation between them. Many different forms of \(u_{ab}\) are
implemented in QMCPACK. We will detail two of the most common ones
below.


\paragraph{Spline form}
\label{\detokenize{intro_wavefunction:spline-form}}\label{\detokenize{intro_wavefunction:onebodyjastrowspline}}
The one\sphinxhyphen{}body spline Jastrow function is the most commonly used one\sphinxhyphen{}body
Jastrow for solids. This form was first described and used in
\sphinxcite{running:eslerkimceperleyshulenburger2012}. Here
\(u_{ab}\) is an interpolating 1D B\sphinxhyphen{}spline (tricublc spline on a
linear grid) between zero distance and \(r_{cut}\). In 3D periodic
systems the default cutoff distance is the Wigner Seitz cell radius. For
other periodicities, including isolated molecules, the \(r_{cut}\)
must be specified. The cusp can be set. \(r_i\) and \(R_I\) are
most commonly the electron and ion positions, but any particlesets that
can provide the needed centers can be used.

Correlation element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

\sphinxstylestrong{Name}
&
\sphinxstylestrong{Datatype}
&
\sphinxstylestrong{Values}
&
\sphinxstylestrong{Defaults}
&
\sphinxstylestrong{Description}
\\
\hline
ElementType
&
Text
&
Name
&
See below
&
Classical
particle
target
\\
\hline
SpeciesA
&
Text
&
Name
&
See below
&
Classical
particle
target
\\
\hline
SpeciesB
&
Text
&
Name
&
See below
&
Quantum
species
target
\\
\hline
Size
&
Integer
&
\(> 0\)
&
(Required)
&
Number of
coefficients
\\
\hline
Rcut
&
Real
&
\(> 0\)
&
See below
&
Distance at
which the
correlation
goes to 0
\\
\hline
Cusp
&
Real
&
\(\ge 0\)
&
0
&
Value for
use in Kato
cusp
condition
\\
\hline
Spin
&
Text
&
Yes or no
&
No
&
Spin
dependent
Jastrow
factor
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

Elements
&&&&\\
\hline&
Coefficients
&&&\\
\hline
Contents
&&&&\\
\hline&
(None)
&&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{elementType, speciesA, speciesB, spin}}}] \leavevmode
For a spin\sphinxhyphen{}independent Jastrow factor (spin = “no”), elementType
should be the name of the group of ions in the classical particleset to
which the quantum particles should be correlated. For a spin\sphinxhyphen{}dependent
Jastrow factor (spin = “yes”), set speciesA to the group name in the
classical particleset and speciesB to the group name in the quantum
particleset.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{rcut}}}] \leavevmode
The cutoff distance for the function in atomic units (bohr). For 3D
fully periodic systems, this parameter is optional, and a default of the
Wigner Seitz cell radius is used. Otherwise this parameter is required.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{cusp}}}] \leavevmode
The one\sphinxhyphen{}body Jastrow factor can be used to make the wavefunction
satisfy the electron\sphinxhyphen{}ion cusp condition :cite:\sphinxcode{\sphinxupquote{kato}}. In this
case, the derivative of the Jastrow factor as the electron approaches
the nucleus will be given by

\end{description}

\end{itemize}
\begin{equation}\label{equation:intro_wavefunction:eq10}
\begin{split}\left(\frac{\partial J}{\partial r_{iI}}\right)_{r_{iI} = 0} = -Z .\end{split}
\end{equation}
Note that if the antisymmetric part of the wavefunction satisfies the electron\sphinxhyphen{}ion cusp
condition (for instance by using single\sphinxhyphen{}particle orbitals that respect the cusp condition)
or if a nondivergent pseudopotential is used, the Jastrow should be cuspless at the
nucleus and this value should be kept at its default of 0.

Coefficients element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

\sphinxstylestrong{Name}
&
\sphinxstylestrong{Datatype}
&
\sphinxstylestrong{Values}
&
\sphinxstylestrong{Defaults}
&
\sphinxstylestrong{Description}
\\
\hline
Id
&
Text
&&
(Required)
&
Unique
identifier
\\
\hline
Type
&
Text
&
Array
&
(Required)
&\\
\hline
Optimize
&
Text
&
Yes or no
&
Yes
&
if no,
values are
fixed in
optimizations
\\
\hline&&&&\\
\hline
Elements
&&&&\\
\hline
(None)
&&&&\\
\hline
Contents
&&&&\\
\hline
(No name)
&
Real array
&&
Zeros
&
Jastrow
coefficients
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\paragraph{Example use cases}
\label{\detokenize{intro_wavefunction:example-use-cases}}\label{\detokenize{intro_wavefunction:bjsplineexamples}}
Specify a spin\sphinxhyphen{}independent function with four parameters. Because rcut  is not
specified, the default cutoff of the Wigner Seitz cell radius is used; this
Jastrow must be used with a 3D periodic system such as a bulk solid. The name of
the particleset holding the ionic positions is “i.”

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{J1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{One\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{function}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{print}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{cusp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}  \PYG{l+m+mi}{0}  \PYG{l+m+mi}{0}  \PYG{l+m+mi}{0}  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Specify a spin\sphinxhyphen{}dependent function with seven up\sphinxhyphen{}spin and seven down\sphinxhyphen{}spin parameters.
The cutoff distance is set to 6 atomic units.  Note here that the particleset holding
the ions is labeled as ion0 rather than “i,” as in the other example.  Also in this case,
the ion is lithium with a coulomb potential, so the cusp condition is satisfied by
setting cusp=”d.”

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{J1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{One\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{function}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{spin}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{speciesA}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Li}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{speciesB}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{7}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{eLiu}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{cusp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{speciesA}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{speciesB}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{7}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{eLid}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{cusp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\paragraph{Pade form}
\label{\detokenize{intro_wavefunction:pade-form}}\label{\detokenize{intro_wavefunction:onebodyjastrowpade}}
Although the spline Jastrow factor is the most flexible and most commonly used form implemented in QMCPACK,
there are times where its flexibility can make it difficult to optimize.  As an example, a spline Jastrow
with a very large cutoff can be difficult to optimize for isolated systems such as molecules because of the small
number of samples present in the tail of the function.  In such cases, a simpler functional
form might be advantageous.  The second\sphinxhyphen{}order Pade Jastrow factor, given in \eqref{equation:intro_wavefunction:eq11}, is a good choice
in such cases.
\begin{equation}\label{equation:intro_wavefunction:eq11}
\begin{split}u_{ab}(r) = \frac{a*r+c*r^2}{1+b*r}\end{split}
\end{equation}
Unlike the spline Jastrow factor, which includes a cutoff, this form has an infinite range and will be applied to every particle
pair (subject to the minimum image convention).  It also is a cuspless Jastrow factor,
so it should be used either in combination with a single particle basis set that contains the proper cusp or
with a smooth pseudopotential.

Correlation element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

\sphinxstylestrong{Name}
&
\sphinxstylestrong{Datatype}
&
\sphinxstylestrong{Values}
&
\sphinxstylestrong{Defaults}
&
\sphinxstylestrong{Description}
\\
\hline
ElementType
&
Text
&
Name
&
See below
&
Classical particle target
\\
\hline
Elements
&&&&\\
\hline&
Coefficients
&&&\\
\hline
Contents
&&&&\\
\hline&
(None)
&&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Parameter element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

\sphinxstylestrong{Name}
&
\sphinxstylestrong{Datatype}
&
\sphinxstylestrong{Values}
&
\sphinxstylestrong{Defaults}
&
\sphinxstylestrong{Description}
\\
\hline
Id
&
String
&
Name
&
(Required)
&
Name for
variable
\\
\hline
Name
&
String
&
A or B or C
&
(Required)
&
See
\eqref{equation:intro_wavefunction:eq11}
\\
\hline
Optimize
&
Text
&
Yes or no
&
Yes
&
If no,
values are
fixed in
optimizations
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

Elements
&&&&\\
\hline
(None)
&&&&\\
\hline
Contents
&&&&\\
\hline
(No name)
&
Real
&
Parameter
value
&
(Required)
&
Jastrow
coefficients
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\paragraph{Example use case}
\label{\detokenize{intro_wavefunction:example-use-case}}\label{\detokenize{intro_wavefunction:bjpadeexamples}}
Specify a spin\sphinxhyphen{}independent function with independent Jastrow factors for two different species (Li and H).
The name of the particleset holding the ionic positions is “i.”

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{J1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{function}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pade2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{One\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{print}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Li}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{var} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LiA}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mf}{0.34} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{var}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{var} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LiB}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{B}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{12.78} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{var}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{var} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LiC}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mf}{1.62} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{var}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{var} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HA}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mf}{0.14} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{var}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{var} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HB}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{B}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{6.88} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{var}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{var} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HC}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.237} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{var}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\paragraph{Short Range Cusp Form}
\label{\detokenize{intro_wavefunction:short-range-cusp-form}}
The idea behind this functor is to encode nuclear cusps and other details at very
short range around a nucleus in the region that the Gaussian orbitals of quantum
chemistry are not capable of describing correctly.
The functor is kept short ranged, because outside this small region, quantum chemistry
orbital expansions are already capable of taking on the correct shapes.
Unlike a pre\sphinxhyphen{}computed cusp correction, this optimizable functor can respond to
changes in the wave function during VMC optimization.
The functor’s form is
\begin{equation}\label{equation:intro_wavefunction:eq12}
\begin{split}u(r) = -\exp{\left(-r/R_0\right)} \left( A R_0 + \sum_{k=0}^{N-1} B_k \frac{ (r/R_0)^{k+2} }{ 1 + (r/R_0)^{k+2} } \right)\end{split}
\end{equation}
in which \(R_0\) acts as a soft cutoff radius (\(u(r)\) decays to zero quickly beyond roughly this distance)
and \(A\) determines the cusp condition.
\begin{equation}\label{equation:intro_wavefunction:eq13}
\begin{split}\lim_{r \to 0} \frac{\partial u}{\partial r} = A\end{split}
\end{equation}
The simple exponential decay is modified by the \(N\) coefficients
\(B_k\) that define an expansion in sigmoidal functions, thus adding
detailed structure in a short\sphinxhyphen{}ranged region around a nucleus while
maintaining the correct cusp condition at the nucleus. Note that
sigmoidal functions are used instead of, say, a bare polynomial
expansion, as they trend to unity past the soft cutoff radius and so
interfere less with the exponential decay that keeps the functor short
ranged. Although \(A\), \(R_0\), and the \(B_k\)
coefficients can all be optimized as variational parameters, \(A\)
will typically be fixed as the desired cusp condition is known.

To specify this one\sphinxhyphen{}body Jastrow factor, use an input section like the following.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{J1Cusps}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{One\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{function}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{shortrangecusp}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{print}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{cusp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Li}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{var} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LiCuspR0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{R0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.06} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{var}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LiCuspB}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{cusp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{var} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HCuspR0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{R0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.2} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{var}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HCuspB}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Here “rcut” is specified as the range beyond which the functor is
assumed to be zero. The value of \(A\) can either be specified via
the “cusp” option as shown above, in which case its optimization is
disabled, or through its own “var” line as for \(R_0\), in which
case it can be specified as either optimizable (“yes”) or not (“no”).
The coefficients \(B_k\) are specified via the “coefficients”
section, with the length \(N\) of the expansion determined
automatically based on the length of the array.

Note that this one\sphinxhyphen{}body Jastrow form can (and probably should) be used in conjunction
with a longer ranged one\sphinxhyphen{}body Jastrow, such as a spline form.
Be sure to set the longer\sphinxhyphen{}ranged Jastrow to be cusp\sphinxhyphen{}free!


\subsection{Two\sphinxhyphen{}body Jastrow functions}
\label{\detokenize{intro_wavefunction:two-body-jastrow-functions}}
The two\sphinxhyphen{}body Jastrow factor is a form that allows for the explicit inclusion
of dynamic correlation between two particles included in the wavefunction.  It
is almost always given in a spin dependent form so as to satisfy the Kato cusp
condition between electrons of different spins \sphinxcite{intro_wavefunction:kato}.

The two body Jastrow function is specified within a \sphinxcode{\sphinxupquote{wavefunction}} element
and must contain one or more correlation elements specifying additional parameters
as well as the actual coefficients.  {\hyperref[\detokenize{intro_wavefunction:id11}]{\sphinxcrossref{\DUrole{std,std-ref}{Example use cases}}}} gives
examples of the typical nesting of \sphinxcode{\sphinxupquote{jastrow}}, \sphinxcode{\sphinxupquote{correlation}} and
\sphinxcode{\sphinxupquote{coefficient}} elements.


\subsubsection{Input Specification}
\label{\detokenize{intro_wavefunction:id8}}
Jastrow element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

\sphinxstylestrong{name}
&
\sphinxstylestrong{datatype}
&
\sphinxstylestrong{values}
&
\sphinxstylestrong{defaults}
&
\sphinxstylestrong{description}
\\
\hline
name
&
text
&&
(required)
&
Unique name
for this
Jastrow
function
\\
\hline
type
&
text
&
Two\sphinxhyphen{}body
&
(required)
&
Define a
one\sphinxhyphen{}body
function
\\
\hline
function
&
text
&
Bspline
&
(required)
&
BSpline
Jastrow
\\
\hline
print
&
text
&
yes / no
&
yes
&
Jastrow
factor
printed in
external
file?
\\
\hline&&&&\\
\hline
elements
&&&&\\
\hline&
Correlation
&&&\\
\hline
Contents
&&&&\\
\hline&
(None)
&&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

The two\sphinxhyphen{}body Jastrow factors used to describe correlations between electrons take the form
\begin{equation}\label{equation:intro_wavefunction:eq14}
\begin{split}J2=\sum_i^{e}\sum_{j>i}^{e} u_{ab}(|r_i-r_j|)\end{split}
\end{equation}
The most commonly used form of two body Jastrow factor supported by the code is a splined
Jastrow factor, with many similarities to the one body spline Jastrow.


\paragraph{Spline form}
\label{\detokenize{intro_wavefunction:twobodyjastrowspline}}\label{\detokenize{intro_wavefunction:id9}}
The two\sphinxhyphen{}body spline Jastrow function is the most commonly used two\sphinxhyphen{}body
Jastrow for solids. This form was first described and used in
\sphinxcite{running:eslerkimceperleyshulenburger2012}. Here
\(u_{ab}\) is an interpolating 1D B\sphinxhyphen{}spline (tricublc spline on a
linear grid) between zero distance and \(r_{cut}\). In 3D periodic
systems, the default cutoff distance is the Wigner Seitz cell radius.
For other periodicities, including isolated molecules, the
\(r_{cut}\) must be specified. \(r_i\) and \(r_j\) are
typically electron positions. The cusp condition as \(r_i\)
approaches \(r_j\) is set by the relative spin of the electrons.

Correlation element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

\sphinxstylestrong{Name}
&
\sphinxstylestrong{Datatype}
&
\sphinxstylestrong{Values}
&
\sphinxstylestrong{Defaults}
&
\sphinxstylestrong{Description}
\\
\hline
SpeciesA
&
Text
&
U or d
&
(Required)
&
Quantum
species
target
\\
\hline
SpeciesB
&
Text
&
U or d
&
(Required)
&
Quantum
species
target
\\
\hline
Size
&
Integer
&
\(> 0\)
&
(Required)
&
Number of
coefficients
\\
\hline
Rcut
&
Real
&
\(> 0\)
&
See below
&
Distance at
which the
correlation
goes to 0
\\
\hline
Spin
&
Text
&
Yes or no
&
No
&
Spin\sphinxhyphen{}dependent
Jastrow factor
\\
\hline&&&&\\
\hline
Elements
&&&&\\
\hline&
Coefficients
&&&\\
\hline
Contents
&&&&\\
\hline&
(None)
&&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{speciesA, speciesB}} The scale function u(r) is defined for species pairs uu and ud.

\end{itemize}

There is no need to define ud or dd since uu=dd and ud=du.  The cusp condition is computed internally
based on the charge of the quantum particles.

Coefficients element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

\sphinxstylestrong{Name}
&
\sphinxstylestrong{Datatype}
&
\sphinxstylestrong{Values}
&
\sphinxstylestrong{Defaults}
&
\sphinxstylestrong{Description}
\\
\hline
Id
&
Text
&&
(Required)
&
Unique
identifier
\\
\hline
Type
&
Text
&
Array
&
(Required)
&\\
\hline
Optimize
&
Text
&
Yes or no
&
Yes
&
If no,
values are
fixed in
optimizations
\\
\hline&&&&\\
\hline
Elements
&&&&\\
\hline
(None)
&&&&\\
\hline
Contents
&&&&\\
\hline
(No name)
&
Real array
&&
Zeros
&
Jastrow
coefficients
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\paragraph{Example use cases}
\label{\detokenize{intro_wavefunction:id11}}\label{\detokenize{intro_wavefunction:id12}}
Specify a spin\sphinxhyphen{}dependent function with four parameters for each channel.  In this case, the cusp is set at
a radius of 4.0 bohr (rather than to the default of the Wigner Seitz cell radius).  Also, in this example,
the coefficients are set to not be optimized during an optimization step.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{J2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Two\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{function}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{print}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{speciesA}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{speciesB}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{uu}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.2309049836} \PYG{l+m+mf}{0.1312646071} \PYG{l+m+mf}{0.05464141356} \PYG{l+m+mf}{0.01306231516}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{speciesA}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{speciesB}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ud}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.4351561096} \PYG{l+m+mf}{0.2377951747} \PYG{l+m+mf}{0.1129144262} \PYG{l+m+mf}{0.0356789236}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{User defined functional form}
\label{\detokenize{intro_wavefunction:user-defined-functional-form}}\label{\detokenize{intro_wavefunction:jastrowuserform}}
To aid in implementing different forms for \(u_{ab}(r)\), there is a
script that uses a symbolic expression to generate the appropriate code
(with spatial and parameter derivatives). The script is located in
\sphinxcode{\sphinxupquote{src/QMCWaveFunctions/Jastrow/codegen/user\_jastrow.py}}. The script
requires Sympy (www.sympy.org) for symbolic mathematics and code
generation.

To use the script, modify it to specify the functional form and a list
of variational parameters. Optionally, there may be fixed parameters \sphinxhyphen{}
ones that are specified in the input file, but are not part of the
variational optimization. Also one symbol may be specified that accepts
a cusp value in order to satisfy the cusp condition. There are several
example forms in the script. The default form is the simple Padé.

Once the functional form and parameters are specified in the script, run
the script from the \sphinxcode{\sphinxupquote{codegen}} directory and recompile QMCPACK. The
main output of the script is the file
\sphinxcode{\sphinxupquote{src/QMCWaveFunctions/Jastrow/UserFunctor.h}}. The script also prints
information to the screen, and one section is a sample XML input block
containing all the parameters.

There is a unit test in
\sphinxcode{\sphinxupquote{src/QMCWaveFunctions/test/test\_user\_jastrow.cpp}} to perform some
minimal testing of the Jastrow factor. The unit test will need updating
to properly test new functional forms. Most of the changes relate to the
number and name of variational parameters.

Jastrow element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

\sphinxstylestrong{name}
&
\sphinxstylestrong{datatype}
&
\sphinxstylestrong{values}
&
\sphinxstylestrong{defaults}
&
\sphinxstylestrong{description}
\\
\hline
name
&
text
&&
(required)
&
Unique name
for this
Jastrow
function
\\
\hline
type
&
text
&
One\sphinxhyphen{}body
&
(required)
&
Define a
one\sphinxhyphen{}body
function
\\
\hline&&
Two\sphinxhyphen{}body
&
(required)
&
Define a
two\sphinxhyphen{}body
function
\\
\hline
function
&
text
&
user
&
(required)
&
User\sphinxhyphen{}defined
functor
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

See other parameters as appropriate for one or two\sphinxhyphen{}body functions


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

elements
&&&&\\
\hline&
Correlation
&&&\\
\hline
Contents
&&&&\\
\hline&
(None)
&&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\subsection{Long\sphinxhyphen{}ranged Jastrow factors}
\label{\detokenize{intro_wavefunction:long-ranged-jastrow-factors}}
While short\sphinxhyphen{}ranged Jastrow factors capture the majority of the benefit
for minimizing the total energy and the energy variance, long\sphinxhyphen{}ranged
Jastrow factors are important to accurately reproduce the short\sphinxhyphen{}ranged
(long wavelength) behavior of quantities such as the static structure
factor, and are therefore essential for modern accurate finite size
corrections in periodic systems.

Below two types of long\sphinxhyphen{}ranged Jastrow factors are described. The first
(the k\sphinxhyphen{}space Jastrow) is simply an expansion of the one and/or two body
correlation functions in plane waves, with the coefficients comprising
the optimizable parameters. The second type have few variational
parameters and use the optimized breakup method of Natoli and
Ceperley \sphinxcite{simulationcell:natoli1995} (the Yukawa and Gaskell RPA
Jastrows).


\subsubsection{Long\sphinxhyphen{}ranged Jastrow: k\sphinxhyphen{}space Jastrow}
\label{\detokenize{intro_wavefunction:long-ranged-jastrow-k-space-jastrow}}
The k\sphinxhyphen{}space Jastrow introduces explicit long\sphinxhyphen{}ranged dependence commensurate with the periodic supercell.  This Jastrow is to be used in periodic boundary conditions only.

The input for the k\sphinxhyphen{}space Jastrow fuses both one and two\sphinxhyphen{}body forms into a single element and so they are discussed together here.  The one\sphinxhyphen{} and two\sphinxhyphen{}body terms in the k\sphinxhyphen{}Space Jastrow have the form:
\begin{equation}\label{equation:intro_wavefunction:eq15}
\begin{split}J_1 = \sum_{G\ne 0}b_G\rho_G^I\rho_{-G}\end{split}
\end{equation}\begin{equation}\label{equation:intro_wavefunction:eq16}
\begin{split}J_2 = \sum_{G\ne 0}a_G\rho_G\rho_{-G}\end{split}
\end{equation}
Here \(\rho_G\) is the Fourier transform of the instantaneous electron density:
\begin{equation}\label{equation:intro_wavefunction:eq17}
\begin{split}\rho_G=\sum_{n\in electrons}e^{iG\cdot r_n}\end{split}
\end{equation}
and \(\rho_G^I\) has the same form, but for the fixed ions. In both cases the coefficients are restricted to be real, though in general the coefficients for the one\sphinxhyphen{}body term need not be.  See \DUrole{xref,std,std-ref}{feature\sphinxhyphen{}kspace\sphinxhyphen{}jastrow} for more detail.

Input for the k\sphinxhyphen{}space Jastrow follows the familar nesting of \sphinxcode{\sphinxupquote{jastrow\sphinxhyphen{}correlation\sphinxhyphen{}coefficients}} elements, with attributes unique to the k\sphinxhyphen{}space Jastrow at the \sphinxcode{\sphinxupquote{correlation}} input level.

\sphinxcode{\sphinxupquote{jastrow type=kSpace}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{wavefunction}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{correlation}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{kSpace}
&&
must be kSpace
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
0
&
Unique name for Jastrow
\\
\hline
\sphinxcode{\sphinxupquote{source}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&&
Ion particleset name
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

\sphinxcode{\sphinxupquote{correlation}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{jastrow type=kSpace}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{coefficients}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{One\sphinxhyphen{}body, Two\sphinxhyphen{}Body}
&&
Must be One\sphinxhyphen{}body/Two\sphinxhyphen{}body
\\
\hline
\sphinxcode{\sphinxupquote{kc}}\(^r\)
&
real
&
kc \(\ge\) 0
&
0.0
&
k\sphinxhyphen{}space cutoff in a.u.
\\
\hline
\sphinxcode{\sphinxupquote{symmetry}}\(^o\)
&
text
&
crystal,isotropic,none
&
crystal
&
symmetry of coefficients
\\
\hline
\sphinxcode{\sphinxupquote{spinDependent}}\(^o\)
&
boolean
&
yes,no
&
no
&
\sphinxstyleemphasis{No current function}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

\sphinxcode{\sphinxupquote{coefficients}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{correlation}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{id}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
cG1/cG2
&
Label for coeffs
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{Array}}
&
0
&
Must be Array
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

body text: The body text is a list of real values for the parameters.
\end{quote}

Additional information:
\begin{itemize}
\item {} 
It is normal to provide no coefficients as an initial guess. The
number of coefficients will be automatically calculated according to
the k\sphinxhyphen{}space cutoff + symmetry and set to zero.

\item {} 
Providing an incorrect number of parameters also results in all
parameters being set to zero.

\item {} 
There is currently no way to turn optimization on/off for the k\sphinxhyphen{}space
Jastrow. The coefficients are always optimized.

\item {} 
Spin dependence is currently not implemented for this Jastrow.

\item {} 
\sphinxcode{\sphinxupquote{kc}}: Parameters with G vectors magnitudes less than \sphinxcode{\sphinxupquote{kc}} are
included in the Jastrow. If \sphinxcode{\sphinxupquote{kc}} is zero, it is the same as
excluding the k\sphinxhyphen{}space term.

\item {} 
\sphinxcode{\sphinxupquote{symmetry=crystal}}: Impose crystal symmetry on coefficients
according to the structure factor.

\item {} 
\sphinxcode{\sphinxupquote{symmetry=isotropic}}: Impose spherical symmetry on coefficients
according to G\sphinxhyphen{}vector magnitude.

\item {} 
\sphinxcode{\sphinxupquote{symmetry=none}}: Impose no symmetry on the coefficients.

\end{itemize}
\sphinxSetupCaptionForVerbatim{k\sphinxhyphen{}space Jastrow with one\sphinxhyphen{} and two\sphinxhyphen{}body terms.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-10}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{kSpace}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Jk}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{kc}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{One\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{symmetry}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cystal}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cG1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{kc}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Two\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{symmetry}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{crystal}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cG2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{k\sphinxhyphen{}space Jastrow with one\sphinxhyphen{}body term only.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-11}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{kSpace}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Jk}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{kc}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{One\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{symmetry}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{crystal}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cG1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{k\sphinxhyphen{}space Jastrow with two\sphinxhyphen{}body term only.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-12}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{kSpace}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Jk}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{kc}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Two\PYGZhy{}Body}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{symmetry}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{crystal}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cG2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\paragraph{Long\sphinxhyphen{}ranged Jastrows: Gaskell RPA and Yukawa forms}
\label{\detokenize{intro_wavefunction:long-ranged-jastrows-gaskell-rpa-and-yukawa-forms}}\label{\detokenize{intro_wavefunction:twobodyjastrowlr}}
\sphinxstylestrong{NOTE: The Yukawa and RPA Jastrows do not work at present
and are currently being revived.  Please contact the developers if
you are interested in using them.}

The exact Jastrow correlation functions contain terms which have a
form similar to the Coulomb pair potential.  In periodic systems
the Coulomb potential is replaced by an Ewald summation of the
bare potential over all periodic image cells.  This sum is often
handled by the optimized breakup method \sphinxcite{simulationcell:natoli1995} and this
same approach is applied to the long\sphinxhyphen{}ranged Jastrow factors in QMCPACK.

There are two main long\sphinxhyphen{}ranged Jastrow factors of this type
implemented in QMCPACK: the Gaskell RPA \sphinxcite{intro_wavefunction:gaskell1961}\sphinxcite{intro_wavefunction:gaskell1962}
form and the \sphinxcite{intro_wavefunction:ceperley1978} form.  Both of these forms
were used by Ceperley in early studies of the electron gas \sphinxcite{intro_wavefunction:ceperley1978},
but they are also appropriate starting points for general solids.

The Yukawa form is defined in real space.  It’s long\sphinxhyphen{}range form is
formally defined as
\begin{equation}\label{equation:intro_wavefunction:eq18}
\begin{split}u_Y^{PBC}(r) = \sum_{L\ne 0}\sum_{i<j}u_Y(\left|{r_i-r_j+L}\right|)\end{split}
\end{equation}
with \(u_Y(r)\) given by
\begin{equation}\label{equation:intro_wavefunction:eq19}
\begin{split}u_Y(r) = \frac{a}{r}\left(1-e^{-r/b}\right)\end{split}
\end{equation}
In QMCPACK a slightly more restricted form is used:
\begin{equation}\label{equation:intro_wavefunction:eq20}
\begin{split}u_Y(r) = \frac{r_s}{r}\left(1-e^{-r/\sqrt{r_s}}\right)\end{split}
\end{equation}
here “\(r_s\)” is understood to be a variational parameter.

The Gaskell RPA form—which contains correct short/long range limits
and minimizes the total energy of the electron gas within the RPA—is
defined directly in k\sphinxhyphen{}space:
\begin{equation}\label{equation:intro_wavefunction:eq21}
\begin{split}u_{RPA}(k) = -\frac{1}{2S_0(k)}+\frac{1}{2}\left(\frac{1}{S_0(k)^2}+\frac{4m_ev_k}{\hbar^2k^2}\right)^{1/2}\end{split}
\end{equation}
where \$v\_k\$ is the Fourier transform of the Coulomb potential and
\(S_0(k)\) is the static structure factor of the non\sphinxhyphen{}interacting
electron gas:
\begin{equation*}
\begin{split}S_0(k) = \left.
    \begin{cases}
      1 &  k>2k_F \\
      \frac{3k}{4k_F}-\frac{1}{2}\left(\frac{k}{2k_F}\right)^3 & k<2k_F
    \end{cases}
    \right.\end{split}
\end{equation*}
When written in atomic units, RPA Jastrow implemented in QMCPACK has the
form
\begin{equation}\label{equation:intro_wavefunction:eq22}
\begin{split}u_{RPA}(k) = \frac{1}{2N_e}\left(-\frac{1}{S_0(k)}+\left(\frac{1}{S_0(k)^2}+\frac{12}{r_s^3k^4}\right)^{1/2}\right)\end{split}
\end{equation}
Here “\(r_s\)” is again a variational parameter and \(k_F\equiv(\tfrac{9\pi}{4r_s^3})^{1/3}\).

For both the Yukawa and Gaskell RPA Jastrows, the default value for \(r_s\) is \(r_s=(\tfrac{3\Omega}{4\pi N_e})^{1/3}\).

\sphinxcode{\sphinxupquote{jastrow type=Two\sphinxhyphen{}Body function=rpa/yukawa}} element:
\begin{quote}
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{wavefunction}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{correlation}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{Two\sphinxhyphen{}body}
&&
Must be two\sphinxhyphen{}body
\\
\hline
\sphinxcode{\sphinxupquote{function}}\(^r\)
&
text
&
\sphinxstylestrong{rpa/yukawa}
&&
Must be rpa or yukawa
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
RPA\_Jee
&
Unique name for Jastrow
\\
\hline
\sphinxcode{\sphinxupquote{longrange}}\(^o\)
&
boolean
&
yes/no
&
yes
&
Use long\sphinxhyphen{}range part
\\
\hline
\sphinxcode{\sphinxupquote{shortrange}}\(^o\)
&
boolean
&
yes/no
&
yes
&
Use short\sphinxhyphen{}range part
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

parameters:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{rs}}\(^o\)
&
rs
&
\(r_s>0\)
&
\(\tfrac{3\Omega}{4\pi N_e}\)
&
Avg. elec\sphinxhyphen{}elec distance
\\
\hline
\sphinxcode{\sphinxupquote{kc}}\(^o\)
&
kc
&
\(k_c>0\)
&
\(2\left(\tfrac{9\pi}{4}\right)^{1/3}\tfrac{4\pi N_e}{3\Omega}\)
&
k\sphinxhyphen{}space cutoff
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}
\end{quote}
\sphinxSetupCaptionForVerbatim{Two body RPA Jastrow with long\sphinxhyphen{} and short\sphinxhyphen{}ranged parts.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro_wavefunction:listing-13}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{n}{Jee}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{n}{Two}\PYG{o}{\PYGZhy{}}\PYG{n}{Body}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{n}{function}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{n}{rpa}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Three\sphinxhyphen{}body Jastrow functions}
\label{\detokenize{intro_wavefunction:three-body-jastrow-functions}}
Explicit three\sphinxhyphen{}body correlations can be included in the wavefunction via
the three\sphinxhyphen{}body Jastrow factor. The three\sphinxhyphen{}body electron\sphinxhyphen{}electron\sphinxhyphen{}ion
correlation function (\(u_{\sigma\sigma'I}\)) currently used in is
identical to the one proposed in \sphinxcite{intro_wavefunction:drummond2004}:
\begin{equation}\label{equation:intro_wavefunction:eq23}
\begin{split} \begin{aligned}
 u_{\sigma\sigma'I}(r_{\sigma I},r_{\sigma'I},r_{\sigma\sigma'}) &= \sum_{\ell=0}^{M_{eI}}\sum_{m=0}^{M_{eI}}\sum_{n=0}^{M_{ee}}\gamma_{\ell mn} r_{\sigma I}^\ell r_{\sigma'I}^m r_{\sigma\sigma'}^n \\
    &\times \left(r_{\sigma I}-\frac{r_c}{2}\right)^3 \Theta\left(r_{\sigma I}-\frac{r_c}{2}\right) \nonumber \\
    &\times \left(r_{\sigma' I}-\frac{r_c}{2}\right)^3 \Theta\left(r_{\sigma' I}-\frac{r_c}{2}\right) \nonumber\end{aligned}\end{split}
\end{equation}
Here \(M_{eI}\) and \(M_{ee}\) are the maximum polynomial orders
of the electron\sphinxhyphen{}ion and electron\sphinxhyphen{}electron distances, respectively,
\(\{\gamma_{\ell mn}\}\) are the optimizable parameters (modulo
constraints), \(r_c\) is a cutoff radius, and \(r_{ab}\) are the
distances between electrons or ions \(a\) and \(b\). i.e. The
correlation function is only a function of the interparticle distances
and not a more complex function of the particle positions,
\(\mathbf{r}\). As indicated by the \(\Theta\) functions,
correlations are set to zero beyond a distance of \(r_c/2\) in
either of the electron\sphinxhyphen{}ion distances and the largest meaningful
electron\sphinxhyphen{}electron distance is \(r_c\). This is the highest\sphinxhyphen{}order
Jastrow correlation function currently implemented.

Today, solid state applications of QMCPACK usually utilize one and
two\sphinxhyphen{}body B\sphinxhyphen{}spline Jastrow functions, with calculations on heavier
elements often also using the three\sphinxhyphen{}body term described above.


\subsubsection{Example use case}
\label{\detokenize{intro_wavefunction:id20}}
Here is an example of H2O molecule. After optimizing one and two body Jastrow factors, add the following block in the wavefunction.
The coefficients will be filled zero automatically if not given.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{jastrow} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{J3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{eeI}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{function}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{polynomial}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{print}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{ispecies}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{O}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{especies}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{isize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{esize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{uuO}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{ispecies}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{O}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{especies1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{especies2}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{isize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{esize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{udO}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{ispecies}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{especies}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{isize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{esize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{uuH}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{correlation} \PYG{n}{ispecies}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{especies1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{especies2}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{isize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{esize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rcut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{coefficients} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{udH}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Array}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{optimize}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coefficients}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{correlation}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jastrow}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\section{Multideterminant wavefunctions}
\label{\detokenize{intro_wavefunction:multideterminant-wavefunctions}}\label{\detokenize{intro_wavefunction:multideterminants}}
Multiple schemes to generate a multideterminant wavefunction are
possible, from CASSF to full CI or selected CI. The QMCPACK converter can
convert MCSCF multideterminant wavefunctions from
GAMESS \sphinxcite{intro_wavefunction:schmidt93} and CIPSI \sphinxcite{intro_wavefunction:caffarel2013} wavefunctions from
Quantum Package \sphinxcite{intro_wavefunction:qp} (QP). Full details of how to run a CIPSI
calculation and convert the wavefunction for QMCPACK are given in
\DUrole{xref,std,std-ref}{cipsi}.

The script \sphinxcode{\sphinxupquote{utils/determinants\_tools.py}} can be used to generate
useful information about the multideterminant wavefunction. This script takes, as a required argument, the path of an h5 file corresponding to the wavefunction. Used without optional arguments, it prints the number of determinants, the number of CSFs, and a histogram of the excitation degree.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}} \PYG{n}{determinants\PYGZus{}tools}\PYG{o}{.}\PYG{n}{py} \PYG{o}{.}\PYG{o}{/}\PYG{n}{tests}\PYG{o}{/}\PYG{n}{molecules}\PYG{o}{/}\PYG{n}{C2\PYGZus{}pp}\PYG{o}{/}\PYG{n}{C2}\PYG{o}{.}\PYG{n}{h5}
\PYG{n}{Summary}\PYG{p}{:}
\PYG{n}{excitation} \PYG{n}{degree} \PYG{l+m+mi}{0} \PYG{n}{count}\PYG{p}{:} \PYG{l+m+mi}{1}
\PYG{n}{excitation} \PYG{n}{degree} \PYG{l+m+mi}{1} \PYG{n}{count}\PYG{p}{:} \PYG{l+m+mi}{6}
\PYG{n}{excitation} \PYG{n}{degree} \PYG{l+m+mi}{2} \PYG{n}{count}\PYG{p}{:} \PYG{l+m+mi}{148}
\PYG{n}{excitation} \PYG{n}{degree} \PYG{l+m+mi}{3} \PYG{n}{count}\PYG{p}{:} \PYG{l+m+mi}{27}
\PYG{n}{excitation} \PYG{n}{degree} \PYG{l+m+mi}{4} \PYG{n}{count}\PYG{p}{:} \PYG{l+m+mi}{20}

\PYG{n}{n\PYGZus{}det} \PYG{l+m+mi}{202}
\PYG{n}{n\PYGZus{}csf} \PYG{l+m+mi}{104}
\end{sphinxVerbatim}

If the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}verbose}} argument is used, the script will print each determinant,
the associated CSF, and the excitation degree relative to the first determinant.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}} \PYG{n}{determinants\PYGZus{}tools}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{v} \PYG{o}{.}\PYG{o}{/}\PYG{n}{tests}\PYG{o}{/}\PYG{n}{molecules}\PYG{o}{/}\PYG{n}{C2\PYGZus{}pp}\PYG{o}{/}\PYG{n}{C2}\PYG{o}{.}\PYG{n}{h5} \PYG{o}{|} \PYG{n}{head}
\PYG{l+m+mi}{1}
\PYG{n}{alpha}  \PYG{l+m+mi}{1111000000000000000000000000000000000000000000000000000000}
\PYG{n}{beta}   \PYG{l+m+mi}{1111000000000000000000000000000000000000000000000000000000}
\PYG{n}{scf}    \PYG{l+m+mi}{2222000000000000000000000000000000000000000000000000000000}
\PYG{n}{excitation} \PYG{n}{degree}  \PYG{l+m+mi}{0}

\PYG{l+m+mi}{2}
\PYG{n}{alpha}  \PYG{l+m+mi}{1011100000000000000000000000000000000000000000000000000000}
\PYG{n}{beta}   \PYG{l+m+mi}{1011100000000000000000000000000000000000000000000000000000}
\PYG{n}{scf}    \PYG{l+m+mi}{2022200000000000000000000000000000000000000000000000000000}
\PYG{n}{excitation} \PYG{n}{degree}  \PYG{l+m+mi}{2}
\end{sphinxVerbatim}


\section{Backflow Wavefunctions}
\label{\detokenize{intro_wavefunction:backflow-wavefunctions}}\label{\detokenize{intro_wavefunction:backflow}}
One can perturb the nodal surface of a single\sphinxhyphen{}Slater/multi\sphinxhyphen{}Slater
wavefunction through use of a backflow transformation. Specifically, if
we have an antisymmetric function
\(D(\mathbf{x}_{0\uparrow},\cdots,\mathbf{x}_{N\uparrow}, \mathbf{x}_{0\downarrow},\cdots,\mathbf{x}_{N\downarrow})\),
and if \(i_\alpha\) is the \(i\)\sphinxhyphen{}th particle of species type
\(\alpha\), then the backflow transformation works by making the
coordinate transformation
\(\mathbf{x}_{i_\alpha} \to \mathbf{x}'_{i_\alpha}\) and evaluating
\(D\) at these new “quasiparticle” coordinates. QMCPACK currently
supports quasiparticle transformations given by
\begin{equation}\label{equation:intro_wavefunction:eq24}
\begin{split}\mathbf{x}'_{i_\alpha}=\mathbf{x}_{i_\alpha}+\sum_{\alpha \leq \beta} \sum_{i_\alpha \neq j_\beta} \eta^{\alpha\beta}(|\mathbf{x}_{i_\alpha}-\mathbf{x}_{j_\beta}|)(\mathbf{x}_{i_\alpha}-\mathbf{x}_{j_\beta})\:.\end{split}
\end{equation}
Here, \(\eta^{\alpha\beta}(|\mathbf{x}_{i_\alpha}-\mathbf{x}_{j_\beta}|)\)
is a radially symmetric backflow transformation between species
\(\alpha\) and \(\beta\). In QMCPACK, particle \(i_\alpha\)
is known as the “target” particle and \(j_\beta\) is known as the
“source.” The main types of transformations are so\sphinxhyphen{}called one\sphinxhyphen{}body
terms, which are between an electron and an ion
\(\eta^{eI}(|\mathbf{x}_{i_e}-\mathbf{x}_{j_I}|)\) and two\sphinxhyphen{}body
terms. Two\sphinxhyphen{}body terms are distinguished as those between like and
opposite spin electrons:
\(\eta^{e(\uparrow)e(\uparrow)}(|\mathbf{x}_{i_e(\uparrow)}-\mathbf{x}_{j_e(\uparrow)}|)\)
and
\(\eta^{e(\uparrow)e(\downarrow)}(|\mathbf{x}_{i_e(\uparrow)}-\mathbf{x}_{j_e(\downarrow)}|)\).
Henceforth, we will assume that
\(\eta^{e(\uparrow)e(\uparrow)}=\eta^{e(\downarrow)e(\downarrow)}\).

In the following, we explain how to describe general terms such as
\eqref{equation:intro_wavefunction:eq24} in a QMCPACK XML file. For specificity, we will
consider a particle set consisting of H and He (in that order). This
ordering will be important when we build the XML file, so you can find
this out either through your specific declaration of \textless{}particleset\textgreater{}, by
looking at the hdf5 file in the case of plane waves, or by looking at
the QMCPACK output file in the section labeled “Summary of QMC systems.”


\subsection{Input specifications}
\label{\detokenize{intro_wavefunction:input-specifications}}
All backflow declarations occur within a single \sphinxcode{\sphinxupquote{\textless{}backflow\textgreater{} ... \textless{}/backflow\textgreater{}}} block.  Backflow transformations occur in \sphinxcode{\sphinxupquote{\textless{}transformation\textgreater{}}} blocks and have the following input parameters:

Transformation element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
name
&
Text
&&
(Required)
&
Unique name for this Jastrow function.
\\
\hline
type
&
Text
&
“e\sphinxhyphen{}I”
&
(Required)
&
Define a one\sphinxhyphen{}body backflow transformation.
\\
\hline&
Text
&
“e\sphinxhyphen{}e”
&&
Define a two\sphinxhyphen{}body backflow transformation.
\\
\hline
function
&
Text
&
B\sphinxhyphen{}spline
&
(Required)
&
B\sphinxhyphen{}spline type transformation (no other types supported).
\\
\hline
source
&
Text
&&&
“e” if two body, ion particle set if one body.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Just like one\sphinxhyphen{} and two\sphinxhyphen{}body jastrows, parameterization of the backflow transformations are specified within the \sphinxcode{\sphinxupquote{\textless{}transformation\textgreater{}}} blocks by  \sphinxcode{\sphinxupquote{\textless{}correlation\textgreater{}}} blocks.  Please refer to {\hyperref[\detokenize{intro_wavefunction:onebodyjastrowspline}]{\sphinxcrossref{\DUrole{std,std-ref}{Spline form}}}} for more information.


\subsection{Example Use Case}
\label{\detokenize{intro_wavefunction:id24}}
Having specified the general form, we present a general example of one\sphinxhyphen{}body and two\sphinxhyphen{}body backflow transformations in a hydrogen\sphinxhyphen{}helium mixture.  The hydrogen and helium ions have independent backflow transformations, as do the like and unlike\sphinxhyphen{}spin two\sphinxhyphen{}body terms.  One caveat is in order:  ionic backflow transformations must be listed in the order they appear in the particle set.  If in our example, helium is listed first and hydrogen is listed second, the following example would be correct.  However, switching backflow declaration to hydrogen first then helium, will result in an error.  Outside of this, declaration of one\sphinxhyphen{}body blocks and two\sphinxhyphen{}body blocks are not sensitive to ordering.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}backflow\PYGZgt{}
\PYGZlt{}!\PYGZhy{}\PYGZhy{}The One\PYGZhy{}Body term with independent e\PYGZhy{}He and e\PYGZhy{}H terms. IN THAT ORDER \PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZlt{}transformation name=\PYGZdq{}eIonB\PYGZdq{} type=\PYGZdq{}e\PYGZhy{}I\PYGZdq{} function=\PYGZdq{}Bspline\PYGZdq{} source=\PYGZdq{}ion0\PYGZdq{}\PYGZgt{}
    \PYGZlt{}correlation cusp=\PYGZdq{}0.0\PYGZdq{} size=\PYGZdq{}8\PYGZdq{} type=\PYGZdq{}shortrange\PYGZdq{} init=\PYGZdq{}no\PYGZdq{} elementType=\PYGZdq{}He\PYGZdq{} rcut=\PYGZdq{}3.0\PYGZdq{}\PYGZgt{}
        \PYGZlt{}coefficients id=\PYGZdq{}eHeC\PYGZdq{} type=\PYGZdq{}Array\PYGZdq{} optimize=\PYGZdq{}yes\PYGZdq{}\PYGZgt{}
            0 0 0 0 0 0 0 0
        \PYGZlt{}/coefficients\PYGZgt{}
    \PYGZlt{}/correlation\PYGZgt{}
    \PYGZlt{}correlation cusp=\PYGZdq{}0.0\PYGZdq{} size=\PYGZdq{}8\PYGZdq{} type=\PYGZdq{}shortrange\PYGZdq{} init=\PYGZdq{}no\PYGZdq{} elementType=\PYGZdq{}H\PYGZdq{} rcut=\PYGZdq{}3.0\PYGZdq{}\PYGZgt{}
        \PYGZlt{}coefficients id=\PYGZdq{}eHC\PYGZdq{} type=\PYGZdq{}Array\PYGZdq{} optimize=\PYGZdq{}yes\PYGZdq{}\PYGZgt{}
            0 0 0 0 0 0 0 0
        \PYGZlt{}/coefficients\PYGZgt{}
    \PYGZlt{}/correlation\PYGZgt{}
\PYGZlt{}/transformation\PYGZgt{}

\PYGZlt{}!\PYGZhy{}\PYGZhy{}The Two\PYGZhy{}Body Term with Like and Unlike Spins \PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZlt{}transformation name=\PYGZdq{}eeB\PYGZdq{} type=\PYGZdq{}e\PYGZhy{}e\PYGZdq{} function=\PYGZdq{}Bspline\PYGZdq{} \PYGZgt{}
    \PYGZlt{}correlation cusp=\PYGZdq{}0.0\PYGZdq{} size=\PYGZdq{}7\PYGZdq{} type=\PYGZdq{}shortrange\PYGZdq{} init=\PYGZdq{}no\PYGZdq{} speciesA=\PYGZdq{}u\PYGZdq{} speciesB=\PYGZdq{}u\PYGZdq{} rcut=\PYGZdq{}1.2\PYGZdq{}\PYGZgt{}
        \PYGZlt{}coefficients id=\PYGZdq{}uuB1\PYGZdq{} type=\PYGZdq{}Array\PYGZdq{} optimize=\PYGZdq{}yes\PYGZdq{}\PYGZgt{}
            0 0 0 0 0 0 0
        \PYGZlt{}/coefficients\PYGZgt{}
    \PYGZlt{}/correlation\PYGZgt{}
    \PYGZlt{}correlation cusp=\PYGZdq{}0.0\PYGZdq{} size=\PYGZdq{}7\PYGZdq{} type=\PYGZdq{}shortrange\PYGZdq{} init=\PYGZdq{}no\PYGZdq{} speciesA=\PYGZdq{}d\PYGZdq{} speciesB=\PYGZdq{}u\PYGZdq{} rcut=\PYGZdq{}1.2\PYGZdq{}\PYGZgt{}
        \PYGZlt{}coefficients id=\PYGZdq{}udB1\PYGZdq{} type=\PYGZdq{}Array\PYGZdq{} optimize=\PYGZdq{}yes\PYGZdq{}\PYGZgt{}
            0 0 0 0 0 0 0
        \PYGZlt{}/coefficients\PYGZgt{}
    \PYGZlt{}/correlation\PYGZgt{}
\PYGZlt{}/transformation\PYGZgt{}
\PYGZlt{}/backflow\PYGZgt{}
\end{sphinxVerbatim}

Currently, backflow works only with single\sphinxhyphen{}Slater determinant wavefunctions.  When a backflow transformation has been declared, it should be placed within the \sphinxcode{\sphinxupquote{\textless{}determinantset\textgreater{}}} block, but outside of the \sphinxcode{\sphinxupquote{\textless{}slaterdeterminant\textgreater{}}} blocks, like so:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}determinantset ... \PYGZgt{}
    \PYGZlt{}!\PYGZhy{}\PYGZhy{}basis set declarations go here, if there are any \PYGZhy{}\PYGZhy{}\PYGZgt{}

    \PYGZlt{}backflow\PYGZgt{}
        \PYGZlt{}transformation ...\PYGZgt{}
          \PYGZlt{}!\PYGZhy{}\PYGZhy{}Here is where one and two\PYGZhy{}body terms are defined \PYGZhy{}\PYGZhy{}\PYGZgt{}
         \PYGZlt{}/transformation\PYGZgt{}
     \PYGZlt{}/backflow\PYGZgt{}

     \PYGZlt{}slaterdeterminant\PYGZgt{}
         \PYGZlt{}!\PYGZhy{}\PYGZhy{}Usual determinant definitions \PYGZhy{}\PYGZhy{}\PYGZgt{}
     \PYGZlt{}/slaterdeterminant\PYGZgt{}
 \PYGZlt{}/determinantset\PYGZgt{}
\end{sphinxVerbatim}


\subsection{Optimization Tips}
\label{\detokenize{intro_wavefunction:optimization-tips}}
Backflow is notoriously difficult to optimize—it is extremely nonlinear in the variational parameters and moves the nodal surface around.  As such, it is likely that a full Jastrow+Backflow optimization with all parameters initialized to zero might not converge in a reasonable time.  If you are experiencing this problem, the following pointers are suggested (in no particular order).


\subsubsection{Get a good starting guess for \protect\(\Psi_T\protect\):}
\label{\detokenize{intro_wavefunction:get-a-good-starting-guess-for-psi-t}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Try optimizing the Jastrow first without backflow.

\item {} 
Freeze the Jastrow parameters, introduce only the e\sphinxhyphen{}e terms in the
backflow transformation, and optimize these parameters.

\item {} 
Freeze the e\sphinxhyphen{}e backflow parameters, and then optimize the e\sphinxhyphen{}I terms.
\begin{itemize}
\item {} 
If difficulty is encountered here, try optimizing each species
independently.

\end{itemize}

\item {} 
Unfreeze all Jastrow, e\sphinxhyphen{}e backflow, and e\sphinxhyphen{}I backflow parameters, and
reoptimize.

\end{enumerate}


\subsubsection{Optimizing Backflow Terms}
\label{\detokenize{intro_wavefunction:optimizing-backflow-terms}}
It is possible that the previous prescription might grind to a halt in steps 2 or 3 with the inability to optimize the e\sphinxhyphen{}e or e\sphinxhyphen{}I backflow transformation independently, especially if it is initialized to zero.  One way to get around this is to build a good starting guess for the e\sphinxhyphen{}e or e\sphinxhyphen{}I backflow terms iteratively as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Start off with a small number of knots initialized to zero. Set
\(r_{cut}\) to be small (much smaller than an interatomic distance).

\item {} 
Optimize the backflow function.

\item {} 
If this works, slowly increase \(r_{cut}\) and/or the number of
knots.

\item {} 
Repeat steps 2 and 3 until there is no noticeable change in energy or
variance of \(\Psi_T\).

\end{enumerate}


\subsubsection{Tweaking the Optimization Run}
\label{\detokenize{intro_wavefunction:tweaking-the-optimization-run}}
The following modifications are worth a try in the optimization block:
\begin{itemize}
\item {} 
Try setting “useDrift” to “no.” This eliminates the use of
wavefunction gradients and force biasing in the VMC algorithm. This
could be an issue for poorly optimized wavefunctions with
pathological gradients.

\item {} 
Try increasing “exp0” in the optimization block. Larger values of
exp0 cause the search directions to more closely follow those
predicted by steepest\sphinxhyphen{}descent than those by the linear method.

\end{itemize}

Note that the new adaptive shift optimizer has not yet been tried with
backflow wavefunctions. It should perform better than the older
optimizers, but a considered optimization process is still recommended.


\section{Finite\sphinxhyphen{}difference linear response wave functions}
\label{\detokenize{intro_wavefunction:finite-difference-linear-response-wave-functions}}\label{\detokenize{intro_wavefunction:fdlr}}
The finite\sphinxhyphen{}difference linear response wavefunction (FDLR) is an
experimental wavefunction type described in detail in
\sphinxcite{intro_wavefunction:blunt-charge-transfer-2017}. In this method, the wavefunction is formed as the linear response of some existing trial wavefunction in QMCPACK. This derivatives of this linear response are
approximated by a simple finite difference.

Forming a wavefunction within the linear response space of an existing ansatz can be very powerful. For example, a configuration interaction singles (CIS) wavefunction can be formed as a linear combination of the first derivatives of a Slater determinant (with respect to its orbital rotation parameters). Thus, in this sense, CIS is the linear response of Hartree\textendash{}Fock theory.

Forming a CIS wavefunction as the linear response of an optimizable Slater determinant is where all testing of this wavefunction has been performed. In theory, the implementation is flexible and can be used with other trial wavefunctions in QMCPACK, but this has not been tested; the FDLR trial wavefunction is experimental.

Mathematically, the FDLR wavefunction has the form
\begin{equation}\label{equation:intro_wavefunction:eq25}
\begin{split}\Psi_{\textrm{FDLR}} (\mathbf{\mu}, \mathbf{X}) = \Psi (\mathbf{X} + \mathbf{\mu}) - \Psi (\mathbf{X} - \mathbf{\mu})\: ,\end{split}
\end{equation}
where \(\Psi(\mathbf{P})\) is some trial wavefunction in QMCPACK,
and \(\mathbf{P}\) is its optimizable parameters. \(\mathbf{X}\)
is the “base” parameters about which the finite difference is performed
(for example, an overall orbital rotation). \(\mathbf{\mu}\) is the
“finite\sphinxhyphen{}difference” parameters, which define the direction of the
derivative, and whose magnitude determines the magnitude of the finite
difference. In the limit that the magnitude of \(\mathbf{mu}\) goes
to \(0\), the \(\Psi_{\textrm{FDLR}}\) object just defined
becomes equivalent to
\begin{equation}\label{equation:intro_wavefunction:eq26}
\begin{split}\Psi_{\textrm{FDLR}} (\mathbf{\mu}, \mathbf{X}) = \sum_{pq} \mu_{pq} \: \frac{\partial \Psi_{\textrm{det}} (\mathbf{X}) }{\partial X_{pq}}\: ,\end{split}
\end{equation}
which is the desired linear response wavefunction we are approximating.
In the case that \(\Psi(\mathbf{P})\) is a determinant with orbital
rotation parameters \(\mathbf{P}\), the previous equation is a CIS
wavefunction with CIS expansion coefficients \(\mathbf{\mu}\) and
orbital rotation \(\mathbf{X}\).


\subsection{Input specifications}
\label{\detokenize{intro_wavefunction:id26}}
An FDLR wavefunction is specified within a \sphinxcode{\sphinxupquote{\textless{}fdlr\textgreater{} ... \textless{}/fdlr\textgreater{}}} block.

To fully specify an FDLR wavefunction as done previously, we require the
initial parameters for both \(\mathbf{X}\) and \(\mathbf{\mu}\)
to be input. This therefore requires two trial wavefunctions to be
provided on input. Each of these is best specified in its own XML file.
The names of these two files are provided in an \sphinxcode{\sphinxupquote{\textless{}include\textgreater{}}} tag via
\sphinxcode{\sphinxupquote{\textless{}include wfn\_x\_href=“ ... ” wfn\_d\_href=“ ... ”\textgreater{}}}. \sphinxcode{\sphinxupquote{wfn\_x\_href}}
specifies the file that will hold the \(\mathbf{X}\) parameters.
\sphinxcode{\sphinxupquote{wfn\_d\_href}} specifies the file that will hold the
\(\mathbf{\mu}\) parameters.

Other options inside the \sphinxcode{\sphinxupquote{\textless{}include\textgreater{}}} tag are \sphinxcode{\sphinxupquote{opt\_x}} and \sphinxcode{\sphinxupquote{opt\_d}},
which specify whether or not \(\mathbf{X}\) and \(\mathbf{\mu}\)
parameters are optimizable, respectively.


\subsection{Example Use Case}
\label{\detokenize{intro_wavefunction:id27}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{fdlrwfn} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{FDLR}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{include} \PYG{n}{wfn\PYGZus{}x\PYGZus{}href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{h2.wfn\PYGZus{}x.xml}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{wfn\PYGZus{}d\PYGZus{}href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{h2.wfn\PYGZus{}d.xml}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{opt\PYGZus{}x}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{opt\PYGZus{}d}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{fdlrwfn}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

with the \sphinxcode{\sphinxupquote{h2.wfn\_x.xml}} file containing one of the wavefunctions and
corresponding set of \(\mathbf{X}\) parameters, such as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}?xml version=\PYGZdq{}1.0\PYGZdq{}?\PYGZgt{}
\PYGZlt{}wfn\PYGZus{}x\PYGZgt{}
    \PYGZlt{}determinantset name=\PYGZdq{}LCAOBSet\PYGZdq{} type=\PYGZdq{}MolecularOrbital\PYGZdq{} transform=\PYGZdq{}yes\PYGZdq{} source=\PYGZdq{}ion0\PYGZdq{}\PYGZgt{}
      \PYGZlt{}basisset name=\PYGZdq{}LCAOBSet\PYGZdq{}\PYGZgt{}
        \PYGZlt{}atomicBasisSet name=\PYGZdq{}Gaussian\PYGZhy{}G2\PYGZdq{} angular=\PYGZdq{}cartesian\PYGZdq{} type=\PYGZdq{}Gaussian\PYGZdq{} elementType=\PYGZdq{}H\PYGZdq{} normalized=\PYGZdq{}no\PYGZdq{}\PYGZgt{}
          \PYGZlt{}grid type=\PYGZdq{}log\PYGZdq{} ri=\PYGZdq{}1.e\PYGZhy{}6\PYGZdq{} rf=\PYGZdq{}1.e2\PYGZdq{} npts=\PYGZdq{}1001\PYGZdq{}/\PYGZgt{}
          \PYGZlt{}basisGroup rid=\PYGZdq{}H00\PYGZdq{} n=\PYGZdq{}0\PYGZdq{} l=\PYGZdq{}0\PYGZdq{} type=\PYGZdq{}Gaussian\PYGZdq{}\PYGZgt{}
            \PYGZlt{}radfunc exponent=\PYGZdq{}1.923840000000e+01\PYGZdq{} contraction=\PYGZdq{}3.282799101900e\PYGZhy{}02\PYGZdq{}/\PYGZgt{}
            \PYGZlt{}radfunc exponent=\PYGZdq{}2.898720000000e+00\PYGZdq{} contraction=\PYGZdq{}2.312039367510e\PYGZhy{}01\PYGZdq{}/\PYGZgt{}
            \PYGZlt{}radfunc exponent=\PYGZdq{}6.534720000000e\PYGZhy{}01\PYGZdq{} contraction=\PYGZdq{}8.172257764360e\PYGZhy{}01\PYGZdq{}/\PYGZgt{}
          \PYGZlt{}/basisGroup\PYGZgt{}
          \PYGZlt{}basisGroup rid=\PYGZdq{}H10\PYGZdq{} n=\PYGZdq{}1\PYGZdq{} l=\PYGZdq{}0\PYGZdq{} type=\PYGZdq{}Gaussian\PYGZdq{}\PYGZgt{}
            \PYGZlt{}radfunc exponent=\PYGZdq{}1.630642000000e\PYGZhy{}01\PYGZdq{} contraction=\PYGZdq{}1.000000000000e+00\PYGZdq{}/\PYGZgt{}
          \PYGZlt{}/basisGroup\PYGZgt{}
        \PYGZlt{}/atomicBasisSet\PYGZgt{}
      \PYGZlt{}/basisset\PYGZgt{}

    \PYGZlt{}slaterdeterminant optimize=\PYGZdq{}yes\PYGZdq{}\PYGZgt{}
      \PYGZlt{}determinant id=\PYGZdq{}det\PYGZus{}up\PYGZdq{} sposet=\PYGZdq{}spo\PYGZhy{}up\PYGZdq{}\PYGZgt{}
        \PYGZlt{}opt\PYGZus{}vars size=\PYGZdq{}3\PYGZdq{}\PYGZgt{}
          0.0 0.0 0.0
        \PYGZlt{}/opt\PYGZus{}vars\PYGZgt{}
      \PYGZlt{}/determinant\PYGZgt{}

      \PYGZlt{}determinant id=\PYGZdq{}det\PYGZus{}down\PYGZdq{} sposet=\PYGZdq{}spo\PYGZhy{}dn\PYGZdq{}\PYGZgt{}
        \PYGZlt{}opt\PYGZus{}vars size=\PYGZdq{}3\PYGZdq{}\PYGZgt{}
          0.0 0.0 0.0
        \PYGZlt{}/opt\PYGZus{}vars\PYGZgt{}
      \PYGZlt{}/determinant\PYGZgt{}
    \PYGZlt{}/slaterdeterminant\PYGZgt{}

      \PYGZlt{}sposet basisset=\PYGZdq{}LCAOBSet\PYGZdq{} name=\PYGZdq{}spo\PYGZhy{}up\PYGZdq{} size=\PYGZdq{}4\PYGZdq{} optimize=\PYGZdq{}yes\PYGZdq{}\PYGZgt{}
        \PYGZlt{}occupation mode=\PYGZdq{}ground\PYGZdq{}/\PYGZgt{}
        \PYGZlt{}coefficient size=\PYGZdq{}4\PYGZdq{} id=\PYGZdq{}updetC\PYGZdq{}\PYGZgt{}
  2.83630000000000e\PYGZhy{}01  3.35683000000000e\PYGZhy{}01  2.83630000000000e\PYGZhy{}01  3.35683000000000e\PYGZhy{}01
  1.66206000000000e\PYGZhy{}01  1.22367400000000e+00 \PYGZhy{}1.66206000000000e\PYGZhy{}01 \PYGZhy{}1.22367400000000e+00
  8.68279000000000e\PYGZhy{}01 \PYGZhy{}6.95081000000000e\PYGZhy{}01  8.68279000000000e\PYGZhy{}01 \PYGZhy{}6.95081000000000e\PYGZhy{}01
 \PYGZhy{}9.77898000000000e\PYGZhy{}01  1.19682400000000e+00  9.77898000000000e\PYGZhy{}01 \PYGZhy{}1.19682400000000e+00
\PYGZlt{}/coefficient\PYGZgt{}
      \PYGZlt{}/sposet\PYGZgt{}
      \PYGZlt{}sposet basisset=\PYGZdq{}LCAOBSet\PYGZdq{} name=\PYGZdq{}spo\PYGZhy{}dn\PYGZdq{} size=\PYGZdq{}4\PYGZdq{} optimize=\PYGZdq{}yes\PYGZdq{}\PYGZgt{}
        \PYGZlt{}occupation mode=\PYGZdq{}ground\PYGZdq{}/\PYGZgt{}
        \PYGZlt{}coefficient size=\PYGZdq{}4\PYGZdq{} id=\PYGZdq{}downdetC\PYGZdq{}\PYGZgt{}
  2.83630000000000e\PYGZhy{}01  3.35683000000000e\PYGZhy{}01  2.83630000000000e\PYGZhy{}01  3.35683000000000e\PYGZhy{}01
  1.66206000000000e\PYGZhy{}01  1.22367400000000e+00 \PYGZhy{}1.66206000000000e\PYGZhy{}01 \PYGZhy{}1.22367400000000e+00
  8.68279000000000e\PYGZhy{}01 \PYGZhy{}6.95081000000000e\PYGZhy{}01  8.68279000000000e\PYGZhy{}01 \PYGZhy{}6.95081000000000e\PYGZhy{}01
 \PYGZhy{}9.77898000000000e\PYGZhy{}01  1.19682400000000e+00  9.77898000000000e\PYGZhy{}01 \PYGZhy{}1.19682400000000e+00
\PYGZlt{}/coefficient\PYGZgt{}
      \PYGZlt{}/sposet\PYGZgt{}

    \PYGZlt{}/determinantset\PYGZgt{}
\PYGZlt{}/wfn\PYGZus{}x\PYGZgt{}
\end{sphinxVerbatim}

and similarly for the \sphinxcode{\sphinxupquote{h2.wfn\_d.xml}} file, which will hold the initial
\(\mathbf{\mu}\) parameters.

This use case is a wavefunction file for an optimizable determinant
wavefunction for H\(_2\), in a double zeta valence basis set.
Thus, the FDLR wavefunction here would perform CIS on H\(_2\) in a
double zeta basis set.


\section{Gaussian Product Wavefunction}
\label{\detokenize{intro_wavefunction:gaussian-product-wavefunction}}\label{\detokenize{intro_wavefunction:ionwf}}
The Gaussian Product wavefunction implements \eqref{equation:intro_wavefunction:eq27}
\begin{equation}\label{equation:intro_wavefunction:eq27}
\begin{split}\Psi(\vec{R}) = \prod_{i=1}^N \exp\left[ -\frac{(\vec{R}_i-\vec{R}_i^o)^2}{2\sigma_i^2} \right]\end{split}
\end{equation}
where \(\vec{R}_i\) is the position of the \(i^{\text{th}}\)
quantum particle and \(\vec{R}_i^o\) is its center. \(\sigma_i\)
is the width of the Gaussian orbital around center \(i\).

This variational wavefunction enhances single\sphinxhyphen{}particle density at chosen
spatial locations with adjustable strengths. It is useful whenever such
localization is physically relevant yet not captured by other parts of
the trial wavefunction. For example, in an electron\sphinxhyphen{}ion simulation of a
solid, the ions are localized around their crystal lattice sites. This
single\sphinxhyphen{}particle localization is not captured by the ion\sphinxhyphen{}ion Jastrow.
Therefore, the addition of this localization term will improve the
wavefunction. The simplest use case of this wavefunction is perhaps the
quantum harmonic oscillator (please see the “tests/models/sho” folder
for examples).

\begin{center}Input specification
\end{center}
Gaussian Product Wavefunction (ionwf):
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
Name
&
Text
&
ionwf
&
(Required)
&
Unique name for this wavefunction
\\
\hline
Width
&
Floats
&
1.0 \sphinxhyphen{}1
&
(Required)
&
Widths of Gaussian orbitals
\\
\hline
Source
&
Text
&
ion0
&
(Required)
&
Name of classical particle set
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{width}} There must be one width provided for each quantum particle.
If a negative width is given, then its corresponding Gaussian orbital
is removed. Negative width is useful if one wants to use Gaussian
wavefunction for a subset of the quantum particles.

\item {} 
\sphinxcode{\sphinxupquote{source}} The Gaussian centers must be specified in the form of a
classical particle set. This classical particle set is likely the ion
positions “ion0,” hence the name “ionwf.” However, arbitrary centers
can be defined using a different particle set. Please refer to the
examples in “tests/models/sho.”

\end{itemize}


\subsection{Example Use Case}
\label{\detokenize{intro_wavefunction:id28}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{qmcsystem}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{simulationcell}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bconds}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
          \PYG{n}{n} \PYG{n}{n} \PYG{n}{n}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{simulationcell}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{particleset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mass}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{5.0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{attrib} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{position}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{datatype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{posArray}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{condition}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{l+m+mf}{0.0001} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0001} \PYG{l+m+mf}{0.0002}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{attrib}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{particleset}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{particleset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{attrib} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{position}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{datatype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{posArray}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{condition}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}
      \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{attrib}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{particleset}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{wavefunction} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{psi0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{ionwf} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{iwf}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{width}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.8165}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{wavefunction}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{hamiltonian} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{h0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{generic}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{extpot} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HarmonicExt}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{mass}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{5.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{energy}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{latticedeviation}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{latdev}\PYG{l+s+s2}{\PYGZdq{}}
      \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}    \PYG{n}{tgroup}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}}
      \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{sgroup}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{hamiltonian}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmcsystem}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}




\chapter{Hamiltonian and Observables}
\label{\detokenize{hamiltonianobservable:hamiltonian-and-observables}}\label{\detokenize{hamiltonianobservable:hamiltobs}}\label{\detokenize{hamiltonianobservable::doc}}
QMCPACK is capable of the simultaneous measurement of the Hamiltonian and many other quantum operators.  The Hamiltonian attains a special status among the available operators (also referred to as observables) because it ultimately generates all available information regarding the quantum system.  This is evident from an algorithmic standpoint as well since the Hamiltonian (embodied in the projector) generates the imaginary time dynamics of the walkers in DMC and reptation Monte Carlo (RMC).

This section covers how the Hamiltonian can be specified, component by component, by the user in the XML format native to qmcpack. It also covers the input structure of statistical estimators corresponding to quantum observables such as the density, static structure factor, and forces.


\section{The Hamiltonian}
\label{\detokenize{hamiltonianobservable:the-hamiltonian}}
The many\sphinxhyphen{}body Hamiltonian in Hartree units is given by
\begin{equation}\label{equation:hamiltonianobservable:eq28}
\begin{split}\hat{H} = -\sum_i\frac{1}{2m_i}\nabla_i^2 + \sum_iv^{ext}(r_i) + \sum_{i<j}v^{qq}(r_i,r_j)   + \sum_{i\ell}v^{qc}(r_i,r_\ell)   + \sum_{\ell<m}v^{cc}(r_\ell,r_m)\:.\end{split}
\end{equation}
Here, the sums indexed by \(i/j\) are over quantum particles, while
\(\ell/m\) are reserved for classical particles. Often the quantum
particles are electrons, and the classical particles are ions, though is
not limited in this way. The mass of each quantum particle is denoted
\(m_i\), \(v^{qq}/v^{qc}/v^{cc}\) are pair potentials between
quantum\sphinxhyphen{}quantum/quantum\sphinxhyphen{}classical/classical\sphinxhyphen{}classical particles, and
\(v^{ext}\) denotes a purely external potential.

QMCPACK is designed modularly so that any potential can be supported with
minimal additions to the code base. Potentials currently supported
include Coulomb interactions in open and periodic boundary conditions,
the MPC potential, nonlocal pseudopotentials, helium pair potentials,
and various model potentials such as hard sphere, Gaussian, and modified
Poschl\sphinxhyphen{}Teller.

Reference information and examples for the \sphinxcode{\sphinxupquote{\textless{}hamiltonian/\textgreater{}}} XML
element are provided subsequently. Detailed descriptions of the input
for individual potentials is given in the sections that follow.

\sphinxcode{\sphinxupquote{hamiltonian}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{simulation, qmcsystem}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{pairpot extpot estimator constant}} (deprecated)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{name/id}}\(^o\)
&
text
&
\sphinxstyleemphasis{anything}
&
h0
&
Unique id for this Hamiltonian instance
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^o\)
&
text
&&
generic
&
\sphinxstyleemphasis{No current function}
\\
\hline
\sphinxcode{\sphinxupquote{role}}\(^o\)
&
text
&
primary/extra
&
extra
&
Designate as Hamiltonian or not
\\
\hline
\sphinxcode{\sphinxupquote{source}}\(^o\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
i
&
Identify classical \sphinxcode{\sphinxupquote{particleset}}
\\
\hline
\sphinxcode{\sphinxupquote{target}}\(^o\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
e
&
Identify quantum \sphinxcode{\sphinxupquote{particleset}}
\\
\hline
\sphinxcode{\sphinxupquote{default}}\(^o\)
&
boolean
&
yes/no
&
yes
&
Include kinetic energy term implicitly
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxstylestrong{target:} Must be set to the name of the quantum \sphinxcode{\sphinxupquote{particleset}}.
The default value is typically sufficient. In normal usage, no other
attributes are provided.

\end{itemize}
\sphinxSetupCaptionForVerbatim{All electron Hamiltonian XML element.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-14}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{hamiltonian} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ElecElec}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coulomb}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ElecIon}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coulomb}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{IonIon}\PYG{l+s+s2}{\PYGZdq{}}   \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coulomb}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{hamiltonian}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{Pseudopotential Hamiltonian XML element.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-15}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{hamiltonian} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ElecElec}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coulomb}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PseudoPot}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pseudo}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{wavefunction}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{psi0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{pseudo} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Li}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Li.xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{pseudo} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H.xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{pairpot}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{IonIon}\PYG{l+s+s2}{\PYGZdq{}}    \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coulomb}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{hamiltonian}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\section{Pair potentials}
\label{\detokenize{hamiltonianobservable:pair-potentials}}
Many pair potentials are supported.  Though only the most commonly used pair potentials are covered in detail in this section, all currently available potentials are listed subsequently.  If a potential you desire is not listed, or is not present at all, feel free to contact the developers.

\sphinxcode{\sphinxupquote{pairpot}} factory element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{type}} attribute
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxstylestrong{type options}
&
coulomb
&
Coulomb/Ewald potential
\\
\hline&
pseudo
&
Semilocal pseudopotential
\\
\hline&
mpc
&
Model periodic Coulomb interaction/correction
\\
\hline&
cpp
&
Core polarization potential
\\
\hline&
skpot
&
\sphinxstyleemphasis{Unknown}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

shared attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstyleemphasis{See above}
&
0
&
Select pairpot type
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{Anything}
&
any
&
Unique name for this pairpot
\\
\hline
\sphinxcode{\sphinxupquote{source}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
\sphinxcode{\sphinxupquote{hamiltonian.target}}
&
Identify interacting particles
\\
\hline
\sphinxcode{\sphinxupquote{target}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
\sphinxcode{\sphinxupquote{hamiltonian.target}}
&
Identify interacting particles
\\
\hline
\sphinxcode{\sphinxupquote{units}}\(^o\)
&
text
&&
hartree
&
\sphinxstyleemphasis{No current function}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxstylestrong{type:} Used to select the desired pair potential. Must be selected
from the list of type options.

\item {} 
\sphinxstylestrong{name:} A unique name used to identify this pair potential. Block
averaged output data will appear under this name in \sphinxcode{\sphinxupquote{scalar.dat}}
and/or \sphinxcode{\sphinxupquote{stat.h5}} files.

\item {} 
\sphinxstylestrong{source/target:} These specify the particles involved in a pair
interaction. If an interaction is between classical (e.g., ions) and
quantum (e.g., electrons), \sphinxcode{\sphinxupquote{source}}/\sphinxcode{\sphinxupquote{target}} should be the name
of the classical/quantum \sphinxcode{\sphinxupquote{particleset}}.

\item {} 
Only \sphinxcode{\sphinxupquote{Coulomb, pseudo}}, and \sphinxcode{\sphinxupquote{mpc}} are described in detail in the
following subsections. The older or less\sphinxhyphen{}used types (\sphinxcode{\sphinxupquote{cpp, skpot}})
are not covered.

\item {} 
Available only if \sphinxcode{\sphinxupquote{QMC\_CUDA}} is not defined: \sphinxcode{\sphinxupquote{skpot}}.

\item {} 
Available only if \sphinxcode{\sphinxupquote{OHMMS\_DIM==3}}: \sphinxcode{\sphinxupquote{mpc, vhxc, pseudo}}.

\item {} 
Available only if \sphinxcode{\sphinxupquote{OHMMS\_DIM==3}} and \sphinxcode{\sphinxupquote{QMC\_CUDA}} is not defined:
\sphinxcode{\sphinxupquote{cpp}}.

\end{itemize}


\subsection{Coulomb potentials}
\label{\detokenize{hamiltonianobservable:coulomb-potentials}}
The bare Coulomb potential is used in open boundary conditions:
\begin{equation}\label{equation:hamiltonianobservable:eq29}
\begin{split}V_c^{open} = \sum_{i<j}\frac{q_iq_j}{\left|{r_i-r_j}\right|}\:.\end{split}
\end{equation}
When periodic boundary conditions are selected, Ewald summation is used automatically:
\begin{equation}\label{equation:hamiltonianobservable:eq30}
\begin{split}V_c^{pbc} = \sum_{i<j}\frac{q_iq_j}{\left|{r_i-r_j}\right|} + \frac{1}{2}\sum_{L\ne0}\sum_{i,j}\frac{q_iq_j}{\left|{r_i-r_j+L}\right|}\:.\end{split}
\end{equation}
The sum indexed by \(L\) is over all nonzero simulation cell lattice vectors.  In practice, the Ewald sum is broken into short\sphinxhyphen{} and long\sphinxhyphen{}range parts in a manner optimized for efficiency (see \sphinxcite{simulationcell:natoli1995}) for details.

For information on how to set the boundary conditions, consult {\hyperref[\detokenize{simulationcell:simulationcell}]{\sphinxcrossref{\DUrole{std,std-ref}{Specifying the system to be simulated}}}}.

\sphinxcode{\sphinxupquote{pairpot type=coulomb}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{coulomb}
&&
Must be coulomb
\\
\hline
\sphinxcode{\sphinxupquote{name/id}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
ElecElec
&
Unique name for interaction
\\
\hline
\sphinxcode{\sphinxupquote{source}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
\sphinxcode{\sphinxupquote{hamiltonian.target}}
&
Identify interacting particles
\\
\hline
\sphinxcode{\sphinxupquote{target}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
\sphinxcode{\sphinxupquote{hamiltonian.target}}
&
Identify interacting particles
\\
\hline
\sphinxcode{\sphinxupquote{pbc}}\(^o\)
&
boolean
&
yes/no
&
yes
&
Use Ewald summation
\\
\hline
\sphinxcode{\sphinxupquote{physical}}\(^o\)
&
boolean
&
yes/no
&
yes
&
Hamiltonian(yes)/Observable(no)
\\
\hline
\sphinxcode{\sphinxupquote{forces}}
&
boolean
&
yes/no
&
no
&
\sphinxstyleemphasis{Deprecated}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxstylestrong{type/source/target:} See description for the previous generic
\sphinxcode{\sphinxupquote{pairpot}} factory element.

\item {} 
\sphinxstylestrong{name:} Traditional user\sphinxhyphen{}specified names for electron\sphinxhyphen{}electron,
electron\sphinxhyphen{}ion, and ion\sphinxhyphen{}ion terms are \sphinxcode{\sphinxupquote{ElecElec}}, \sphinxcode{\sphinxupquote{ElecIon}}, and
\sphinxcode{\sphinxupquote{IonIon}}, respectively. Although any choice can be used, the data
analysis tools expect to find columns in \sphinxcode{\sphinxupquote{*.scalar.dat}} with these
names.

\item {} 
\sphinxstylestrong{pbc}: Ewald summation will not be performed if
\sphinxcode{\sphinxupquote{simulationcell.bconds== n n n}}, regardless of the value of
\sphinxcode{\sphinxupquote{pbc}}. Similarly, the \sphinxcode{\sphinxupquote{pbc}} attribute can only be used to turn
off Ewald summation if \sphinxcode{\sphinxupquote{simulationcell.bconds!= n n n}}. The default
value is recommended.

\item {} 
\sphinxstylestrong{physical}: If \sphinxcode{\sphinxupquote{physical==yes}}, this pair potential is included
in the Hamiltonian and will factor into the \sphinxcode{\sphinxupquote{LocalEnergy}} reported
by QMCPACK and also in the DMC branching weight. If \sphinxcode{\sphinxupquote{physical==no}},
then the pair potential is treated as a passive observable but not as
part of the Hamiltonian itself. As such it does not contribute to the
outputted \sphinxcode{\sphinxupquote{LocalEnergy}}. Regardless of the value of \sphinxcode{\sphinxupquote{physical}}
output data will appear in \sphinxcode{\sphinxupquote{scalar.dat}} in a column headed by
\sphinxcode{\sphinxupquote{name}}.

\end{itemize}
\sphinxSetupCaptionForVerbatim{QMCPXML element for Coulomb interaction between electrons.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-16}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ElecElec}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coulomb}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{QMCPXML element for Coulomb interaction between electrons and ions (all\sphinxhyphen{}electron only).}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-17}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ElecIon}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coulomb}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{QMCPXML element for Coulomb interaction between ions.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-18}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{IonIon}\PYG{l+s+s2}{\PYGZdq{}}   \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coulomb}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Pseudopotentials}
\label{\detokenize{hamiltonianobservable:pseudopotentials}}\label{\detokenize{hamiltonianobservable:nlpp}}
QMCPACK supports pseudopotentials in semilocal form, which is local in the
radial coordinate and nonlocal in angular coordinates. When all angular
momentum channels above a certain threshold (\(\ell_{max}\)) are
well approximated by the same potential
(\(V_{\bar{\ell}}\equiv V_{loc}\)), the pseudopotential separates
into a fully local channel and an angularly nonlocal component:
\begin{equation}\label{equation:hamiltonianobservable:eq31}
\begin{split}V^{PP} = \sum_{ij}\Big(V_{\bar{\ell}}(\left|{r_i-\tilde{r}_j}\right|) + \sum_{\ell\ne\bar{\ell}}^{\ell_{max}}\sum_{m=-\ell}^\ell |{Y_{\ell m}}\rangle{\big[V_\ell(\left|{r_i-\tilde{r}_j}\right|) - V_{\bar{\ell}}(\left|{r_i-\tilde{r}_j}\right|) \big]}\langle{Y_{\ell m}}| \Big)\:.\end{split}
\end{equation}
Here the electron/ion index is \(i/j\), and only one type of ion is
shown for simplicity.

Evaluation of the localized pseudopotential energy
\(\Psi_T^{-1}V^{PP}\Psi_T\) requires additional angular integrals.
These integrals are evaluated on a randomly shifted angular grid. The
size of this grid is determined by \(\ell_{max}\). See
\sphinxcite{hamiltonianobservable:mitas1991} for further detail.

uses the FSAtom pseudopotential file format associated with the “Free
Software Project for Atomic\sphinxhyphen{}scale Simulations” initiated in 2002. See
\sphinxurl{http://www.tddft.org/fsatom/manifest.php} for more information. The
FSAtom format uses XML for structured data. Files in this format do not
use a specific identifying file extension; instead they are simply
suffixed with “\sphinxcode{\sphinxupquote{.xml}}.” The tabular data format of CASINO is also
supported.

\sphinxcode{\sphinxupquote{pairpot type=pseudo}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{pseudo}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{pseudo}
&&
Must be pseudo
\\
\hline
\sphinxcode{\sphinxupquote{name/id}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
PseudoPot
&
\sphinxstyleemphasis{No current function}
\\
\hline
\sphinxcode{\sphinxupquote{source}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
i
&
Ion \sphinxcode{\sphinxupquote{particleset}} name
\\
\hline
\sphinxcode{\sphinxupquote{target}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
\sphinxcode{\sphinxupquote{hamiltonian.target}}
&
Electron \sphinxcode{\sphinxupquote{particleset}} name
\\
\hline
\sphinxcode{\sphinxupquote{pbc}}\(^o\)
&
boolean
&
yes/no
&
yes*
&
Use Ewald summation
\\
\hline
\sphinxcode{\sphinxupquote{forces}}
&
boolean
&
yes/no
&
no
&
\sphinxstyleemphasis{Deprecated}
\\
\hline
\sphinxcode{\sphinxupquote{wavefunction}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{wavefunction.name}}
&
invalid
&
Identify wavefunction
\\
\hline
\sphinxcode{\sphinxupquote{format}}\(^r\)
&
text
&
xml/table
&
table
&
Select file format
\\
\hline
\sphinxcode{\sphinxupquote{algorithm}}\(^o\)
&
text
&
batched/default
&
default
&
Choose NLPP algorithm
\\
\hline
\sphinxcode{\sphinxupquote{DLA}}\(^o\)
&
text
&
yes/no
&
no
&
Use determinant localization approximation
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxstylestrong{type/source/target} See description for the generic \sphinxcode{\sphinxupquote{pairpot}}
factory element.

\item {} 
\sphinxstylestrong{name:} Ignored. Instead, default names will be present in
\sphinxcode{\sphinxupquote{*scalar.dat}} output files when pseudopotentials are used. The
field \sphinxcode{\sphinxupquote{LocalECP}} refers to the local part of the pseudopotential.
If nonlocal channels are present, a \sphinxcode{\sphinxupquote{NonLocalECP}} field will be
added that contains the nonlocal energy summed over all angular
momentum channels.

\item {} 
\sphinxstylestrong{pbc:} Ewald summation will not be performed if
\sphinxcode{\sphinxupquote{simulationcell.bconds== n n n}}, regardless of the value of
\sphinxcode{\sphinxupquote{pbc}}. Similarly, the \sphinxcode{\sphinxupquote{pbc}} attribute can only be used to turn
off Ewald summation if \sphinxcode{\sphinxupquote{simulationcell.bconds!= n n n}}.

\item {} 
\sphinxstylestrong{format:} If \sphinxcode{\sphinxupquote{format}}==table, QMCPACK looks for \sphinxcode{\sphinxupquote{*.psf}} files
containing pseudopotential data in a tabular format. The files must
be named after the ionic species provided in \sphinxcode{\sphinxupquote{particleset}} (e.g.,
\sphinxcode{\sphinxupquote{Li.psf}} and \sphinxcode{\sphinxupquote{H.psf}}). If \sphinxcode{\sphinxupquote{format}}==xml, additional
\sphinxcode{\sphinxupquote{pseudo}} child XML elements must be provided (see the following).
These elements specify individual file names and formats (both the
FSAtom XML and CASINO tabular data formats are supported).

\item {} 
\sphinxstylestrong{algorithm} The default algorithm evaluates the ratios of
wavefunction components together for each quadrature point and then
one point after another. The batched algorithm evaluates the ratios
of quadrature points together for each wavefunction component and
then one component after another. Internally, it uses
\sphinxcode{\sphinxupquote{VirtualParticleSet}} for quadrature points. Hybrid orbital
representation has an extra optimization enabled when using the
batched algorithm.

\item {} 
\sphinxstylestrong{DLA} Determinant localization approximation
(DLA) \sphinxcite{hamiltonianobservable:zen2019dla} uses only the fermionic part of
the wavefunction when calculating NLPP.

\end{itemize}
\sphinxSetupCaptionForVerbatim{QMCPXML element for pseudopotential electron\sphinxhyphen{}ion interaction (psf files).}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-19}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PseudoPot}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pseudo}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{wavefunction}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{psi0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{psf}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{QMCPXML element for pseudopotential electron\sphinxhyphen{}ion interaction (xml files).}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-20}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PseudoPot}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pseudo}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{wavefunction}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{psi0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{pseudo} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Li}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Li.xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{pseudo} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H.xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{pairpot}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Details of \sphinxcode{\sphinxupquote{\textless{}pseudo/\textgreater{}}} input elements are shown in the following. It
is possible to include (or construct) a full pseudopotential directly in
the input file without providing an external file via \sphinxcode{\sphinxupquote{href}}. The full
XML format for pseudopotentials is not yet covered.

\sphinxcode{\sphinxupquote{pseudo}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{pairpot type=pseudo}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{header local grid}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{elementType/symbol}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{groupe.name}}
&
none
&
Identify ionic species
\\
\hline
\sphinxcode{\sphinxupquote{href}}\(^r\)
&
text
&
\sphinxstyleemphasis{filepath}
&
none
&
Pseudopotential file path
\\
\hline
\sphinxcode{\sphinxupquote{format}}\(^r\)
&
text
&
xml/casino
&
xml
&
Specify file format
\\
\hline
\sphinxcode{\sphinxupquote{cutoff}}\(^o\)
&
real
&&&
Nonlocal cutoff radius
\\
\hline
\sphinxcode{\sphinxupquote{lmax}}\(^o\)
&
integer
&&&
Largest angular momentum
\\
\hline
\sphinxcode{\sphinxupquote{nrule}}\(^o\)
&
integer
&&&
Integration grid order
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}
\sphinxSetupCaptionForVerbatim{QMCPXML element for pseudopotential of single ionic species.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-21}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{o}{\PYGZlt{}}\PYG{n}{pseudo} \PYG{n}{elementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Li}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Li.xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{MPC Interaction/correction}
\label{\detokenize{hamiltonianobservable:mpc-interaction-correction}}
The MPC interaction is an alternative to direct Ewald summation. The MPC
corrects the exchange correlation hole to more closely match its
thermodynamic limit. Because of this, the MPC exhibits smaller
finite\sphinxhyphen{}size errors than the bare Ewald interaction, though a few
alternative and competitive finite\sphinxhyphen{}size correction schemes now exist.
The MPC is itself often used just as a finite\sphinxhyphen{}size correction in
post\sphinxhyphen{}processing (set \sphinxcode{\sphinxupquote{physical=false}} in the input).

\sphinxcode{\sphinxupquote{pairpot type=mpc}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{mpc}
&&
Must be MPC
\\
\hline
\sphinxcode{\sphinxupquote{name/id}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
MPC
&
Unique name for interaction
\\
\hline
\sphinxcode{\sphinxupquote{source}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
\sphinxcode{\sphinxupquote{hamiltonian.target}}
&
Identify interacting particles
\\
\hline
\sphinxcode{\sphinxupquote{target}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
\sphinxcode{\sphinxupquote{hamiltonian.target}}
&
Identify interacting particles
\\
\hline
\sphinxcode{\sphinxupquote{physical}}\(^o\)
&
boolean
&
yes/no
&
no
&
Hamiltonian(yes)/observable(no)
\\
\hline
\sphinxcode{\sphinxupquote{cutoff}}
&
real
&
\(>0\)
&
30.0
&
Kinetic energy cutoff
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Remarks:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{physical}}: Typically set to \sphinxcode{\sphinxupquote{no}}, meaning the standard Ewald
interaction will be used during sampling and MPC will be measured as
an observable for finite\sphinxhyphen{}size post\sphinxhyphen{}correction. If \sphinxcode{\sphinxupquote{physical}} is
\sphinxcode{\sphinxupquote{yes}}, the MPC interaction will be used during sampling. In this
case an electron\sphinxhyphen{}electron Coulomb \sphinxcode{\sphinxupquote{pairpot}} element should not be
supplied.

\item {} 
\sphinxstylestrong{Developer note:} Currently the \sphinxcode{\sphinxupquote{name}} attribute for the MPC
interaction is ignored. The name is always reset to \sphinxcode{\sphinxupquote{MPC}}.

\end{itemize}
\sphinxSetupCaptionForVerbatim{MPC for finite\sphinxhyphen{}size postcorrection.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-22}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{o}{\PYGZlt{}}\PYG{n}{pairpot} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MPC}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MPC}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{ecut}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{60.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{physical}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\section{General estimators}
\label{\detokenize{hamiltonianobservable:general-estimators}}
A broad range of estimators for physical observables are available in QMCPACK.
The following sections contain input details for the total number
density (\sphinxcode{\sphinxupquote{density}}), number density resolved by particle spin
(\sphinxcode{\sphinxupquote{spindensity}}), spherically averaged pair correlation function
(\sphinxcode{\sphinxupquote{gofr}}), static structure factor (\sphinxcode{\sphinxupquote{sk}}), static structure factor
(\sphinxcode{\sphinxupquote{skall}}), energy density (\sphinxcode{\sphinxupquote{energydensity}}), one body reduced
density matrix (\sphinxcode{\sphinxupquote{dm1b}}), \(S(k)\) based kinetic energy correction
(\sphinxcode{\sphinxupquote{chiesa}}), forward walking (\sphinxcode{\sphinxupquote{ForwardWalking}}), and force
(\sphinxcode{\sphinxupquote{Force}}) estimators. Other estimators are not yet covered.

When an \sphinxcode{\sphinxupquote{\textless{}estimator/\textgreater{}}} element appears in \sphinxcode{\sphinxupquote{\textless{}hamiltonian/\textgreater{}}}, it is
evaluated for all applicable chained QMC runs (e.g.,
VMC\(\rightarrow\)DMC\(\rightarrow\)DMC). Estimators are
generally not accumulated during wavefunction optimization sections. If
an \sphinxcode{\sphinxupquote{\textless{}estimator/\textgreater{}}} element is instead provided in a particular
\sphinxcode{\sphinxupquote{\textless{}qmc/\textgreater{}}} element, that estimator is only evaluated for that specific
section (e.g., during VMC only).

\sphinxcode{\sphinxupquote{estimator}} factory element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
type selector:
&
\sphinxcode{\sphinxupquote{type}} attribute
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxstylestrong{type options}
&
density
&
Density on a grid
\\
\hline&
spindensity
&
Spin density on a grid
\\
\hline&
gofr
&
Pair correlation function (quantum species)
\\
\hline&
sk
&
Static structure factor
\\
\hline&
SkAll
&
Static structure factor needed for finite size correction
\\
\hline&
structurefactor
&
Species resolved structure factor
\\
\hline&
species kinetic
&
Species resolved kinetic energy
\\
\hline&
latticedeviation
&
Spatial deviation between two particlesets
\\
\hline&
momentum
&
Momentum distribution
\\
\hline&
energydensity
&
Energy density on uniform or Voronoi grid
\\
\hline&
dm1b
&
One body density matrix in arbitrary basis
\\
\hline&
chiesa
&
Chiesa\sphinxhyphen{}Ceperley\sphinxhyphen{}Martin\sphinxhyphen{}Holzmann kinetic energy correction
\\
\hline&
Force
&
Family of “force” estimators (see {\hyperref[\detokenize{hamiltonianobservable:force-est}]{\sphinxcrossref{\DUrole{std,std-ref}{“Force” estimators}}}})
\\
\hline&
ForwardWalking
&
Forward walking values for existing estimators
\\
\hline&
orbitalimages
&
Create image files for orbitals, then exit
\\
\hline&
flux
&
Checks sampling of kinetic energy
\\
\hline&
localmoment
&
Atomic spin polarization within cutoff radius
\\
\hline&
Pressure
&
\sphinxstyleemphasis{No current function}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

shared attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstyleemphasis{See above}
&
0
&
Select estimator type
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
any
&
Unique name for this estimator
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\subsection{Chiesa\sphinxhyphen{}Ceperley\sphinxhyphen{}Martin\sphinxhyphen{}Holzmann kinetic energy correction}
\label{\detokenize{hamiltonianobservable:chiesa-ceperley-martin-holzmann-kinetic-energy-correction}}
This estimator calculates a finite\sphinxhyphen{}size correction to the kinetic energy following the formalism laid out in \sphinxcite{hamiltonianobservable:chiesa2006}.  The total energy can be corrected for finite\sphinxhyphen{}size effects by using this estimator in conjunction with the MPC correction.

\sphinxcode{\sphinxupquote{estimator type=chiesa}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{chiesa}
&&
Must be chiesa
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^o\)
&
text
&
\sphinxstyleemphasis{anything}
&
KEcorr
&
Always reset to KEcorr
\\
\hline
\sphinxcode{\sphinxupquote{source}}\(^o\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
e
&
Identify quantum particles
\\
\hline
\sphinxcode{\sphinxupquote{psi}}\(^o\)
&
text
&
\sphinxcode{\sphinxupquote{wavefunction.name}}
&
psi0
&
Identify wavefunction
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}
\sphinxSetupCaptionForVerbatim{“Chiesa” kinetic energy finite\sphinxhyphen{}size postcorrection.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-23}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
   \PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{KEcorr}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{chiesa}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{psi}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{psi0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Density estimator}
\label{\detokenize{hamiltonianobservable:density-estimator}}
The particle number density operator is given by
\begin{equation}\label{equation:hamiltonianobservable:eq32}
\begin{split}\hat{n}_r = \sum_i\delta(r-r_i)\:.\end{split}
\end{equation}
The \sphinxcode{\sphinxupquote{density}} estimator accumulates the number density on a uniform
histogram grid over the simulation cell. The value obtained for a grid
cell \(c\) with volume \(\Omega_c\) is then the average number
of particles in that cell:
\begin{equation}\label{equation:hamiltonianobservable:eq33}
\begin{split}n_c = \int dR \left|{\Psi}\right|^2 \int_{\Omega_c}dr \sum_i\delta(r-r_i)\:.\end{split}
\end{equation}
\sphinxcode{\sphinxupquote{estimator type=density}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{density}
&&
Must be density
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
any
&
Unique name for estimator
\\
\hline
\sphinxcode{\sphinxupquote{delta}}\(^o\)
&
real array(3)
&
\(0\le v_i \le 1\)
&
0.1 0.1 0.1
&
Grid cell spacing, unit coords
\\
\hline
\sphinxcode{\sphinxupquote{x\_min}}\(^o\)
&
real
&
\(>0\)
&
0
&
Grid starting point in x (Bohr)
\\
\hline
\sphinxcode{\sphinxupquote{x\_max}}\(^o\)
&
real
&
\(>0\)
&
\(|\) \sphinxcode{\sphinxupquote{lattice{[}0{]}}} \(|\)
&
Grid ending point in x (Bohr)
\\
\hline
\sphinxcode{\sphinxupquote{y\_min}}\(^o\)
&
real
&
\(>0\)
&
0
&
Grid starting point in y (Bohr)
\\
\hline
\sphinxcode{\sphinxupquote{y\_max}}\(^o\)
&
real
&
\(>0\)
&
\(|\) \sphinxcode{\sphinxupquote{lattice{[}1{]}}} \(|\)
&
Grid ending point in y (Bohr)
\\
\hline
\sphinxcode{\sphinxupquote{z\_min}}\(^o\)
&
real
&
\(>0\)
&
0
&
Grid starting point in z (Bohr)
\\
\hline
\sphinxcode{\sphinxupquote{z\_max}}\(^o\)
&
real
&
\(>0\)
&
\(|\) \sphinxcode{\sphinxupquote{lattice{[}2{]}}} \(|\)
&
Grid ending point in z (Bohr)
\\
\hline
\sphinxcode{\sphinxupquote{potential}}\(^o\)
&
boolean
&
yes/no
&
no
&
Accumulate local potential, \sphinxstyleemphasis{deprecated}
\\
\hline
\sphinxcode{\sphinxupquote{debug}}\(^o\)
&
boolean
&
yes/no
&
no
&
\sphinxstyleemphasis{No current function}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name}}: The name provided will be used as a label in the
\sphinxcode{\sphinxupquote{stat.h5}} file for the blocked output data. Postprocessing tools
expect \sphinxcode{\sphinxupquote{name="Density."}}

\item {} 
\sphinxcode{\sphinxupquote{delta}}: This sets the histogram grid size used to accumulate the
density:
\sphinxcode{\sphinxupquote{delta="0.1 0.1 0.05"}}\(\rightarrow 10\times 10\times 20\)
grid,
\sphinxcode{\sphinxupquote{delta="0.01 0.01 0.01"}}\(\rightarrow 100\times 100\times 100\)
grid. The density grid is written to a \sphinxcode{\sphinxupquote{stat.h5}} file at the end of
each MC block. If you request many \(blocks\) in a \sphinxcode{\sphinxupquote{\textless{}qmc/\textgreater{}}}
element, or select a large grid, the resulting \sphinxcode{\sphinxupquote{stat.h5}} file could
be many gigabytes in size.

\item {} 
\sphinxcode{\sphinxupquote{*\_min/*\_max}}: Can be used to select a subset of the simulation
cell for the density histogram grid. For example if a (cubic)
simulation cell is 20 Bohr on a side, setting \sphinxcode{\sphinxupquote{*\_min=5.0}} and
\sphinxcode{\sphinxupquote{*\_max=15.0}} will result in a density histogram grid spanning a
\(10\times 10\times 10\) Bohr cube about the center of the box.
Use of \sphinxcode{\sphinxupquote{x\_min, x\_max, y\_min, y\_max, z\_min, z\_max}} is only
appropriate for orthorhombic simulation cells with open boundary
conditions.

\item {} 
When open boundary conditions are used, a \sphinxcode{\sphinxupquote{\textless{}simulationcell/\textgreater{}}}
element must be explicitly provided as the first subelement of
\sphinxcode{\sphinxupquote{\textless{}qmcsystem/\textgreater{}}} for the density estimator to work. In this case the
molecule should be centered around the middle of the simulation cell
(\(L/2\)) and not the origin (\(0\) since the space within
the cell, and hence the density grid, is defined from \(0\) to
\(L\)).

\end{itemize}
\sphinxSetupCaptionForVerbatim{QMCPXML,caption=Density estimator (uniform grid).}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-24}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
   \PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Density}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{density}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{delta}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.05 0.05 0.05}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Spin density estimator}
\label{\detokenize{hamiltonianobservable:spin-density-estimator}}
The spin density is similar to the total density described previously.  In this case, the sum over particles is performed independently for each spin component.

\sphinxcode{\sphinxupquote{estimator type=spindensity}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{spindensity}
&&
Must be spindensity
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
any
&
Unique name for estimator
\\
\hline
\sphinxcode{\sphinxupquote{report}}\(^o\)
&
boolean
&
yes/no
&
no
&
Write setup details to stdout
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

parameters:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{grid}}\(^o\)
&
integer array(3)
&
\(v_i>\)
&&
Grid cell count
\\
\hline
\sphinxcode{\sphinxupquote{dr}}\(^o\)
&
real array(3)
&
\(v_i>\)
&&
Grid cell spacing (Bohr)
\\
\hline
\sphinxcode{\sphinxupquote{cell}}\(^o\)
&
real array(3,3)
&
\sphinxstyleemphasis{anything}
&&
Volume grid exists in
\\
\hline
\sphinxcode{\sphinxupquote{corner}}\(^o\)
&
real array(3)
&
\sphinxstyleemphasis{anything}
&&
Volume corner location
\\
\hline
\sphinxcode{\sphinxupquote{center}}\(^o\)
&
real array (3)
&
\sphinxstyleemphasis{anything}
&&
Volume center/origin location
\\
\hline
\sphinxcode{\sphinxupquote{voronoi}}\(^o\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&&
\sphinxstyleemphasis{Under development}
\\
\hline
\sphinxcode{\sphinxupquote{test\_moves}}\(^o\)
&
integer
&
\(>=0\)
&
0
&
Test estimator with random moves
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name}}: The name provided will be used as a label in the
\sphinxcode{\sphinxupquote{stat.h5}} file for the blocked output data. Postprocessing tools
expect \sphinxcode{\sphinxupquote{name="SpinDensity."}}

\item {} 
\sphinxcode{\sphinxupquote{grid}}: The grid sets the dimension of the histogram grid. Input
like \sphinxcode{\sphinxupquote{\textless{}parameter name="grid"\textgreater{} 40 40 40 \textless{}/parameter\textgreater{}}} requests a
\(40 \times 40\times 40\) grid. The shape of individual grid
cells is commensurate with the supercell shape.

\item {} 
\sphinxcode{\sphinxupquote{dr}}: The \sphinxcode{\sphinxupquote{dr}} sets the real\sphinxhyphen{}space dimensions of grid cell edges
(Bohr units). Input like
\sphinxcode{\sphinxupquote{\textless{}parameter name="dr"\textgreater{} 0.5 0.5 0.5 \textless{}/parameter\textgreater{}}} in a supercell
with axes of length 10 Bohr each (but of arbitrary shape) will
produce a \(20\times 20\times 20\) grid. The inputted \sphinxcode{\sphinxupquote{dr}}
values are rounded to produce an integer number of grid cells along
each supercell axis. Either \sphinxcode{\sphinxupquote{grid}} or \sphinxcode{\sphinxupquote{dr}} must be provided, but
not both.

\item {} 
\sphinxcode{\sphinxupquote{cell}}: When \sphinxcode{\sphinxupquote{cell}} is provided, a user\sphinxhyphen{}defined grid volume is
used instead of the global supercell. This must be provided if open
boundary conditions are used. Additionally, if \sphinxcode{\sphinxupquote{cell}} is provided,
the user must specify where the volume is located in space in
addition to its size/shape (\sphinxcode{\sphinxupquote{cell}}) using either the \sphinxcode{\sphinxupquote{corner}} or
\sphinxcode{\sphinxupquote{center}} parameters.

\item {} 
\sphinxcode{\sphinxupquote{corner}}: The grid volume is defined as
\(corner+\sum_{d=1}^3u_dcell_d\) with \(0<u_d<1\) (“cell”
refers to either the supercell or user\sphinxhyphen{}provided cell).

\item {} 
\sphinxcode{\sphinxupquote{center}}: The grid volume is defined as
\(center+\sum_{d=1}^3u_dcell_d\) with \(-1/2<u_d<1/2\)
(“cell” refers to either the supercell or user\sphinxhyphen{}provided cell).
\sphinxcode{\sphinxupquote{corner/center}} can be used to shift the grid even if \sphinxcode{\sphinxupquote{cell}} is
not specified. Simultaneous use of \sphinxcode{\sphinxupquote{corner}} and \sphinxcode{\sphinxupquote{center}} will
cause QMCPACK to abort.

\end{itemize}
\sphinxSetupCaptionForVerbatim{Spin density estimator (uniform grid).}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-25}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spindensity}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SpinDensity}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{report}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{grid}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{40} \PYG{l+m+mi}{40} \PYG{l+m+mi}{40} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{estimator}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{Spin density estimator (uniform grid centered about origin).}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-26}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spindensity}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SpinDensity}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{report}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{grid}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{l+m+mi}{20} \PYG{l+m+mi}{20} \PYG{l+m+mi}{20}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{center}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cell}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{l+m+mf}{10.0}  \PYG{l+m+mf}{0.0}  \PYG{l+m+mf}{0.0}
     \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{10.0}  \PYG{l+m+mf}{0.0}
     \PYG{l+m+mf}{0.0}  \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{10.0}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{estimator}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Pair correlation function, \protect\(g(r)\protect\)}
\label{\detokenize{hamiltonianobservable:pair-correlation-function-g-r}}
The functional form of the species\sphinxhyphen{}resolved radial pair correlation function operator is
\begin{equation}\label{equation:hamiltonianobservable:eq34}
\begin{split}g_{ss'}(r) = \frac{V}{4\pi r^2N_sN_{s'}}\sum_{i_s=1}^{N_s}\sum_{j_{s'}=1}^{N_{s'}}\delta(r-|r_{i_s}-r_{j_{s'}}|)\:,\end{split}
\end{equation}
where \(N_s\) is the number of particles of species \(s\) and
\(V\) is the supercell volume. If \(s=s'\), then the sum is
restricted so that \(i_s\ne j_s\).

In QMCPACK, an estimate of \(g_{ss'}(r)\) is obtained as a radial
histogram with a set of \(N_b\) uniform bins of width
\(\delta r\). This can be expressed analytically as
\begin{equation}\label{equation:hamiltonianobservable:eq35}
\begin{split}\tilde{g}_{ss'}(r) = \frac{V}{4\pi r^2N_sN_{s'}}\sum_{i=1}^{N_s}\sum_{j=1}^{N_{s'}}\frac{1}{\delta r}\int_{r-\delta r/2}^{r+\delta r/2}dr'\delta(r'-|r_{si}-r_{s'j}|)\:,\end{split}
\end{equation}
where the radial coordinate \(r\) is restricted to reside at the bin
centers, \(\delta r/2, 3 \delta r/2, 5 \delta r/2, \ldots\).

\sphinxcode{\sphinxupquote{estimator type=gofr}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{gofr}
&&
Must be gofr
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^o\)
&
text
&
\sphinxstyleemphasis{anything}
&
any
&
\sphinxstyleemphasis{No current function}
\\
\hline
\sphinxcode{\sphinxupquote{num\_bin}}\(^r\)
&
integer
&
\(>1\)
&
20
&
\# of histogram bins
\\
\hline
\sphinxcode{\sphinxupquote{rmax}}\(^o\)
&
real
&
\(>0\)
&
10
&
Histogram extent (Bohr)
\\
\hline
\sphinxcode{\sphinxupquote{dr}}\(^o\)
&
real
&
\(0\)
&
0.5
&
\sphinxstyleemphasis{No current function}
\\
\hline
\sphinxcode{\sphinxupquote{debug}}\(^o\)
&
boolean
&
yes/no
&
no
&
\sphinxstyleemphasis{No current function}
\\
\hline
\sphinxcode{\sphinxupquote{target}}\(^o\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
\sphinxcode{\sphinxupquote{hamiltonian.target}}
&
Quantum particles
\\
\hline
\sphinxcode{\sphinxupquote{source/sources}}\(^o\)
&
text array
&
\sphinxcode{\sphinxupquote{particleset.name}}
&
\sphinxcode{\sphinxupquote{hamiltonian.target}}
&
Classical particles
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{num\_bin:}} This is the number of bins in each species pair radial
histogram.

\item {} 
\sphinxcode{\sphinxupquote{rmax:}} This is the maximum pair distance included in the
histogram. The uniform bin width is
\(\delta r=\texttt{rmax/num\_bin}\). If periodic boundary
conditions are used for any dimension of the simulation cell, then
the default value of \sphinxcode{\sphinxupquote{rmax}} is the simulation cell radius instead
of 10 Bohr. For open boundary conditions, the volume (\(V\)) used
is 1.0 Bohr\(^3\).

\item {} 
\sphinxcode{\sphinxupquote{source/sources:}} If unspecified, only pair correlations between
each species of quantum particle will be measured. For each classical
particleset specified by \sphinxcode{\sphinxupquote{source/sources}}, additional pair
correlations between each quantum and classical species will be
measured. Typically there is only one classical particleset (e.g.,
\sphinxcode{\sphinxupquote{source="ion0"}}), but there can be several in principle (e.g.,
\sphinxcode{\sphinxupquote{sources="ion0 ion1 ion2"}}).

\item {} 
\sphinxcode{\sphinxupquote{target:}} The default value is the preferred usage (i.e.,
\sphinxcode{\sphinxupquote{target}} does not need to be provided).

\item {} 
Data is output to the \sphinxcode{\sphinxupquote{stat.h5}} for each QMC subrun. Individual
histograms are named according to the quantum particleset and index
of the pair. For example, if the quantum particleset is named “e” and
there are two species (up and down electrons, say), then there will
be three sets of histogram data in each \sphinxcode{\sphinxupquote{stat.h5}} file named
\sphinxcode{\sphinxupquote{gofr\_e\_0\_0}}, \sphinxcode{\sphinxupquote{gofr\_e\_0\_1}}, and \sphinxcode{\sphinxupquote{gofr\_e\_1\_1}} for up\sphinxhyphen{}up,
up\sphinxhyphen{}down, and down\sphinxhyphen{}down correlations, respectively.

\end{itemize}
\sphinxSetupCaptionForVerbatim{Pair correlation function estimator element.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-27}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{gofr}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{gofr}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{num\PYGZus{}bin}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{200}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rmax}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{Pair correlation function estimator element with additional electron\sphinxhyphen{}ion correlations.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-28}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{gofr}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{gofr}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{num\PYGZus{}bin}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{200}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{rmax}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Static structure factor, \protect\(S(k)\protect\)}
\label{\detokenize{hamiltonianobservable:static-structure-factor-s-k}}
Let
\(\rho^e_{\mathbf{k}}=\sum_j e^{i \mathbf{k}\cdot\mathbf{r}_j^e}\)
be the Fourier space electron density, with \(\mathbf{r}^e_j\) being
the coordinate of the j\sphinxhyphen{}th electron. \(\mathbf{k}\) is a wavevector
commensurate with the simulation cell. QMCPACK allows the user to
accumulate the static electron structure factor \(S(\mathbf{k})\) at
all commensurate \(\mathbf{k}\) such that
\(|\mathbf{k}| \leq (LR\_DIM\_CUTOFF) r_c\). \(N^e\) is the
number of electrons, \sphinxcode{\sphinxupquote{LR\_DIM\_CUTOFF}} is the optimized breakup
parameter, and \(r_c\) is the Wigner\sphinxhyphen{}Seitz radius. It is defined as
follows:
\begin{equation}\label{equation:hamiltonianobservable:eq36}
\begin{split}S(\mathbf{k}) = \frac{1}{N^e}\langle \rho^e_{-\mathbf{k}} \rho^e_{\mathbf{k}} \rangle\:.\end{split}
\end{equation}
\sphinxcode{\sphinxupquote{estimator type=sk}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
sk
&&
Must sk
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
any
&
Unique name for estimator
\\
\hline
\sphinxcode{\sphinxupquote{hdf5}}\(^o\)
&
boolean
&
yes/no
&
no
&
Output to \sphinxcode{\sphinxupquote{stat.h5}} (yes) or \sphinxcode{\sphinxupquote{scalar.dat}} (no)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name:}} This is the unique name for estimator instance. A data
structure of the same name will appear in \sphinxcode{\sphinxupquote{stat.h5}} output files.

\item {} 
\sphinxcode{\sphinxupquote{hdf5:}} If \sphinxcode{\sphinxupquote{hdf5==yes}}, output data for \(S(k)\) is directed
to the \sphinxcode{\sphinxupquote{stat.h5}} file (recommended usage). If \sphinxcode{\sphinxupquote{hdf5==no}}, the
data is instead routed to the \sphinxcode{\sphinxupquote{scalar.dat}} file, resulting in many
columns of data with headings prefixed by \sphinxcode{\sphinxupquote{name}} and postfixed by
the k\sphinxhyphen{}point index (e.g., \sphinxcode{\sphinxupquote{sk\_0 sk\_1 …sk\_1037 …}}).

\item {} 
This estimator only works in periodic boundary conditions. Its
presence in the input file is ignored otherwise.

\item {} 
This is not a species\sphinxhyphen{}resolved structure factor. Additionally, for
\(\mathbf{k}\) vectors commensurate with the unit cell,
\(S(\mathbf{k})\) will include contributions from the static
electronic density, thus meaning it will not accurately measure the
electron\sphinxhyphen{}electron density response.

\end{itemize}
\sphinxSetupCaptionForVerbatim{Static structure factor estimator element.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-29}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sk}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sk}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{hdf5}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Static structure factor, \sphinxstyleliteralintitle{\sphinxupquote{SkAll}}}
\label{\detokenize{hamiltonianobservable:static-structure-factor-skall}}
In order to compute the finite size correction to the potential energy,
records of \(\rho(\mathbf{k})\) is required. What sets \sphinxcode{\sphinxupquote{SkAll}}
apart from \sphinxcode{\sphinxupquote{sk}} is that \sphinxcode{\sphinxupquote{SkAll}} records \(\rho(\mathbf{k})\) in
addition to \(s(\mathbf{k})\).

\sphinxcode{\sphinxupquote{estimator type=SkAll}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
sk
&&
Must be sk
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
any
&
Unique name for estimator
\\
\hline
\sphinxcode{\sphinxupquote{source}}\(^r\)
&
text
&
Ion ParticleSet name
&
None
&
\sphinxtitleref{\sphinxhyphen{}}
\\
\hline
\sphinxcode{\sphinxupquote{target}}\(^r\)
&
text
&
Electron ParticleSet name
&
None
&
\sphinxtitleref{\sphinxhyphen{}}
\\
\hline
\sphinxcode{\sphinxupquote{hdf5}}\(^o\)
&
boolean
&
yes/no
&
no
&
Output to \sphinxcode{\sphinxupquote{stat.h5}} (yes) or \sphinxcode{\sphinxupquote{scalar.dat}} (no)
\\
\hline
\sphinxcode{\sphinxupquote{writeionion}}\(^o\)
&
boolean
&
yes/no
&
no
&
Writes file rhok\_IonIon.dat containing \(s(\mathbf{k})\) for the ions
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name:}} This is the unique name for estimator instance. A data
structure of the same name will appear in \sphinxcode{\sphinxupquote{stat.h5}} output files.

\item {} 
\sphinxcode{\sphinxupquote{hdf5:}} If \sphinxcode{\sphinxupquote{hdf5==yes}}, output data is directed to the
\sphinxcode{\sphinxupquote{stat.h5}} file (recommended usage). If \sphinxcode{\sphinxupquote{hdf5==no}}, the data is
instead routed to the \sphinxcode{\sphinxupquote{scalar.dat}} file, resulting in many columns
of data with headings prefixed by \sphinxcode{\sphinxupquote{rhok}} and postfixed by the
k\sphinxhyphen{}point index.

\item {} 
This estimator only works in periodic boundary conditions. Its
presence in the input file is ignored otherwise.

\item {} 
This is not a species\sphinxhyphen{}resolved structure factor. Additionally, for
\(\mathbf{k}\) vectors commensurate with the unit cell,
\(S(\mathbf{k})\) will include contributions from the static
electronic density, thus meaning it wil not accurately measure the
electron\sphinxhyphen{}electron density response.

\end{itemize}
\sphinxSetupCaptionForVerbatim{SkAll estimator element.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-30}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{skall}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SkAll}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{hdf5}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Species kinetic energy}
\label{\detokenize{hamiltonianobservable:species-kinetic-energy}}
Record species\sphinxhyphen{}resolved kinetic energy instead of the total kinetic
energy in the \sphinxcode{\sphinxupquote{Kinetic}} column of scalar.dat. \sphinxcode{\sphinxupquote{SpeciesKineticEnergy}}
is arguably the simplest estimator in QMCPACK. The implementation of
this estimator is detailed in
\sphinxcode{\sphinxupquote{manual/estimator/estimator\_implementation.pdf}}.

\sphinxcode{\sphinxupquote{estimator type=specieskinetic}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
specieskinetic
&&
Must be specieskinetic
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
any
&
Unique name for estimator
\\
\hline
\sphinxcode{\sphinxupquote{hdf5}}\(^o\)
&
boolean
&
yes/no
&
no
&
Output to \sphinxcode{\sphinxupquote{stat.h5}} (yes)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}
\sphinxSetupCaptionForVerbatim{Species kinetic energy estimator element.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-31}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{specieskinetic}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{skinetic}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{hdf5}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Lattice deviation estimator}
\label{\detokenize{hamiltonianobservable:lattice-deviation-estimator}}
Record deviation of a group of particles in one particle set (target) from a group of particles in another particle set (source).

\sphinxcode{\sphinxupquote{estimator type=latticedeviation}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
latticedeviation
&&
Must be latticedeviation
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
any
&
Unique name for estimator
\\
\hline
\sphinxcode{\sphinxupquote{hdf5}}\(^o\)
&
boolean
&
yes/no
&
no
&
Output to \sphinxcode{\sphinxupquote{stat.h5}} (yes)
\\
\hline
\sphinxcode{\sphinxupquote{per\_xyz}}\(^o\)
&
boolean
&
yes/no
&
no
&
Directionally resolved (yes)
\\
\hline
\sphinxcode{\sphinxupquote{source}}\(^r\)
&
text
&
e/ion0/…
&
no
&
source particleset
\\
\hline
\sphinxcode{\sphinxupquote{sgroup}}\(^r\)
&
text
&
u/d/…
&
no
&
source particle group
\\
\hline
\sphinxcode{\sphinxupquote{target}}\(^r\)
&
text
&
e/ion0/…
&
no
&
target particleset
\\
\hline
\sphinxcode{\sphinxupquote{tgroup}}\(^r\)
&
text
&
u/d/…
&
no
&
target particle group
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{source}}: The “reference” particleset to measure distances from;
actual reference points are determined together with \sphinxcode{\sphinxupquote{sgroup}}.

\item {} 
\sphinxcode{\sphinxupquote{sgroup}}: The “reference” particle group to measure distances from.

\item {} 
\sphinxcode{\sphinxupquote{source}}: The “target” particleset to measure distances to.

\item {} 
\sphinxcode{\sphinxupquote{sgroup}}: The “target” particle group to measure distances to. For
example, in {\hyperref[\detokenize{hamiltonianobservable:listing-32}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 32}}}} the distance from the up
electron (“u”) to the origin of the coordinate system is recorded.

\item {} 
\sphinxcode{\sphinxupquote{per\_xyz}}: Used to record direction\sphinxhyphen{}resolved distance. In
{\hyperref[\detokenize{hamiltonianobservable:listing-32}]{\sphinxcrossref{\DUrole{std,std-ref}{Listing 32}}}}, the x,y,z coordinates of the up electron
will be recorded separately if \sphinxcode{\sphinxupquote{per\_xyz=yes}}.

\item {} 
\sphinxcode{\sphinxupquote{hdf5}}: Used to record particle\sphinxhyphen{}resolved distances in the h5 file
if \sphinxcode{\sphinxupquote{gdf5=yes}}.

\end{itemize}
\sphinxSetupCaptionForVerbatim{Lattice deviation estimator element.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-32}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{particleset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{random}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{mass}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}              \PYG{o}{\PYGZgt{}}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}                    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mass}\PYG{l+s+s2}{\PYGZdq{}}                \PYG{o}{\PYGZgt{}}    \PYG{l+m+mf}{1.0}                   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{mass}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}              \PYG{o}{\PYGZgt{}}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}                    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mass}\PYG{l+s+s2}{\PYGZdq{}}                \PYG{o}{\PYGZgt{}}    \PYG{l+m+mf}{1.0}                   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{particleset}\PYG{o}{\PYGZgt{}}

\PYG{o}{\PYGZlt{}}\PYG{n}{particleset} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{wf\PYGZus{}center}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{group} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{origin}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{attrib} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{position}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{datatype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{posArray}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{condition}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
             \PYG{l+m+mf}{0.00000000}        \PYG{l+m+mf}{0.00000000}        \PYG{l+m+mf}{0.00000000}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{attrib}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{group}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{particleset}\PYG{o}{\PYGZgt{}}

\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{latticedeviation}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{latdev}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{hdf5}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{per\PYGZus{}xyz}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{n}{source}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{wf\PYGZus{}center}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{sgroup}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{origin}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{tgroup}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Energy density estimator}
\label{\detokenize{hamiltonianobservable:energy-density-estimator}}
An energy density operator, \(\hat{\mathcal{E}}_r\), satisfies
\begin{equation}\label{equation:hamiltonianobservable:eq37}
\begin{split}\int dr \hat{\mathcal{E}}_r = \hat{H},\end{split}
\end{equation}
where the integral is over all space and \(\hat{H}\) is the
Hamiltonian. In QMCPACK, the energy density is split into kinetic and potential
components
\begin{equation}\label{equation:hamiltonianobservable:eq38}
\begin{split}\hat{\mathcal{E}}_r = \hat{\mathcal{T}}_r + \hat{\mathcal{V}}_r\:,\end{split}
\end{equation}
with each component given by
\begin{equation}\label{equation:hamiltonianobservable:eq39}
\begin{split}\begin{aligned}
    \hat{\mathcal{T}}_r &=  \frac{1}{2}\sum_i\delta(r-r_i)\hat{p}_i^2 \\
    \hat{\mathcal{V}}_r &=  \sum_{i<j}\frac{\delta(r-r_i)+\delta(r-r_j)}{2}\hat{v}^{ee}(r_i,r_j)
               + \sum_{i\ell}\frac{\delta(r-r_i)+\delta(r-\tilde{r}_\ell)}{2}\hat{v}^{eI}(r_i,\tilde{r}_\ell) \nonumber\\
     &\qquad   + \sum_{\ell< m}\frac{\delta(r-\tilde{r}_\ell)+\delta(r-\tilde{r}_m)}{2}\hat{v}^{II}(\tilde{r}_\ell,\tilde{r}_m)\:.\nonumber\end{aligned}\end{split}
\end{equation}
Here, \(r_i\) and \(\tilde{r}_\ell\) represent electron and ion
positions, respectively; \(\hat{p}_i\) is a single electron momentum
operator; and \(\hat{v}^{ee}(r_i,r_j)\),
\(\hat{v}^{eI}(r_i,\tilde{r}_\ell)\), and
\(\hat{v}^{II}(\tilde{r}_\ell,\tilde{r}_m)\) are the
electron\sphinxhyphen{}electron, electron\sphinxhyphen{}ion, and ion\sphinxhyphen{}ion pair potential operators
(including nonlocal pseudopotentials, if present). This form of the
energy density is size consistent; that is, the partially integrated
energy density operators of well\sphinxhyphen{}separated atoms gives the isolated
Hamiltonians of the respective atoms. For periodic systems with
twist\sphinxhyphen{}averaged boundary conditions, the energy density is formally
correct only for either a set of supercell k\sphinxhyphen{}points that correspond to
real\sphinxhyphen{}valued wavefunctions or a k\sphinxhyphen{}point set that has inversion symmetry
around a k\sphinxhyphen{}point having a real\sphinxhyphen{}valued wavefunction. For more information
about the energy density, see \sphinxcite{hamiltonianobservable:krogel2013}.

In QMCPACK, the energy density can be accumulated on piecewise uniform 3D grids in generalized Cartesian, cylindrical, or spherical coordinates.  The energy density integrated within Voronoi volumes centered on ion positions is also available.  The total particle number density is also accumulated on the same grids by the energy density estimator for convenience so that related quantities, such as the regional energy per particle, can be computed easily.

\sphinxcode{\sphinxupquote{estimator type=EnergyDensity}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{reference\_points, spacegrid}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{EnergyDensity}
&&
Must be EnergyDensity
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&&
Unique name for estimator
\\
\hline
\sphinxcode{\sphinxupquote{dynamic}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&&
Identify electrons
\\
\hline
\sphinxcode{\sphinxupquote{static}}\(^o\)
&
text
&
\sphinxcode{\sphinxupquote{particleset.name}}
&&
Identify ions
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name:}} Must be unique. A dataset with blocked statistical data for
the energy density will appear in the \sphinxcode{\sphinxupquote{stat.h5}} files labeled as
\sphinxcode{\sphinxupquote{name}}.

\end{itemize}
\sphinxSetupCaptionForVerbatim{Energy density estimator accumulated on a \(20 \times  10 \times 10\) grid over the simulation cell.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-33}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EnergyDensity}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EDcell}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{dynamic}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{static}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{spacegrid} \PYG{n}{coord}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cartesian}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{origin} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{zero}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{axis} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{scale}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.5}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{grid}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}1 (.05) 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{axis} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{scale}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.5}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{grid}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}1 (.1) 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
     \PYG{o}{\PYGZlt{}}\PYG{n}{axis} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{scale}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.5}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{z}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{grid}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}1 (.1) 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{spacegrid}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{estimator}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{Energy density estimator accumulated within spheres of radius 6.9 Bohr centered on the first and second atoms in the ion0 particleset.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-34}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EnergyDensity}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EDatom}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{dynamic}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{static}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{reference\PYGZus{}points} \PYG{n}{coord}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cartesian}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{r1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}
    \PYG{n}{r2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0}
    \PYG{n}{r3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{reference\PYGZus{}points}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{spacegrid} \PYG{n}{coord}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spherical}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{origin} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion01}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{axis} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{scale}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6.9}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r}\PYG{l+s+s2}{\PYGZdq{}}     \PYG{n}{grid}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{axis} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{scale}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6.9}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{phi}\PYG{l+s+s2}{\PYGZdq{}}   \PYG{n}{grid}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{axis} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{scale}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6.9}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{theta}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{grid}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{spacegrid}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{spacegrid} \PYG{n}{coord}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spherical}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{origin} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion02}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{axis} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{scale}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6.9}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r}\PYG{l+s+s2}{\PYGZdq{}}     \PYG{n}{grid}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{axis} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{scale}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6.9}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{phi}\PYG{l+s+s2}{\PYGZdq{}}   \PYG{n}{grid}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{axis} \PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{scale}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6.9}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{theta}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{grid}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{spacegrid}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{estimator}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{Energy density estimator accumulated within Voronoi polyhedra centered on the ions.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-35}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EnergyDensity}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EDvoronoi}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{dynamic}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{static}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ion0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{spacegrid} \PYG{n}{coord}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{voronoi}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{estimator}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{\textless{}reference\_points/\textgreater{}}} element provides a set of points for later
use in specifying the origin and coordinate axes needed to construct a
spatial histogramming grid. Several reference points on the surface of
the simulation cell (see \hyperref[\detokenize{hamiltonianobservable:table8}]{Table \ref{\detokenize{hamiltonianobservable:table8}}}), as well as the
positions of the ions (see the \sphinxcode{\sphinxupquote{energydensity.static}} attribute), are
made available by default. The reference points can be used, for
example, to construct a cylindrical grid along a bond with the origin on
the bond center.
\begin{quote}

\sphinxcode{\sphinxupquote{reference\_points}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{estimator type=EnergyDensity}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{coord}}\(^r\)
&
text
&
Cartesian/cell
&&
Specify coordinate system
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

body text: The body text is a line formatted list of points with labels
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{coord:}} If \sphinxcode{\sphinxupquote{coord=cartesian}}, labeled points are in Cartesian
(x,y,z) format in units of Bohr. If \sphinxcode{\sphinxupquote{coord=cell}}, then labeled
points are in units of the simulation cell axes.

\item {} 
\sphinxcode{\sphinxupquote{body text:}} The list of points provided in the body text are line
formatted, with four entries per line (\sphinxstyleemphasis{label} \sphinxstyleemphasis{coor1} \sphinxstyleemphasis{coor2}
\sphinxstyleemphasis{coor3}). A set of points referenced to the simulation cell is
available by default (see \hyperref[\detokenize{hamiltonianobservable:table8}]{Table \ref{\detokenize{hamiltonianobservable:table8}}}). If
\sphinxcode{\sphinxupquote{energydensity.static}} is provided, the location of each individual
ion is also available (e.g., if \sphinxcode{\sphinxupquote{energydensity.static=ion0}}, then
the location of the first atom is available with label ion01, the
second with ion02, etc.). All points can be used by label when
constructing spatial histogramming grids (see the following
\sphinxcode{\sphinxupquote{spacegrid}} element) used to collect energy densities.

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{hamiltonianobservable:table8}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{label}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{point}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{description}}
\\
\hline
\sphinxcode{\sphinxupquote{zero}}
&
0 0 0
&
Cell center
\\
\hline
\sphinxcode{\sphinxupquote{a1}}
&
\(a_1\)
&
Cell axis 1
\\
\hline
\sphinxcode{\sphinxupquote{a2}}
&
\(a_2\)
&
Cell axis 2
\\
\hline
\sphinxcode{\sphinxupquote{a3}}
&
\(a_3\)
&
Cell axis 3
\\
\hline
\sphinxcode{\sphinxupquote{f1p}}
&
\(a_1\)/2
&
Cell face 1+
\\
\hline
\sphinxcode{\sphinxupquote{f1m}}
&
\sphinxhyphen{}\(a_1\)/2
&
Cell face 1\sphinxhyphen{}
\\
\hline
\sphinxcode{\sphinxupquote{f2p}}
&
\(a_2\)/2
&
Cell face 2+
\\
\hline
\sphinxcode{\sphinxupquote{f2m}}
&
\sphinxhyphen{}\(a_2\)/2
&
Cell face 2\sphinxhyphen{}
\\
\hline
\sphinxcode{\sphinxupquote{f3p}}
&
\(a_3\)/2
&
Cell face 3+
\\
\hline
\sphinxcode{\sphinxupquote{f3m}}
&
\sphinxhyphen{}\(a_3\)/2
&
Cell face 3\sphinxhyphen{}
\\
\hline
\sphinxcode{\sphinxupquote{cppp}}
&
\((a_1+a_2+a_3)/2\)
&
Cell corner +,+,+
\\
\hline
\sphinxcode{\sphinxupquote{cppm}}
&
\((a_1+a_2-a_3)/2\)
&
Cell corner +,+,\sphinxhyphen{}
\\
\hline
\sphinxcode{\sphinxupquote{cpmp}}
&
\((a_1-a_2+a_3)/2\)
&
Cell corner +,\sphinxhyphen{},+
\\
\hline
\sphinxcode{\sphinxupquote{cmpp}}
&
\((-a_1+a_2+a_3)/2\)
&
Cell corner \sphinxhyphen{},+,+
\\
\hline
\sphinxcode{\sphinxupquote{cpmm}}
&
\((a_1-a_2-a_3)/2\)
&
Cell corner +,\sphinxhyphen{},\sphinxhyphen{}
\\
\hline
\sphinxcode{\sphinxupquote{cmpm}}
&
\((-a_1+a_2-a_3)/2\)
&
Cell corner \sphinxhyphen{},+,\sphinxhyphen{}
\\
\hline
\sphinxcode{\sphinxupquote{cmmp}}
&
\((-a_1-a_2+a_3)/2\)
&
Cell corner \sphinxhyphen{},\sphinxhyphen{},+
\\
\hline
\sphinxcode{\sphinxupquote{cmmm}}
&
\((-a_1-a_2-a_3)/2\)
&
Cell corner \sphinxhyphen{},\sphinxhyphen{},\sphinxhyphen{}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{center}Table 8 Reference points available by default. Vectors \(a_1\), \(a_2\), and \(a_3\) refer to the simulation cell axes. The representation of the cell is centered around \sphinxcode{\sphinxupquote{zero}}.
\end{center}
The \sphinxcode{\sphinxupquote{\textless{}spacegrid/\textgreater{}}} element is used to specify a spatial histogramming
grid for the energy density. Grids are constructed based on a set of,
potentially nonorthogonal, user\sphinxhyphen{}provided coordinate axes. The axes are
based on information available from \sphinxcode{\sphinxupquote{reference\_points}}. Voronoi grids
are based only on nearest neighbor distances between electrons and ions.
Any number of space grids can be provided to a single energy density
estimator.

\sphinxcode{\sphinxupquote{spacegrid}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{estimator type=EnergyDensity}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{origin, axis}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{coord}}\(^r\)
&
text
&
Cartesian
&&
Specify coordinate system
\\
\hline&&
cylindrical
&&\\
\hline&&
spherical
&&\\
\hline&&
Voronoi
&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

The \sphinxcode{\sphinxupquote{\textless{}origin/\textgreater{}}} element gives the location of the origin for a
non\sphinxhyphen{}Voronoi grid.

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{p1/p2/fraction:}} The location of the origin is set to
\sphinxcode{\sphinxupquote{p1+fraction*(p2\sphinxhyphen{}p1)}}. If only \sphinxcode{\sphinxupquote{p1}} is provided, the origin is at
\sphinxcode{\sphinxupquote{p1}}.

\end{itemize}

\sphinxcode{\sphinxupquote{origin}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{spacegrid}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{p1}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{reference\_point.label}}
&&
Select end point
\\
\hline
\sphinxcode{\sphinxupquote{p2}}\(^o\)
&
text
&
\sphinxcode{\sphinxupquote{reference\_point.label}}
&&
Select end point
\\
\hline
\sphinxcode{\sphinxupquote{fraction}}\(^o\)
&
real
&&
0
&
Interpolation fraction
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

The \sphinxcode{\sphinxupquote{\textless{}axis/\textgreater{}}} element represents a coordinate axis used to construct the, possibly curved, coordinate system for the histogramming grid.  Three \sphinxcode{\sphinxupquote{\textless{}axis/\textgreater{}}} elements must be provided to a non\sphinxhyphen{}Voronoi \sphinxcode{\sphinxupquote{\textless{}spacegrid/\textgreater{}}} element.

\sphinxcode{\sphinxupquote{axis}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{spacegrid}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{label}}\(^r\)
&
text
&
\sphinxstyleemphasis{See below}
&&
Axis/dimension label
\\
\hline
\sphinxcode{\sphinxupquote{grid}}\(^r\)
&
text
&&
“0 1”
&
Grid ranges/intervals
\\
\hline
\sphinxcode{\sphinxupquote{p1}}\(^r\)
&
text
&
\sphinxcode{\sphinxupquote{reference\_point.label}}
&&
Select end point
\\
\hline
\sphinxcode{\sphinxupquote{p2}}\(^o\)
&
text
&
\sphinxcode{\sphinxupquote{reference\_point.label}}
&&
Select end point
\\
\hline
\sphinxcode{\sphinxupquote{scale}}\(^o\)
&
real
&&&
Interpolation fraction
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{label:}} The allowed set of axis labels depends on the coordinate
system (i.e., \sphinxcode{\sphinxupquote{spacegrid.coord}}). Labels are \sphinxcode{\sphinxupquote{x/y/z}} for
\sphinxcode{\sphinxupquote{coord=cartesian}}, \sphinxcode{\sphinxupquote{r/phi/z}} for \sphinxcode{\sphinxupquote{coord=cylindrical}},
\sphinxcode{\sphinxupquote{r/phi/theta}} for \sphinxcode{\sphinxupquote{coord=spherical}}.

\item {} 
\sphinxcode{\sphinxupquote{p1/p2/scale:}} The axis vector is set to \sphinxcode{\sphinxupquote{p1+scale*(p2\sphinxhyphen{}p1)}}. If
only \sphinxcode{\sphinxupquote{p1}} is provided, the axis vector is \sphinxcode{\sphinxupquote{p1}}.

\item {} 
\sphinxcode{\sphinxupquote{grid:}} The grid specifies the histogram grid along the direction
specified by \sphinxcode{\sphinxupquote{label}}. The allowed grid points fall in the range
{[}\sphinxhyphen{}1,1{]} for \sphinxcode{\sphinxupquote{label=x/y/z}} or {[}0,1{]} for \sphinxcode{\sphinxupquote{r/phi/theta}}. A grid of 10
evenly spaced points between 0 and 1 can be requested equivalently by
\sphinxcode{\sphinxupquote{grid="0 (0.1) 1"}} or \sphinxcode{\sphinxupquote{grid="0 (10) 1."}} Piecewise uniform grids
covering portions of the range are supported, e.g.,
\sphinxcode{\sphinxupquote{grid="\sphinxhyphen{}0.7 (10) 0.0 (20) 0.5."}}

\item {} 
Note that \sphinxcode{\sphinxupquote{grid}} specifies the histogram grid along the (curved)
coordinate given by \sphinxcode{\sphinxupquote{label}}. The axis specified by \sphinxcode{\sphinxupquote{p1/p2/scale}}
does not correspond one\sphinxhyphen{}to\sphinxhyphen{}one with \sphinxcode{\sphinxupquote{label}} unless \sphinxcode{\sphinxupquote{label=x/y/z}},
but the full set of axes provided defines the (sheared) space on top
of which the curved (e.g., spherical) coordinate system is built.

\end{itemize}


\subsection{One body density matrix}
\label{\detokenize{hamiltonianobservable:one-body-density-matrix}}
The N\sphinxhyphen{}body density matrix in DMC is
\(\hat{\rho}_N=\left|{\Psi_{T}}\rangle{}\langle{\Psi_{FN}}\right|\) (for VMC,
substitute \(\Psi_T\) for \(\Psi_{FN}\)). The one body reduced
density matrix (1RDM) is obtained by tracing out all particle
coordinates but one:
\begin{equation}\label{equation:hamiltonianobservable:eq40}
\begin{split}\hat{n}_1 = \sum_nTr_{R_n}\left|{\Psi_{T}}\rangle{}\langle{\Psi_{FN}}\right|\end{split}
\end{equation}
In this formula, the sum is over all electron indices and
\(Tr_{R_n}(*)\equiv\int dR_n\langle{R_n}\left|{*}\right|{R_n}\rangle\) with
\(R_n=[r_1,...,r_{n-1},r_{n+1},...,r_N]\). When the sum is
restricted over spin\sphinxhyphen{}up or spin\sphinxhyphen{}down electrons, one obtains a density
matrix for each spin species. The 1RDM computed by is partitioned in
this way.

In real space, the matrix elements of the 1RDM are
\begin{equation}\label{equation:hamiltonianobservable:eq41}
\begin{split}\begin{aligned}
   n_1(r,r') &= \langle{r}\left|{\hat{n}_1}\right|{r'}\rangle = \sum_n\int dR_n \Psi_T(r,R_n)\Psi_{FN}^*(r',R_n)\:. \end{aligned}\end{split}
\end{equation}
A more efficient and compact representation of the 1RDM is obtained by
expanding in the SPOs obtained from a Hartree\sphinxhyphen{}Fock or DFT calculation,
\(\{\phi_i\}\):
\begin{equation}\label{equation:hamiltonianobservable:eq42}
\begin{split}n_1(i,j) &= \langle{\phi_i}\left|{\hat{n}_1}\right|{\phi_j}\rangle \nonumber \\
         &= \int dR \Psi_{FN}^*(R)\Psi_{T}(R) \sum_n\int dr'_n \frac{\Psi_T(r_n',R_n)}{\Psi_T(r_n,R_n)}\phi_i(r_n')^* \phi_j(r_n)\:.\end{split}
\end{equation}
The integration over \(r'\) in \eqref{equation:hamiltonianobservable:eq42} is inefficient when one is also interested in obtaining matrices involving energetic quantities, such as the energy density matrix of \sphinxcite{hamiltonianobservable:krogel2014} or the related (and more well known) generalized Fock matrix.  For this reason, an approximation is introduced as follows:
\begin{equation}\label{equation:hamiltonianobservable:eq43}
\begin{split}\begin{aligned}
    n_1(i,j) \approx \int dR \Psi_{FN}(R)^*\Psi_T(R)  \sum_n \int dr_n' \frac{\Psi_T(r_n',R_n)^*}{\Psi_T(r_n,R_n)^*}\phi_i(r_n)^* \phi_j(r_n')\:. \end{aligned}\end{split}
\end{equation}
For VMC, FN\sphinxhyphen{}DMC, FP\sphinxhyphen{}DMC, and RN\sphinxhyphen{}DMC this formula represents an exact
sampling of the 1RDM corresponding to \(\hat{\rho}_N^\dagger\) (see
appendix A of \sphinxcite{hamiltonianobservable:krogel2014} for more detail).

\sphinxcode{\sphinxupquote{estimtor type=dm1b}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{dm1b}
&&
Must be dm1b
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&&
Unique name for estimator
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

parameters:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{basis}}\(^r\)
&
text array
&
sposet.name(s)
&&
Orbital basis
\\
\hline
\sphinxcode{\sphinxupquote{integrator}}\(^o\)
&
text
&
uniform\_grid uniform density
&
uniform\_grid
&
Integration method
\\
\hline
\sphinxcode{\sphinxupquote{evaluator}}\(^o\)
&
text
&
loop/matrix
&
loop
&
Evaluation method
\\
\hline
\sphinxcode{\sphinxupquote{scale}}\(^o\)
&
real
&
\(0<scale<1\)
&
1.0
&
Scale integration cell
\\
\hline
\sphinxcode{\sphinxupquote{center}}\(^o\)
&
real array(3)
&
\sphinxstyleemphasis{any point}
&&
Center of cell
\\
\hline
\sphinxcode{\sphinxupquote{points}}\(^o\)
&
integer
&
\(>0\)
&
10
&
Grid points in each dim
\\
\hline
\sphinxcode{\sphinxupquote{samples}}\(^o\)
&
integer
&
\(>0\)
&
10
&
MC samples
\\
\hline
\sphinxcode{\sphinxupquote{warmup}}\(^o\)
&
integer
&
\(>0\)
&
30
&
MC warmup
\\
\hline
\sphinxcode{\sphinxupquote{timestep}}\(^o\)
&
real
&
\(>0\)
&
0.5
&
MC time step
\\
\hline
\sphinxcode{\sphinxupquote{use\_drift}}\(^o\)
&
boolean
&
yes/no
&
no
&
Use drift in VMC
\\
\hline
\sphinxcode{\sphinxupquote{check\_overlap}}\(^o\)
&
boolean
&
yes/no
&
no
&
Print overlap matrix
\\
\hline
\sphinxcode{\sphinxupquote{check\_derivatives}}\(^o\)
&
boolean
&
yes/no
&
no
&
Check density derivatives
\\
\hline
\sphinxcode{\sphinxupquote{acceptance\_ratio}}\(^o\)
&
boolean
&
yes/no
&
no
&
Print accept ratio
\\
\hline
\sphinxcode{\sphinxupquote{rstats}}\(^o\)
&
boolean
&
yes/no
&
no
&
Print spatial stats
\\
\hline
\sphinxcode{\sphinxupquote{normalized}}\(^o\)
&
boolean
&
yes/no
&
yes
&
\sphinxcode{\sphinxupquote{basis}} comes norm’ed
\\
\hline
\sphinxcode{\sphinxupquote{volume\_normed}}\(^o\)
&
boolean
&
yes/no
&
yes
&
\sphinxcode{\sphinxupquote{basis}} norm is volume
\\
\hline
\sphinxcode{\sphinxupquote{energy\_matrix}}\(^o\)
&
boolean
&
yes/no
&
no
&
Energy density matrix
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name:}} Density matrix results appear in \sphinxcode{\sphinxupquote{stat.h5}} files labeled
according to \sphinxcode{\sphinxupquote{name}}.

\item {} 
\sphinxcode{\sphinxupquote{basis:}} List \sphinxcode{\sphinxupquote{sposet.name}}’s. The total set of orbitals
contained in all \sphinxcode{\sphinxupquote{sposet}}’s comprises the basis (subspace) onto
which the one body density matrix is projected. This set of orbitals
generally includes many virtual orbitals that are not occupied in a
single reference Slater determinant.

\item {} 
\sphinxcode{\sphinxupquote{integrator:}} Select the method used to perform the additional
single particle integration. Options are \sphinxcode{\sphinxupquote{uniform\_grid}} (uniform
grid of points over the cell), \sphinxcode{\sphinxupquote{uniform}} (uniform random sampling
over the cell), and \sphinxcode{\sphinxupquote{density}} (Metropolis sampling of approximate
density, \(\sum_{b\in \texttt{basis}}\left|{\phi_b}\right|^2\), is not
well tested, please check results carefully!). Depending on the
integrator selected, different subsets of the other input parameters
are active.

\item {} 
\sphinxcode{\sphinxupquote{evaluator:}} Select for\sphinxhyphen{}loop or matrix multiply implementations.
Matrix is preferred for speed. Both implementations should give the
same results, but please check as this has not been exhaustively
tested.

\item {} 
\sphinxcode{\sphinxupquote{scale:}} Resize the simulation cell by scale for use as an
integration volume (active for \sphinxcode{\sphinxupquote{integrator=uniform/uniform\_grid}}).

\item {} 
\sphinxcode{\sphinxupquote{center:}} Translate the integration volume to center at this point
(active for \sphinxcode{\sphinxupquote{integrator=uniform/ uniform\_grid}}). If \sphinxcode{\sphinxupquote{center}} is
not provided, the scaled simulation cell is used as is.

\item {} 
\sphinxcode{\sphinxupquote{points:}} Number of grid points in each dimension for
\sphinxcode{\sphinxupquote{integrator=uniform\_grid}}. For example, \sphinxcode{\sphinxupquote{points=10}} results in a
uniform \(10 \times 10 \times 10\) grid over the cell.

\item {} 
\sphinxcode{\sphinxupquote{samples:}} Sets the number of MC samples collected for each step
(active for \sphinxcode{\sphinxupquote{integrator=uniform/ density}}).

\item {} 
\sphinxcode{\sphinxupquote{warmup:}} Number of warmup Metropolis steps at the start of the run
before data collection (active for \sphinxcode{\sphinxupquote{integrator=density}}).

\item {} 
\sphinxcode{\sphinxupquote{timestep:}} Drift\sphinxhyphen{}diffusion time step used in Metropolis sampling
(active for \sphinxcode{\sphinxupquote{integrator=density}}).

\item {} 
\sphinxcode{\sphinxupquote{use\_drift:}} Enable drift in Metropolis sampling (active for
\sphinxcode{\sphinxupquote{integrator=density}}).

\item {} 
\sphinxcode{\sphinxupquote{check\_overlap:}} Print the overlap matrix (computed via simple
Riemann sums) to the log, then abort. Note that subsequent analysis
based on the 1RDM is simplest if the input orbitals are orthogonal.

\item {} 
\sphinxcode{\sphinxupquote{check\_derivatives:}} Print analytic and numerical derivatives of
the approximate (sampled) density for several sample points, then
abort.

\item {} 
\sphinxcode{\sphinxupquote{acceptance\_ratio:}} Print the acceptance ratio of the density
sampling to the log for each step.

\item {} 
\sphinxcode{\sphinxupquote{rstats:}} Print statistical information about the spatial motion of
the sampled points to the log for each step.

\item {} 
\sphinxcode{\sphinxupquote{normalized:}} Declare whether the inputted orbitals are normalized
or not. If \sphinxcode{\sphinxupquote{normalized=no}}, direct Riemann integration over a
\(200 \times 200 \times 200\) grid will be used to compute the
normalizations before use.

\item {} 
\sphinxcode{\sphinxupquote{volume\_normed:}} Declare whether the inputted orbitals are
normalized to the cell volume (default) or not (a norm of 1.0 is
assumed in this case). Currently, B\sphinxhyphen{}spline orbitals coming from QE
and HEG planewave orbitals native to QMCPACK are known to be volume
normalized.

\item {} 
\sphinxcode{\sphinxupquote{energy\_matrix:}} Accumulate the one body reduced energy density
matrix, and write it to \sphinxcode{\sphinxupquote{stat.h5}}. This matrix is not covered in
any detail here; the interested reader is referred to
\sphinxcite{hamiltonianobservable:krogel2014}.

\end{itemize}
\sphinxSetupCaptionForVerbatim{One body density matrix with uniform grid integration.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-36}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dm1b}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DensityMatrices}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{basis}\PYG{l+s+s2}{\PYGZdq{}}        \PYG{o}{\PYGZgt{}}  \PYG{n}{spo\PYGZus{}u} \PYG{n}{spo\PYGZus{}uv}  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{evaluator}\PYG{l+s+s2}{\PYGZdq{}}    \PYG{o}{\PYGZgt{}}  \PYG{n}{matrix}        \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{integrator}\PYG{l+s+s2}{\PYGZdq{}}   \PYG{o}{\PYGZgt{}}  \PYG{n}{uniform\PYGZus{}grid}  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{points}\PYG{l+s+s2}{\PYGZdq{}}       \PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{4}             \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scale}\PYG{l+s+s2}{\PYGZdq{}}        \PYG{o}{\PYGZgt{}}  \PYG{l+m+mf}{1.0}           \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{center}\PYG{l+s+s2}{\PYGZdq{}}       \PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}         \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{estimator}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{One body density matrix with uniform sampling.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-37}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dm1b}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DensityMatrices}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{basis}\PYG{l+s+s2}{\PYGZdq{}}        \PYG{o}{\PYGZgt{}}  \PYG{n}{spo\PYGZus{}u} \PYG{n}{spo\PYGZus{}uv}  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{evaluator}\PYG{l+s+s2}{\PYGZdq{}}    \PYG{o}{\PYGZgt{}}  \PYG{n}{matrix}        \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{integrator}\PYG{l+s+s2}{\PYGZdq{}}   \PYG{o}{\PYGZgt{}}  \PYG{n}{uniform}       \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{samples}\PYG{l+s+s2}{\PYGZdq{}}      \PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{64}            \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scale}\PYG{l+s+s2}{\PYGZdq{}}        \PYG{o}{\PYGZgt{}}  \PYG{l+m+mf}{1.0}           \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{center}\PYG{l+s+s2}{\PYGZdq{}}       \PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}         \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{estimator}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{One body density matrix with density sampling.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-38}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dm1b}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DensityMatrices}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{basis}\PYG{l+s+s2}{\PYGZdq{}}        \PYG{o}{\PYGZgt{}}  \PYG{n}{spo\PYGZus{}u} \PYG{n}{spo\PYGZus{}uv}  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{evaluator}\PYG{l+s+s2}{\PYGZdq{}}    \PYG{o}{\PYGZgt{}}  \PYG{n}{matrix}        \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{integrator}\PYG{l+s+s2}{\PYGZdq{}}   \PYG{o}{\PYGZgt{}}  \PYG{n}{density}       \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{samples}\PYG{l+s+s2}{\PYGZdq{}}      \PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{64}            \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}     \PYG{o}{\PYGZgt{}}  \PYG{l+m+mf}{0.5}           \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{use\PYGZus{}drift}\PYG{l+s+s2}{\PYGZdq{}}    \PYG{o}{\PYGZgt{}}  \PYG{n}{no}            \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{estimator}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{Example \sphinxcode{\sphinxupquote{sposet}} initialization for density matrix use.  Occupied and virtual orbital sets are created separately, then joined (\sphinxcode{\sphinxupquote{basis="spo\_u spo\_uv"}}).}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-39}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{sposet\PYGZus{}builder} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{../dft/pwscf\PYGZus{}output/pwscf.pwscf.h5}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{tilematrix}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1 0 0 0 1 0 0 0 1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{twistnum}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{meshfactor}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{gpu}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{precision}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{single}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{sposet} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spo\PYGZus{}u}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n}{group}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{sposet} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spo\PYGZus{}d}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n}{group}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{sposet} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spo\PYGZus{}uv}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{group}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{index\PYGZus{}min}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{index\PYGZus{}max}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{sposet\PYGZus{}builder}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{Example \sphinxcode{\sphinxupquote{sposet}} initialization for density matrix use. Density matrix orbital basis created separately (\sphinxcode{\sphinxupquote{basis="dm\_basis"}}).}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-40}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{sposet\PYGZus{}builder} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{../dft/pwscf\PYGZus{}output/pwscf.pwscf.h5}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{tilematrix}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1 0 0 0 1 0 0 0 1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{twistnum}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{meshfactor}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1.0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{gpu}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{precision}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{single}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{sposet} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spo\PYGZus{}u}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n}{group}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{sposet} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spo\PYGZus{}d}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n}{group}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{sposet} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bspline}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dm\PYGZus{}basis}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{50}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{spindataset}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{sposet\PYGZus{}builder}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\section{Forward\sphinxhyphen{}Walking Estimators}
\label{\detokenize{hamiltonianobservable:forward-walking-estimators}}\label{\detokenize{hamiltonianobservable:forward-walking}}
Forward walking is a method for sampling the pure fixed\sphinxhyphen{}node
distribution \(\langle \Phi_0 | \Phi_0\rangle\). Specifically, one
multiplies each walker’s DMC mixed estimate for the observable
\(\mathcal{O}\),
\(\frac{\mathcal{O}(\mathbf{R})\Psi_T(\mathbf{R})}{\Psi_T(\mathbf{R})}\),
by the weighting factor
\(\frac{\Phi_0(\mathbf{R})}{\Psi_T(\mathbf{R})}\). As it turns out,
this weighting factor for any walker \(\mathbf{R}\) is proportional
to the total number of descendants the walker will have after a
sufficiently long projection time \(\beta\).

To forward walk on an observable, declare a generic forward\sphinxhyphen{}walking
estimator within a \sphinxcode{\sphinxupquote{\textless{}hamiltonian\textgreater{}}} block, and then specify the
observables to forward walk on and the forward\sphinxhyphen{}walking parameters. Here
is a summary.

\sphinxcode{\sphinxupquote{estimator type=ForwardWalking}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{Observable}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
\sphinxstylestrong{ForwardWalking}
&&
Must be “ForwardWalking”
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
any
&
Unique name for estimator
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}
\end{quote}

\sphinxcode{\sphinxupquote{Observable}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{estimator, hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxstyleemphasis{None}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^r\)
&
text
&
\sphinxstyleemphasis{anything}
&
any
&
Registered name of existing estimator on which to forward walk
\\
\hline
\sphinxcode{\sphinxupquote{max}}\(^r\)
&
integer
&
\(>0\)
&&
Maximum projection time in steps (\sphinxcode{\sphinxupquote{max}}\(=\beta/\tau\))
\\
\hline
\sphinxcode{\sphinxupquote{frequency}}\(^r\)
&
text
&
\(\geq 1\)
&&
Dump data only for every \sphinxcode{\sphinxupquote{frequency}}\sphinxhyphen{}th to \sphinxcode{\sphinxupquote{scalar.dat}} file
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxstylestrong{Cost}: Because histories of observables up to \sphinxcode{\sphinxupquote{max}} time steps
have to be stored, the memory cost of storing the nonforward\sphinxhyphen{}walked
observables variables should be multiplied by \(\texttt{max}\).
Although this is not an issue for items such as potential energy, it
could be prohibitive for observables such as density, forces, etc.

\item {} 
\sphinxstylestrong{Naming Convention}: Forward\sphinxhyphen{}walked observables are automatically
named \sphinxcode{\sphinxupquote{FWE\_name\_i}}, where \sphinxcode{\sphinxupquote{i}} is the forward\sphinxhyphen{}walked expectation
value at time step \sphinxcode{\sphinxupquote{i}}, and \sphinxcode{\sphinxupquote{name}} is whatever name appears in
the \sphinxcode{\sphinxupquote{\textless{}Observable\textgreater{}}} block. This is also how it will appear in the
\sphinxcode{\sphinxupquote{scalar.dat}} file.

\end{itemize}

In the following example case, QMCPACK forward walks on the potential
energy for 300 time steps and dumps the forward\sphinxhyphen{}walked value at every
time step.
\sphinxSetupCaptionForVerbatim{Forward\sphinxhyphen{}walking estimator element.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{hamiltonianobservable:listing-41}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}estimator name=\PYGZdq{}fw\PYGZdq{} type=\PYGZdq{}ForwardWalking\PYGZdq{}\PYGZgt{}
    \PYGZlt{}Observable name=\PYGZdq{}LocalPotential\PYGZdq{} max=\PYGZdq{}300\PYGZdq{} frequency=\PYGZdq{}1\PYGZdq{}/\PYGZgt{}
     \PYGZlt{}!\PYGZhy{}\PYGZhy{}\PYGZhy{} Additional Observable blocks go here \PYGZhy{}\PYGZhy{}\PYGZgt{}
 \PYGZlt{}/estimator\PYGZgt{}
\end{sphinxVerbatim}


\section{“Force” estimators}
\label{\detokenize{hamiltonianobservable:force-estimators}}\label{\detokenize{hamiltonianobservable:force-est}}
QMCPACK supports force estimation by use of the Chiesa\sphinxhyphen{}Ceperly\sphinxhyphen{}Zhang
(CCZ) estimator. Currently, open and periodic boundary conditions are
supported but for all\sphinxhyphen{}electron calculations only.

Without loss of generality, the CCZ estimator for the z\sphinxhyphen{}component of the
force on an ion centered at the origin is given by the following
expression:
\begin{equation}\label{equation:hamiltonianobservable:eq44}
\begin{split}F_z = -Z \sum_{i=1}^{N_e}\frac{z_i}{r_i^3}[\theta(r_i-\mathcal{R}) + \theta(\mathcal{R}-r_i)\sum_{\ell=1}^{M}c_\ell r_i^\ell]\:.\end{split}
\end{equation}
Z is the ionic charge, \(M\) is the degree of the smoothing
polynomial, \(\mathcal{R}\) is a real\sphinxhyphen{}space cutoff of the sphere
within which the bare\sphinxhyphen{}force estimator is smoothed, and \(c_\ell\)
are predetermined coefficients. These coefficients are chosen to
minimize the weighted mean square error between the bare force estimate
and the s\sphinxhyphen{}wave filtered estimator. Specifically,
\begin{equation}\label{equation:hamiltonianobservable:eq45}
\begin{split}\chi^2 = \int_0^\mathcal{R}dr\,r^m\,[f_z(r) - \tilde{f}_z(r)]^2\:.\end{split}
\end{equation}
Here, \(m\) is the weighting exponent, \(f_z(r)\) is the
unfiltered radial force density for the z force component, and
\(\tilde{f}_z(r)\) is the smoothed polynomial function for the same
force density. The reader is invited to refer to the original paper for
a more thorough explanation of the methodology, but with the notation in
hand, QMCPACK takes the following parameters.

\sphinxcode{\sphinxupquote{estimator type=Force}} element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

parent elements:
&
\sphinxcode{\sphinxupquote{hamiltonian, qmc}}
\\
\hline
child elements:
&
\sphinxcode{\sphinxupquote{parameter}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

attributes:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{mode}}\(^o\)
&
text
&
\sphinxstyleemphasis{See above}
&
bare
&
Select estimator type
\\
\hline
\sphinxcode{\sphinxupquote{lrmethod}}\(^o\)
&
text
&
ewald or srcoul
&
ewald
&
Select long\sphinxhyphen{}range potential breakup method
\\
\hline
\sphinxcode{\sphinxupquote{type}}\(^r\)
&
text
&
Force
&&
Must be “Force”
\\
\hline
\sphinxcode{\sphinxupquote{name}}\(^o\)
&
text
&
\sphinxstyleemphasis{Anything}
&
ForceBase
&
Unique name for this estimator
\\
\hline
\sphinxcode{\sphinxupquote{pbc}}\(^o\)
&
boolean
&
yes/no
&
yes
&
Using periodic BCs or not
\\
\hline
\sphinxcode{\sphinxupquote{addionion}}\(^o\)
&
boolean
&
yes/no
&
no
&
Add the ion\sphinxhyphen{}ion force contribution to output force estimate
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

parameters:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{rcut}}\(^o\)
&
real
&
\(>0\)
&
1.0
&
Real\sphinxhyphen{}space cutoff \(\mathcal{R}\) in bohr
\\
\hline
\sphinxcode{\sphinxupquote{nbasis}}\(^o\)
&
integer
&
\(>0\)
&
2
&
Degree of smoothing polynomial \(M\)
\\
\hline
\sphinxcode{\sphinxupquote{weightexp}}\(^o\)
&
integer
&
\(>0\)
&
2
&
\(\chi^2\) weighting exponent :math\textasciigrave{}m\textasciigrave{}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxstylestrong{Naming Convention}: The unique identifier \sphinxcode{\sphinxupquote{name}} is appended
with \sphinxcode{\sphinxupquote{name\_X\_Y}} in the \sphinxcode{\sphinxupquote{scalar.dat}} file, where \sphinxcode{\sphinxupquote{X}} is the ion
ID number and \sphinxcode{\sphinxupquote{Y}} is the component ID (an integer with x=0, y=1,
z=2). All force components for all ions are computed and dumped to
the \sphinxcode{\sphinxupquote{scalar.dat}} file.

\item {} 
\sphinxstylestrong{Long\sphinxhyphen{}range breakup}: With periodic boundary conditions, it is
important to converge the lattice sum when calculating Coulomb
contribution to the forces. As a quick test, increase the
\sphinxcode{\sphinxupquote{LR\_dim\_cutoff}} parameter until ion\sphinxhyphen{}ion forces are converged. The
Ewald method (\sphinxcode{\sphinxupquote{lrmethod}}=”ewald”) converges more slowly than
optimized method (\sphinxcode{\sphinxupquote{lrmethod}}=”srcoul”).

\item {} 
\sphinxstylestrong{Miscellaneous}: Usually, the default choice of \sphinxcode{\sphinxupquote{weightexp}} is
sufficient. Different combinations of \sphinxcode{\sphinxupquote{rcut}} and \sphinxcode{\sphinxupquote{nbasis}} should
be tested though to minimize variance and bias. There is, of course,
a tradeoff, with larger \sphinxcode{\sphinxupquote{nbasis}} and smaller \sphinxcode{\sphinxupquote{rcut}} leading to
smaller biases and larger variances.

\end{itemize}

The following is an example use case.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{simulationcell}\PYG{o}{\PYGZgt{}}
  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LR}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{\PYGZus{}dim}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{\PYGZus{}cutoff}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{20}  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{simulationcell}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{myforce}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Force}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cep}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{addionion}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{lrmethod}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{srcoul}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{rcut}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nbasis}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{4}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{weightexp}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{2}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{estimator}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}




\chapter{Quantum Monte Carlo Methods}
\label{\detokenize{methods:quantum-monte-carlo-methods}}\label{\detokenize{methods:qmcmethods}}\label{\detokenize{methods::doc}}
\sphinxcode{\sphinxupquote{qmc}} factory element:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Parent elements
&
\sphinxcode{\sphinxupquote{simulation, loop}}
\\
\hline
type selector
&
\sphinxcode{\sphinxupquote{method}} attribute
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

type options:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

vmc
&
Variational Monte Carlo
\\
\hline
linear
&
Wavefunction optimization with linear method
\\
\hline
dmc
&
Diffusion Monte Carlo
\\
\hline
rmc
&
Reptation Monte Carlo
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

shared attributes:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{method}}
&
text
&
listed above
&
invalid
&
QMC driver
\\
\hline
\sphinxcode{\sphinxupquote{move}}
&
text
&
pbyp, alle
&
pbyp
&
Method used to move electrons
\\
\hline
\sphinxcode{\sphinxupquote{gpu}}
&
text
&
yes/no
&
dep.
&
Use the GPU
\\
\hline
\sphinxcode{\sphinxupquote{trace}}
&
text
&&
no
&
???
\\
\hline
\sphinxcode{\sphinxupquote{checkpoint}}
&
integer
&
\sphinxhyphen{}1, 0, n
&
\sphinxhyphen{}1
&
Checkpoint frequency
\\
\hline
\sphinxcode{\sphinxupquote{record}}
&
integer
&
n
&
0
&
Save configuration ever n steps
\\
\hline
\sphinxcode{\sphinxupquote{target}}
&
text
&&&
???
\\
\hline
\sphinxcode{\sphinxupquote{completed}}
&
text
&&&
???
\\
\hline
\sphinxcode{\sphinxupquote{append}}
&
text
&
yes/no
&
no
&
???
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{move}}: There are two ways to move electrons. The more used method
is the particle\sphinxhyphen{}by\sphinxhyphen{}particle move. In this method, only one electron
is moved for acceptance or rejection. The other method is the
all\sphinxhyphen{}electron move; namely, all the electrons are moved once for
testing acceptance or rejection.

\item {} 
\sphinxcode{\sphinxupquote{gpu}}: When the executable is compiled with CUDA, the target
computing device can be chosen by this switch. With a regular
CPU\sphinxhyphen{}only compilation, this option is not effective.

\item {} 
\sphinxcode{\sphinxupquote{checkpoint}}: This enables and disables checkpointing and
specifying the frequency of output. Possible values are:
\begin{itemize}
\item {} 
\sphinxstylestrong{{[}\sphinxhyphen{}1{]}} No checkpoint (default setting).

\item {} 
\sphinxstylestrong{{[}0{]}} Dump after the completion of a QMC section.

\item {} 
\sphinxstylestrong{{[}n{]}} Dump after every \(n\) blocks.  Also dump at the end of the run.

\end{itemize}

\end{itemize}

The particle configurations are written to a \sphinxcode{\sphinxupquote{.config.h5}} file.
\sphinxSetupCaptionForVerbatim{The following is an example of running a simulation that can be restarted.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{methods:listing-42}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dmc}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pbyp}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n}{checkpoint}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}         \PYG{l+m+mf}{0.004}  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}           \PYG{l+m+mi}{100}   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{steps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}            \PYG{l+m+mi}{400}    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

The checkpoint flag instructs QMCPACK to output walker configurations.  This also
works in VMC.  This outputs an h5 file with the name \sphinxcode{\sphinxupquote{projectid.run\sphinxhyphen{}number.config.h5}}.
Check that this file exists before attempting a restart.

To continue a run, specify the \sphinxcode{\sphinxupquote{mcwalkerset}} element before your VMC/DMC block:
\sphinxSetupCaptionForVerbatim{Restart (read walkers from previous run).}
\def\sphinxLiteralBlockLabel{\label{\detokenize{methods:listing-43}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{mcwalkerset} \PYG{n}{fileroot}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{BH.s002}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{version}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0 6}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{collected}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dmc}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pbyp}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{n}{checkpoint}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}         \PYG{l+m+mf}{0.004}  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}           \PYG{l+m+mi}{100}   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{steps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}            \PYG{l+m+mi}{400}    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{BH}} is the project id, and \sphinxcode{\sphinxupquote{s002}} is the calculation number to read in the walkers from the previous run.

In the project id section, make sure that the series number is different from any existing ones to avoid overwriting them.


\section{Variational Monte Carlo}
\label{\detokenize{methods:variational-monte-carlo}}\label{\detokenize{methods:vmc}}
\sphinxcode{\sphinxupquote{vmc}} method:
\begin{quote}

parameters:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{walkers}}
&
integer
&
\(> 0\)
&
dep.
&
Number of walkers per MPI task
\\
\hline
\sphinxcode{\sphinxupquote{blocks}}
&
integer
&
\(\geq 0\)
&
1
&
Number of blocks
\\
\hline
\sphinxcode{\sphinxupquote{steps}}
&
integer
&
\(\geq 0\)
&
1
&
Number of steps per block
\\
\hline
\sphinxcode{\sphinxupquote{warmupsteps}}
&
integer
&
\(\geq 0\)
&
0
&
Number of steps for warming up
\\
\hline
\sphinxcode{\sphinxupquote{substeps}}
&
integer
&
\(\geq 0\)
&
1
&
Number of substeps per step
\\
\hline
\sphinxcode{\sphinxupquote{usedrift}}
&
text
&
yes,no
&
yes
&
Use the algorithm with drift
\\
\hline
\sphinxcode{\sphinxupquote{timestep}}
&
real
&
\(> 0\)
&
0.1
&
Time step for each electron move
\\
\hline
\sphinxcode{\sphinxupquote{samples}}
&
integer
&
\(\geq 0\)
&
0
&
Number of walker samples for DMC/optimization
\\
\hline
\sphinxcode{\sphinxupquote{stepsbetweensamples}}
&
integer
&
\(> 0\)
&
1
&
Period of sample accumulation
\\
\hline
\sphinxcode{\sphinxupquote{samplesperthread}}
&
integer
&
\(\geq 0\)
&
0
&
Number of samples per thread
\\
\hline
\sphinxcode{\sphinxupquote{storeconfigs}}
&
integer
&
all values
&
0
&
Show configurations o
\\
\hline
\sphinxcode{\sphinxupquote{blocks\_between\_recompute}}
&
integer
&
\(\geq 0\)
&
dep.
&
Wavefunction recompute frequency
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{walkers}} The number of walkers per MPI task. The initial default number of ixml\{walkers\} is one per OpenMP thread or per MPI task if threading is disabled. The number is rounded down to a multiple of the number of threads with a minimum of one per thread to ensure perfect load balancing. One walker per thread is created in the event fewer \sphinxcode{\sphinxupquote{walkers}} than threads are requested.

\item {} 
\sphinxcode{\sphinxupquote{blocks}} This parameter is universal for all the QMC
methods. The MC processes are divided into a number of
\sphinxcode{\sphinxupquote{blocks}}, each containing a number of steps. At the end of each block,
the statistics accumulated in the block are dumped into files,
e.g., \sphinxcode{\sphinxupquote{scalar.dat}}. Typically, each block should have a sufficient number of steps that the I/O at the end of each block is negligible
compared with the computational cost. Each block should not take so
long that monitoring its progress is difficult. There should be a
sufficient number of \sphinxcode{\sphinxupquote{blocks}} to perform statistical analysis.

\item {} 
\sphinxcode{\sphinxupquote{warmupsteps}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{warmupsteps}} are used only for
equilibration. Property measurements are not performed during
warm\sphinxhyphen{}up steps.

\item {} 
\sphinxcode{\sphinxupquote{steps}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{steps}} are the number of energy and other property measurements to perform per block.

\item {} 
\sphinxcode{\sphinxupquote{substeps}}  For each substep, an attempt is made to move each of the electrons once only by either particle\sphinxhyphen{}by\sphinxhyphen{}particle or an
all\sphinxhyphen{}electron move.  Because the local energy is evaluated only at
each full step and not each substep, \sphinxcode{\sphinxupquote{substeps}} are computationally cheaper
and can be used to reduce the correlation between property measurements
at a lower cost.

\item {} 
\sphinxcode{\sphinxupquote{usedrift}} The VMC is implemented in two algorithms with
or without drift. In the no\sphinxhyphen{}drift algorithm, the move of each
electron is proposed with a Gaussian distribution. The standard
deviation is chosen as the time step input. In the drift algorithm,
electrons are moved by Langevin dynamics.

\item {} 
\sphinxcode{\sphinxupquote{timestep}} The meaning of time step depends on whether or not
the drift is used. In general, larger time steps reduce the
time correlation but might also reduce the acceptance ratio,
reducing overall statistical efficiency. For VMC, typically the
acceptance ratio should be close to 50\% for an efficient
simulation.

\item {} 
\sphinxcode{\sphinxupquote{samples}} Seperate from conventional energy and other
property measurements, samples refers to storing whole electron
configurations in memory (“walker samples”) as would be needed by subsequent
wavefunction optimization or DMC steps. \sphinxstyleemphasis{A standard VMC run to
measure the energy does not need samples to be set.}
\begin{equation*}
\begin{split}\texttt{samples}=
\frac{\texttt{blocks}\cdot\texttt{steps}\cdot\texttt{walkers}}{\texttt{stepsbetweensamples}}\cdot\texttt{number of MPI tasks}\end{split}
\end{equation*}
\item {} 
\sphinxcode{\sphinxupquote{samplesperthread}} This is an alternative way to set the target amount of samples and can be useful when preparing a stored population for a subsequent DMC calculation.
\begin{equation*}
\begin{split}\texttt{samplesperthread}=
\frac{\texttt{blocks}\cdot\texttt{steps}}{\texttt{stepsbetweensamples}}\end{split}
\end{equation*}
\item {} 
\sphinxcode{\sphinxupquote{stepsbetweensamples}} Because samples generated by consecutive steps are correlated, having \sphinxcode{\sphinxupquote{stepsbetweensamples}} larger than 1 can be used to reduces that correlation. In practice, using larger substeps is cheaper than using \sphinxcode{\sphinxupquote{stepsbetweensamples}} to decorrelate samples.

\item {} 
\sphinxcode{\sphinxupquote{storeconfigs}} If \sphinxcode{\sphinxupquote{storeconfigs}} is set to a nonzero value, then electron configurations during the VMC run are saved to files.

\item {} 
\sphinxcode{\sphinxupquote{blocks\_between\_recompute}} Recompute the accuracy critical determinant part of the wavefunction
from scratch: =1 by default when using mixed precision. =0 (no
recompute) by default when not using mixed precision. Recomputing
introduces a performance penalty dependent on system size.

\end{itemize}

An example VMC section for a simple VMC run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{vmc}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pbyp}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LocalEnergy}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{hdf5}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{walkers}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}    \PYG{l+m+mi}{256} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{warmupSteps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{100} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{substeps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{5} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{20} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{steps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{100} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mf}{1.0} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{usedrift}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}   \PYG{n}{yes} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Here we set 256 \sphinxcode{\sphinxupquote{walkers}} per MPI, have a brief initial equilibration of 100 \sphinxcode{\sphinxupquote{steps}}, and then have 20 \sphinxcode{\sphinxupquote{blocks}} of 100 \sphinxcode{\sphinxupquote{steps}} with 5 \sphinxcode{\sphinxupquote{substeps}} each.

The following is an example of VMC section storing configurations (walker samples) for optimization.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{qmc} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{vmc}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{move}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pbyp}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{gpu}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{estimator} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LocalEnergy}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{hdf5}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{walkers}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}    \PYG{l+m+mi}{256} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{samples}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}    \PYG{l+m+mi}{2867200} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{stepsbetweensamples}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}    \PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{substeps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{5} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{warmupSteps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{5} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{blocks}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mi}{70} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timestep}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}  \PYG{l+m+mf}{1.0} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{usedrift}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}   \PYG{n}{no} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{qmc}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\section{Wavefunction optimization}
\label{\detokenize{methods:wavefunction-optimization}}\label{\detokenize{methods:optimization}}
Optimizing wavefunction is critical in all kinds of real\sphinxhyphen{}space QMC calculations
because it significantly improves both the accuracy and efficiency of computation.
However, it is very difficult to directly adopt deterministic minimization approaches because of the stochastic nature of evaluating quantities with MC.
Thanks to the algorithmic breakthrough during the first decade of this century and the tremendous computer power available,
it is now feasible to optimize tens of thousands of parameters in a wavefunction for a solid or molecule.
QMCPACK has multiple optimizers implemented based on the state\sphinxhyphen{}of\sphinxhyphen{}the\sphinxhyphen{}art linear method.
We are continually improving our optimizers for robustness and friendliness and are trying to provide a single solution.
Because of the large variation of wavefunction types carrying distinct characteristics, using several optimizers might be needed in some cases.
We strongly suggested reading recommendations from the experts who maintain these optimizers.

A typical optimization block looks like the following. It starts with method=”linear” and contains three blocks of parameters.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}loop max=\PYGZdq{}10\PYGZdq{}\PYGZgt{}
 \PYGZlt{}qmc method=\PYGZdq{}linear\PYGZdq{} move=\PYGZdq{}pbyp\PYGZdq{} gpu=\PYGZdq{}yes\PYGZdq{}\PYGZgt{}
   \PYGZlt{}!\PYGZhy{}\PYGZhy{} Specify the VMC options \PYGZhy{}\PYGZhy{}\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}walkers\PYGZdq{}\PYGZgt{}              256 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}samples\PYGZdq{}\PYGZgt{}          2867200 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}stepsbetweensamples\PYGZdq{}\PYGZgt{}    1 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}substeps\PYGZdq{}\PYGZgt{}               5 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}warmupSteps\PYGZdq{}\PYGZgt{}            5 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}blocks\PYGZdq{}\PYGZgt{}                70 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}timestep\PYGZdq{}\PYGZgt{}             1.0 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}usedrift\PYGZdq{}\PYGZgt{}              no \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}estimator name=\PYGZdq{}LocalEnergy\PYGZdq{} hdf5=\PYGZdq{}no\PYGZdq{}/\PYGZgt{}
   ...
   \PYGZlt{}!\PYGZhy{}\PYGZhy{} Specify the correlated sampling options and define the cost function \PYGZhy{}\PYGZhy{}\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}minwalkers\PYGZdq{}\PYGZgt{}            0.3 \PYGZlt{}/parameter\PYGZgt{}
        \PYGZlt{}cost name=\PYGZdq{}energy\PYGZdq{}\PYGZgt{}               0.95 \PYGZlt{}/cost\PYGZgt{}
        \PYGZlt{}cost name=\PYGZdq{}unreweightedvariance\PYGZdq{}\PYGZgt{} 0.00 \PYGZlt{}/cost\PYGZgt{}
        \PYGZlt{}cost name=\PYGZdq{}reweightedvariance\PYGZdq{}\PYGZgt{}   0.05 \PYGZlt{}/cost\PYGZgt{}
   ...
   \PYGZlt{}!\PYGZhy{}\PYGZhy{} Specify the optimizer options \PYGZhy{}\PYGZhy{}\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}MinMethod\PYGZdq{}\PYGZgt{}    OneShiftOnly \PYGZlt{}/parameter\PYGZgt{}
   ...
 \PYGZlt{}/qmc\PYGZgt{}
\PYGZlt{}/loop\PYGZgt{}

\PYGZhy{}  Loop is helpful to repeatedly execute identical optimization blocks.

\PYGZhy{}  The first part is highly identical to a regular VMC block.

\PYGZhy{}  The second part is to specify the correlated sampling options and
   define the cost function.

\PYGZhy{}  The last part is used to specify the options of different optimizers,
   which can be very distinct from one to another.
\end{sphinxVerbatim}


\subsection{VMC run for the optimization}
\label{\detokenize{methods:vmc-run-for-the-optimization}}
The VMC calculation for the wavefunction optimization has a strict requirement
that \sphinxcode{\sphinxupquote{samples}} or \sphinxcode{\sphinxupquote{samplesperthread}} must be specified because of the optimizer needs for the stored \sphinxcode{\sphinxupquote{samples}}.
The input parameters of this part are identical to the VMC method.

Recommendations:
\begin{itemize}
\item {} 
Run the inclusive VMC calculation correctly and efficiently because
this takes a significant amount of time during optimization. For
example, make sure the derived \sphinxcode{\sphinxupquote{steps}} per block is 1 and use larger \sphinxcode{\sphinxupquote{substeps}} to
control the correlation between \sphinxcode{\sphinxupquote{samples}}.

\item {} 
A reasonable starting wavefunction is necessary. A lot of
optimization fails because of a bad wavefunction starting point. The
sign of a bad initial wavefunction includes but is not limited to a
very long equilibration time, low acceptance ratio, and huge
variance. The first thing to do after a failed optimization is to
check the information provided by the VMC calculation via
\sphinxcode{\sphinxupquote{*.scalar.dat files}}.

\end{itemize}


\subsection{Correlated sampling and cost function}
\label{\detokenize{methods:correlated-sampling-and-cost-function}}
After generating the samples with VMC, the derivatives of the wavefunction with respect to the parameters are computed for proposing a new set of parameters by optimizers.
And later, a correlated sampling calculation is performed to quickly evaluate values of the cost function on the old set of parameters and the new set for further decisions.
The input parameters are listed in the following table.

\sphinxcode{\sphinxupquote{linear}} method:
\begin{quote}

parameters:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{nonlocalpp}}
&
text
&
yes, no
&
no
&
include non\sphinxhyphen{}local PP energy in the cost function
\\
\hline
\sphinxcode{\sphinxupquote{minwalkers}}
&
real
&
0\textendash{}1
&
0.3
&
Lower bound of the effective weight
\\
\hline
\sphinxcode{\sphinxupquote{maxWeight}}
&
real
&
\(> 1\)
&
1e6
&
Maximum weight allowed in reweighting
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{maxWeight}} The default should be good.

\item {} 
\sphinxcode{\sphinxupquote{nonlocalpp}} The \sphinxcode{\sphinxupquote{nonlocalpp}} contribution to the local energy depends on the
wavefunction. When a new set of parameters is proposed, this
contribution needs to be updated if the cost function consists of local
energy. Fortunately, nonlocal contribution is chosen small when making a
PP for small locality error. We can ignore its change and avoid the
expensive computational cost. An implementation issue with GPU code is
that a large amount of memory is consumed with this option.

\item {} 
\sphinxcode{\sphinxupquote{minwalkers}} This is a \sphinxcode{\sphinxupquote{critical}} parameter. When the ratio of effective samples to actual number of samples in a reweighting step goes lower than \sphinxcode{\sphinxupquote{minwalkers}},
the proposed set of parameters is invalid.

\end{itemize}

The cost function consists of three components: energy, unreweighted variance, and reweighted variance.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{cost} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{energy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}                   \PYG{l+m+mf}{0.95} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{cost}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{cost} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{unreweightedvariance}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}     \PYG{l+m+mf}{0.00} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{cost}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{cost} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{reweightedvariance}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}       \PYG{l+m+mf}{0.05} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{cost}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Optimizers}
\label{\detokenize{methods:optimizers}}
QMCPACK implements a number of different optimizers each with different
priorities for accuracy, convergence, memory usage, and stability. The
optimizers can be switched among “OneShiftOnly” (default), “adaptive,”
“descent,” “hybrid,” and “quartic” (old) using the following line in the
optimization block:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MinMethod}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}} \PYG{n}{THE} \PYG{n}{METHOD} \PYG{n}{YOU} \PYG{n}{LIKE} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{OneShiftOnly Optimizer}
\label{\detokenize{methods:oneshiftonly-optimizer}}
The OneShiftOnly optimizer targets a fast optimization by moving parameters more aggressively. It works with OpenMP and GPU and can be considered for large systems.
This method relies on the effective weight of correlated sampling rather than the cost function value to justify a new set of parameters.
If the effective weight is larger than \sphinxcode{\sphinxupquote{minwalkers}}, the new set is taken whether or not the cost function value decreases.
If a proposed set is rejected, the standard output prints the measured ratio of effective samples to the total number of samples
and adjustment on \sphinxcode{\sphinxupquote{minwalkers}} can be made if needed.

\sphinxcode{\sphinxupquote{linear}} method:
\begin{quote}

parameters:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Datatype}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Default}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{\sphinxupquote{shift\_i}}
&
real
&
\(> 0\)
&
0.01
&
Direct stabilizer added to the Hamiltonian matrix
\\
\hline
\sphinxcode{\sphinxupquote{shift\_s}}
&
real
&
\(> 0\)
&
1.00
&
Initial stabilizer based on the overlap matrix
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Additional information:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{shift\_i}} This is the direct term added to the diagonal of the Hamiltonian
matrix. It provides more stable but slower optimization with a large
value.

\item {} 
\sphinxcode{\sphinxupquote{shift\_s}} This is the initial value of the stabilizer based on the overlap
matrix added to the Hamiltonian matrix. It provides more stable but
slower optimization with a large value. The used value is
auto\sphinxhyphen{}adjusted by the optimizer.

\end{itemize}

Recommendations:
\begin{itemize}
\item {} 
Default \sphinxcode{\sphinxupquote{shift\_i}}, \sphinxcode{\sphinxupquote{shift\_s}} should be fine.

\item {} 
For hard cases, increasing \sphinxcode{\sphinxupquote{shift\_i}} (by a factor of 5 or 10) can significantly stabilize the optimization by reducing the pace towards the optimal parameter set.

\item {} 
If the VMC energy of the last optimization iterations grows significantly, increase \sphinxcode{\sphinxupquote{minwalkers}} closer to 1 and make the optimization stable.

\item {} 
If the first iterations of optimization are rejected on a reasonable initial wavefunction,
lower the \sphinxcode{\sphinxupquote{minwalkers}} value based on the measured value printed in the standard output to accept the move.

\end{itemize}

We recommended using this optimizer in two sections with a very small \sphinxcode{\sphinxupquote{minwalkers}} in the first and a large value in the second, such as the following.
In the very beginning, parameters are far away from optimal values and large changes are proposed by the optimizer.
Having a small \sphinxcode{\sphinxupquote{minwalkers}} makes it much easier to accept these changes.
When the energy gradually converges, we can have a large \sphinxcode{\sphinxupquote{minwalkers}} to avoid risky parameter sets.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}loop max=\PYGZdq{}6\PYGZdq{}\PYGZgt{}
 \PYGZlt{}qmc method=\PYGZdq{}linear\PYGZdq{} move=\PYGZdq{}pbyp\PYGZdq{} gpu=\PYGZdq{}yes\PYGZdq{}\PYGZgt{}
   \PYGZlt{}!\PYGZhy{}\PYGZhy{} Specify the VMC options \PYGZhy{}\PYGZhy{}\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}walkers\PYGZdq{}\PYGZgt{}                1 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}samples\PYGZdq{}\PYGZgt{}            10000 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}stepsbetweensamples\PYGZdq{}\PYGZgt{}    1 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}substeps\PYGZdq{}\PYGZgt{}               5 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}warmupSteps\PYGZdq{}\PYGZgt{}            5 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}blocks\PYGZdq{}\PYGZgt{}                25 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}timestep\PYGZdq{}\PYGZgt{}             1.0 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}usedrift\PYGZdq{}\PYGZgt{}              no \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}estimator name=\PYGZdq{}LocalEnergy\PYGZdq{} hdf5=\PYGZdq{}no\PYGZdq{}/\PYGZgt{}
   \PYGZlt{}!\PYGZhy{}\PYGZhy{} Specify the optimizer options \PYGZhy{}\PYGZhy{}\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}MinMethod\PYGZdq{}\PYGZgt{}    OneShiftOnly \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}minwalkers\PYGZdq{}\PYGZgt{}           1e\PYGZhy{}4 \PYGZlt{}/parameter\PYGZgt{}
 \PYGZlt{}/qmc\PYGZgt{}
\PYGZlt{}/loop\PYGZgt{}
\PYGZlt{}loop max=\PYGZdq{}12\PYGZdq{}\PYGZgt{}
 \PYGZlt{}qmc method=\PYGZdq{}linear\PYGZdq{} move=\PYGZdq{}pbyp\PYGZdq{} gpu=\PYGZdq{}yes\PYGZdq{}\PYGZgt{}
   \PYGZlt{}!\PYGZhy{}\PYGZhy{} Specify the VMC options \PYGZhy{}\PYGZhy{}\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}walkers\PYGZdq{}\PYGZgt{}                1 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}samples\PYGZdq{}\PYGZgt{}            20000 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}stepsbetweensamples\PYGZdq{}\PYGZgt{}    1 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}substeps\PYGZdq{}\PYGZgt{}               5 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}warmupSteps\PYGZdq{}\PYGZgt{}            2 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}blocks\PYGZdq{}\PYGZgt{}                50 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}timestep\PYGZdq{}\PYGZgt{}             1.0 \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}usedrift\PYGZdq{}\PYGZgt{}              no \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}estimator name=\PYGZdq{}LocalEnergy\PYGZdq{} hdf5=\PYGZdq{}no\PYGZdq{}/\PYGZgt{}
   \PYGZlt{}!\PYGZhy{}\PYGZhy{} Specify the optimizer options \PYGZhy{}\PYGZhy{}\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}MinMethod\PYGZdq{}\PYGZgt{}    OneShiftOnly \PYGZlt{}/parameter\PYGZgt{}
   \PYGZlt{}parameter name=\PYGZdq{}minwalkers\PYGZdq{}\PYGZgt{}            0.5 \PYGZlt{}/parameter\PYGZgt{}
 \PYGZlt{}/qmc\PYGZgt{}
\PYGZlt{}/loop\PYGZgt{}
\end{sphinxVerbatim}

For each optimization step, you will see

\begin{sphinxVerbatim}[commandchars=\\\{\}]
The new set of parameters is valid. Updating the trial wave function!
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
The new set of parameters is not valid. Revert to the old set!
\end{sphinxVerbatim}

Occasional rejection is fine. Frequent rejection indicates potential
problems, and users should inspect the VMC calculation or change
optimization strategy. To track the progress of optimization, use the
command \sphinxcode{\sphinxupquote{qmca \sphinxhyphen{}q ev *.scalar.dat}} to look at the VMC energy and
variance for each optimization step.


\subsection{Adaptive Organizer}
\label{\detokenize{methods:adaptive-organizer}}
The default setting of the adaptive optimizer is to construct the linear
method Hamiltonian and overlap matrices explicitly and add different
shifts to the Hamiltonian matrix as “stabilizers.” The generalized
eigenvalue problem is solved for each shift to obtain updates to the
wavefunction parameters. Then a correlated sampling is performed for
each shift’s updated wavefunction and the initial trial wavefunction
using the middle shift’s updated wavefunction as the guiding function.
The cost function for these wavefunctions is compared, and the update
corresponding to the best cost function is selected. In the next
iteration, the median magnitude of the stabilizers is set to the
magnitude that generated the best update in the current iteration, thus
adapting the magnitude of the stabilizers automatically.

When the trial wavefunction contains more than 10,000 parameters,
constructing and storing the linear method matrices could become a
memory bottleneck. To avoid explicit construction of these matrices, the
adaptive optimizer implements the block linear method (BLM) approach.
\DUrole{bibtex}{{[}Zhao:2017:blocked\_lm{]}} The BLM tries to find an
approximate solution \(\vec{c}_{opt}\) to the standard LM
generalized eigenvalue problem by dividing the variable space into a
number of blocks and making intelligent estimates for which directions
within those blocks will be most important for constructing
\(\vec{c}_{opt}\), which is then obtained by solving a smaller, more
memory\sphinxhyphen{}efficient eigenproblem in the basis of these supposedly important
block\sphinxhyphen{}wise directions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{QMCPACK} \PYG{n}{website}\PYG{p}{:} \PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{www}\PYG{o}{.}\PYG{n}{qmcpack}\PYG{o}{.}\PYG{n}{org}

\PYG{n}{Releases} \PYG{o}{\PYGZam{}} \PYG{n}{source} \PYG{n}{code}\PYG{p}{:} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{QMCPACK}

\PYG{n}{Google} \PYG{n}{Group}\PYG{p}{:} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{groups}\PYG{o}{.}\PYG{n}{google}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{forum}\PYG{o}{/}\PYG{c+c1}{\PYGZsh{}!forum/qmcpack}
\end{sphinxVerbatim}

\begin{sphinxthebibliography}{MDAzeved}
\bibitem[MLC+17]{features:ipcc-sc17}
Amrita Mathuriya, Ye Luo, Raymond C. Clay, III, Anouar Benali, Luke Shulenburger, and Jeongnim Kim. Embracing a new era of highly efficient and productive quantum monte carlo simulations. In \sphinxstyleemphasis{Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis}, SC ‘17, 38:1\textendash{}38:12. New York, NY, USA, 2017. ACM. URL: \sphinxurl{http://doi.acm.org/10.1145/3126908.3126952}, \sphinxhref{https://doi.org/10.1145/3126908.3126952}{doi:10.1145/3126908.3126952}.
\bibitem[EKCS12]{running:eslerkimceperleyshulenburger2012}
Kenneth P. Esler, Jeongnim Kim, David M. Ceperley, and Luke Shulenburger. Accelerating quantum monte carlo simulations of real materials on gpu clusters. \sphinxstyleemphasis{Computing in Science and Engineering}, 14(1):40\textendash{}51, 2012. \sphinxhref{https://doi.org/http://doi.ieeecomputersociety.org/10.1109/MCSE.2010.122}{doi:http://doi.ieeecomputersociety.org/10.1109/MCSE.2010.122}.
\bibitem[NC95]{simulationcell:natoli1995}
Vincent Natoli and David M. Ceperley. An optimized method for treating long\sphinxhyphen{}range potentials. \sphinxstyleemphasis{Journal of Computational Physics}, 117(1):171 \textendash{} 178, 1995. URL: \sphinxurl{http://www.sciencedirect.com/science/article/pii/S0021999185710546}, \sphinxhref{https://doi.org/http://dx.doi.org/10.1006/jcph.1995.1054}{doi:http://dx.doi.org/10.1006/jcph.1995.1054}.
\bibitem[AlfeG04]{intro_wavefunction:blips4qmc}
D. Alfè and M. J. Gillan. An efficient localized basis set for quantum Monte Carlo calculations on condensed matter. \sphinxstyleemphasis{Physical Review B}, 70(16):161101, 2004.
\bibitem[BN17]{intro_wavefunction:blunt-charge-transfer-2017}
N. S. Blunt and Eric Neuscamman. Charge\sphinxhyphen{}transfer excited states: Seeking a balanced and efficient wave function ansatz in variational Monte Carlo. \sphinxstyleemphasis{The Journal of Chemical Physics}, 147(19):194101, November 2017. \sphinxhref{https://doi.org/10.1063/1.4998197}{doi:10.1063/1.4998197}.
\bibitem[Cep78]{intro_wavefunction:ceperley1978}
D. Ceperley. Ground state of the fermion one\sphinxhyphen{}component plasma: a monte carlo study in two and three dimensions. \sphinxstyleemphasis{Phys. Rev. B}, 18:3126\textendash{}3138, October 1978. URL: \sphinxurl{https://link.aps.org/doi/10.1103/PhysRevB.18.3126}, \sphinxhref{https://doi.org/10.1103/PhysRevB.18.3126}{doi:10.1103/PhysRevB.18.3126}.
\bibitem[DTN04]{intro_wavefunction:drummond2004}
N. D. Drummond, M. D. Towler, and R. J. Needs. Jastrow correlation factor for atoms, molecules, and solids. \sphinxstyleemphasis{Physical Review B \sphinxhyphen{} Condensed Matter and Materials Physics}, 70(23):1\textendash{}11, 2004. \sphinxhref{https://doi.org/10.1103/PhysRevB.70.235119}{doi:10.1103/PhysRevB.70.235119}.
\bibitem[EG13]{intro_wavefunction:caffarel2013}
M. Caffarel E. Giner, A. Scemama. Using perturbatively selected configuration interaction in quantum monte carlo calculations. \sphinxstyleemphasis{Canadian Journal of Chemistry}, 91:9, 2013.
\bibitem[EKCS12]{intro_wavefunction:eslerkimceperleyshulenburger2012}
Kenneth P. Esler, Jeongnim Kim, David M. Ceperley, and Luke Shulenburger. Accelerating quantum monte carlo simulations of real materials on gpu clusters. \sphinxstyleemphasis{Computing in Science and Engineering}, 14(1):40\textendash{}51, 2012. \sphinxhref{https://doi.org/http://doi.ieeecomputersociety.org/10.1109/MCSE.2010.122}{doi:http://doi.ieeecomputersociety.org/10.1109/MCSE.2010.122}.
\bibitem[FWL90]{intro_wavefunction:fahy1990}
S. Fahy, X. W. Wang, and Steven G. Louie. Variational quantum Monte Carlo nonlocal pseudopotential approach to solids: Formulation and application to diamond, graphite, and silicon. \sphinxstyleemphasis{Physical Review B}, 42(6):3503\textendash{}3522, 1990. \sphinxhref{https://doi.org/10.1103/PhysRevB.42.3503}{doi:10.1103/PhysRevB.42.3503}.
\bibitem[Gas61]{intro_wavefunction:gaskell1961}
T Gaskell. The collective treatment of a fermi gas: ii. \sphinxstyleemphasis{Proceedings of the Physical Society}, 77(6):1182, 1961. URL: \sphinxurl{http://stacks.iop.org/0370-1328/77/i=6/a=312}.
\bibitem[Gas62]{intro_wavefunction:gaskell1962}
T Gaskell. The collective treatment of many\sphinxhyphen{}body systems: iii. \sphinxstyleemphasis{Proceedings of the Physical Society}, 80(5):1091, 1962. URL: \sphinxurl{http://stacks.iop.org/0370-1328/80/i=5/a=307}.
\bibitem[Kat51]{intro_wavefunction:kato}
T Kato. Fundamental properties of hamiltonian operators of the schrodinger type. \sphinxstyleemphasis{Transactions of the American Mathematical Society}, 70:195\textendash{}211, 1951.
\bibitem[LEKS18]{intro_wavefunction:luo2018hyb}
Ye Luo, Kenneth P. Esler, Paul R. C. Kent, and Luke Shulenburger. An efficient hybrid orbital representation for quantum monte carlo calculations. \sphinxstyleemphasis{The Journal of Chemical Physics}, 149(8):084107, 2018.
\bibitem[LK18]{intro_wavefunction:luo2018delayedupdate}
Ye Luo and Jeongnim Kim. An highly efficient delayed update algorithm for evaluating slater determinants in quantum monte carlo. \sphinxstyleemphasis{in preparation}, ():, 2018.
\bibitem[MDAzevedoL+17]{intro_wavefunction:mcdaniel2017}
T. McDaniel, E. F. D’Azevedo, Y. W. Li, K. Wong, and P. R. C. Kent. Delayed slater determinant update algorithms for high efficiency quantum monte carlo. \sphinxstyleemphasis{The Journal of Chemical Physics}, 147(17):174107, November 2017. \sphinxhref{https://doi.org/10.1063/1.4998616}{doi:10.1063/1.4998616}.
\bibitem[NC95]{intro_wavefunction:natoli1995}
Vincent Natoli and David M. Ceperley. An optimized method for treating long\sphinxhyphen{}range potentials. \sphinxstyleemphasis{Journal of Computational Physics}, 117(1):171 \textendash{} 178, 1995. URL: \sphinxurl{http://www.sciencedirect.com/science/article/pii/S0021999185710546}, \sphinxhref{https://doi.org/http://dx.doi.org/10.1006/jcph.1995.1054}{doi:http://dx.doi.org/10.1006/jcph.1995.1054}.
\bibitem[Sce17]{intro_wavefunction:qp}
A. Scemamma. Quantum package. https://github.com/LCPQ/quantum\_package, 2013\textendash{}2017.
\bibitem[SBB+93]{intro_wavefunction:schmidt93}
Michael W. Schmidt, Kim K. Baldridge, Jerry A. Boatz, Steven T. Elbert, Mark S. Gordon, Jan H. Jensen, Shiro Koseki, Nikita Matsunaga, Kiet A. Nguyen, Shujun Su, Theresa L. Windus, Michel Dupuis, and John A. Montgomery. General atomic and molecular electronic structure system. \sphinxstyleemphasis{Journal of Computational Chemistry}, 14(11):1347\textendash{}1363, 1993. URL: \sphinxurl{http://dx.doi.org/10.1002/jcc.540141112}, \sphinxhref{https://doi.org/10.1002/jcc.540141112}{doi:10.1002/jcc.540141112}.
\bibitem[CCMH06]{hamiltonianobservable:chiesa2006}
Simone Chiesa, David M. Ceperley, Richard M. Martin, and Markus Holzmann. Finite\sphinxhyphen{}size error in many\sphinxhyphen{}body simulations with long\sphinxhyphen{}range interactions. \sphinxstyleemphasis{Phys. Rev. Lett.}, 97:076404, August 2006. \sphinxhref{https://doi.org/10.1103/PhysRevLett.97.076404}{doi:10.1103/PhysRevLett.97.076404}.
\bibitem[KKR14]{hamiltonianobservable:krogel2014}
Jaron T. Krogel, Jeongnim Kim, and Fernando A. Reboredo. Energy density matrix formalism for interacting quantum systems: quantum monte carlo study. \sphinxstyleemphasis{Phys. Rev. B}, 90:035125, July 2014. \sphinxhref{https://doi.org/10.1103/PhysRevB.90.035125}{doi:10.1103/PhysRevB.90.035125}.
\bibitem[KYKC13]{hamiltonianobservable:krogel2013}
Jaron T. Krogel, Min Yu, Jeongnim Kim, and David M. Ceperley. Quantum energy density: improved efficiency for quantum monte carlo calculations. \sphinxstyleemphasis{Phys. Rev. B}, 88:035137, July 2013. \sphinxhref{https://doi.org/10.1103/PhysRevB.88.035137}{doi:10.1103/PhysRevB.88.035137}.
\bibitem[MSC91]{hamiltonianobservable:mitas1991}
Lubos Mitas, Eric L. Shirley, and David M. Ceperley. Nonlocal pseudopotentials and diffusion monte carlo. \sphinxstyleemphasis{The Journal of Chemical Physics}, 95(5):3467\textendash{}3475, 1991. \sphinxhref{https://doi.org/10.1063/1.460849}{doi:10.1063/1.460849}.
\bibitem[NC95]{hamiltonianobservable:natoli1995}
Vincent Natoli and David M. Ceperley. An optimized method for treating long\sphinxhyphen{}range potentials. \sphinxstyleemphasis{Journal of Computational Physics}, 117(1):171\textendash{}178, 1995. URL: \sphinxurl{http://www.sciencedirect.com/science/article/pii/S0021999185710546}, \sphinxhref{https://doi.org/10.1006/jcph.1995.1054}{doi:10.1006/jcph.1995.1054}.
\bibitem[ZBMAlfe19]{hamiltonianobservable:zen2019dla}
Andrea Zen, Jan Gerit Brandenburg, Angelos Michaelides, and Dario Alfè. A new scheme for fixed node diffusion quantum monte carlo with pseudopotentials: improving reproducibility and reducing the trial\sphinxhyphen{}wave\sphinxhyphen{}function bias. \sphinxstyleemphasis{The Journal of Chemical Physics}, 151(13):134105, October 2019. \sphinxhref{https://doi.org/10.1063/1.5119729}{doi:10.1063/1.5119729}.
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
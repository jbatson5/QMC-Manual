

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Quantum Monte Carlo Methods &mdash; QMCPACK Manual 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Output Overview" href="output_overview.html" />
    <link rel="prev" title="Hamiltonian and Observables" href="hamiltonianobservable.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> QMCPACK Manual
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="features.html">Features of QMCPACK</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Obtaining, installing, and validating QMCPACK</a></li>
<li class="toctree-l1"><a class="reference internal" href="running.html">Running QMCPACK</a></li>
<li class="toctree-l1"><a class="reference internal" href="units.html">Units used in QMCPACK</a></li>
<li class="toctree-l1"><a class="reference internal" href="input_overview.html">Input file overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="simulationcell.html">Specifying the system to be simulated</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro_wavefunction.html">Trial wavefunction specificaion</a></li>
<li class="toctree-l1"><a class="reference internal" href="hamiltonianobservable.html">Hamiltonian and Observables</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Quantum Monte Carlo Methods</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#variational-monte-carlo">Variational Monte Carlo</a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavefunction-optimization">Wavefunction optimization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#vmc-run-for-the-optimization">VMC run for the optimization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#correlated-sampling-and-cost-function">Correlated sampling and cost function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#optimizers">Optimizers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#oneshiftonly-optimizer">OneShiftOnly Optimizer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adaptive-organizer">Adaptive Organizer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#descent-optimizer">Descent Optimizer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hybrid-optimizer">Hybrid Optimizer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quartic-optimizer">Quartic Optimizer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#general-recommendations">General Recommendations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#optimization-of-ci-coefficients">Optimization of CI coefficients</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#diffusion-monte-carlo">Diffusion Monte Carlo</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reptation-monte-carlo">Reptation Monte Carlo</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="output_overview.html">Output Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="analyzing.html">Analyzing QMCPACK data</a></li>
<li class="toctree-l1"><a class="reference internal" href="LCAO.html">Periodic LCAO for Solids</a></li>
<li class="toctree-l1"><a class="reference internal" href="sCI.html">Selected Configuration Interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="afqmc.html">Auxiliary-Field Quantum Monte Carlo</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="lab_qmc_statistics.html">Lab 1: MC Statistical Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="lab_qmc_basics.html">Lab 2: QMC Basics</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">QMCPACK Manual</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Quantum Monte Carlo Methods</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/methods.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="quantum-monte-carlo-methods">
<span id="qmcmethods"></span><h1>Quantum Monte Carlo Methods<a class="headerlink" href="#quantum-monte-carlo-methods" title="Permalink to this headline">¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">qmc</span></code> factory element:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 44%" />
<col style="width: 56%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Parent elements</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">simulation,</span> <span class="pre">loop</span></code></p></td>
</tr>
<tr class="row-even"><td><p>type selector</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">method</span></code> attribute</p></td>
</tr>
</tbody>
</table>
<p>type options:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>vmc</p></td>
<td><p>Variational Monte Carlo</p></td>
</tr>
<tr class="row-even"><td><p>linear</p></td>
<td><p>Wavefunction optimization with linear method</p></td>
</tr>
<tr class="row-odd"><td><p>dmc</p></td>
<td><p>Diffusion Monte Carlo</p></td>
</tr>
<tr class="row-even"><td><p>rmc</p></td>
<td><p>Reptation Monte Carlo</p></td>
</tr>
</tbody>
</table>
<p>shared attributes:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 14%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Name</strong></p></th>
<th class="head"><p><strong>Datatype</strong></p></th>
<th class="head"><p><strong>Values</strong></p></th>
<th class="head"><p><strong>Default</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">method</span></code></p></td>
<td><p>text</p></td>
<td><p>listed above</p></td>
<td><p>invalid</p></td>
<td><p>QMC driver</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">move</span></code></p></td>
<td><p>text</p></td>
<td><p>pbyp, alle</p></td>
<td><p>pbyp</p></td>
<td><p>Method used to move electrons</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gpu</span></code></p></td>
<td><p>text</p></td>
<td><p>yes/no</p></td>
<td><p>dep.</p></td>
<td><p>Use the GPU</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">trace</span></code></p></td>
<td><p>text</p></td>
<td></td>
<td><p>no</p></td>
<td><p>???</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">checkpoint</span></code></p></td>
<td><p>integer</p></td>
<td><p>-1, 0, n</p></td>
<td><p>-1</p></td>
<td><p>Checkpoint frequency</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">record</span></code></p></td>
<td><p>integer</p></td>
<td><p>n</p></td>
<td><p>0</p></td>
<td><p>Save configuration ever n steps</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">target</span></code></p></td>
<td><p>text</p></td>
<td></td>
<td></td>
<td><p>???</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">completed</span></code></p></td>
<td><p>text</p></td>
<td></td>
<td></td>
<td><p>???</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">append</span></code></p></td>
<td><p>text</p></td>
<td><p>yes/no</p></td>
<td><p>no</p></td>
<td><p>???</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additional information:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">move</span></code>: There are two ways to move electrons. The more used method
is the particle-by-particle move. In this method, only one electron
is moved for acceptance or rejection. The other method is the
all-electron move; namely, all the electrons are moved once for
testing acceptance or rejection.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gpu</span></code>: When the executable is compiled with CUDA, the target
computing device can be chosen by this switch. With a regular
CPU-only compilation, this option is not effective.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">checkpoint</span></code>: This enables and disables checkpointing and
specifying the frequency of output. Possible values are:</p>
<ul>
<li><p><strong>[-1]</strong> No checkpoint (default setting).</p></li>
<li><p><strong>[0]</strong> Dump after the completion of a QMC section.</p></li>
<li><p><strong>[n]</strong> Dump after every <span class="math notranslate nohighlight">\(n\)</span> blocks.  Also dump at the end of the run.</p></li>
</ul>
</li>
</ul>
<p>The particle configurations are written to a <code class="docutils literal notranslate"><span class="pre">.config.h5</span></code> file.</p>
<div class="literal-block-wrapper docutils container" id="listing-42">
<div class="code-block-caption"><span class="caption-number">Listing 42 </span><span class="caption-text">The following is an example of running a simulation that can be restarted.</span><a class="headerlink" href="#listing-42" title="Permalink to this code">¶</a></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">qmc</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;dmc&quot;</span> <span class="n">move</span><span class="o">=</span><span class="s2">&quot;pbyp&quot;</span>  <span class="n">checkpoint</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;timestep&quot;</span><span class="o">&gt;</span>         <span class="mf">0.004</span>  <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;blocks&quot;</span><span class="o">&gt;</span>           <span class="mi">100</span>   <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;steps&quot;</span><span class="o">&gt;</span>            <span class="mi">400</span>    <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">qmc</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<p>The checkpoint flag instructs QMCPACK to output walker configurations.  This also
works in VMC.  This outputs an h5 file with the name <code class="docutils literal notranslate"><span class="pre">projectid.run-number.config.h5</span></code>.
Check that this file exists before attempting a restart.</p>
<p>To continue a run, specify the <code class="docutils literal notranslate"><span class="pre">mcwalkerset</span></code> element before your VMC/DMC block:</p>
<div class="literal-block-wrapper docutils container" id="listing-43">
<div class="code-block-caption"><span class="caption-number">Listing 43 </span><span class="caption-text">Restart (read walkers from previous run).</span><a class="headerlink" href="#listing-43" title="Permalink to this code">¶</a></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">mcwalkerset</span> <span class="n">fileroot</span><span class="o">=</span><span class="s2">&quot;BH.s002&quot;</span> <span class="n">version</span><span class="o">=</span><span class="s2">&quot;0 6&quot;</span> <span class="n">collected</span><span class="o">=</span><span class="s2">&quot;yes&quot;</span><span class="o">/&gt;</span>
 <span class="o">&lt;</span><span class="n">qmc</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;dmc&quot;</span> <span class="n">move</span><span class="o">=</span><span class="s2">&quot;pbyp&quot;</span>  <span class="n">checkpoint</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;timestep&quot;</span><span class="o">&gt;</span>         <span class="mf">0.004</span>  <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;blocks&quot;</span><span class="o">&gt;</span>           <span class="mi">100</span>   <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;steps&quot;</span><span class="o">&gt;</span>            <span class="mi">400</span>    <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
 <span class="o">&lt;/</span><span class="n">qmc</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">BH</span></code> is the project id, and <code class="docutils literal notranslate"><span class="pre">s002</span></code> is the calculation number to read in the walkers from the previous run.</p>
<p>In the project id section, make sure that the series number is different from any existing ones to avoid overwriting them.</p>
<div class="section" id="variational-monte-carlo">
<span id="vmc"></span><h2>Variational Monte Carlo<a class="headerlink" href="#variational-monte-carlo" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">vmc</span></code> method:</p>
<blockquote>
<div><p>parameters:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 24%" />
<col style="width: 11%" />
<col style="width: 19%" />
<col style="width: 10%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Name</strong></p></th>
<th class="head"><p><strong>Datatype</strong></p></th>
<th class="head"><p><strong>Values</strong></p></th>
<th class="head"><p><strong>Default</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">walkers</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>dep.</p></td>
<td><p>Number of walkers per MPI task</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">blocks</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>1</p></td>
<td><p>Number of blocks</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">steps</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>1</p></td>
<td><p>Number of steps per block</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">warmupsteps</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>0</p></td>
<td><p>Number of steps for warming up</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">substeps</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>1</p></td>
<td><p>Number of substeps per step</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">usedrift</span></code></p></td>
<td><p>text</p></td>
<td><p>yes,no</p></td>
<td><p>yes</p></td>
<td><p>Use the algorithm with drift</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">timestep</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>0.1</p></td>
<td><p>Time step for each electron move</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">samples</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>0</p></td>
<td><p>Number of walker samples for DMC/optimization</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">stepsbetweensamples</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>1</p></td>
<td><p>Period of sample accumulation</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">samplesperthread</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>0</p></td>
<td><p>Number of samples per thread</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">storeconfigs</span></code></p></td>
<td><p>integer</p></td>
<td><p>all values</p></td>
<td><p>0</p></td>
<td><p>Show configurations o</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">blocks_between_recompute</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>dep.</p></td>
<td><p>Wavefunction recompute frequency</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additional information:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">walkers</span></code> The number of walkers per MPI task. The initial default number of ixml{walkers} is one per OpenMP thread or per MPI task if threading is disabled. The number is rounded down to a multiple of the number of threads with a minimum of one per thread to ensure perfect load balancing. One walker per thread is created in the event fewer <code class="docutils literal notranslate"><span class="pre">walkers</span></code> than threads are requested.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">blocks</span></code> This parameter is universal for all the QMC
methods. The MC processes are divided into a number of
<code class="docutils literal notranslate"><span class="pre">blocks</span></code>, each containing a number of steps. At the end of each block,
the statistics accumulated in the block are dumped into files,
e.g., <code class="docutils literal notranslate"><span class="pre">scalar.dat</span></code>. Typically, each block should have a sufficient number of steps that the I/O at the end of each block is negligible
compared with the computational cost. Each block should not take so
long that monitoring its progress is difficult. There should be a
sufficient number of <code class="docutils literal notranslate"><span class="pre">blocks</span></code> to perform statistical analysis.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">warmupsteps</span></code> - <code class="docutils literal notranslate"><span class="pre">warmupsteps</span></code> are used only for
equilibration. Property measurements are not performed during
warm-up steps.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">steps</span></code> - <code class="docutils literal notranslate"><span class="pre">steps</span></code> are the number of energy and other property measurements to perform per block.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">substeps</span></code>  For each substep, an attempt is made to move each of the electrons once only by either particle-by-particle or an
all-electron move.  Because the local energy is evaluated only at
each full step and not each substep, <code class="docutils literal notranslate"><span class="pre">substeps</span></code> are computationally cheaper
and can be used to reduce the correlation between property measurements
at a lower cost.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">usedrift</span></code> The VMC is implemented in two algorithms with
or without drift. In the no-drift algorithm, the move of each
electron is proposed with a Gaussian distribution. The standard
deviation is chosen as the time step input. In the drift algorithm,
electrons are moved by Langevin dynamics.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">timestep</span></code> The meaning of time step depends on whether or not
the drift is used. In general, larger time steps reduce the
time correlation but might also reduce the acceptance ratio,
reducing overall statistical efficiency. For VMC, typically the
acceptance ratio should be close to 50% for an efficient
simulation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">samples</span></code> Seperate from conventional energy and other
property measurements, samples refers to storing whole electron
configurations in memory (“walker samples”) as would be needed by subsequent
wavefunction optimization or DMC steps. <em>A standard VMC run to
measure the energy does not need samples to be set.</em></p>
<div class="math notranslate nohighlight">
\[\texttt{samples}=
\frac{\texttt{blocks}\cdot\texttt{steps}\cdot\texttt{walkers}}{\texttt{stepsbetweensamples}}\cdot\texttt{number of MPI tasks}\]</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">samplesperthread</span></code> This is an alternative way to set the target amount of samples and can be useful when preparing a stored population for a subsequent DMC calculation.</p>
<div class="math notranslate nohighlight">
\[\texttt{samplesperthread}=
\frac{\texttt{blocks}\cdot\texttt{steps}}{\texttt{stepsbetweensamples}}\]</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">stepsbetweensamples</span></code> Because samples generated by consecutive steps are correlated, having <code class="docutils literal notranslate"><span class="pre">stepsbetweensamples</span></code> larger than 1 can be used to reduces that correlation. In practice, using larger substeps is cheaper than using <code class="docutils literal notranslate"><span class="pre">stepsbetweensamples</span></code> to decorrelate samples.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">storeconfigs</span></code> If <code class="docutils literal notranslate"><span class="pre">storeconfigs</span></code> is set to a nonzero value, then electron configurations during the VMC run are saved to files.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">blocks_between_recompute</span></code> Recompute the accuracy critical determinant part of the wavefunction
from scratch: =1 by default when using mixed precision. =0 (no
recompute) by default when not using mixed precision. Recomputing
introduces a performance penalty dependent on system size.</p></li>
</ul>
<p>An example VMC section for a simple VMC run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">qmc</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;vmc&quot;</span> <span class="n">move</span><span class="o">=</span><span class="s2">&quot;pbyp&quot;</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">estimator</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;LocalEnergy&quot;</span> <span class="n">hdf5</span><span class="o">=</span><span class="s2">&quot;no&quot;</span><span class="o">/&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;walkers&quot;</span><span class="o">&gt;</span>    <span class="mi">256</span> <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;warmupSteps&quot;</span><span class="o">&gt;</span>  <span class="mi">100</span> <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;substeps&quot;</span><span class="o">&gt;</span>  <span class="mi">5</span> <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;blocks&quot;</span><span class="o">&gt;</span>  <span class="mi">20</span> <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;steps&quot;</span><span class="o">&gt;</span>  <span class="mi">100</span> <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;timestep&quot;</span><span class="o">&gt;</span>  <span class="mf">1.0</span> <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;usedrift&quot;</span><span class="o">&gt;</span>   <span class="n">yes</span> <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">qmc</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Here we set 256 <code class="docutils literal notranslate"><span class="pre">walkers</span></code> per MPI, have a brief initial equilibration of 100 <code class="docutils literal notranslate"><span class="pre">steps</span></code>, and then have 20 <code class="docutils literal notranslate"><span class="pre">blocks</span></code> of 100 <code class="docutils literal notranslate"><span class="pre">steps</span></code> with 5 <code class="docutils literal notranslate"><span class="pre">substeps</span></code> each.</p>
<p>The following is an example of VMC section storing configurations (walker samples) for optimization.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">qmc</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;vmc&quot;</span> <span class="n">move</span><span class="o">=</span><span class="s2">&quot;pbyp&quot;</span> <span class="n">gpu</span><span class="o">=</span><span class="s2">&quot;yes&quot;</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="n">estimator</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;LocalEnergy&quot;</span> <span class="n">hdf5</span><span class="o">=</span><span class="s2">&quot;no&quot;</span><span class="o">/&gt;</span>
   <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;walkers&quot;</span><span class="o">&gt;</span>    <span class="mi">256</span> <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;samples&quot;</span><span class="o">&gt;</span>    <span class="mi">2867200</span> <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;stepsbetweensamples&quot;</span><span class="o">&gt;</span>    <span class="mi">1</span> <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;substeps&quot;</span><span class="o">&gt;</span>  <span class="mi">5</span> <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;warmupSteps&quot;</span><span class="o">&gt;</span>  <span class="mi">5</span> <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;blocks&quot;</span><span class="o">&gt;</span>  <span class="mi">70</span> <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;timestep&quot;</span><span class="o">&gt;</span>  <span class="mf">1.0</span> <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;usedrift&quot;</span><span class="o">&gt;</span>   <span class="n">no</span> <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
 <span class="o">&lt;/</span><span class="n">qmc</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="wavefunction-optimization">
<span id="optimization"></span><h2>Wavefunction optimization<a class="headerlink" href="#wavefunction-optimization" title="Permalink to this headline">¶</a></h2>
<p>Optimizing wavefunction is critical in all kinds of real-space QMC calculations
because it significantly improves both the accuracy and efficiency of computation.
However, it is very difficult to directly adopt deterministic minimization approaches because of the stochastic nature of evaluating quantities with MC.
Thanks to the algorithmic breakthrough during the first decade of this century and the tremendous computer power available,
it is now feasible to optimize tens of thousands of parameters in a wavefunction for a solid or molecule.
QMCPACK has multiple optimizers implemented based on the state-of-the-art linear method.
We are continually improving our optimizers for robustness and friendliness and are trying to provide a single solution.
Because of the large variation of wavefunction types carrying distinct characteristics, using several optimizers might be needed in some cases.
We strongly suggested reading recommendations from the experts who maintain these optimizers.</p>
<p>A typical optimization block looks like the following. It starts with method=”linear” and contains three blocks of parameters.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;loop max=&quot;10&quot;&gt;
 &lt;qmc method=&quot;linear&quot; move=&quot;pbyp&quot; gpu=&quot;yes&quot;&gt;
   &lt;!-- Specify the VMC options --&gt;
   &lt;parameter name=&quot;walkers&quot;&gt;              256 &lt;/parameter&gt;
   &lt;parameter name=&quot;samples&quot;&gt;          2867200 &lt;/parameter&gt;
   &lt;parameter name=&quot;stepsbetweensamples&quot;&gt;    1 &lt;/parameter&gt;
   &lt;parameter name=&quot;substeps&quot;&gt;               5 &lt;/parameter&gt;
   &lt;parameter name=&quot;warmupSteps&quot;&gt;            5 &lt;/parameter&gt;
   &lt;parameter name=&quot;blocks&quot;&gt;                70 &lt;/parameter&gt;
   &lt;parameter name=&quot;timestep&quot;&gt;             1.0 &lt;/parameter&gt;
   &lt;parameter name=&quot;usedrift&quot;&gt;              no &lt;/parameter&gt;
   &lt;estimator name=&quot;LocalEnergy&quot; hdf5=&quot;no&quot;/&gt;
   ...
   &lt;!-- Specify the correlated sampling options and define the cost function --&gt;
   &lt;parameter name=&quot;minwalkers&quot;&gt;            0.3 &lt;/parameter&gt;
        &lt;cost name=&quot;energy&quot;&gt;               0.95 &lt;/cost&gt;
        &lt;cost name=&quot;unreweightedvariance&quot;&gt; 0.00 &lt;/cost&gt;
        &lt;cost name=&quot;reweightedvariance&quot;&gt;   0.05 &lt;/cost&gt;
   ...
   &lt;!-- Specify the optimizer options --&gt;
   &lt;parameter name=&quot;MinMethod&quot;&gt;    OneShiftOnly &lt;/parameter&gt;
   ...
 &lt;/qmc&gt;
&lt;/loop&gt;

-  Loop is helpful to repeatedly execute identical optimization blocks.

-  The first part is highly identical to a regular VMC block.

-  The second part is to specify the correlated sampling options and
   define the cost function.

-  The last part is used to specify the options of different optimizers,
   which can be very distinct from one to another.
</pre></div>
</div>
<div class="section" id="vmc-run-for-the-optimization">
<h3>VMC run for the optimization<a class="headerlink" href="#vmc-run-for-the-optimization" title="Permalink to this headline">¶</a></h3>
<p>The VMC calculation for the wavefunction optimization has a strict requirement
that <code class="docutils literal notranslate"><span class="pre">samples</span></code> or <code class="docutils literal notranslate"><span class="pre">samplesperthread</span></code> must be specified because of the optimizer needs for the stored <code class="docutils literal notranslate"><span class="pre">samples</span></code>.
The input parameters of this part are identical to the VMC method.</p>
<p>Recommendations:</p>
<ul class="simple">
<li><p>Run the inclusive VMC calculation correctly and efficiently because
this takes a significant amount of time during optimization. For
example, make sure the derived <code class="docutils literal notranslate"><span class="pre">steps</span></code> per block is 1 and use larger <code class="docutils literal notranslate"><span class="pre">substeps</span></code> to
control the correlation between <code class="docutils literal notranslate"><span class="pre">samples</span></code>.</p></li>
<li><p>A reasonable starting wavefunction is necessary. A lot of
optimization fails because of a bad wavefunction starting point. The
sign of a bad initial wavefunction includes but is not limited to a
very long equilibration time, low acceptance ratio, and huge
variance. The first thing to do after a failed optimization is to
check the information provided by the VMC calculation via
<code class="docutils literal notranslate"><span class="pre">*.scalar.dat</span> <span class="pre">files</span></code>.</p></li>
</ul>
</div>
<div class="section" id="correlated-sampling-and-cost-function">
<h3>Correlated sampling and cost function<a class="headerlink" href="#correlated-sampling-and-cost-function" title="Permalink to this headline">¶</a></h3>
<p>After generating the samples with VMC, the derivatives of the wavefunction with respect to the parameters are computed for proposing a new set of parameters by optimizers.
And later, a correlated sampling calculation is performed to quickly evaluate values of the cost function on the old set of parameters and the new set for further decisions.
The input parameters are listed in the following table.</p>
<p><code class="docutils literal notranslate"><span class="pre">linear</span></code> method:</p>
<blockquote>
<div><p>parameters:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 13%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Name</strong></p></th>
<th class="head"><p><strong>Datatype</strong></p></th>
<th class="head"><p><strong>Values</strong></p></th>
<th class="head"><p><strong>Default</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">nonlocalpp</span></code></p></td>
<td><p>text</p></td>
<td><p>yes, no</p></td>
<td><p>no</p></td>
<td><p>include non-local PP energy in the cost function</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">minwalkers</span></code></p></td>
<td><p>real</p></td>
<td><p>0–1</p></td>
<td><p>0.3</p></td>
<td><p>Lower bound of the effective weight</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">maxWeight</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 1\)</span></p></td>
<td><p>1e6</p></td>
<td><p>Maximum weight allowed in reweighting</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additional information:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">maxWeight</span></code> The default should be good.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nonlocalpp</span></code> The <code class="docutils literal notranslate"><span class="pre">nonlocalpp</span></code> contribution to the local energy depends on the
wavefunction. When a new set of parameters is proposed, this
contribution needs to be updated if the cost function consists of local
energy. Fortunately, nonlocal contribution is chosen small when making a
PP for small locality error. We can ignore its change and avoid the
expensive computational cost. An implementation issue with GPU code is
that a large amount of memory is consumed with this option.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">minwalkers</span></code> This is a <code class="docutils literal notranslate"><span class="pre">critical</span></code> parameter. When the ratio of effective samples to actual number of samples in a reweighting step goes lower than <code class="docutils literal notranslate"><span class="pre">minwalkers</span></code>,
the proposed set of parameters is invalid.</p></li>
</ul>
<p>The cost function consists of three components: energy, unreweighted variance, and reweighted variance.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">cost</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;energy&quot;</span><span class="o">&gt;</span>                   <span class="mf">0.95</span> <span class="o">&lt;/</span><span class="n">cost</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">cost</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;unreweightedvariance&quot;</span><span class="o">&gt;</span>     <span class="mf">0.00</span> <span class="o">&lt;/</span><span class="n">cost</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">cost</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;reweightedvariance&quot;</span><span class="o">&gt;</span>       <span class="mf">0.05</span> <span class="o">&lt;/</span><span class="n">cost</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="optimizers">
<h3>Optimizers<a class="headerlink" href="#optimizers" title="Permalink to this headline">¶</a></h3>
<p>QMCPACK implements a number of different optimizers each with different
priorities for accuracy, convergence, memory usage, and stability. The
optimizers can be switched among “OneShiftOnly” (default), “adaptive,”
“descent,” “hybrid,” and “quartic” (old) using the following line in the
optimization block:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;MinMethod&quot;</span><span class="o">&gt;</span> <span class="n">THE</span> <span class="n">METHOD</span> <span class="n">YOU</span> <span class="n">LIKE</span> <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="oneshiftonly-optimizer">
<h3>OneShiftOnly Optimizer<a class="headerlink" href="#oneshiftonly-optimizer" title="Permalink to this headline">¶</a></h3>
<p>The OneShiftOnly optimizer targets a fast optimization by moving parameters more aggressively. It works with OpenMP and GPU and can be considered for large systems.
This method relies on the effective weight of correlated sampling rather than the cost function value to justify a new set of parameters.
If the effective weight is larger than <code class="docutils literal notranslate"><span class="pre">minwalkers</span></code>, the new set is taken whether or not the cost function value decreases.
If a proposed set is rejected, the standard output prints the measured ratio of effective samples to the total number of samples
and adjustment on <code class="docutils literal notranslate"><span class="pre">minwalkers</span></code> can be made if needed.</p>
<p><code class="docutils literal notranslate"><span class="pre">linear</span></code> method:</p>
<blockquote>
<div><p>parameters:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Name</strong></p></th>
<th class="head"><p><strong>Datatype</strong></p></th>
<th class="head"><p><strong>Values</strong></p></th>
<th class="head"><p><strong>Default</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">shift_i</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>0.01</p></td>
<td><p>Direct stabilizer added to the Hamiltonian matrix</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">shift_s</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>1.00</p></td>
<td><p>Initial stabilizer based on the overlap matrix</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additional information:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">shift_i</span></code> This is the direct term added to the diagonal of the Hamiltonian
matrix. It provides more stable but slower optimization with a large
value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shift_s</span></code> This is the initial value of the stabilizer based on the overlap
matrix added to the Hamiltonian matrix. It provides more stable but
slower optimization with a large value. The used value is
auto-adjusted by the optimizer.</p></li>
</ul>
<p>Recommendations:</p>
<ul class="simple">
<li><p>Default <code class="docutils literal notranslate"><span class="pre">shift_i</span></code>, <code class="docutils literal notranslate"><span class="pre">shift_s</span></code> should be fine.</p></li>
<li><p>For hard cases, increasing <code class="docutils literal notranslate"><span class="pre">shift_i</span></code> (by a factor of 5 or 10) can significantly stabilize the optimization by reducing the pace towards the optimal parameter set.</p></li>
<li><p>If the VMC energy of the last optimization iterations grows significantly, increase <code class="docutils literal notranslate"><span class="pre">minwalkers</span></code> closer to 1 and make the optimization stable.</p></li>
<li><p>If the first iterations of optimization are rejected on a reasonable initial wavefunction,
lower the <code class="docutils literal notranslate"><span class="pre">minwalkers</span></code> value based on the measured value printed in the standard output to accept the move.</p></li>
</ul>
<p>We recommended using this optimizer in two sections with a very small <code class="docutils literal notranslate"><span class="pre">minwalkers</span></code> in the first and a large value in the second, such as the following.
In the very beginning, parameters are far away from optimal values and large changes are proposed by the optimizer.
Having a small <code class="docutils literal notranslate"><span class="pre">minwalkers</span></code> makes it much easier to accept these changes.
When the energy gradually converges, we can have a large <code class="docutils literal notranslate"><span class="pre">minwalkers</span></code> to avoid risky parameter sets.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;loop max=&quot;6&quot;&gt;
 &lt;qmc method=&quot;linear&quot; move=&quot;pbyp&quot; gpu=&quot;yes&quot;&gt;
   &lt;!-- Specify the VMC options --&gt;
   &lt;parameter name=&quot;walkers&quot;&gt;                1 &lt;/parameter&gt;
   &lt;parameter name=&quot;samples&quot;&gt;            10000 &lt;/parameter&gt;
   &lt;parameter name=&quot;stepsbetweensamples&quot;&gt;    1 &lt;/parameter&gt;
   &lt;parameter name=&quot;substeps&quot;&gt;               5 &lt;/parameter&gt;
   &lt;parameter name=&quot;warmupSteps&quot;&gt;            5 &lt;/parameter&gt;
   &lt;parameter name=&quot;blocks&quot;&gt;                25 &lt;/parameter&gt;
   &lt;parameter name=&quot;timestep&quot;&gt;             1.0 &lt;/parameter&gt;
   &lt;parameter name=&quot;usedrift&quot;&gt;              no &lt;/parameter&gt;
   &lt;estimator name=&quot;LocalEnergy&quot; hdf5=&quot;no&quot;/&gt;
   &lt;!-- Specify the optimizer options --&gt;
   &lt;parameter name=&quot;MinMethod&quot;&gt;    OneShiftOnly &lt;/parameter&gt;
   &lt;parameter name=&quot;minwalkers&quot;&gt;           1e-4 &lt;/parameter&gt;
 &lt;/qmc&gt;
&lt;/loop&gt;
&lt;loop max=&quot;12&quot;&gt;
 &lt;qmc method=&quot;linear&quot; move=&quot;pbyp&quot; gpu=&quot;yes&quot;&gt;
   &lt;!-- Specify the VMC options --&gt;
   &lt;parameter name=&quot;walkers&quot;&gt;                1 &lt;/parameter&gt;
   &lt;parameter name=&quot;samples&quot;&gt;            20000 &lt;/parameter&gt;
   &lt;parameter name=&quot;stepsbetweensamples&quot;&gt;    1 &lt;/parameter&gt;
   &lt;parameter name=&quot;substeps&quot;&gt;               5 &lt;/parameter&gt;
   &lt;parameter name=&quot;warmupSteps&quot;&gt;            2 &lt;/parameter&gt;
   &lt;parameter name=&quot;blocks&quot;&gt;                50 &lt;/parameter&gt;
   &lt;parameter name=&quot;timestep&quot;&gt;             1.0 &lt;/parameter&gt;
   &lt;parameter name=&quot;usedrift&quot;&gt;              no &lt;/parameter&gt;
   &lt;estimator name=&quot;LocalEnergy&quot; hdf5=&quot;no&quot;/&gt;
   &lt;!-- Specify the optimizer options --&gt;
   &lt;parameter name=&quot;MinMethod&quot;&gt;    OneShiftOnly &lt;/parameter&gt;
   &lt;parameter name=&quot;minwalkers&quot;&gt;            0.5 &lt;/parameter&gt;
 &lt;/qmc&gt;
&lt;/loop&gt;
</pre></div>
</div>
<p>For each optimization step, you will see</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>The new set of parameters is valid. Updating the trial wave function!
</pre></div>
</div>
<p>or</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>The new set of parameters is not valid. Revert to the old set!
</pre></div>
</div>
<p>Occasional rejection is fine. Frequent rejection indicates potential
problems, and users should inspect the VMC calculation or change
optimization strategy. To track the progress of optimization, use the
command <code class="docutils literal notranslate"><span class="pre">qmca</span> <span class="pre">-q</span> <span class="pre">ev</span> <span class="pre">*.scalar.dat</span></code> to look at the VMC energy and
variance for each optimization step.</p>
</div>
<div class="section" id="adaptive-organizer">
<h3>Adaptive Organizer<a class="headerlink" href="#adaptive-organizer" title="Permalink to this headline">¶</a></h3>
<p>The default setting of the adaptive optimizer is to construct the linear
method Hamiltonian and overlap matrices explicitly and add different
shifts to the Hamiltonian matrix as “stabilizers.” The generalized
eigenvalue problem is solved for each shift to obtain updates to the
wavefunction parameters. Then a correlated sampling is performed for
each shift’s updated wavefunction and the initial trial wavefunction
using the middle shift’s updated wavefunction as the guiding function.
The cost function for these wavefunctions is compared, and the update
corresponding to the best cost function is selected. In the next
iteration, the median magnitude of the stabilizers is set to the
magnitude that generated the best update in the current iteration, thus
adapting the magnitude of the stabilizers automatically.</p>
<p>When the trial wavefunction contains more than 10,000 parameters,
constructing and storing the linear method matrices could become a
memory bottleneck. To avoid explicit construction of these matrices, the
adaptive optimizer implements the block linear method (BLM) approach.
<a class="bibtex reference internal" href="#zhao-2017-blocked-lm" id="id1">[ZN17]</a> The BLM tries to find an
approximate solution <span class="math notranslate nohighlight">\(\vec{c}_{opt}\)</span> to the standard LM
generalized eigenvalue problem by dividing the variable space into a
number of blocks and making intelligent estimates for which directions
within those blocks will be most important for constructing
<span class="math notranslate nohighlight">\(\vec{c}_{opt}\)</span>, which is then obtained by solving a smaller, more
memory-efficient eigenproblem in the basis of these supposedly important
block-wise directions.</p>
<p><code class="docutils literal notranslate"><span class="pre">linear</span></code> method:</p>
<blockquote>
<div><p>parameters:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 8%" />
<col style="width: 14%" />
<col style="width: 7%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Name</strong></p></th>
<th class="head"><p><strong>Datatype</strong></p></th>
<th class="head"><p><strong>Values</strong></p></th>
<th class="head"><p><strong>Default</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">max_relative_change</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>10.0</p></td>
<td><p>Allowed change in cost function</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">max_param_change</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>0.3</p></td>
<td><p>Allowed change in wavefunction parameter</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">shift_i</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>0.01</p></td>
<td><p>Initial diagonal stabilizer added to the Hamiltonian matrix</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">shift_s</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>1.00</p></td>
<td><p>Initial overlap-based stabilizer added to the Hamiltonian matrix</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">target_shift_i</span></code></p></td>
<td><p>real</p></td>
<td><p>any</p></td>
<td><p>-1.0</p></td>
<td><p>Diagonal stabilizer value aimed for during adaptive method (disabled if <span class="math notranslate nohighlight">\(\leq 0\)</span>)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cost_increase_tol</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>0.0</p></td>
<td><p>Tolerance for cost function increases</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">chase_lowest</span></code></p></td>
<td><p>text</p></td>
<td><p>yes, no</p></td>
<td><p>yes</p></td>
<td><p>Chase the lowest eigenvector in iterative solver</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">chase_closest</span></code></p></td>
<td><p>text</p></td>
<td><p>yes, no</p></td>
<td><p>no</p></td>
<td><p>Chase the eigenvector closest to initial guess</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">block_lm</span></code></p></td>
<td><p>text</p></td>
<td><p>yes, no</p></td>
<td><p>no</p></td>
<td><p>Use BLM</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">blocks</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td></td>
<td><p>Number of blocks in BLM</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">nolds</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td></td>
<td><p>Number of old update vectors used in BLM</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">nkept</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td></td>
<td><p>Number of eigenvectors to keep per block in BLM</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additional information:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">shift_i</span></code> This is the initial coefficient used to scale the diagonal
stabilizer. More stable but slower optimization is expected with a
large value. The adaptive method will automatically adjust this value
after each linear method iteration.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shift_s</span></code> This is the initial coefficient used to scale the overlap-based
stabilizer. More stable but slower optimization is expected with a
large value. The adaptive method will automatically adjust this value
after each linear method iteration.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">target_shift_i</span></code> If set greater than zero, the adaptive method will choose the
update whose shift_i value is closest to this target value so long as
the associated cost is within cost_increase_tol of the lowest cost.
Disable this behavior by setting target_shift_i to a negative number.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cost_increase_tol</span></code> Tolerance for cost function increases when selecting the best
shift.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nblocks</span></code> This is the number of blocks used in BLM. The amount of memory
required to store LM matrices decreases as the number of blocks
increases. But the error introduced by BLM would increase as the
number of blocks increases.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nolds</span></code> In BLM, the interblock correlation is accounted for by including a
small number of wavefunction update vectors outside the block. Larger
would include more interblock correlation and more accurate results
but also higher memory requirements.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nkept</span></code> This is the number of update directions retained from each block in
the BLM. If all directions are retained in each block, then the BLM
becomes equivalent to the standard LM. Retaining five or fewer
directions per block is often sufficient.</p></li>
</ul>
<p>Recommendations:</p>
<ul class="simple">
<li><p>Default <code class="docutils literal notranslate"><span class="pre">shift_i</span></code>, <code class="docutils literal notranslate"><span class="pre">shift_s</span></code> should be fine.</p></li>
<li><p>When there are fewer than about 5,000 variables being optimized, the
traditional LM is preferred because it has a lower overhead than the
BLM when the number of variables is small.</p></li>
<li><p>Initial experience with the BLM suggests that a few hundred blocks
and a handful of and often provide a good balance between memory use
and accuracy. In general, using fewer blocks should be more accurate
but would require more memory.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;loop max=&quot;15&quot;&gt;
 &lt;qmc method=&quot;linear&quot; move=&quot;pbyp&quot;&gt;
   &lt;!-- Specify the VMC options --&gt;
   &lt;parameter name=&quot;walkers&quot;&gt;                1 &lt;/parameter&gt;
   &lt;parameter name=&quot;samples&quot;&gt;            20000 &lt;/parameter&gt;
   &lt;parameter name=&quot;stepsbetweensamples&quot;&gt;    1 &lt;/parameter&gt;
   &lt;parameter name=&quot;substeps&quot;&gt;               5 &lt;/parameter&gt;
   &lt;parameter name=&quot;warmupSteps&quot;&gt;            5 &lt;/parameter&gt;
   &lt;parameter name=&quot;blocks&quot;&gt;                50 &lt;/parameter&gt;
   &lt;parameter name=&quot;timestep&quot;&gt;             1.0 &lt;/parameter&gt;
   &lt;parameter name=&quot;usedrift&quot;&gt;              no &lt;/parameter&gt;
   &lt;estimator name=&quot;LocalEnergy&quot; hdf5=&quot;no&quot;/&gt;
   &lt;!-- Specify the correlated sampling options and define the cost function --&gt;
        &lt;cost name=&quot;energy&quot;&gt;               1.00 &lt;/cost&gt;
        &lt;cost name=&quot;unreweightedvariance&quot;&gt; 0.00 &lt;/cost&gt;
        &lt;cost name=&quot;reweightedvariance&quot;&gt;   0.00 &lt;/cost&gt;
   &lt;!-- Specify the optimizer options --&gt;
   &lt;parameter name=&quot;MinMethod&quot;&gt;adaptive&lt;/parameter&gt;
   &lt;parameter name=&quot;max_relative_cost_change&quot;&gt;10.0&lt;/parameter&gt;
   &lt;parameter name=&quot;shift_i&quot;&gt; 1.00 &lt;/parameter&gt;
   &lt;parameter name=&quot;shift_s&quot;&gt; 1.00 &lt;/parameter&gt;
   &lt;parameter name=&quot;max_param_change&quot;&gt; 0.3 &lt;/parameter&gt;
   &lt;parameter name=&quot;chase_lowest&quot;&gt; yes &lt;/parameter&gt;
   &lt;parameter name=&quot;chase_closest&quot;&gt; yes &lt;/parameter&gt;
   &lt;parameter name=&quot;block_lm&quot;&gt; no &lt;/parameter&gt;
   &lt;!-- Specify the BLM specific options if needed
     &lt;parameter name=&quot;nblocks&quot;&gt; 100 &lt;/parameter&gt;
     &lt;parameter name=&quot;nolds&quot;&gt; 5 &lt;/parameter&gt;
     &lt;parameter name=&quot;nkept&quot;&gt; 3 &lt;/parameter&gt;
   --&gt;
 &lt;/qmc&gt;
&lt;/loop&gt;
</pre></div>
</div>
<p>The adaptive optimizer is also able to optimize individual excited states directly. <a class="bibtex reference internal" href="#zhao-2016-dir-tar" id="id2">[ZN16]</a>
In this case, it tries to minimize the following function:</p>
<div class="math notranslate nohighlight">
\[\Omega[\Psi]=\frac{\left&lt;\Psi|\omega-H|\Psi\right&gt;}{\left&lt;\Psi|{\left(\omega-H\right)}^2|\Psi\right&gt;}\:.\]</div>
<p>The global minimum of this function corresponds to the state whose
energy lies immediately above the shift parameter <span class="math notranslate nohighlight">\(\omega\)</span> in the
energy spectrum. For example, if <span class="math notranslate nohighlight">\(\omega\)</span> were placed in between
the ground state energy and the first excited state energy and the
wavefunction ansatz was capable of a good description for the first
excited state, then the wavefunction would be optimized for the first
excited state. Note that if the ansatz is not capable of a good
description of the excited state in question, the optimization could
converge to a different state, as is known to occur in some
circumstances for traditional ground state optimizations. Note also that
the ground state can be targeted by this method by choosing
<span class="math notranslate nohighlight">\(\omega\)</span> to be below the ground state energy, although we should
stress that this is not the same thing as a traditional ground state
optimization and will in general give a slightly different wavefunction.
Excited state targeting requires two additional parameters, as shown in
the following table.</p>
<p>Excited state targeting:</p>
<blockquote>
<div><p>parameters:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 11%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Name</strong></p></th>
<th class="head"><p><strong>Datatype</strong></p></th>
<th class="head"><p><strong>Values</strong></p></th>
<th class="head"><p><strong>Default</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">targetExcited</span></code></p></td>
<td><p>text</p></td>
<td><p>yes, no</p></td>
<td><p>no</p></td>
<td><p>Whether to use the excited state targeting optimization</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">omega</span></code></p></td>
<td><p>real</p></td>
<td><p>real numbers</p></td>
<td><p>none</p></td>
<td><p>Energy shift used to target different excited states</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Excited state recommendations:</p>
<ul class="simple">
<li><p>Because of the finite variance in any approximate wavefunction, we
recommended setting <span class="math notranslate nohighlight">\(\omega=\omega_0-\sigma\)</span>, where
<span class="math notranslate nohighlight">\(\omega_0\)</span> is placed just below the energy of the targeted
state and <span class="math notranslate nohighlight">\(\sigma^2\)</span> is the energy variance.</p></li>
<li><p>To obtain an unbiased excitation energy, the ground state should be
optimized with the excited state variational principle as well by
setting <code class="docutils literal notranslate"><span class="pre">omega</span></code> below the ground state energy. Note that using the ground
state variational principle for the ground state and the excited
state variational principle for the excited state creates a bias in
favor of the ground state.</p></li>
</ul>
</div>
<div class="section" id="descent-optimizer">
<h3>Descent Optimizer<a class="headerlink" href="#descent-optimizer" title="Permalink to this headline">¶</a></h3>
<p>Gradient descent algorithms are an alternative set of optimization methods to the OneShiftOnly and adaptive optimizers based on the linear method.
These methods use only first derivatives to optimize trial wave functions and convergence can be accelerated by retaining a memory of previous derivative values.
Multiple flavors of accelerated descent methods are available. They differ in details such as the schemes for adaptive adjustment of step sizes. <a class="bibtex reference internal" href="#otis2019" id="id3">[ON19]</a>
Descent algorithms avoid the construction of matrices that occurs in the linear method and consequently can be applied to larger sets of
optimizable parameters.
Currently, descent optimization is only available for ground state calculations.
Parameters for descent are shown in the table below.</p>
<p><code class="docutils literal notranslate"><span class="pre">descent</span></code> method:</p>
<blockquote>
<div><p>parameters:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 10%" />
<col style="width: 22%" />
<col style="width: 9%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Name</strong></p></th>
<th class="head"><p><strong>Datatype</strong></p></th>
<th class="head"><p><strong>Values</strong></p></th>
<th class="head"><p><strong>Default</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">flavor</span></code></p></td>
<td><p>text</p></td>
<td><p>RMSprop, Random, ADAM, AMSGrad</p></td>
<td><p>RMSprop</p></td>
<td><p>Particular type of descent method</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">Ramp_eta</span></code></p></td>
<td><p>text</p></td>
<td><p>yes, no</p></td>
<td><p>no</p></td>
<td><p>Whether to gradually ramp up step sizes</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">Ramp_num</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>30</p></td>
<td><p>Number of steps over which to ramp up step size</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">TJF_2Body_eta</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>0.01</p></td>
<td><p>Step size for two body Jastrow parameters</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">TJF_1Body_eta</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>0.01</p></td>
<td><p>Step size for one body Jastrow parameters</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">F_eta</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>0.001</p></td>
<td><p>Step size for number counting Jastrow F matrix parameters</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">Gauss_eta</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>0.001</p></td>
<td><p>Step size for number counting Jastrow gaussian basis parameters</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">CI_eta</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>0.01</p></td>
<td><p>Step size for CI parameters</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">Orb_eta</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>0.001</p></td>
<td><p>Step size for orbital parameters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additional information and recommendations:</p>
<ul class="simple">
<li><p>It is generally advantageous to set different step sizes for
different types of parameters. More nonlinear parameters such as
those for number counting Jastrow factors or orbitals typically
require smaller steps sizes than those for CI coefficients or
traditional Jastrow parameters. There are defaults for several
parameter types and a default of .001 has been chosen for all other
parameters.</p></li>
<li><p>The ability to gradually ramp up step sizes to their input values is
useful for avoiding spikes in the average local energy during early
iterations of descent optimization. This initial rise in the energy
occurs as a memory of past gradients is being built up and it may be
possible for the energy to recover without ramping if there are
enough iterations in the optimization.</p></li>
<li><p>The step sizes chosen can have a substantial influence on the quality
of the optimization and the final variational energy achieved. Larger
step sizes may be helpful if there is reason to think the descent
optimization is not reaching the minimum energy. There are also
additional hyperparameters in the descent algorithms with default
values. <a class="bibtex reference internal" href="#otis2019" id="id4">[ON19]</a> They seem to have limited
influence on the effectiveness of the optimization compared to step
sizes, but users can adjust them within the source code of the
descent engine if they wish.</p></li>
<li><p>The sampling effort for individual descent steps can be small
compared that for linear method iterations as shown in the example
input below. Something in the range of 10,000 to 30,000 seems
sufficient for molecules with tens of electrons. However, descent
optimizations may require anywhere from a few hundred to a few
thousand iterations.</p></li>
<li><p>In cases where a descent optimization struggles to reach the minimum
and a linear method optimization is not possible or unsatisfactory,
it may be useful to try the hybrid optimization approach described in
the next subsection.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;loop max=&quot;100&quot;&gt;
   &lt;qmc method=&quot;linear&quot; move=&quot;pbyp&quot; checkpoint=&quot;-1&quot; gpu=&quot;no&quot;&gt;

   &lt;!-- VMC inputs --&gt;
    &lt;parameter name=&quot;blocks&quot;&gt;2000&lt;/parameter&gt;
    &lt;parameter name=&quot;steps&quot;&gt;1&lt;/parameter&gt;
    &lt;parameter name=&quot;samples&quot;&gt;20000&lt;/parameter&gt;
    &lt;parameter name=&quot;warmupsteps&quot;&gt;100&lt;/parameter&gt;
    &lt;parameter name=&quot;timestep&quot;&gt;0.05&lt;/parameter&gt;

    &lt;parameter name=&quot;MinMethod&quot;&gt;descent&lt;/parameter&gt;
    &lt;estimator name=&quot;LocalEnergy&quot; hdf5=&quot;no&quot;/&gt;
    &lt;parameter name=&quot;usebuffer&quot;&gt;yes&lt;/parameter&gt;

    &lt;estimator name=&quot;LocalEnergy&quot; hdf5=&quot;no&quot;/&gt;

    &lt;!-- Descent Inputs --&gt;
      &lt;parameter name=&quot;flavor&quot;&gt;RMSprop&lt;/parameter&gt;

      &lt;parameter name=&quot;Ramp_eta&quot;&gt;no&lt;/parameter&gt;
      &lt;parameter name=&quot;Ramp_num&quot;&gt;30&lt;/parameter&gt;

     &lt;parameter name=&quot;TJF_2Body_eta&quot;&gt;.02&lt;/parameter&gt;
      &lt;parameter name=&quot;TJF_1Body_eta&quot;&gt;.02&lt;/parameter&gt;
     &lt;parameter name=&quot;F_eta&quot;&gt;.001&lt;/parameter&gt;
     &lt;parameter name=&quot;Gauss_eta&quot;&gt;.001&lt;/parameter&gt;
     &lt;parameter name=&quot;CI_eta&quot;&gt;.1&lt;/parameter&gt;
     &lt;parameter name=&quot;Orb_eta&quot;&gt;.0001&lt;/parameter&gt;


   &lt;/qmc&gt;
&lt;/loop&gt;
</pre></div>
</div>
</div>
<div class="section" id="hybrid-optimizer">
<h3>Hybrid Optimizer<a class="headerlink" href="#hybrid-optimizer" title="Permalink to this headline">¶</a></h3>
<p>Another optimization option is to use a hybrid combination of accelerated descent and blocked linear method.
It provides a means to retain the advantages of both individual methods while scaling to large numbers of parameters beyond the traditional 10,000 parameter limit of the linear method. <a class="bibtex reference internal" href="#otis2019" id="id5">[ON19]</a>
In a hybrid optimization, alternating sections of descent and BLM optimization are used.
Gradient descent is used to identify the previous important directions in parameter space used by the BLM, the number of which is set by the <code class="docutils literal notranslate"><span class="pre">nold</span></code> input for the BLM.
Over the course of a section of descent, vectors of parameter differences are stored and then passed to the linear method engine after the optimization changes to the BLM.
One motivation for including sections of descent is to counteract noise in linear method updates due to uncertainties in its step direction and allow for a smoother movement to the minimum.
There are two additional parameters used in the hybrid optimization and it requires a slightly different format of input to specify the constituent methods as shown below in the example.</p>
<p><code class="docutils literal notranslate"><span class="pre">descent</span></code> method:</p>
<blockquote>
<div><p>parameters:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 14%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Name</strong></p></th>
<th class="head"><p><strong>Datatype</strong></p></th>
<th class="head"><p><strong>Values</strong></p></th>
<th class="head"><p><strong>Default</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">num_updates</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td></td>
<td><p>Number of steps for a method</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">Stored_Vectors</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>5</p></td>
<td><p>Number of vectors to transfer to BLM</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">loop</span> <span class="nb">max</span><span class="o">=</span><span class="s2">&quot;203&quot;</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">qmc</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span> <span class="n">move</span><span class="o">=</span><span class="s2">&quot;pbyp&quot;</span> <span class="n">checkpoint</span><span class="o">=</span><span class="s2">&quot;-1&quot;</span> <span class="n">gpu</span><span class="o">=</span><span class="s2">&quot;no&quot;</span><span class="o">&gt;</span>
 <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Minmethod&quot;</span><span class="o">&gt;</span> <span class="n">hybrid</span> <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>

 <span class="o">&lt;</span><span class="n">optimizer</span> <span class="n">num_updates</span><span class="o">=</span><span class="s2">&quot;100&quot;</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;blocks&quot;</span><span class="o">&gt;</span><span class="mi">1000</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;steps&quot;</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;samples&quot;</span><span class="o">&gt;</span><span class="mi">20000</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;warmupsteps&quot;</span><span class="o">&gt;</span><span class="mi">1000</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;timestep&quot;</span><span class="o">&gt;</span><span class="mf">0.05</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>

     <span class="o">&lt;</span><span class="n">estimator</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;LocalEnergy&quot;</span> <span class="n">hdf5</span><span class="o">=</span><span class="s2">&quot;no&quot;</span><span class="o">/&gt;</span>

     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Minmethod&quot;</span><span class="o">&gt;</span> <span class="n">descent</span> <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Stored_Vectors&quot;</span><span class="o">&gt;</span><span class="mi">5</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;flavor&quot;</span><span class="o">&gt;</span><span class="n">RMSprop</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;TJF_2Body_eta&quot;</span><span class="o">&gt;.</span><span class="mi">01</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;TJF_1Body_eta&quot;</span><span class="o">&gt;.</span><span class="mi">01</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CI_eta&quot;</span><span class="o">&gt;.</span><span class="mi">1</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>

     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Ramp_eta&quot;</span><span class="o">&gt;</span><span class="n">no</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Ramp_num&quot;</span><span class="o">&gt;</span><span class="mi">10</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
 <span class="o">&lt;/</span><span class="n">optimizer</span><span class="o">&gt;</span>

 <span class="o">&lt;</span><span class="n">optimizer</span> <span class="n">num_updates</span><span class="o">=</span><span class="s2">&quot;3&quot;</span><span class="o">&gt;</span>

     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;blocks&quot;</span><span class="o">&gt;</span><span class="mi">2000</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;steps&quot;</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;samples&quot;</span><span class="o">&gt;</span><span class="mi">1000000</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;warmupsteps&quot;</span><span class="o">&gt;</span><span class="mi">1000</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;timestep&quot;</span><span class="o">&gt;</span><span class="mf">0.05</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>

     <span class="o">&lt;</span><span class="n">estimator</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;LocalEnergy&quot;</span> <span class="n">hdf5</span><span class="o">=</span><span class="s2">&quot;no&quot;</span><span class="o">/&gt;</span>

     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Minmethod&quot;</span><span class="o">&gt;</span> <span class="n">adaptive</span> <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;max_relative_cost_change&quot;</span><span class="o">&gt;</span><span class="mf">10.0</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;max_param_change&quot;</span><span class="o">&gt;</span><span class="mi">3</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;shift_i&quot;</span><span class="o">&gt;</span><span class="mf">0.01</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;shift_s&quot;</span><span class="o">&gt;</span><span class="mf">1.00</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>

     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;block_lm&quot;</span><span class="o">&gt;</span><span class="n">yes</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;nblocks&quot;</span><span class="o">&gt;</span><span class="mi">2</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;nolds&quot;</span><span class="o">&gt;</span><span class="mi">5</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;nkept&quot;</span><span class="o">&gt;</span><span class="mi">5</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>

 <span class="o">&lt;/</span><span class="n">optimizer</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">qmc</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">loop</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Additional information and recommendations:</p>
<ul class="simple">
<li><p>In the example above, the input for <code class="docutils literal notranslate"><span class="pre">loop</span></code> gives the total number
of steps for the full optimization while the inputs for
<code class="docutils literal notranslate"><span class="pre">num_updates</span></code> specify the number of steps in the constituent
methods. For this case, the optimization would begin with 100 steps
of descent using the parameters in the first <code class="docutils literal notranslate"><span class="pre">optimizer</span></code> block and
then switch to the BLM for 3 steps before switching back to descent
for the final 100 iterations of the total of 203.</p></li>
<li><p>The design of the hybrid method allows for more than two
<code class="docutils literal notranslate"><span class="pre">optimizer</span></code> blocks to be used and the optimization will cycle
through the individual methods. However, the effectiveness of this in
terms of the quality of optimization results is unexplored.</p></li>
<li><p>As the descent algorithms are currently only implemented for ground
state optimizations, this hybrid combination of them with the BLM is
also restricted to the ground state for now.</p></li>
<li><p>It can be useful to follow a hybrid optimization with a section of
pure descent optimization and take an average energy over the last
few hundred iterations as the final variational energy. This approach
can achieve a lower statistical uncertainty on the energy for less
overall sampling effort compared to what a pure linear method
optimization would require.</p></li>
</ul>
</div>
<div class="section" id="quartic-optimizer">
<h3>Quartic Optimizer<a class="headerlink" href="#quartic-optimizer" title="Permalink to this headline">¶</a></h3>
<p><em>This is an older optimizer method retained for compatibility. We
recommend starting with the newest OneShiftOnly or adaptive optimizers.</em>
The quartic optimizer fits a quartic polynomial to 7 values of the cost
function obtained using reweighting along the chosen direction and
determines the optimal move. This optimizer is very robust but is a bit
conservative when accepting new steps, especially when large parameters
changes are proposed.</p>
<p><code class="docutils literal notranslate"><span class="pre">linear</span></code> method:</p>
<blockquote>
<div><p>parameters:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Name</strong></p></th>
<th class="head"><p><strong>Datatype</strong></p></th>
<th class="head"><p><strong>Values</strong></p></th>
<th class="head"><p><strong>Default</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">bigchange</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>50.0</p></td>
<td><p>Largest parameter change allowed</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">alloweddifference</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>1e-4</p></td>
<td><p>Allowed increase in energy</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">exp0</span></code></p></td>
<td><p>real</p></td>
<td><p>any value</p></td>
<td><p>-16.0</p></td>
<td><p>Initial value for stabilizer</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">stabilizerscale</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>2.0</p></td>
<td><p>Increase in value of <code class="docutils literal notranslate"><span class="pre">exp0</span></code> between iterations</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">nstabilizers</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>3</p></td>
<td><p>Number of stabilizers to try</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">max_its</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>1</p></td>
<td><p>Number of inner loops with same samples</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additional information:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">exp0</span></code> This is the initial value for stabilizer (shift to diagonal of H).
The actual value of stabilizer is <span class="math notranslate nohighlight">\(10^{\textrm{exp0}}\)</span>.</p></li>
</ul>
<p>Recommendations:</p>
<ul class="simple">
<li><p>For hard cases (e.g., simultaneous optimization of long MSD and
3-Body J), set <code class="docutils literal notranslate"><span class="pre">exp0</span></code> to 0 and do a single inner iteration (max its=1) per
sample of configurations.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;!-- Specify the optimizer options --&gt;
&lt;parameter name=&quot;MinMethod&quot;&gt;quartic&lt;/parameter&gt;
&lt;parameter name=&quot;exp0&quot;&gt;-6&lt;/parameter&gt;
&lt;parameter name=&quot;alloweddifference&quot;&gt; 1.0e-4 &lt;/parameter&gt;
&lt;parameter name=&quot;nstabilizers&quot;&gt; 1 &lt;/parameter&gt;
&lt;parameter name=&quot;bigchange&quot;&gt;15.0&lt;/parameter&gt;
</pre></div>
</div>
</div>
<div class="section" id="general-recommendations">
<h3>General Recommendations<a class="headerlink" href="#general-recommendations" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>All electron wavefunctions are typically more difficult to optimize
than pseudopotential wavefunctions because of the importance of the
wavefunction near the nucleus.</p></li>
<li><p>Two-body Jastrow contributes the largest portion of correlation
energy from bare Slater determinants. Consequently, the recommended
order for optimizing wavefunction components is two-body, one-body,
three-body Jastrow factors and MSD coefficients.</p></li>
<li><p>For two-body spline Jastrows, always start from a reasonable one. The
lack of physically motivated constraints in the functional form at
large distances can cause slow convergence if starting from zero.</p></li>
<li><p>One-body spline Jastrow from old calculations can be a good starting
point.</p></li>
<li><p>Three-body polynomial Jastrow can start from zero. It is beneficial
to first optimize one-body and two-body Jastrow factors without
adding three-body terms in the calculation and then add the
three-body Jastrow and optimize all the three components together.</p></li>
</ul>
<div class="section" id="optimization-of-ci-coefficients">
<h4>Optimization of CI coefficients<a class="headerlink" href="#optimization-of-ci-coefficients" title="Permalink to this headline">¶</a></h4>
<p>When storing a CI wavefunction in HDF5 format, the CI coefficients and
the <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> components of each CI are not in
the XML input file. When optimizing the CI coefficients, they will be
stored in HDF5 format. The optimization header block will have to
specify that the new CI coefficients will be saved to HDF5 format. If
the tag is not added coefficients will not be saved.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">qmc</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span> <span class="n">move</span><span class="o">=</span><span class="s2">&quot;pbyp&quot;</span> <span class="n">gpu</span><span class="o">=</span><span class="s2">&quot;no&quot;</span> <span class="n">hdf5</span><span class="o">=</span><span class="s2">&quot;yes&quot;</span><span class="o">&gt;</span>

<span class="n">The</span> <span class="n">rest</span> <span class="n">of</span> <span class="n">the</span> <span class="n">optimization</span> <span class="n">block</span> <span class="n">remains</span> <span class="n">the</span> <span class="n">same</span><span class="o">.</span>
</pre></div>
</div>
<p>When running the optimization, the new coefficients will be stored in a <a href="#id6"><span class="problematic" id="id7">*</span></a>.sXXX.opt.h5 file,  where XXX coressponds to the series number. The H5 file contains only the optimized coefficients. The corresponding <a href="#id8"><span class="problematic" id="id9">*</span></a>.sXXX.opt.xml  will be updated for each optimization block as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">detlist</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;1487&quot;</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;DETS&quot;</span> <span class="n">nca</span><span class="o">=</span><span class="s2">&quot;0&quot;</span> <span class="n">ncb</span><span class="o">=</span><span class="s2">&quot;0&quot;</span> <span class="n">nea</span><span class="o">=</span><span class="s2">&quot;2&quot;</span> <span class="n">neb</span><span class="o">=</span><span class="s2">&quot;2&quot;</span> <span class="n">nstates</span><span class="o">=</span><span class="s2">&quot;85&quot;</span> <span class="n">cutoff</span><span class="o">=</span><span class="s2">&quot;1e-2&quot;</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;../LiH.orbs.h5&quot;</span> <span class="n">opt_coeffs</span><span class="o">=</span><span class="s2">&quot;LiH.s001.opt.h5&quot;</span><span class="o">/&gt;</span>
</pre></div>
</div>
<p>The opt_coeffs tag will then reference where the new CI coefficients are
stored.</p>
<p>When restarting the run with the new optimized coeffs, you need to
specify the previous hdf5 containing the basis set, orbitals, and MSD,
as well as the new optimized coefficients. The code will read the
previous data but will rewrite the coefficients that were optimized with
the values found in the *.sXXX.opt.h5 file. Be careful to keep the pair
of optimized CI coefficients and Jastrow coefficients together to avoid
inconsistencies.</p>
</div>
</div>
</div>
<div class="section" id="diffusion-monte-carlo">
<span id="dmc"></span><h2>Diffusion Monte Carlo<a class="headerlink" href="#diffusion-monte-carlo" title="Permalink to this headline">¶</a></h2>
<p>Main input parameters are given in <a class="reference internal" href="#table9"><span class="std std-numref">Table 9</span></a>, additional in <a class="reference internal" href="#table10"><span class="std std-numref">Table 10</span></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">dmc</span></code> method:</p>
<p>parameters:</p>
<table class="docutils align-default" id="table9">
<colgroup>
<col style="width: 26%" />
<col style="width: 12%" />
<col style="width: 21%" />
<col style="width: 11%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Name</strong></p></th>
<th class="head"><p><strong>Datatype</strong></p></th>
<th class="head"><p><strong>Values</strong></p></th>
<th class="head"><p><strong>Default</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">targetwalkers</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>dep.</p></td>
<td><p>Overall total number of walkers</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">blocks</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>1</p></td>
<td><p>Number of blocks</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">steps</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>1</p></td>
<td><p>Number of steps per block</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">warmupsteps</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>0</p></td>
<td><p>Number of steps for warming up</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">timestep</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>0.1</p></td>
<td><p>Time step for each electron move</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">nonlocalmoves</span></code></p></td>
<td><p>string</p></td>
<td><p>yes, no, v0, v1, v3</p></td>
<td><p>no</p></td>
<td><p>Run with T-moves</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">branching_cutoff_scheme</span></code></p></td>
<td><p>string</p></td>
<td><p>classic/DRV/ZSGMA/YL</p></td>
<td><p>classic</p></td>
<td><p>Branch cutoff scheme</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">maxcpusecs</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>3.6e5</p></td>
<td><p>Maximum allowed walltime in seconds</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">blocks_between_recompute</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>dep.</p></td>
<td><p>Wavefunction recompute frequency</p></td>
</tr>
</tbody>
</table>
<p class="centered">
<strong>Table 9 Main DMC input parameters.</strong></p><table class="docutils align-default" id="table10">
<colgroup>
<col style="width: 24%" />
<col style="width: 11%" />
<col style="width: 20%" />
<col style="width: 11%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Name</strong></p></th>
<th class="head"><p><strong>Datatype</strong></p></th>
<th class="head"><p><strong>Values</strong></p></th>
<th class="head"><p><strong>Default</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">energyUpdateInterval</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>0</p></td>
<td><p>Trial energy update interval</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">refEnergy</span></code></p></td>
<td><p>real</p></td>
<td><p>all values</p></td>
<td><p>dep.</p></td>
<td><p>Reference energy in atomic units</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">feedback</span></code></p></td>
<td><p>double</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>1.0</p></td>
<td><p>Population feedback on the trial energy</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sigmaBound</span></code></p></td>
<td><p>10</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>10</p></td>
<td><p>Parameter to cutoff large weights</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">killnode</span></code></p></td>
<td><p>string</p></td>
<td><p>yes/other</p></td>
<td><p>no</p></td>
<td><p>Kill or reject walkers that cross nodes</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">warmupByReconfiguration</span></code></p></td>
<td><p>option</p></td>
<td><p>yes,no</p></td>
<td><p>0</p></td>
<td><p>Warm up with a fixed population</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">reconfiguration</span></code></p></td>
<td><p>string</p></td>
<td><p>yes/pure/other</p></td>
<td><p>no</p></td>
<td><p>Fixed population technique</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">branchInterval</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>1</p></td>
<td><p>Branching interval</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">substeps</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>1</p></td>
<td><p>Branching interval</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">MaxAge</span></code></p></td>
<td><p>double</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>10</p></td>
<td><p>Kill persistent walkers</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">MaxCopy</span></code></p></td>
<td><p>double</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>2</p></td>
<td><p>Limit population growth</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">maxDisplSq</span></code></p></td>
<td><p>real</p></td>
<td><p>all values</p></td>
<td><p>-1</p></td>
<td><p>Maximum particle move</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">scaleweight</span></code></p></td>
<td><p>string</p></td>
<td><p>yes/other</p></td>
<td><p>yes</p></td>
<td><p>Scale weights (CUDA only)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">checkproperties</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>100</p></td>
<td><p>Number of steps between walker updates</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">fastgrad</span></code></p></td>
<td><p>text</p></td>
<td><p>yes/other</p></td>
<td><p>yes</p></td>
<td><p>Fast gradients</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">storeconfigs</span></code></p></td>
<td><p>integer</p></td>
<td><p>all values</p></td>
<td><p>0</p></td>
<td><p>Store configurations</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">use_nonblocking</span></code></p></td>
<td><p>string</p></td>
<td><p>yes/no</p></td>
<td><p>yes</p></td>
<td><p>Using nonblocking send/recv</p></td>
</tr>
</tbody>
</table>
<p class="centered">
<strong>Table 10 Additional DMC input parameters.</strong></p><p>Additional information:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">targetwalkers</span></code>: A DMC run can be considered a restart run or a new
run. A restart run is considered to be any method block beyond the
first one, such as when a DMC method block follows a VMC block.
Alternatively, a user reading in configurations from disk would also
considered a restart run. In the case of a restart run, the DMC
driver will use the configurations from the previous run, and this
variable will not be used. For a new run, if the number of walkers is
less than the number of threads, then the number of walkers will be
set equal to the number of threads.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">blocks</span></code>: This is the number of blocks run during a DMC method
block. A block consists of a number of DMC steps (steps), after which
all the statistics accumulated in the block are written to disk.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">steps</span></code>: This is the number of DMC steps in a block.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">warmupsteps</span></code>: These are the steps at the beginning of a DMC run in
which the instantaneous average energy is used to update the trial
energy. During regular steps, E<span class="math notranslate nohighlight">\(_{ref}\)</span> is used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">timestep</span></code>: The <code class="docutils literal notranslate"><span class="pre">timestep</span></code> determines the accuracy of the
imaginary time propagator. Generally, multiple time steps are used to
extrapolate to the infinite time step limit. A good range of time
steps in which to perform time step extrapolation will typically have
a minimum of 99% acceptance probability for each step.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">checkproperties</span></code>: When using a particle-by-particle driver, this
variable specifies how often to reset all the variables kept in the
buffer.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">maxcpusecs</span></code>: The default is 100 hours. Once the specified time has
elapsed, the program will finalize the simulation even if all blocks
are not completed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">energyUpdateInterval</span></code>: The default is to update the trial energy
at every step. Otherwise the trial energy is updated every
<code class="docutils literal notranslate"><span class="pre">energyUpdateInterval</span></code> step.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[E_{\text{trial}}=
\textrm{refEnergy}+\textrm{feedback}\cdot(\ln\texttt{targetWalkers}-\ln N)\:,\]</div>
<p>where <span class="math notranslate nohighlight">\(N\)</span> is the current population.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">refEnergy</span></code>: The default reference energy is taken from the VMC run
that precedes the DMC run. This value is updated to the current mean
whenever branching happens.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">feedback</span></code>: This variable is used to determine how strong to react
to population fluctuations when doing population control. See the
equation in energyUpdateInterval for more details.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">useBareTau</span></code>: The same time step is used whether or not a move is
rejected. The default is to use an effective time step when a move is
rejected.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">warmupByReconfiguration</span></code>: Warmup DMC is done with a fixed
population.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sigmaBound</span></code>: This determines the branch cutoff to limit wild
weights based on the sigma and <code class="docutils literal notranslate"><span class="pre">sigmaBound</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">killnode</span></code>: When running fixed-node, if a walker attempts to cross
a node, the move will normally be rejected. If <code class="docutils literal notranslate"><span class="pre">killnode</span></code> = “yes,”
then walkers are destroyed when they cross a node.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reconfiguration</span></code>: If <code class="docutils literal notranslate"><span class="pre">reconfiguration</span></code> is “yes,” then run with a
fixed walker population using the reconfiguration technique.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">branchInterval</span></code>: This is the number of steps between branching.
The total number of DMC steps in a block will be
<code class="docutils literal notranslate"><span class="pre">BranchInterval</span></code>*Steps.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">substeps</span></code>: This is the same as <code class="docutils literal notranslate"><span class="pre">BranchInterval</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nonlocalmoves</span></code>: Evaluate pseudopotentials using one of the
nonlocal move algorithms such as T-moves.</p>
<ul>
<li><p>no(default): Imposes the locality approximation.</p></li>
<li><p>yes/v0: Implements the algorithm in the 2006 Casula
paper <a class="bibtex reference internal" href="#casula2006" id="id10">[Cas06]</a>.</p></li>
<li><p>v1: Implements the v1 algorithm in the 2010 Casula
paper <a class="bibtex reference internal" href="#casula2010" id="id11">[CMSF10]</a>.</p></li>
<li><p>v2: Is <strong>not implemented</strong> and is <strong>skipped</strong> to avoid any confusion
with the v2 algorithm in the 2010 Casula
paper <a class="bibtex reference internal" href="#casula2010" id="id12">[CMSF10]</a>.</p></li>
<li><p>v3: (Experimental) Implements an algorithm similar to v1 but is much
faster. v1 computes the transition probability before each single
electron T-move selection because of the acceptance of previous
T-moves. v3 mostly reuses the transition probability computed during
the evaluation of nonlocal pseudopotentials for the local energy,
namely before accepting any T-moves, and only recomputes the
transition probability of the electrons within the same
pseudopotential region of any electrons touched by T-moves. This is
an approximation to v1 and results in a slightly different time step
error, but it significantly reduces the computational cost. v1 and v3
agree at zero time step. This faster algorithm is the topic of a
paper in preparation.</p>
<p>The v1 and v3 algorithms are size-consistent and are important advances over the previous v0 non-size-consistent algorithm. We highly recommend investigating the importance of size-consistency.</p>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">scaleweight</span></code>: This is the scaling weight per Umrigar/Nightengale.
CUDA only.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MaxAge</span></code>: Set the weight of a walker to min(currentweight,0.5)
after a walker has not moved for <code class="docutils literal notranslate"><span class="pre">MaxAge</span></code> steps. Needed if
persistent walkers appear during the course of a run.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MaxCopy</span></code>: When determining the number of copies of a walker to
branch, set the number of copies equal to min(Multiplicity,MaxCopy).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fastgrad</span></code>: This calculates gradients with either the fast version
or the full-ratio version.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">maxDisplSq</span></code>: When running a DMC calculation with particle by
particle, this sets the maximum displacement allowed for a single
particle move. All distance displacements larger than the max are
rejected. If initialized to a negative value, it becomes equal to
Lattice(LR/rc).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sigmaBound</span></code>: This determines the branch cutoff to limit wild
weights based on the sigma and <code class="docutils literal notranslate"><span class="pre">sigmaBound</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">storeconfigs</span></code>: If <code class="docutils literal notranslate"><span class="pre">storeconfigs</span></code> is set to a nonzero value, then
electron configurations during the DMC run will be saved. This option
is disabled for the OpenMP version of DMC.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">blocks_between_recompute</span></code>: See details in <a class="reference internal" href="#vmc"><span class="std std-ref">Variational Monte Carlo</span></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">branching_cutoff_scheme:</span></code> Modifies how the branching factor is
computed so as to avoid divergences and stability problems near nodal
surfaces.</p>
<ul class="simple">
<li><p>classic (default): The implementation found in QMCPACK v3.0.0 and
earlier.
<span class="math notranslate nohighlight">\(E_{\rm cut}=\mathrm{min}(\mathrm{max}(\sigma^2 \times \mathrm{sigmaBound},\mathrm{maxSigma}),2.5/\tau)\)</span>,
where <span class="math notranslate nohighlight">\(\sigma^2\)</span> is the variance and
<span class="math notranslate nohighlight">\(\mathrm{maxSigma}\)</span> is set to 50 during warmup
(equilibration) and 10 thereafter. <span class="math notranslate nohighlight">\(\mathrm{sigmaBound}\)</span> is
default to 10.</p></li>
<li><p>DRV: Implements the algorithm of DePasquale et al., Eq. 3 in
<a class="bibtex reference internal" href="#depasqualereliable1988" id="id13">[DRV88]</a> or Eq. 9 of
<a class="bibtex reference internal" href="#umrigar1993" id="id14">[UNR93]</a>.
<span class="math notranslate nohighlight">\(E_{\rm cut}=2.0/\sqrt{\tau}\)</span>.</p></li>
<li><p>ZSGMA: Implements the “ZSGMA” algorithm of
<a class="bibtex reference internal" href="#zenboosting2016" id="id15">[ZSG+16]</a> with <span class="math notranslate nohighlight">\(\alpha=0.2\)</span>.
The cutoff energy is modified by a factor including the electron
count, <span class="math notranslate nohighlight">\(E_{\rm cut}=\alpha \sqrt{N/\tau}\)</span>, which greatly
improves size consistency over Eq. 39 of
<a class="bibtex reference internal" href="#umrigar1993" id="id16">[UNR93]</a>. See Eq. 6 in
<a class="bibtex reference internal" href="#zenboosting2016" id="id17">[ZSG+16]</a> and for an application to
molecular crystals <a class="bibtex reference internal" href="#zenfast2018" id="id18">[ZBKlimevs+18]</a>.</p></li>
<li><p>YL: An unpublished algorithm due to Ye Luo.
<span class="math notranslate nohighlight">\(E_{\rm cut}=\sigma\times\mathrm{min}(\mathrm{sigmaBound},\sqrt{1/\tau})\)</span>.
This option takes into account both size consistency and
wavefunction quality via the term <span class="math notranslate nohighlight">\(\sigma\)</span>.
<span class="math notranslate nohighlight">\(\mathrm{sigmaBound}\)</span> is default to 10.</p></li>
</ul>
</li>
</ul>
<div class="literal-block-wrapper docutils container" id="listing-44">
<div class="code-block-caption"><span class="caption-number">Listing 44 </span><span class="caption-text">The following is an example of a very simple DMC section.</span><a class="headerlink" href="#listing-44" title="Permalink to this code">¶</a></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">qmc</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;dmc&quot;</span> <span class="n">move</span><span class="o">=</span><span class="s2">&quot;pbyp&quot;</span> <span class="n">target</span><span class="o">=</span><span class="s2">&quot;e&quot;</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;blocks&quot;</span><span class="o">&gt;</span><span class="mi">100</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;steps&quot;</span><span class="o">&gt;</span><span class="mi">400</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;timestep&quot;</span><span class="o">&gt;</span><span class="mf">0.010</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;warmupsteps&quot;</span><span class="o">&gt;</span><span class="mi">100</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">qmc</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<p>The time step should be individually adjusted for each problem.  Please refer to the theory section
on diffusion Monte Carlo.</p>
<div class="literal-block-wrapper docutils container" id="listing-45">
<div class="code-block-caption"><span class="caption-number">Listing 45 </span><span class="caption-text">The following is an example of running a simulation that can be restarted.</span><a class="headerlink" href="#listing-45" title="Permalink to this code">¶</a></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">qmc</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;dmc&quot;</span> <span class="n">move</span><span class="o">=</span><span class="s2">&quot;pbyp&quot;</span>  <span class="n">checkpoint</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;timestep&quot;</span><span class="o">&gt;</span>         <span class="mf">0.004</span>  <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;blocks&quot;</span><span class="o">&gt;</span>           <span class="mi">100</span>   <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;steps&quot;</span><span class="o">&gt;</span>            <span class="mi">400</span>    <span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">qmc</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<p>The checkpoint flag instructs QMCPACK to output walker configurations.
This also works in VMC. This will output an h5 file with the name
<code class="docutils literal notranslate"><span class="pre">projectid.run-number.config.h5</span></code>. Check that this file exists before
attempting a restart. To read in this file for a continuation run,
specify the following:</p>
<div class="literal-block-wrapper docutils container" id="listing-46">
<div class="code-block-caption"><span class="caption-number">Listing 46 </span><span class="caption-text">Restart (read walkers from previous run).</span><a class="headerlink" href="#listing-46" title="Permalink to this code">¶</a></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">mcwalkerset</span> <span class="n">fileroot</span><span class="o">=</span><span class="s2">&quot;BH.s002&quot;</span> <span class="n">version</span><span class="o">=</span><span class="s2">&quot;0 6&quot;</span> <span class="n">collected</span><span class="o">=</span><span class="s2">&quot;yes&quot;</span><span class="o">/&gt;</span>
</pre></div>
</div>
</div>
<p>BH is the project id, and s002 is the calculation number to read in the walkers from the previous run.</p>
<p>Combining VMC and DMC in a single run (wavefunction optimization can be combined in this way too) is the standard way in which QMCPACK is typically run.   There is no need to run two separate jobs since method sections can be stacked and walkers are transferred between them.</p>
<div class="literal-block-wrapper docutils container" id="listing-47">
<div class="code-block-caption"><span class="caption-number">Listing 47 </span><span class="caption-text">Combined VMC and DMC run.</span><a class="headerlink" href="#listing-47" title="Permalink to this code">¶</a></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">qmc</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;vmc&quot;</span> <span class="n">move</span><span class="o">=</span><span class="s2">&quot;pbyp&quot;</span> <span class="n">target</span><span class="o">=</span><span class="s2">&quot;e&quot;</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;blocks&quot;</span><span class="o">&gt;</span><span class="mi">100</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;steps&quot;</span><span class="o">&gt;</span><span class="mi">4000</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;warmupsteps&quot;</span><span class="o">&gt;</span><span class="mi">100</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;samples&quot;</span><span class="o">&gt;</span><span class="mi">1920</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;walkers&quot;</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;timestep&quot;</span><span class="o">&gt;</span><span class="mf">0.5</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">qmc</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">qmc</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;dmc&quot;</span> <span class="n">move</span><span class="o">=</span><span class="s2">&quot;pbyp&quot;</span> <span class="n">target</span><span class="o">=</span><span class="s2">&quot;e&quot;</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;blocks&quot;</span><span class="o">&gt;</span><span class="mi">100</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;steps&quot;</span><span class="o">&gt;</span><span class="mi">400</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;timestep&quot;</span><span class="o">&gt;</span><span class="mf">0.010</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;warmupsteps&quot;</span><span class="o">&gt;</span><span class="mi">100</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">qmc</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">qmc</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;dmc&quot;</span> <span class="n">move</span><span class="o">=</span><span class="s2">&quot;pbyp&quot;</span> <span class="n">target</span><span class="o">=</span><span class="s2">&quot;e&quot;</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;warmupsteps&quot;</span><span class="o">&gt;</span><span class="mi">500</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;blocks&quot;</span><span class="o">&gt;</span><span class="mi">50</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;steps&quot;</span><span class="o">&gt;</span><span class="mi">100</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;timestep&quot;</span><span class="o">&gt;</span><span class="mf">0.005</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">qmc</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="reptation-monte-carlo">
<span id="rmc"></span><h2>Reptation Monte Carlo<a class="headerlink" href="#reptation-monte-carlo" title="Permalink to this headline">¶</a></h2>
<p>Like DMC, RMC is a projector-based method that allows sampling of the
fixed-node wavefunciton. However, by exploiting the path-integral
formulation of Schrödinger’s equation, the RMC algorithm can offer some
advantages over traditional DMC, such as sampling both the mixed and
pure fixed-node distributions in polynomial time, as well as not having
population fluctuations and biases. The current implementation does not
work with T-moves.</p>
<p>There are two adjustable parameters that affect the quality of the RMC
projection: imaginary projection time <span class="math notranslate nohighlight">\(\beta\)</span> of the sampling path
(commonly called a “reptile”) and the Trotter time step <span class="math notranslate nohighlight">\(\tau\)</span>.
<span class="math notranslate nohighlight">\(\beta\)</span> must be chosen to be large enough such that
<span class="math notranslate nohighlight">\(e^{-\beta \hat{H}}|\Psi_T\rangle \approx |\Phi_0\rangle\)</span> for
mixed observables, and
<span class="math notranslate nohighlight">\(e^{-\frac{\beta}{2} \hat{H}}|\Psi_T\rangle \approx |\Phi_0\rangle\)</span>
for pure observables. The reptile is discretized into
<span class="math notranslate nohighlight">\(M=\beta/\tau\)</span> beads at the cost of an <span class="math notranslate nohighlight">\(\mathcal{O}(\tau)\)</span>
time-step error for observables arising from the Trotter-Suzuki breakup
of the short-time propagator.</p>
<p>The following table lists some of the more practical</p>
<p><code class="docutils literal notranslate"><span class="pre">vmc</span></code> method:</p>
<blockquote>
<div><p>parameters:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 11%" />
<col style="width: 19%" />
<col style="width: 10%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Name</strong></p></th>
<th class="head"><p><strong>Datatype</strong></p></th>
<th class="head"><p><strong>Values</strong></p></th>
<th class="head"><p><strong>Default</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">beta</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>dep.</p></td>
<td><p>Reptile project time <span class="math notranslate nohighlight">\(\beta\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">timestep</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>0.1</p></td>
<td><p>Trotter time step <span class="math notranslate nohighlight">\(\tau\)</span> for each electron move</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">beads</span></code></p></td>
<td><p>int</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>1</p></td>
<td><p>Number of reptile beads <span class="math notranslate nohighlight">\(M=\beta/\tau\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">blocks</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(&gt; 0\)</span></p></td>
<td><p>1</p></td>
<td><p>Number of blocks</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">steps</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>1</p></td>
<td><p>Number of steps per block</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">vmcpresteps</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>0</p></td>
<td><p>Propagates reptile using VMC for given number of steps</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">warmupsteps</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>0</p></td>
<td><p>Number of steps for warming up</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">maxAge</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(\geq 0\)</span></p></td>
<td><p>0</p></td>
<td><p>Force accept for stuck reptile if age exceeds <code class="docutils literal notranslate"><span class="pre">maxAge</span></code></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additional information:</p>
<p>Because of the sampling differences between DMC ensembles of walkers and
RMC reptiles, the RMC block should contain the following estimator
declaration to ensure correct sampling:
<code class="docutils literal notranslate"><span class="pre">&lt;estimator</span> <span class="pre">name=&quot;RMC&quot;</span> <span class="pre">hdf5=&quot;no&quot;&gt;</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">beta</span></code> or <code class="docutils literal notranslate"><span class="pre">beads</span></code>? One or the other can be specified, and from
the Trotter time step, the code will construct an appropriately sized
reptile. If both are given, <code class="docutils literal notranslate"><span class="pre">beta</span></code> overrides <code class="docutils literal notranslate"><span class="pre">beads</span></code>.</p></li>
<li><p><strong>Mixed vs. pure observables?</strong> Configurations sampled by the
endpoints of the reptile are distributed according to the mixed
distribution
<span class="math notranslate nohighlight">\(f(\mathbf{R})=\Psi_T(\mathbf{R})\Phi_0(\mathbf{R})\)</span>. Any
observable that is computable within DMC and is dumped to the
<code class="docutils literal notranslate"><span class="pre">scalar.dat</span></code> file will likewise be found in the <code class="docutils literal notranslate"><span class="pre">scalar.dat</span></code> file
generated by RMC, except there will be an appended <code class="docutils literal notranslate"><span class="pre">_m</span></code> to alert
the user that the observable was computed on the mixed distribution.
For pure observables, care must be taken in the interpretation. If
the observable is diagonal in the position basis (in layman’s terms,
if it is entirely computable from a single electron configuration
<span class="math notranslate nohighlight">\(\mathbf{R}\)</span>, like the potential energy), and if the observable
does not have an explicit dependence on the trial wavefunction (e.g.,
the local energy has an explicit dependence on the trial wavefunction
from the kinetic energy term), then pure estimates will be correctly
computed. These observables will be found in either the
<code class="docutils literal notranslate"><span class="pre">scalar.dat</span></code>, where they will be appended with a <code class="docutils literal notranslate"><span class="pre">_p</span></code> suffix, or
in the <code class="docutils literal notranslate"><span class="pre">stat.h5</span></code> file. No mixed estimators will be dumped to the h5
file.</p></li>
<li><p><strong>Sampling</strong>: For pure estimators, the traces of both pure and mixed
estimates should be checked. Ergodicity is a known problem in RMC.
Because we use the bounce algorithm, it is possible for the reptile
to bounce back and forth without changing the electron coordinates of
the central beads. This might not easily show up with mixed
estimators, since these are accumulated at constantly regrown ends,
but pure estimates are accumulated on these central beads and so can
exhibit strong autocorrelations in pure estimate traces.</p></li>
<li><p><strong>Propagator</strong>: Our implementation of RMC uses Moroni’s DMC link
action (symmetrized), with Umrigar’s scaled drift near nodes. In this
regard, the propagator is identical to the one QMCPACK uses in DMC.</p></li>
<li><p><strong>Sampling</strong>: We use Ceperley’s bounce algorithm. <code class="docutils literal notranslate"><span class="pre">MaxAge</span></code> is used
in case the reptile gets stuck, at which point the code forces move
acceptance, stops accumulating statistics, and requilibrates the
reptile. Very rarely will this be required. For move proposals, we
use particle-by-particle VMC a total of <span class="math notranslate nohighlight">\(N_e\)</span> times to generate
a new all-electron configuration, at which point the action is
computed and the move is either accepted or rejected.</p></li>
</ul>
<p id="bibtex-bibliography-methods-0"><dl class="citation">
<dt class="bibtex label" id="casula2006"><span class="brackets"><a class="fn-backref" href="#id10">Cas06</a></span></dt>
<dd><p>Michele Casula. Beyond the locality approximation in the standard diffusion Monte Carlo method. <em>Physical Review B - Condensed Matter and Materials Physics</em>, 74:1–4, 2006. <a class="reference external" href="https://arxiv.org/abs/0610246">arXiv:0610246</a>, <a class="reference external" href="https://doi.org/10.1103/PhysRevB.74.161102">doi:10.1103/PhysRevB.74.161102</a>.</p>
</dd>
<dt class="bibtex label" id="casula2010"><span class="brackets">CMSF10</span><span class="fn-backref">(<a href="#id11">1</a>,<a href="#id12">2</a>)</span></dt>
<dd><p>Michele Casula, Saverio Moroni, Sandro Sorella, and Claudia Filippi. Size-consistent variational approaches to nonlocal pseudopotentials: Standard and lattice regularized diffusion Monte Carlo methods revisited. <em>Journal of Chemical Physics</em>, 2010. <a class="reference external" href="https://arxiv.org/abs/1002.0356">arXiv:1002.0356</a>, <a class="reference external" href="https://doi.org/10.1063/1.3380831">doi:10.1063/1.3380831</a>.</p>
</dd>
<dt class="bibtex label" id="depasqualereliable1988"><span class="brackets"><a class="fn-backref" href="#id13">DRV88</a></span></dt>
<dd><p>Michael F. DePasquale, Stuart M. Rothstein, and Jan Vrbik. Reliable diffusion quantum monte carlo. <em>The Journal of Chemical Physics</em>, 89(6):3629–3637, September 1988. <a class="reference external" href="https://doi.org/10.1063/1.454883">doi:10.1063/1.454883</a>.</p>
</dd>
<dt class="bibtex label" id="otis2019"><span class="brackets">ON19</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id4">2</a>,<a href="#id5">3</a>)</span></dt>
<dd><p>Leon Otis and Eric Neuscamman. Complementary first and second derivative methods for ansatz optimization in variational monte carlo. <em>Phys. Chem. Chem. Phys.</em>, 21:14491, 2019.</p>
</dd>
<dt class="bibtex label" id="umrigar1993"><span class="brackets">UNR93</span><span class="fn-backref">(<a href="#id14">1</a>,<a href="#id16">2</a>)</span></dt>
<dd><p>C J Umrigar, M P Nightingale, and K J Runge. A diffusion Monte Carlo algorithm with very small timestep errors A diffusion Monte Carlo algorithm with very small time-step errors. <em>The Journal of Chemical Physics</em>, 99(4):2865, 1993. <a class="reference external" href="https://doi.org/10.1063/1.465195">doi:10.1063/1.465195</a>.</p>
</dd>
<dt class="bibtex label" id="zenfast2018"><span class="brackets"><a class="fn-backref" href="#id18">ZBKlimevs+18</a></span></dt>
<dd><p>Andrea Zen, Jan Gerit Brandenburg, Jiř’ı Klimeš, Alexandre Tkatchenko, Dario Alfè, and Angelos Michaelides. Fast and accurate quantum monte carlo for molecular crystals. <em>Proceedings of the National Academy of Sciences</em>, 115(8):1724–1729, February 2018. <a class="reference external" href="https://doi.org/10.1073/pnas.1715434115">doi:10.1073/pnas.1715434115</a>.</p>
</dd>
<dt class="bibtex label" id="zenboosting2016"><span class="brackets">ZSG+16</span><span class="fn-backref">(<a href="#id15">1</a>,<a href="#id17">2</a>)</span></dt>
<dd><p>Andrea Zen, Sandro Sorella, Michael J. Gillan, Angelos Michaelides, and Dario Alfè. Boosting the accuracy and speed of quantum monte carlo: size consistency and time step. <em>Physical Review B</em>, June 2016. <a class="reference external" href="https://doi.org/10.1103/physrevb.93.241118">doi:10.1103/physrevb.93.241118</a>.</p>
</dd>
<dt class="bibtex label" id="zhao-2016-dir-tar"><span class="brackets"><a class="fn-backref" href="#id2">ZN16</a></span></dt>
<dd><p>Luning Zhao and Eric Neuscamman. An efficient variational principle for the direct optimization of excited states. <em>J. Chem. Theory. Comput.</em>, 12:3436, 2016.</p>
</dd>
<dt class="bibtex label" id="zhao-2017-blocked-lm"><span class="brackets"><a class="fn-backref" href="#id1">ZN17</a></span></dt>
<dd><p>Luning Zhao and Eric Neuscamman. A blocked linear method for optimizing large parameter sets in variational monte carlo. <em>J. Chem. Theory. Comput.</em>, 2017. <a class="reference external" href="https://doi.org/10.1021/acs.jctc.7b00119">doi:10.1021/acs.jctc.7b00119</a>.</p>
</dd>
</dl>
</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="output_overview.html" class="btn btn-neutral float-right" title="Output Overview" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="hamiltonianobservable.html" class="btn btn-neutral float-left" title="Hamiltonian and Observables" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, QMCPACK Developers

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
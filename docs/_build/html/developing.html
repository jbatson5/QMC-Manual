

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Development Guide &mdash; QMCPACK Manual  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Appendices" href="appendices.html" />
    <link rel="prev" title="QMCPACK Design and Feature Documentation" href="design_features.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> QMCPACK Manual
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="features.html">Features of QMCPACK</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Obtaining, installing, and validating QMCPACK</a></li>
<li class="toctree-l1"><a class="reference internal" href="running.html">Running QMCPACK</a></li>
<li class="toctree-l1"><a class="reference internal" href="units.html">Units used in QMCPACK</a></li>
<li class="toctree-l1"><a class="reference internal" href="input_overview.html">Input file overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="simulationcell.html">Specifying the system to be simulated</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro_wavefunction.html">Trial wavefunction specificaion</a></li>
<li class="toctree-l1"><a class="reference internal" href="hamiltonianobservable.html">Hamiltonian and Observables</a></li>
<li class="toctree-l1"><a class="reference internal" href="methods.html">Quantum Monte Carlo Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="output_overview.html">Output Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="analyzing.html">Analyzing QMCPACK data</a></li>
<li class="toctree-l1"><a class="reference internal" href="LCAO.html">Periodic LCAO for Solids</a></li>
<li class="toctree-l1"><a class="reference internal" href="sCI.html">Selected Configuration Interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="afqmc.html">Auxiliary-Field Quantum Monte Carlo</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="lab_qmc_statistics.html">Lab 1: MC Statistical Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="lab_qmc_basics.html">Lab 2: QMC Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="lab_advanced_molecules.html">Lab 3: Advanced molecular calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="lab_condensed_matter.html">Lab 4: Condensed Matter Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="lab_excited.html">Lab 5: Excited state calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="additional_tools.html">Additional Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="external_tools.html">External Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing to the Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="unit_testing.html">Unit Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="design_features.html">QMCPACK Design and Feature Documentation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Development Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#qmcpack-coding-standards">QMCPACK coding standards</a></li>
<li class="toctree-l2"><a class="reference internal" href="#files">Files</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#file-organization">File organization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#file-names">File names</a></li>
<li class="toctree-l3"><a class="reference internal" href="#header-files">Header files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#includes">Includes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#naming">Naming</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#namespace-names">Namespace names</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-and-class-names">Type and class names</a></li>
<li class="toctree-l3"><a class="reference internal" href="#variable-names">Variable names</a></li>
<li class="toctree-l3"><a class="reference internal" href="#class-data-members">Class data members</a></li>
<li class="toctree-l3"><a class="reference internal" href="#member-function-names">(Member) function names</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lambda-expressions">Lambda expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#macro-names">Macro names</a></li>
<li class="toctree-l3"><a class="reference internal" href="#test-case-and-test-names">Test case and test names</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#comments">Comments</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#comment-style">Comment style</a></li>
<li class="toctree-l3"><a class="reference internal" href="#documentation">Documentation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#file-docs">File docs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-docs">Class docs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#function-docs">Function docs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#variable-documentation">Variable documentation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#golden-rule-of-comments">Golden rule of comments</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#formatting-and-style">Formatting and “style”</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#indentation">Indentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#line-length">Line length</a></li>
<li class="toctree-l3"><a class="reference internal" href="#horizontal-spacing">Horizontal spacing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#preprocessor-directives">Preprocessor directives</a></li>
<li class="toctree-l3"><a class="reference internal" href="#binary-operators">Binary operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unary-operators">Unary operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#types">Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pointers-and-references">Pointers and references</a></li>
<li class="toctree-l3"><a class="reference internal" href="#templates">Templates</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vertical-spacing">Vertical spacing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#variable-declarations-and-definitions">Variable declarations and definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-declarations-and-definitions">Function declarations and definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#conditionals">Conditionals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#switch-statement">Switch statement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#loops">Loops</a></li>
<li class="toctree-l3"><a class="reference internal" href="#class-format">Class format</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#constructor-initializer-lists">Constructor initializer lists</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#namespace-formatting">Namespace formatting</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#qmcpack-c-guidance">QMCPACK C++ guidance</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#encapsulation">Encapsulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#casting">Casting</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pre-increment-and-pre-decrement">Pre-increment and pre-decrement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#alternative-operator-representations">Alternative operator representations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#use-of-const">Use of const</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#scalar-estimator-implementation">Scalar estimator implementation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction-life-of-a-specialized-operatorbase">Introduction: Life of a specialized OperatorBase</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#initialization">Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cloning">Cloning</a></li>
<li class="toctree-l4"><a class="reference internal" href="#evaluate">Evaluate</a></li>
<li class="toctree-l4"><a class="reference internal" href="#collection">Collection</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#single-scalar-estimator-implementation-guide">Single scalar estimator implementation guide</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#barebone">Barebone</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id2">Evaluate</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parse-extra-input">Parse extra input</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#multiple-scalars">Multiple scalars</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hdf5-output">HDF5 output</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#estimator-output">Estimator output</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#estimator-definition">Estimator definition</a></li>
<li class="toctree-l3"><a class="reference internal" href="#class-relations">Class relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#estimator-output-stages">Estimator output stages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#collect-stage">Collect stage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unload-ensemble-stage">Unload ensemble stage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#load-ensemble-stage">Load ensemble stage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#evaluate-stage">Evaluate stage</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#estimator-use-cases">Estimator use cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#vmcsingleomp-pseudo-code">VMCSingleOMP pseudo code</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dmcomp-pseudo-code">DMCOMP  pseudo code</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#summary">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="#appendix-dmc-dat">Appendix: dmc.dat</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#slater-backflow-wavefunction-implementation-details">Slater-backflow wavefunction implementation details</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#value">Value</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gradient">Gradient</a></li>
<li class="toctree-l3"><a class="reference internal" href="#laplacian">Laplacian</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wavefunction-parameter-derivative">Wavefunction parameter derivative</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#particles-and-distance-tables">Particles and distance tables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#particlesets">ParticleSets</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#groups">Groups</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id7">Distance tables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#looping-over-particles">Looping over particles</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#adding-a-wavefunction">Adding a wavefunction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mathematical-preliminaries">Mathematical preliminaries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wavefunction-evaluation">Wavefunction evaluation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-use">Function use</a></li>
<li class="toctree-l3"><a class="reference internal" href="#particle-distances">Particle distances</a></li>
<li class="toctree-l3"><a class="reference internal" href="#setup">Setup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#caching-values">Caching values</a></li>
<li class="toctree-l3"><a class="reference internal" href="#threading">Threading</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parameter-optimization">Parameter optimization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#helium-wavefunction-example">Helium Wavefunction Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#linear-algebra">Linear Algebra</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#real-space-qmc">Real space QMC</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#single-particle-orbitals">Single particle orbitals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#slater-determinants">Slater determinants</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wavefunction-optimizer">Wavefunction optimizer</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#auxiliary-field-qmc">Auxiliary field QMC</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="appendices.html">Appendices</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">QMCPACK Manual</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Development Guide</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/developing.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="development-guide">
<span id="developguide"></span><h1>Development Guide<a class="headerlink" href="#development-guide" title="Permalink to this headline">¶</a></h1>
<p>The section gives guidance on how to extend the functionality of QMCPACK. Future examples will likely include topics such as the addition of a Jastrow function or a new QMC method.</p>
<div class="section" id="qmcpack-coding-standards">
<h2>QMCPACK coding standards<a class="headerlink" href="#qmcpack-coding-standards" title="Permalink to this headline">¶</a></h2>
<p>This chapter presents what we collectively have agreed are best practices for the code. This includes formatting style, naming conventions, documentation conventions, and certain prescriptions for C++ language use. At the moment only the formatting can be enforced in an objective fashion.</p>
<p>New development should follow these guidelines, and contributors are expected to adhere to them as they represent an integral part of our effort to continue QMCPACK as a world-class, sustainable QMC code. Although some of the source code has a ways to go to live up to these ideas, new code, even in old files, should follow the new conventions not the local conventions of the file whenever possible. Work on the code with continuous improvement in mind rather than a commitment to stasis.</p>
<p>The <a class="reference external" href="https://github.com/QMCPACK/qmcpack/wiki/Development-workflow">current workflow conventions</a> for the project are described in the wiki on the GitHub repository. It will save you and all the maintainers considerable time if you read these and ask questions up front.</p>
<p>A PR should follow these standards before inclusion in the mainline. You can be sure of properly following the formatting conventions if you use clang-format.  The mechanics of clang-format setup and use can be found at <a class="reference external" href="https://github.com/QMCPACK/qmcpack/wiki/Source-formatting">https://github.com/QMCPACK/qmcpack/wiki/Source-formatting</a>.</p>
<p>The clang-format file found at <code class="docutils literal notranslate"><span class="pre">qmcpack/src/.clang-format</span></code> should be run over all code touched in a PR before a pull request is prepared. We also encourage developers to run clang-tidy with the <code class="docutils literal notranslate"><span class="pre">qmcpack/src/.clang-tidy</span></code> configuration over all new code.</p>
<p>As much as possible, try to break up refactoring, reformatting, feature, and bugs into separate, small PRs. Aim for something that would take a reviewer no more than an hour. In this way we can maintain a good collective development velocity.</p>
</div>
<div class="section" id="files">
<h2>Files<a class="headerlink" href="#files" title="Permalink to this headline">¶</a></h2>
<p>Each file should start with the header.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//////////////////////////////////////////////////////////////////////////////////////</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span><span class="o">/</span><span class="n">NCSA</span> <span class="n">Open</span> <span class="n">Source</span> <span class="n">License</span><span class="o">.</span>
<span class="o">//</span> <span class="n">See</span> <span class="n">LICENSE</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">top</span> <span class="n">directory</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">Copyright</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="mi">2018</span> <span class="n">QMCPACK</span> <span class="n">developers</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">File</span> <span class="n">developed</span> <span class="n">by</span><span class="p">:</span> <span class="n">Name</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="n">affiliation</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">File</span> <span class="n">created</span> <span class="n">by</span><span class="p">:</span> <span class="n">Name</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="n">affiliation</span>
<span class="o">//////////////////////////////////////////////////////////////////////////////////////</span>
</pre></div>
</div>
<p>If you make significant changes to an existing file, add yourself to the list of “developed by” authors.</p>
<div class="section" id="file-organization">
<h3>File organization<a class="headerlink" href="#file-organization" title="Permalink to this headline">¶</a></h3>
<p>Header files should be placed in the same directory as their implementations.
Unit tests should be written for all new functionality. These tests should be placed in a <code class="docutils literal notranslate"><span class="pre">tests</span></code> subdirectory below the implementations.</p>
</div>
<div class="section" id="file-names">
<h3>File names<a class="headerlink" href="#file-names" title="Permalink to this headline">¶</a></h3>
<p>Each class should be defined in a separate file with the same name as the class name. Use separate <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> implementation files whenever possible to aid in incremental compilation.</p>
<p>The filenames of tests are composed by the filename of the object tested and the prefix <code class="docutils literal notranslate"><span class="pre">test_</span></code>.
The filenames of <em>fake</em> and <em>mock</em> objects used in tests are composed by the prefixes <code class="docutils literal notranslate"><span class="pre">fake_</span></code> and <code class="docutils literal notranslate"><span class="pre">mock_</span></code>, respectively, and the filename of the object that is imitated.</p>
</div>
<div class="section" id="header-files">
<h3>Header files<a class="headerlink" href="#header-files" title="Permalink to this headline">¶</a></h3>
<p>All header files should be self-contained (i.e., not dependent on following any other header when it is included). Nor should they include files that are not necessary for their use (i.e., headers needed only by the implementation). Implementation files should not include files only for the benefit of files they include.</p>
<p>There are many header files that currently violate this.
Each header must use <code class="docutils literal notranslate"><span class="pre">\#define</span></code> guards to prevent multiple inclusion.
The symbol name of the <code class="docutils literal notranslate"><span class="pre">\#define</span></code> guards should be <code class="docutils literal notranslate"><span class="pre">NAMESPACE(s)_CLASSNAME_H</span></code>.</p>
</div>
<div class="section" id="includes">
<h3>Includes<a class="headerlink" href="#includes" title="Permalink to this headline">¶</a></h3>
<p>Header files should be included with the full path based on the <code class="docutils literal notranslate"><span class="pre">src</span></code> directory.
For example, the file <code class="docutils literal notranslate"><span class="pre">qmcpack/src/QMCWaveFunctions/SPOSet.h</span></code> should be included as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &quot;QMCWaveFunctions/SPOSet.h&quot;</span>
</pre></div>
</div>
<p>Even if the included file is located in the same directory as the including file, this rule should be obeyed. Header files from external projects and standard libraries should be includes using the <code class="docutils literal notranslate"><span class="pre">&lt;iostream&gt;</span></code> convention, while headers that are part of the QMCPACK project should be included using the <code class="docutils literal notranslate"><span class="pre">&quot;our_header.h&quot;</span></code> convention.</p>
<p>For readability, we suggest using the following standard order of includes:</p>
<ol class="arabic simple">
<li><p>related header</p></li>
<li><p>std C library headers</p></li>
<li><p>std C++ library headers</p></li>
<li><p>Other libraries’ headers</p></li>
<li><p>QMCPACK headers</p></li>
</ol>
<p>In each section the included files should be sorted in alphabetical order.</p>
</div>
</div>
<div class="section" id="naming">
<h2>Naming<a class="headerlink" href="#naming" title="Permalink to this headline">¶</a></h2>
<p>The balance between description and ease of implementation should be balanced such that the code remains self-documenting within a single terminal window.  If an extremely short variable name is used, its scope must be shorter than <span class="math notranslate nohighlight">\(\sim 40\)</span> lines. An exception is made for template parameters, which must be in all CAPS.</p>
<div class="section" id="namespace-names">
<h3>Namespace names<a class="headerlink" href="#namespace-names" title="Permalink to this headline">¶</a></h3>
<p>Namespace names should be one word, lowercase.</p>
</div>
<div class="section" id="type-and-class-names">
<h3>Type and class names<a class="headerlink" href="#type-and-class-names" title="Permalink to this headline">¶</a></h3>
<p>Type and class names should start with a capital letter and have a capital letter for each new word.
Underscores (<code class="docutils literal notranslate"><span class="pre">_</span></code>) are not allowed.</p>
</div>
<div class="section" id="variable-names">
<h3>Variable names<a class="headerlink" href="#variable-names" title="Permalink to this headline">¶</a></h3>
<p>Variable names should not begin with a capital letter, which is reserved for type and class names. Underscores (<code class="docutils literal notranslate"><span class="pre">_</span></code>) should be used to separate words.</p>
</div>
<div class="section" id="class-data-members">
<h3>Class data members<a class="headerlink" href="#class-data-members" title="Permalink to this headline">¶</a></h3>
<p>Class private/protected data members names should follow the convention of variable names with a trailing underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>).</p>
</div>
<div class="section" id="member-function-names">
<h3>(Member) function names<a class="headerlink" href="#member-function-names" title="Permalink to this headline">¶</a></h3>
<p>Function names should start with a lowercase character and have a capital letter for each new word.</p>
</div>
<div class="section" id="lambda-expressions">
<h3>Lambda expressions<a class="headerlink" href="#lambda-expressions" title="Permalink to this headline">¶</a></h3>
<p>Named lambda expressions follow the naming convention for functions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="n">myWhatever</span> <span class="o">=</span> <span class="p">[](</span><span class="nb">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span> <span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="macro-names">
<h3>Macro names<a class="headerlink" href="#macro-names" title="Permalink to this headline">¶</a></h3>
<p>Macro names should be all uppercase and can include underscores (<code class="docutils literal notranslate"><span class="pre">_</span></code>).
The underscore is not allowed as first or last character.</p>
</div>
<div class="section" id="test-case-and-test-names">
<h3>Test case and test names<a class="headerlink" href="#test-case-and-test-names" title="Permalink to this headline">¶</a></h3>
<p>Test code files should be named as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DiracMatrix</span><span class="p">;</span>
<span class="o">//</span><span class="n">leads</span> <span class="n">to</span>
<span class="n">test_dirac_matrix</span><span class="o">.</span><span class="n">cpp</span>
<span class="o">//</span><span class="n">which</span> <span class="n">contains</span> <span class="n">test</span> <span class="n">cases</span> <span class="n">named</span>
<span class="n">TEST_CASE</span><span class="p">(</span><span class="s2">&quot;DiracMatrix_update_row&quot;</span><span class="p">,</span><span class="s2">&quot;[wavefunction][fermion]&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>where the test case covers the <code class="docutils literal notranslate"><span class="pre">updateRow</span></code> and  <code class="docutils literal notranslate"><span class="pre">[wavefunction][fermion]</span></code> indicates the test belongs to the fermion wavefunction functionality.</p>
</div>
</div>
<div class="section" id="comments">
<h2>Comments<a class="headerlink" href="#comments" title="Permalink to this headline">¶</a></h2>
<div class="section" id="comment-style">
<h3>Comment style<a class="headerlink" href="#comment-style" title="Permalink to this headline">¶</a></h3>
<p>Use the <code class="docutils literal notranslate"><span class="pre">//</span> <span class="pre">Comment</span></code> syntax for actual comments.</p>
<p>Use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/** base class for Single-particle orbital sets
 *
 * SPOSet stands for S(ingle)P(article)O(rbital)Set which contains
 * a number of single-particle orbitals with capabilities of
 * evaluating \f$ \psi_j({\bf r}_i)\f$
 */
</pre></div>
</div>
<p>or</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">///</span><span class="n">index</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">builder</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">sposets</span>
<span class="nb">int</span> <span class="n">builder_index</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="documentation">
<h3>Documentation<a class="headerlink" href="#documentation" title="Permalink to this headline">¶</a></h3>
<p>Doxygen will be used for source documentation. Doxygen commands should be used when appropriate guidance on this has been decided.</p>
<div class="section" id="file-docs">
<h4>File docs<a class="headerlink" href="#file-docs" title="Permalink to this headline">¶</a></h4>
<p>Do not put the file name after the <code class="docutils literal notranslate"><span class="pre">\file</span></code> Doxygen command. Doxygen will fill it in for the file the tag appears in.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span> \<span class="n">file</span>
 <span class="o">*</span>  <span class="n">File</span> <span class="n">level</span> <span class="n">documentation</span>
 <span class="o">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="class-docs">
<h4>Class docs<a class="headerlink" href="#class-docs" title="Permalink to this headline">¶</a></h4>
<p>Every class should have a short description (in the header of the file) of what it is and what is does.
Comments for public class member functions follow the same rules as general function comments.
Comments for private members are allowed but are not mandatory.</p>
</div>
<div class="section" id="function-docs">
<h4>Function docs<a class="headerlink" href="#function-docs" title="Permalink to this headline">¶</a></h4>
<p>For function parameters whose type is non-const reference or pointer to non-const memory,
it should be specified if they are input (In:), output (Out:) or input-output parameters (InOut:).</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span> <span class="n">Updates</span> <span class="n">foo</span> <span class="ow">and</span> <span class="n">computes</span> <span class="n">bar</span> <span class="n">using</span> <span class="n">in_1</span> <span class="o">..</span> <span class="n">in_5</span><span class="o">.</span>
 <span class="o">*</span> \<span class="n">param</span><span class="p">[</span><span class="ow">in</span><span class="p">]</span> <span class="n">in_3</span>
 <span class="o">*</span> \<span class="n">param</span><span class="p">[</span><span class="ow">in</span><span class="p">]</span> <span class="n">in_5</span>
 <span class="o">*</span> \<span class="n">param</span><span class="p">[</span><span class="ow">in</span><span class="p">,</span><span class="n">out</span><span class="p">]</span> <span class="n">foo</span>
 <span class="o">*</span> \<span class="n">param</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="n">bar</span>
 <span class="o">*/</span>

<span class="o">//</span><span class="n">This</span> <span class="ow">is</span> <span class="n">probably</span> <span class="ow">not</span> <span class="n">what</span> <span class="n">our</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">would</span> <span class="n">do</span>
<span class="n">void</span> <span class="n">computeFooBar</span><span class="p">(</span><span class="n">Type</span> <span class="n">in_1</span><span class="p">,</span> <span class="n">const</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">in_2</span><span class="p">,</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">in_3</span><span class="p">,</span>
                   <span class="n">const</span> <span class="n">Type</span><span class="o">*</span> <span class="n">in_4</span><span class="p">,</span> <span class="n">Type</span><span class="o">*</span> <span class="n">in_5</span><span class="p">,</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">,</span>
                   <span class="n">Type</span><span class="o">&amp;</span> <span class="n">bar</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="variable-documentation">
<h4>Variable documentation<a class="headerlink" href="#variable-documentation" title="Permalink to this headline">¶</a></h4>
<p>Name should be self-descriptive.  If you need documentation consider renaming first.</p>
</div>
</div>
<div class="section" id="golden-rule-of-comments">
<h3>Golden rule of comments<a class="headerlink" href="#golden-rule-of-comments" title="Permalink to this headline">¶</a></h3>
<p>If you modify a piece of code, also adapt the comments that belong to it if necessary.</p>
</div>
</div>
<div class="section" id="formatting-and-style">
<h2>Formatting and “style”<a class="headerlink" href="#formatting-and-style" title="Permalink to this headline">¶</a></h2>
<p>Use the provided clang-format style in <code class="docutils literal notranslate"><span class="pre">src/.clang-format}</span></code> to format <code class="docutils literal notranslate"><span class="pre">.h</span></code>, <code class="docutils literal notranslate"><span class="pre">.hpp</span></code>, <code class="docutils literal notranslate"><span class="pre">.cu</span></code>, and <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> files. Many of the following rules will be applied to the code by clang-format, which should allow you to ignore most of them if you always run it on your modified code.</p>
<p>You should use clang-format support and the <code class="docutils literal notranslate"><span class="pre">.clangformat</span></code> file with your editor, use a Git precommit hook to run clang-format or run clang-format manually on every file you modify.  However, if you see numerous formatting updates outside of the code you have modified, first commit the formatting changes in a separate PR.</p>
<div class="section" id="indentation">
<h3>Indentation<a class="headerlink" href="#indentation" title="Permalink to this headline">¶</a></h3>
<p>Indentation consists of two spaces. Do not use tabs in the code.</p>
</div>
<div class="section" id="line-length">
<h3>Line length<a class="headerlink" href="#line-length" title="Permalink to this headline">¶</a></h3>
<p>The length of each line of your code should be at most <em>120</em> characters.</p>
</div>
<div class="section" id="horizontal-spacing">
<h3>Horizontal spacing<a class="headerlink" href="#horizontal-spacing" title="Permalink to this headline">¶</a></h3>
<p>No trailing white spaces should be added to any line.
Use no space before a comma (<code class="docutils literal notranslate"><span class="pre">,</span></code>) and a semicolon (<code class="docutils literal notranslate"><span class="pre">;</span></code>), and add a space after them if they are not at the end of a line.</p>
</div>
<div class="section" id="preprocessor-directives">
<h3>Preprocessor directives<a class="headerlink" href="#preprocessor-directives" title="Permalink to this headline">¶</a></h3>
<p>The preprocessor directives are not indented.
The hash is the first character of the line.</p>
</div>
<div class="section" id="binary-operators">
<h3>Binary operators<a class="headerlink" href="#binary-operators" title="Permalink to this headline">¶</a></h3>
<p>The assignment operators should always have spaces around them.</p>
</div>
<div class="section" id="unary-operators">
<h3>Unary operators<a class="headerlink" href="#unary-operators" title="Permalink to this headline">¶</a></h3>
<p>Do not put any space between an unary operator and its argument.</p>
</div>
<div class="section" id="types">
<h3>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">using</span></code> syntax is preferred to <code class="docutils literal notranslate"><span class="pre">typedef</span></code> for type aliases.
If the actual type is not excessively long or complex, simply use it; renaming simple types makes code less understandable.</p>
</div>
<div class="section" id="pointers-and-references">
<h3>Pointers and references<a class="headerlink" href="#pointers-and-references" title="Permalink to this headline">¶</a></h3>
<p>Pointer or reference operators should go with the type. But understand the compiler reads them from right to left.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Type</span><span class="o">*</span> <span class="n">var</span><span class="p">;</span>
<span class="n">Type</span><span class="o">&amp;</span> <span class="n">var</span><span class="p">;</span>

<span class="o">//</span><span class="n">Understand</span> <span class="n">this</span> <span class="ow">is</span> <span class="n">incompatible</span> <span class="k">with</span> <span class="n">multiple</span> <span class="n">declarations</span>
<span class="n">Type</span><span class="o">*</span> <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">;</span> <span class="o">//</span> <span class="n">var1</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">Type</span> <span class="n">but</span> <span class="n">var2</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">Type</span><span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="templates">
<h3>Templates<a class="headerlink" href="#templates" title="Permalink to this headline">¶</a></h3>
<p>The angle brackets of templates should not have any external or internal padding.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">C</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Class1</span><span class="p">;</span>

<span class="n">Class1</span><span class="o">&lt;</span><span class="n">Class2</span><span class="o">&lt;</span><span class="n">type1</span><span class="o">&gt;&gt;</span> <span class="nb">object</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="vertical-spacing">
<h3>Vertical spacing<a class="headerlink" href="#vertical-spacing" title="Permalink to this headline">¶</a></h3>
<p>Use empty lines when it helps to improve the readability of the code, but do not use too many.
Do not use empty lines after a brace that opens a scope
or before a brace that closes a scope.
Each file should contain an empty line at the end of the file.
Some editors add an empty line automatically, some do not.</p>
</div>
<div class="section" id="variable-declarations-and-definitions">
<h3>Variable declarations and definitions<a class="headerlink" href="#variable-declarations-and-definitions" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>Avoid declaring multiple variables in the same declaration, especially if they are not fundamental types:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>                        <span class="o">//</span> <span class="n">Not</span> <span class="n">recommended</span>
<span class="n">Matrix</span> <span class="n">a</span><span class="p">(</span><span class="s2">&quot;my-matrix&quot;</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>  <span class="o">//</span> <span class="n">Not</span> <span class="n">allowed</span>

<span class="o">//</span> <span class="n">Preferred</span>
<span class="nb">int</span> <span class="n">x</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">y</span><span class="p">;</span>
<span class="n">Matrix</span> <span class="n">a</span><span class="p">(</span><span class="s2">&quot;my-matrix&quot;</span><span class="p">);</span>
<span class="n">Matrix</span> <span class="n">b</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>Use the following order for keywords and modifiers in  variable declarations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">General</span> <span class="nb">type</span>
<span class="p">[</span><span class="n">static</span><span class="p">]</span> <span class="p">[</span><span class="n">const</span><span class="o">/</span><span class="n">constexpr</span><span class="p">]</span> <span class="n">Type</span> <span class="n">variable_name</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Pointer</span>
<span class="p">[</span><span class="n">static</span><span class="p">]</span> <span class="p">[</span><span class="n">const</span><span class="p">]</span> <span class="n">Type</span><span class="o">*</span> <span class="p">[</span><span class="n">const</span><span class="p">]</span> <span class="n">variable_name</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Integer</span>
<span class="o">//</span> <span class="n">the</span> <span class="nb">int</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">optional</span> <span class="ow">not</span> <span class="nb">all</span> <span class="n">platforms</span> <span class="n">support</span> <span class="n">long</span><span class="p">,</span> <span class="n">etc</span><span class="o">.</span>
<span class="p">[</span><span class="n">static</span><span class="p">]</span> <span class="p">[</span><span class="n">const</span><span class="o">/</span><span class="n">constexpr</span><span class="p">]</span> <span class="p">[</span><span class="n">signedness</span><span class="p">]</span> <span class="p">[</span><span class="n">size</span><span class="p">]</span> <span class="nb">int</span> <span class="n">variable_name</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Examples</span><span class="p">:</span>
<span class="n">static</span> <span class="n">const</span> <span class="n">Matrix</span> <span class="n">a</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>


<span class="n">const</span> <span class="n">double</span><span class="o">*</span> <span class="n">const</span> <span class="n">d</span><span class="p">(</span><span class="mf">3.14</span><span class="p">);</span>
<span class="n">constexpr</span> <span class="n">unsigned</span> <span class="n">long</span> <span class="n">l</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="function-declarations-and-definitions">
<h3>Function declarations and definitions<a class="headerlink" href="#function-declarations-and-definitions" title="Permalink to this headline">¶</a></h3>
<p>The return type should be on the same line as the function name.
Parameters should also be on the same line unless they do not fit on it, in which case one parameter
per line aligned with the first parameter should be used.</p>
<p>Also include the parameter names in the declaration of a function, that is,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">calculates</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">+</span><span class="n">c</span>
<span class="n">double</span> <span class="n">function</span><span class="p">(</span><span class="n">double</span> <span class="n">a</span><span class="p">,</span> <span class="n">double</span> <span class="n">b</span><span class="p">,</span> <span class="n">double</span> <span class="n">c</span><span class="p">);</span>

<span class="o">//</span> <span class="n">avoid</span>
<span class="n">double</span> <span class="n">function</span><span class="p">(</span><span class="n">double</span><span class="p">,</span> <span class="n">double</span><span class="p">,</span> <span class="n">double</span><span class="p">);</span>

<span class="o">//</span><span class="n">dont</span> <span class="n">do</span> <span class="n">this</span>
<span class="n">double</span> <span class="n">function</span><span class="p">(</span><span class="n">BigTemplatedSomething</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">BigTemplatedSomething</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">,</span>
                <span class="n">BigTemplatedSomething</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">);</span>

<span class="o">//</span><span class="n">do</span> <span class="n">this</span>
<span class="n">double</span> <span class="n">function</span><span class="p">(</span><span class="n">BigTemplatedSomething</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span>
                <span class="n">BigTemplatedSomething</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">,</span>
                <span class="n">BigTemplatedSomething</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="conditionals">
<h3>Conditionals<a class="headerlink" href="#conditionals" title="Permalink to this headline">¶</a></h3>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
  <span class="n">statement</span><span class="p">;</span>
<span class="k">else</span>
  <span class="n">statement</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">statement</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">condition2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">statement</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
  <span class="n">statement</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="switch-statement">
<h3>Switch statement<a class="headerlink" href="#switch-statement" title="Permalink to this headline">¶</a></h3>
<p>Switch statements should always have a default case.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">switch</span> <span class="p">(</span><span class="n">var</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">case</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">statement1</span><span class="p">;</span>
    <span class="n">statement2</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="n">case</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">statement1</span><span class="p">;</span>
    <span class="n">statement2</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="n">default</span><span class="p">:</span>
    <span class="n">statement1</span><span class="p">;</span>
    <span class="n">statement2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="loops">
<h3>Loops<a class="headerlink" href="#loops" title="Permalink to this headline">¶</a></h3>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">statement</span><span class="p">;</span> <span class="n">condition</span><span class="p">;</span> <span class="n">statement</span><span class="p">)</span>
  <span class="n">statement</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">statement</span><span class="p">;</span> <span class="n">condition</span><span class="p">;</span> <span class="n">statement</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">statement1</span><span class="p">;</span>
  <span class="n">statement2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
  <span class="n">statement</span><span class="p">;</span>

<span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">statement1</span><span class="p">;</span>
  <span class="n">statement2</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">do</span>
<span class="p">{</span>
  <span class="n">statement</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="class-format">
<span id="id1"></span><h3>Class format<a class="headerlink" href="#class-format" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">public</span></code>, <code class="docutils literal notranslate"><span class="pre">protected</span></code>, and <code class="docutils literal notranslate"><span class="pre">private</span></code> keywords are not indented.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span> <span class="p">:</span> <span class="n">public</span> <span class="n">Bar</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
  <span class="n">Foo</span><span class="p">();</span>
  <span class="n">explicit</span> <span class="n">Foo</span><span class="p">(</span><span class="nb">int</span> <span class="n">var</span><span class="p">);</span>

  <span class="n">void</span> <span class="n">function</span><span class="p">();</span>
  <span class="n">void</span> <span class="n">emptyFunction</span><span class="p">()</span> <span class="p">{}</span>

  <span class="n">void</span> <span class="n">setVar</span><span class="p">(</span><span class="n">const</span> <span class="nb">int</span> <span class="n">var</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">var_</span> <span class="o">=</span> <span class="n">var</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nb">int</span> <span class="n">getVar</span><span class="p">()</span> <span class="n">const</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">var_</span><span class="p">;</span>
  <span class="p">}</span>

<span class="n">private</span><span class="p">:</span>
  <span class="nb">bool</span> <span class="n">privateFunction</span><span class="p">();</span>

  <span class="nb">int</span> <span class="n">var_</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">var2_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="section" id="constructor-initializer-lists">
<h4>Constructor initializer lists<a class="headerlink" href="#constructor-initializer-lists" title="Permalink to this headline">¶</a></h4>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">When</span> <span class="n">everything</span> <span class="n">fits</span> <span class="n">on</span> <span class="n">one</span> <span class="n">line</span><span class="p">:</span>
<span class="n">Foo</span><span class="p">::</span><span class="n">Foo</span><span class="p">(</span><span class="nb">int</span> <span class="n">var</span><span class="p">)</span> <span class="p">:</span> <span class="n">var_</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">statement</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">If</span> <span class="n">the</span> <span class="n">signature</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">initializer</span> <span class="nb">list</span> <span class="n">do</span> <span class="ow">not</span>
<span class="o">//</span> <span class="n">fit</span> <span class="n">on</span> <span class="n">one</span> <span class="n">line</span><span class="p">,</span> <span class="n">the</span> <span class="n">colon</span> <span class="ow">is</span> <span class="n">indented</span> <span class="n">by</span> <span class="mi">4</span> <span class="n">spaces</span><span class="p">:</span>
<span class="n">Foo</span><span class="p">::</span><span class="n">Foo</span><span class="p">(</span><span class="nb">int</span> <span class="n">var</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">var_</span><span class="p">(</span><span class="n">var</span><span class="p">),</span> <span class="n">var2_</span><span class="p">(</span><span class="n">var</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">statement</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">If</span> <span class="n">the</span> <span class="n">initializer</span> <span class="nb">list</span> <span class="n">occupies</span> <span class="n">more</span> <span class="n">lines</span><span class="p">,</span>
<span class="o">//</span> <span class="n">they</span> <span class="n">are</span> <span class="n">aligned</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">following</span> <span class="n">way</span><span class="p">:</span>
<span class="n">Foo</span><span class="p">::</span><span class="n">Foo</span><span class="p">(</span><span class="nb">int</span> <span class="n">var</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">some_var_</span><span class="p">(</span><span class="n">var</span><span class="p">),</span>
      <span class="n">some_other_var_</span><span class="p">(</span><span class="n">var</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">statement</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">No</span> <span class="n">statements</span><span class="p">:</span>
<span class="n">Foo</span><span class="p">::</span><span class="n">Foo</span><span class="p">(</span><span class="nb">int</span> <span class="n">var</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">some_var_</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="namespace-formatting">
<h3>Namespace formatting<a class="headerlink" href="#namespace-formatting" title="Permalink to this headline">¶</a></h3>
<p>The content of namespaces is not indented.
A comment should indicate when a namespace is closed. (clang-format will add these if absent).
If nested namespaces are used, a comment with the full namespace is required after opening a set of namespaces or an inner namespace.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">namespace</span> <span class="n">ns</span>
<span class="p">{</span>
<span class="n">void</span> <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>  <span class="o">//</span> <span class="n">ns</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">namespace</span> <span class="n">ns1</span>
<span class="p">{</span>
<span class="n">namespace</span> <span class="n">ns2</span>
<span class="p">{</span>
<span class="o">//</span> <span class="n">ns1</span><span class="p">::</span><span class="n">ns2</span><span class="p">::</span>
<span class="n">void</span> <span class="n">foo</span><span class="p">();</span>

<span class="n">namespace</span> <span class="n">ns3</span>
<span class="p">{</span>
<span class="o">//</span> <span class="n">ns1</span><span class="p">::</span><span class="n">ns2</span><span class="p">::</span><span class="n">ns3</span><span class="p">::</span>
<span class="n">void</span> <span class="n">bar</span><span class="p">();</span>
<span class="p">}</span>  <span class="o">//</span> <span class="n">ns3</span>
<span class="p">}</span>  <span class="o">//</span> <span class="n">ns2</span>

<span class="n">namespace</span> <span class="n">ns4</span>
<span class="p">{</span>
<span class="n">namespace</span> <span class="n">ns5</span>
<span class="p">{</span>
<span class="o">//</span> <span class="n">ns1</span><span class="p">::</span><span class="n">ns4</span><span class="p">::</span><span class="n">ns5</span><span class="p">::</span>
<span class="n">void</span> <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>  <span class="o">//</span> <span class="n">ns5</span>
<span class="p">}</span>  <span class="o">//</span> <span class="n">ns4</span>
<span class="p">}</span>  <span class="o">//</span> <span class="n">ns1</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="qmcpack-c-guidance">
<h2>QMCPACK C++ guidance<a class="headerlink" href="#qmcpack-c-guidance" title="Permalink to this headline">¶</a></h2>
<p>The guidance here, like any advice on how to program, should not be treated as a set of rules but rather the hard-won wisdom of many hours of suffering development. In the past, many rules were ignored, and the absolute worst results of that will affect whatever code you need to work with. Your PR should go much smoother if you do not ignore them.</p>
<div class="section" id="encapsulation">
<h3>Encapsulation<a class="headerlink" href="#encapsulation" title="Permalink to this headline">¶</a></h3>
<p>A class is not just a naming scheme for a set of variables and functions. It should provide a logical set of methods, could contain the state of a logical object, and might allow access to object data through a well-defined interface related variables, while preserving maximally ability to change internal implementation of the class.</p>
<p>Do not use <code class="docutils literal notranslate"><span class="pre">struct</span></code> as a way to avoid controlling access to the class. Only in rare cases where a class is a fully public data structure <code class="docutils literal notranslate"><span class="pre">struct</span></code> is this appropriate. Ignore (or fix one) the many examples of this in QMCPACK.</p>
<p>Do not use inheritance primarily as a means to break encapsulation. If your class could aggregate or compose another class, do that, and access it solely through its public interface. This will reduce dependencies.</p>
</div>
<div class="section" id="casting">
<h3>Casting<a class="headerlink" href="#casting" title="Permalink to this headline">¶</a></h3>
<p>In C++ source, avoid C style casts; they are difficult to search for and imprecise in function.
An exception is made for controlling implicit conversion of simple numerical types.</p>
<p>Explicit C++ style casts make it clear what the safety of the cast is and what sort of conversion is expected to be possible.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">double</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">double</span><span class="p">)</span><span class="n">c</span> <span class="o">/</span> <span class="n">d</span><span class="p">;</span>  <span class="o">//</span> <span class="n">Ok</span>

<span class="n">const</span> <span class="n">class1</span> <span class="n">c1</span><span class="p">;</span>
<span class="n">class2</span><span class="o">*</span> <span class="n">c2</span><span class="p">;</span>
<span class="n">c2</span> <span class="o">=</span> <span class="p">(</span><span class="n">class2</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">c1</span><span class="p">;</span> <span class="o">//</span> <span class="n">NO</span>
<span class="n">SPOSetAdvanced</span><span class="o">*</span> <span class="n">spo_advanced</span> <span class="o">=</span> <span class="n">new</span> <span class="n">SPOSetAdvanced</span><span class="p">();</span>

<span class="n">SPOSet</span><span class="o">*</span> <span class="n">spo</span> <span class="o">=</span> <span class="p">(</span><span class="n">SPOSet</span><span class="o">*</span><span class="p">)</span><span class="n">spo_advanced</span><span class="p">;</span> <span class="o">//</span> <span class="n">NO</span>
<span class="n">SPOSet</span><span class="o">*</span> <span class="n">spo</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="n">SPOSet</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">spo_advanced</span><span class="p">);</span> <span class="o">//</span> <span class="n">OK</span> <span class="k">if</span> <span class="n">upcast</span><span class="p">,</span> <span class="n">dangerous</span> <span class="k">if</span> <span class="n">downcast</span>
</pre></div>
</div>
</div>
<div class="section" id="pre-increment-and-pre-decrement">
<h3>Pre-increment and pre-decrement<a class="headerlink" href="#pre-increment-and-pre-decrement" title="Permalink to this headline">¶</a></h3>
<p>Use the pre-increment (pre-decrement) operator when a variable is incremented (decremented) and the value of the expression is not used.
In particular, use the pre-increment (pre-decrement) operator for loop counters where i is not used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">doSomething</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">doSomething</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The post-increment and post-decrement operators create an unnecessary copy that the compiler cannot optimize away in the case of iterators or other classes with overloaded increment and decrement operators.</p>
</div>
<div class="section" id="alternative-operator-representations">
<h3>Alternative operator representations<a class="headerlink" href="#alternative-operator-representations" title="Permalink to this headline">¶</a></h3>
<p>Alternative representations of operators and other tokens such as <code class="docutils literal notranslate"><span class="pre">and</span></code>, <code class="docutils literal notranslate"><span class="pre">or</span></code>, and <code class="docutils literal notranslate"><span class="pre">not</span></code> instead of <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">||</span></code>, and <code class="docutils literal notranslate"><span class="pre">!</span></code> are not allowed.
For the reason of consistency, the far more common primary tokens should always be used.</p>
</div>
<div class="section" id="use-of-const">
<h3>Use of const<a class="headerlink" href="#use-of-const" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>Add the <code class="docutils literal notranslate"><span class="pre">const</span></code> qualifier to all function parameters that are not modified in the function body.</p></li>
<li><p>For parameters passed by value, add only the keyword in the function definition.</p></li>
<li><p>Member functions should be specified const whenever possible.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Declaration</span>
<span class="nb">int</span> <span class="n">computeFoo</span><span class="p">(</span><span class="nb">int</span> <span class="n">bar</span><span class="p">,</span> <span class="n">const</span> <span class="n">Matrix</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span>

<span class="o">//</span> <span class="n">Definition</span>
<span class="nb">int</span> <span class="n">computeFoo</span><span class="p">(</span><span class="n">const</span> <span class="nb">int</span> <span class="n">bar</span><span class="p">,</span> <span class="n">const</span> <span class="n">Matrix</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>

  <span class="o">//</span> <span class="n">Compute</span> <span class="n">foo</span> <span class="n">without</span> <span class="n">changing</span> <span class="n">bar</span> <span class="ow">or</span> <span class="n">m</span><span class="o">.</span>
  <span class="o">//</span> <span class="o">...</span>

  <span class="k">return</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">MyClass</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">count_</span>
  <span class="o">...</span>
  <span class="nb">int</span> <span class="n">getCount</span><span class="p">()</span> <span class="n">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">count_</span><span class="p">;}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="scalar-estimator-implementation">
<h2>Scalar estimator implementation<a class="headerlink" href="#scalar-estimator-implementation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="introduction-life-of-a-specialized-operatorbase">
<h3>Introduction: Life of a specialized OperatorBase<a class="headerlink" href="#introduction-life-of-a-specialized-operatorbase" title="Permalink to this headline">¶</a></h3>
<p>Almost all observables in QMCPACK are implemented as specialized derived
classes of the OperatorBase base class. Each observable is instantiated
in HamiltonianFactory and added to QMCHamiltonian for tracking.
QMCHamiltonian tracks two types of observables: main and auxiliary. Main
observables contribute to the local energy. These observables are
elements of the simulated Hamiltonian such as kinetic or potential
energy. Auxiliary observables are expectation values of matrix elements
that do not contribute to the local energy. These Hamiltonians do not
affect the dynamics of the simulation. In the code, the main observables
are labeled by “physical” flag; the auxiliary observables have
“physical” set to false.</p>
<div class="section" id="initialization">
<h4>Initialization<a class="headerlink" href="#initialization" title="Permalink to this headline">¶</a></h4>
<p>When an <code class="docutils literal notranslate"><span class="pre">&lt;estimator</span> <span class="pre">type=&quot;est_type&quot;</span> <span class="pre">name=&quot;est_name&quot;</span> <span class="pre">other_stuff=&quot;value&quot;/&gt;</span></code> tag is present in the <code class="docutils literal notranslate"><span class="pre">&lt;hamiltonian/&gt;</span></code> section, it is first read by HamiltonianFactory. In general, the <code class="docutils literal notranslate"><span class="pre">type</span></code> of the estimator will determine which specialization of OperatorBase should be instantiated, and a derived class with <code class="docutils literal notranslate"><span class="pre">myName=&quot;est_name&quot;</span></code> will be constructed. Then, the put() method of this specific class will be called to read any other parameters in the <code class="docutils literal notranslate"><span class="pre">&lt;estimator/&gt;</span></code> XML node. Sometimes these parameters will instead be read by HamiltonianFactory because it can access more objects than OperatorBase.</p>
</div>
<div class="section" id="cloning">
<h4>Cloning<a class="headerlink" href="#cloning" title="Permalink to this headline">¶</a></h4>
<p>When <code class="docutils literal notranslate"><span class="pre">OpenMP</span></code> threads are spawned, the estimator will be cloned by the <code class="docutils literal notranslate"><span class="pre">CloneManager</span></code>, which is a parent class of many QMC drivers.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">CloneManager</span><span class="o">.</span><span class="n">cpp</span>
<span class="c1">#pragma omp parallel for shared(w,psi,ham)</span>
<span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">ip</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">ip</span><span class="o">&lt;</span><span class="n">NumThreads</span><span class="p">;</span> <span class="o">++</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">wClones</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="o">=</span><span class="n">new</span> <span class="n">MCWalkerConfiguration</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
  <span class="n">psiClones</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="o">=</span><span class="n">psi</span><span class="o">.</span><span class="n">makeClone</span><span class="p">(</span><span class="o">*</span><span class="n">wClones</span><span class="p">[</span><span class="n">ip</span><span class="p">]);</span>
  <span class="n">hClones</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="o">=</span><span class="n">ham</span><span class="o">.</span><span class="n">makeClone</span><span class="p">(</span><span class="o">*</span><span class="n">wClones</span><span class="p">[</span><span class="n">ip</span><span class="p">],</span><span class="o">*</span><span class="n">psiClones</span><span class="p">[</span><span class="n">ip</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the preceding snippet, <code class="docutils literal notranslate"><span class="pre">ham</span></code> is the reference to the estimator on the master thread. If the implemented estimator does not allocate memory for any array, then the default constructor should suffice for the <code class="docutils literal notranslate"><span class="pre">makeClone</span></code> method.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">SpeciesKineticEnergy</span><span class="o">.</span><span class="n">cpp</span>
<span class="n">OperatorBase</span><span class="o">*</span> <span class="n">SpeciesKineticEnergy</span><span class="p">::</span><span class="n">makeClone</span><span class="p">(</span><span class="n">ParticleSet</span><span class="o">&amp;</span> <span class="n">qp</span><span class="p">,</span> <span class="n">TrialWaveFunction</span><span class="o">&amp;</span> <span class="n">psi</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">new</span> <span class="n">SpeciesKineticEnergy</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If memory is allocated during estimator construction (usually when parsing the XML node in the <code class="docutils literal notranslate"><span class="pre">put</span></code> method), then the <code class="docutils literal notranslate"><span class="pre">makeClone</span></code> method should perform the same initialization on each thread.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OperatorBase</span><span class="o">*</span> <span class="n">LatticeDeviationEstimator</span><span class="p">::</span><span class="n">makeClone</span><span class="p">(</span><span class="n">ParticleSet</span><span class="o">&amp;</span> <span class="n">qp</span><span class="p">,</span> <span class="n">TrialWaveFunction</span><span class="o">&amp;</span> <span class="n">psi</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">LatticeDeviationEstimator</span><span class="o">*</span> <span class="n">myclone</span> <span class="o">=</span> <span class="n">new</span> <span class="n">LatticeDeviationEstimator</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span><span class="n">spset</span><span class="p">,</span><span class="n">tgroup</span><span class="p">,</span><span class="n">sgroup</span><span class="p">);</span>
  <span class="n">myclone</span><span class="o">-&gt;</span><span class="n">put</span><span class="p">(</span><span class="n">input_xml</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">myclone</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="evaluate">
<h4>Evaluate<a class="headerlink" href="#evaluate" title="Permalink to this headline">¶</a></h4>
<p>After the observable class (derived class of OperatorBase) is constructed and prepared (by the put() method), it is ready to be used in a QMCDriver. A QMCDriver will call <code class="docutils literal notranslate"><span class="pre">H.auxHevaluate(W,thisWalker)</span></code> after every accepted move, where H is the QMCHamiltonian that holds all main and auxiliary Hamiltonian elements, W is a MCWalkerConfiguration, and thisWalker is a pointer to the current walker being worked on. As shown in the following, this function goes through each auxiliary Hamiltonian element and evaluates it using the current walker configuration. Under the hood, observables are calculated and dumped to the main particle set’s property list for later collection.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">QMCHamiltonian</span><span class="o">.</span><span class="n">cpp</span>
<span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">more</span> <span class="n">efficient</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Only</span> <span class="n">calculate</span> <span class="n">auxH</span> <span class="n">elements</span> <span class="k">if</span> <span class="n">moves</span> <span class="n">are</span> <span class="n">accepted</span><span class="o">.</span>
<span class="n">void</span> <span class="n">QMCHamiltonian</span><span class="p">::</span><span class="n">auxHevaluate</span><span class="p">(</span><span class="n">ParticleSet</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">,</span> <span class="n">Walker_t</span><span class="o">&amp;</span> <span class="n">ThisWalker</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">#if !defined(REMOVE_TRACEMANAGER)</span>
  <span class="n">collect_walker_traces</span><span class="p">(</span><span class="n">ThisWalker</span><span class="p">,</span><span class="n">P</span><span class="o">.</span><span class="n">current_step</span><span class="p">);</span>
<span class="c1">#endif</span>
  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">auxH</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">auxH</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setHistories</span><span class="p">(</span><span class="n">ThisWalker</span><span class="p">);</span>
    <span class="n">RealType</span> <span class="n">sink</span> <span class="o">=</span> <span class="n">auxH</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">evaluate</span><span class="p">(</span><span class="n">P</span><span class="p">);</span>
    <span class="n">auxH</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setObservables</span><span class="p">(</span><span class="n">Observables</span><span class="p">);</span>
<span class="c1">#if !defined(REMOVE_TRACEMANAGER)</span>
    <span class="n">auxH</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">collect_scalar_traces</span><span class="p">();</span>
<span class="c1">#endif</span>
    <span class="n">auxH</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setParticlePropertyList</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">PropertyList</span><span class="p">,</span><span class="n">myIndex</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For estimators that contribute to the local energy (main observables), the return value of evaluate() is used in accumulating the local energy. For auxiliary estimators, the return value is not used (<code class="docutils literal notranslate"><span class="pre">sink</span></code> local variable above); only the value of Value is recorded property lists by the setObservables() method as shown in the preceding code snippet. By default, the setObservables() method will transfer <code class="docutils literal notranslate"><span class="pre">auxH[i]-&gt;Value</span></code> to <code class="docutils literal notranslate"><span class="pre">P.PropertyList[auxH[i]-&gt;myIndex]</span></code>. The same property list is also kept by the particle set being moved by QMCDriver. This list is updated by <code class="docutils literal notranslate"><span class="pre">auxH[i]-&gt;setParticlePropertyList(P.PropertyList,myIndex)</span></code>, where myIndex is the starting index of space allocated to this specific auxiliary Hamiltonian in the property list kept by the target particle set P.</p>
</div>
<div class="section" id="collection">
<h4>Collection<a class="headerlink" href="#collection" title="Permalink to this headline">¶</a></h4>
<p>The actual statistics are collected within the QMCDriver, which owns
an EstimatorManager object. This object (or a clone in the case of
multithreading) will be registered with each mover it owns. For each mover
(such as VMCUpdatePbyP derived from QMCUpdateBase), an accumulate() call
is made, which by default, makes an accumulate(walkerset) call to the
EstimatorManager it owns. Since each walker has a property set, EstimatorManager uses that local copy to calculate statistics. The EstimatorManager performs block averaging and file I/O.</p>
</div>
</div>
<div class="section" id="single-scalar-estimator-implementation-guide">
<h3>Single scalar estimator implementation guide<a class="headerlink" href="#single-scalar-estimator-implementation-guide" title="Permalink to this headline">¶</a></h3>
<p>Almost all of the defaults can be used for a single scalar observable. With any luck, only the put() and evaluate() methods need to be implemented. As an example, this section presents a step-by-step guide for implementing a verb|SpeciesKineticEnergy| estimator that calculates the kinetic energy of a specific species instead of the entire particle set. For example, a possible input to this estimator can be:</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;estimator</span> <span class="pre">type=&quot;specieskinetic&quot;</span> <span class="pre">name=&quot;ukinetic&quot;</span> <span class="pre">group=&quot;u&quot;/&gt;</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;estimator</span> <span class="pre">type=&quot;specieskinetic&quot;</span> <span class="pre">name=&quot;dkinetic&quot;</span> <span class="pre">group=&quot;d&quot;/&gt;</span></code>.</p>
<p>This should create two extra columns in the <code class="docutils literal notranslate"><span class="pre">scalar.dat</span></code> file that contains the kinetic energy of the up and down electrons in two separate columns. If the estimator is properly implemented, then the sum of these two columns should be equal to the default <code class="docutils literal notranslate"><span class="pre">Kinetic</span></code> column.</p>
<div class="section" id="barebone">
<h4>Barebone<a class="headerlink" href="#barebone" title="Permalink to this headline">¶</a></h4>
<p>The first step is to create a barebone class structure for this simple scalar estimator. The goal is to be able to instantiate this scalar estimator with an XML node and have it print out a column of zeros in the <code class="docutils literal notranslate"><span class="pre">scalar.dat</span></code> file.</p>
<p>To achieve this, first create a header file “SpeciesKineticEnergy.h” in the QMCHamiltonians folder, with only the required functions declared as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">SpeciesKineticEnergy</span><span class="o">.</span><span class="n">h</span>
<span class="c1">#ifndef QMCPLUSPLUS_SPECIESKINETICENERGY_H</span>
<span class="c1">#define QMCPLUSPLUS_SPECIESKINETICENERGY_H</span>

<span class="c1">#include &lt;Particle/WalkerSetRef.h&gt;</span>
<span class="c1">#include &lt;QMCHamiltonians/OperatorBase.h&gt;</span>

<span class="n">namespace</span> <span class="n">qmcplusplus</span>
<span class="p">{</span>

<span class="k">class</span> <span class="nc">SpeciesKineticEnergy</span><span class="p">:</span> <span class="n">public</span> <span class="n">OperatorBase</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>

  <span class="n">SpeciesKineticEnergy</span><span class="p">(</span><span class="n">ParticleSet</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">):</span><span class="n">tpset</span><span class="p">(</span><span class="n">P</span><span class="p">){</span> <span class="p">};</span>

  <span class="nb">bool</span> <span class="n">put</span><span class="p">(</span><span class="n">xmlNodePtr</span> <span class="n">cur</span><span class="p">);</span>         <span class="o">//</span> <span class="n">read</span> <span class="nb">input</span> <span class="n">xml</span> <span class="n">node</span><span class="p">,</span> <span class="n">required</span>
  <span class="nb">bool</span> <span class="n">get</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span> <span class="o">//</span> <span class="k">class</span> <span class="nc">description</span><span class="p">,</span> <span class="n">required</span>

  <span class="n">Return_t</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">ParticleSet</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">);</span>
  <span class="n">inline</span> <span class="n">Return_t</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">ParticleSet</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">NonLocalData</span><span class="o">&gt;&amp;</span> <span class="n">Txy</span><span class="p">)</span>
  <span class="p">{</span> <span class="o">//</span> <span class="n">delegate</span> <span class="n">responsity</span> <span class="n">inline</span> <span class="k">for</span> <span class="n">speed</span>
    <span class="k">return</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">P</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="o">//</span> <span class="n">pure</span> <span class="n">virtual</span> <span class="n">functions</span> <span class="n">require</span> <span class="n">overrider</span>
  <span class="n">void</span> <span class="n">resetTargetParticleSet</span><span class="p">(</span><span class="n">ParticleSet</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>                         <span class="o">//</span> <span class="n">required</span>
  <span class="n">OperatorBase</span><span class="o">*</span> <span class="n">makeClone</span><span class="p">(</span><span class="n">ParticleSet</span><span class="o">&amp;</span> <span class="n">qp</span><span class="p">,</span> <span class="n">TrialWaveFunction</span><span class="o">&amp;</span> <span class="n">psi</span><span class="p">);</span> <span class="o">//</span> <span class="n">required</span>

<span class="n">private</span><span class="p">:</span>
  <span class="n">ParticleSet</span><span class="o">&amp;</span> <span class="n">tpset</span><span class="p">;</span>

<span class="p">};</span> <span class="o">//</span> <span class="n">SpeciesKineticEnergy</span>

<span class="p">}</span> <span class="o">//</span> <span class="n">namespace</span> <span class="n">qmcplusplus</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p>Notice that a local reference <code class="docutils literal notranslate"><span class="pre">tpset</span></code> to the target particle set <code class="docutils literal notranslate"><span class="pre">P</span></code> is saved in the constructor. The target particle set carries much information useful for calculating observables. Next, make “SpeciesKineticEnergy.cpp,” and make vacuous definitions.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">SpeciesKineticEnergy</span><span class="o">.</span><span class="n">cpp</span>
<span class="c1">#include &lt;QMCHamiltonians/SpeciesKineticEnergy.h&gt;</span>
<span class="n">namespace</span> <span class="n">qmcplusplus</span>
<span class="p">{</span>

<span class="nb">bool</span> <span class="n">SpeciesKineticEnergy</span><span class="p">::</span><span class="n">put</span><span class="p">(</span><span class="n">xmlNodePtr</span> <span class="n">cur</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">bool</span> <span class="n">SpeciesKineticEnergy</span><span class="p">::</span><span class="n">get</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SpeciesKineticEnergy</span><span class="p">::</span><span class="n">Return_t</span> <span class="n">SpeciesKineticEnergy</span><span class="p">::</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ParticleSet</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Value</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">Value</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">OperatorBase</span><span class="o">*</span> <span class="n">SpeciesKineticEnergy</span><span class="p">::</span><span class="n">makeClone</span><span class="p">(</span><span class="n">ParticleSet</span><span class="o">&amp;</span> <span class="n">qp</span><span class="p">,</span> <span class="n">TrialWaveFunction</span><span class="o">&amp;</span> <span class="n">psi</span><span class="p">)</span>
<span class="p">{</span>
  <span class="o">//</span> <span class="n">no</span> <span class="n">local</span> <span class="n">array</span> <span class="n">allocated</span><span class="p">,</span> <span class="n">default</span> <span class="n">constructor</span> <span class="n">should</span> <span class="n">be</span> <span class="n">enough</span>
  <span class="k">return</span> <span class="n">new</span> <span class="n">SpeciesKineticEnergy</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">}</span> <span class="o">//</span> <span class="n">namespace</span> <span class="n">qmcplusplus</span>
</pre></div>
</div>
<p>Now, head over to HamiltonianFactory and instantiate this observable if an XML node is found requesting it. Look for “gofr” in HamiltonianFactory.cpp, for example, and follow the if block.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">HamiltonianFactory</span><span class="o">.</span><span class="n">cpp</span>
<span class="c1">#include &lt;QMCHamiltonians/SpeciesKineticEnergy.h&gt;</span>
<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">potType</span> <span class="o">==</span><span class="s2">&quot;specieskinetic&quot;</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">SpeciesKineticEnergy</span><span class="o">*</span> <span class="n">apot</span> <span class="o">=</span> <span class="n">new</span> <span class="n">SpeciesKineticEnergy</span><span class="p">(</span><span class="o">*</span><span class="n">target_particle_set</span><span class="p">);</span>
  <span class="n">apot</span><span class="o">-&gt;</span><span class="n">put</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
  <span class="n">targetH</span><span class="o">-&gt;</span><span class="n">addOperator</span><span class="p">(</span><span class="n">apot</span><span class="p">,</span><span class="n">potName</span><span class="p">,</span><span class="n">false</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The last argument of addOperator() (i.e., the <code class="docutils literal notranslate"><span class="pre">false</span></code> flag) is <strong>crucial</strong>. This tells QMCPACK that the observable we implemented is not a physical Hamiltonian; thus, it will not contribute to the local energy. Changes to the local energy will alter the dynamics of the simulation. Finally, add “SpeciesKineticEnergy.cpp” to HAMSRCS in “CMakeLists.txt” located in the QMCHamiltonians folder. Now, recompile QMCPACK and run it on an input that requests <code class="docutils literal notranslate"><span class="pre">&lt;estimator</span> <span class="pre">type=&quot;specieskinetic&quot;</span> <span class="pre">name=&quot;ukinetic&quot;/&gt;</span></code> in the <code class="docutils literal notranslate"><span class="pre">hamiltonian</span></code> block. A column of zeros should appear in the <code class="docutils literal notranslate"><span class="pre">scalar.dat</span></code> file under the name “ukinetic.”</p>
</div>
<div class="section" id="id2">
<h4>Evaluate<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>The evaluate() method is where we perform the calculation of the desired observable. In a first iteration, we will simply hard-code the name and mass of the particles.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">SpeciesKineticEnergy</span><span class="o">.</span><span class="n">cpp</span>
<span class="c1">#include &lt;QMCHamiltonians/BareKineticEnergy.h&gt; // laplaician() defined here</span>
<span class="n">SpeciesKineticEnergy</span><span class="p">::</span><span class="n">Return_t</span> <span class="n">SpeciesKineticEnergy</span><span class="p">::</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ParticleSet</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">group</span><span class="o">=</span><span class="s2">&quot;u&quot;</span><span class="p">;</span>
  <span class="n">RealType</span> <span class="n">minus_over_2m</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">;</span>

  <span class="n">SpeciesSet</span><span class="o">&amp;</span> <span class="n">tspecies</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">getSpeciesSet</span><span class="p">());</span>

  <span class="n">Value</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">iat</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">iat</span><span class="o">&lt;</span><span class="n">P</span><span class="o">.</span><span class="n">getTotalNum</span><span class="p">();</span> <span class="n">iat</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tspecies</span><span class="o">.</span><span class="n">speciesName</span><span class="p">[</span> <span class="n">P</span><span class="o">.</span><span class="n">GroupID</span><span class="p">(</span><span class="n">iat</span><span class="p">)</span> <span class="p">]</span> <span class="o">==</span> <span class="n">group</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">Value</span> <span class="o">+=</span> <span class="n">minus_over_2m</span><span class="o">*</span><span class="n">laplacian</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">G</span><span class="p">[</span><span class="n">iat</span><span class="p">],</span><span class="n">P</span><span class="o">.</span><span class="n">L</span><span class="p">[</span><span class="n">iat</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Value</span><span class="p">;</span>

  <span class="o">//</span> <span class="n">Kinetic</span> <span class="n">column</span> <span class="n">has</span><span class="p">:</span>
  <span class="o">//</span> <span class="n">Value</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span> <span class="n">Dot</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">G</span><span class="p">,</span><span class="n">P</span><span class="o">.</span><span class="n">G</span><span class="p">)</span> <span class="o">+</span> <span class="n">Sum</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">L</span><span class="p">)</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>Voila</em>—you should now be able to compile QMCPACK, rerun, and see that the values in the “ukinetic” column are no longer zero. Now, the only task left to make this basic observable complete is to read in the extra parameters instead of hard-coding them.</p>
</div>
<div class="section" id="parse-extra-input">
<h4>Parse extra input<a class="headerlink" href="#parse-extra-input" title="Permalink to this headline">¶</a></h4>
<p>The preferred method to parse extra input parameters in the XML node is
to implement the put() function of our specific observable. Suppose we
wish to read in a single string that tells us whether to record the
kinetic energy of the up electron (group=“u”) or the down electron
(group=“d”). This is easily achievable using the OhmmsAttributeSet
class,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">SpeciesKineticEnergy</span><span class="o">.</span><span class="n">cpp</span>
<span class="c1">#include &lt;OhmmsData/AttributeSet.h&gt;</span>
<span class="nb">bool</span> <span class="n">SpeciesKineticEnergy</span><span class="p">::</span><span class="n">put</span><span class="p">(</span><span class="n">xmlNodePtr</span> <span class="n">cur</span><span class="p">)</span>
<span class="p">{</span>
  <span class="o">//</span> <span class="n">read</span> <span class="ow">in</span> <span class="n">extra</span> <span class="n">parameter</span> <span class="s2">&quot;group&quot;</span>
  <span class="n">OhmmsAttributeSet</span> <span class="n">attrib</span><span class="p">;</span>
  <span class="n">attrib</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="s2">&quot;group&quot;</span><span class="p">);</span>
  <span class="n">attrib</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>

  <span class="o">//</span> <span class="n">save</span> <span class="n">mass</span> <span class="n">of</span> <span class="n">specified</span> <span class="n">group</span> <span class="n">of</span> <span class="n">particles</span>
  <span class="n">SpeciesSet</span><span class="o">&amp;</span> <span class="n">tspecies</span><span class="p">(</span><span class="n">tpset</span><span class="o">.</span><span class="n">getSpeciesSet</span><span class="p">());</span>
  <span class="nb">int</span> <span class="n">group_id</span>  <span class="o">=</span> <span class="n">tspecies</span><span class="o">.</span><span class="n">findSpecies</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
  <span class="nb">int</span> <span class="n">massind</span>   <span class="o">=</span> <span class="n">tspecies</span><span class="o">.</span><span class="n">getAttribute</span><span class="p">(</span><span class="s2">&quot;mass&quot;</span><span class="p">);</span>
  <span class="n">minus_over_2m</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">tspecies</span><span class="p">(</span><span class="n">massind</span><span class="p">,</span><span class="n">group_id</span><span class="p">));</span>

  <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>where we may keep “group” and “minus_over_2m” as local variables to our specific class.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">SpeciesKineticEnergy</span><span class="o">.</span><span class="n">h</span>
<span class="n">private</span><span class="p">:</span>
  <span class="n">ParticleSet</span><span class="o">&amp;</span> <span class="n">tpset</span><span class="p">;</span>
  <span class="n">std</span><span class="p">::</span><span class="n">string</span>  <span class="n">group</span><span class="p">;</span>
  <span class="n">RealType</span> <span class="n">minus_over_2m</span><span class="p">;</span>
</pre></div>
</div>
<p>Notice that the previous operations are made possible by the saved reference to the target particle set. Last but not least, compile and run a full example (i.e., a short DMC calculation) with the following XML nodes in your input:</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;estimator</span> <span class="pre">type=&quot;specieskinetic&quot;</span> <span class="pre">name=&quot;ukinetic&quot;</span> <span class="pre">group=&quot;u&quot;/&gt;</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;estimator</span> <span class="pre">type=&quot;specieskinetic&quot;</span> <span class="pre">name=&quot;dkinetic&quot;</span> <span class="pre">group=&quot;d&quot;/&gt;</span></code></p>
<p>Make sure the sum of the “ukinetic” and “dkinetic” columns is
<strong>exactly</strong> the same as the Kinetic columns at <strong>every block</strong>.</p>
<p>For easy reference, a summary of the complete list of changes follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">HamiltonianFactory</span><span class="o">.</span><span class="n">cpp</span>
<span class="c1">#include &quot;QMCHamiltonians/SpeciesKineticEnergy.h&quot;</span>
<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">potType</span> <span class="o">==</span><span class="s2">&quot;specieskinetic&quot;</span><span class="p">)</span>
<span class="p">{</span>
      <span class="n">SpeciesKineticEnergy</span><span class="o">*</span> <span class="n">apot</span> <span class="o">=</span> <span class="n">new</span> <span class="n">SpeciesKineticEnergy</span><span class="p">(</span><span class="o">*</span><span class="n">targetPtcl</span><span class="p">);</span>
      <span class="n">apot</span><span class="o">-&gt;</span><span class="n">put</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
      <span class="n">targetH</span><span class="o">-&gt;</span><span class="n">addOperator</span><span class="p">(</span><span class="n">apot</span><span class="p">,</span><span class="n">potName</span><span class="p">,</span><span class="n">false</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// In SpeciesKineticEnergy.h
#include &lt;Particle/WalkerSetRef.h&gt;
#include &lt;QMCHamiltonians/OperatorBase.h&gt;

namespace qmcplusplus
{

class SpeciesKineticEnergy: public OperatorBase
{
public:

  SpeciesKineticEnergy(ParticleSet&amp; P):tpset(P){ };

  // xml node is read by HamiltonianFactory, eg. the sum of following should be equivalent to Kinetic
  // &lt;estimator name=&quot;ukinetic&quot; type=&quot;specieskinetic&quot; target=&quot;e&quot; group=&quot;u&quot;/&gt;
  // &lt;estimator name=&quot;dkinetic&quot; type=&quot;specieskinetic&quot; target=&quot;e&quot; group=&quot;d&quot;/&gt;
  bool put(xmlNodePtr cur);         // read input xml node, required
  bool get(std::ostream&amp; os) const; // class description, required

  Return_t evaluate(ParticleSet&amp; P);
  inline Return_t evaluate(ParticleSet&amp; P, std::vector&lt;NonLocalData&gt;&amp; Txy)
  { // delegate responsity inline for speed
    return evaluate(P);
  }

  // pure virtual functions require overrider
  void resetTargetParticleSet(ParticleSet&amp; P) { }                         // required
  OperatorBase* makeClone(ParticleSet&amp; qp, TrialWaveFunction&amp; psi); // required

private:
  ParticleSet&amp;       tpset; // reference to target particle set
  std::string        group; // name of species to track
  RealType   minus_over_2m; // mass of the species !! assume same mass
  // for multiple species, simply initialize multiple estimators

}; // SpeciesKineticEnergy

} // namespace qmcplusplus
#endif
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">SpeciesKineticEnergy</span><span class="o">.</span><span class="n">cpp</span>
<span class="c1">#include &lt;QMCHamiltonians/SpeciesKineticEnergy.h&gt;</span>
<span class="c1">#include &lt;QMCHamiltonians/BareKineticEnergy.h&gt; // laplaician() defined here</span>
<span class="c1">#include &lt;OhmmsData/AttributeSet.h&gt;</span>

<span class="n">namespace</span> <span class="n">qmcplusplus</span>
<span class="p">{</span>

<span class="nb">bool</span> <span class="n">SpeciesKineticEnergy</span><span class="p">::</span><span class="n">put</span><span class="p">(</span><span class="n">xmlNodePtr</span> <span class="n">cur</span><span class="p">)</span>
<span class="p">{</span>
  <span class="o">//</span> <span class="n">read</span> <span class="ow">in</span> <span class="n">extra</span> <span class="n">parameter</span> <span class="s2">&quot;group&quot;</span>
  <span class="n">OhmmsAttributeSet</span> <span class="n">attrib</span><span class="p">;</span>
  <span class="n">attrib</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="s2">&quot;group&quot;</span><span class="p">);</span>
  <span class="n">attrib</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>

  <span class="o">//</span> <span class="n">save</span> <span class="n">mass</span> <span class="n">of</span> <span class="n">specified</span> <span class="n">group</span> <span class="n">of</span> <span class="n">particles</span>
  <span class="nb">int</span> <span class="n">group_id</span>  <span class="o">=</span> <span class="n">tspecies</span><span class="o">.</span><span class="n">findSpecies</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
  <span class="nb">int</span> <span class="n">massind</span>   <span class="o">=</span> <span class="n">tspecies</span><span class="o">.</span><span class="n">getAttribute</span><span class="p">(</span><span class="s2">&quot;mass&quot;</span><span class="p">);</span>
  <span class="n">minus_over_2m</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">tspecies</span><span class="p">(</span><span class="n">massind</span><span class="p">,</span><span class="n">group_id</span><span class="p">));</span>

  <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">bool</span> <span class="n">SpeciesKineticEnergy</span><span class="p">::</span><span class="n">get</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span> <span class="o">//</span> <span class="k">class</span> <span class="nc">description</span>
  <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;SpeciesKineticEnergy: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">myName</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot; for species &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">group</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SpeciesKineticEnergy</span><span class="p">::</span><span class="n">Return_t</span> <span class="n">SpeciesKineticEnergy</span><span class="p">::</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ParticleSet</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Value</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">iat</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">iat</span><span class="o">&lt;</span><span class="n">P</span><span class="o">.</span><span class="n">getTotalNum</span><span class="p">();</span> <span class="n">iat</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tspecies</span><span class="o">.</span><span class="n">speciesName</span><span class="p">[</span> <span class="n">P</span><span class="o">.</span><span class="n">GroupID</span><span class="p">(</span><span class="n">iat</span><span class="p">)</span> <span class="p">]</span> <span class="o">==</span> <span class="n">group</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">Value</span> <span class="o">+=</span> <span class="n">minus_over_2m</span><span class="o">*</span><span class="n">laplacian</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">G</span><span class="p">[</span><span class="n">iat</span><span class="p">],</span><span class="n">P</span><span class="o">.</span><span class="n">L</span><span class="p">[</span><span class="n">iat</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Value</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">OperatorBase</span><span class="o">*</span> <span class="n">SpeciesKineticEnergy</span><span class="p">::</span><span class="n">makeClone</span><span class="p">(</span><span class="n">ParticleSet</span><span class="o">&amp;</span> <span class="n">qp</span><span class="p">,</span> <span class="n">TrialWaveFunction</span><span class="o">&amp;</span> <span class="n">psi</span><span class="p">)</span>
<span class="p">{</span> <span class="o">//</span><span class="n">default</span> <span class="n">constructor</span>
  <span class="k">return</span> <span class="n">new</span> <span class="n">SpeciesKineticEnergy</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">}</span> <span class="o">//</span> <span class="n">namespace</span> <span class="n">qmcplusplus</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="multiple-scalars">
<h3>Multiple scalars<a class="headerlink" href="#multiple-scalars" title="Permalink to this headline">¶</a></h3>
<p>It is fairly straightforward to create more than one column in the <code class="docutils literal notranslate"><span class="pre">scalar.dat</span></code> file with a single observable class. For example, if we want a single SpeciesKineticEnergy estimator to simultaneously record the kinetic energies of all species in the target particle set, we only have to write two new methods: addObservables() and setObservables(), then tweak the behavior of evaluate(). First, we will have to override the default behavior of addObservables() to make room for more than one column in the <code class="docutils literal notranslate"><span class="pre">scalar.dat</span></code> file as follows,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">SpeciesKineticEnergy</span><span class="o">.</span><span class="n">cpp</span>
<span class="n">void</span> <span class="n">SpeciesKineticEnergy</span><span class="p">::</span><span class="n">addObservables</span><span class="p">(</span><span class="n">PropertySetType</span><span class="o">&amp;</span> <span class="n">plist</span><span class="p">,</span> <span class="n">BufferType</span><span class="o">&amp;</span> <span class="n">collectables</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">myIndex</span> <span class="o">=</span> <span class="n">plist</span><span class="o">.</span><span class="n">size</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">ispec</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">ispec</span><span class="o">&lt;</span><span class="n">num_species</span><span class="p">;</span> <span class="n">ispec</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span> <span class="o">//</span> <span class="n">make</span> <span class="n">columns</span> <span class="n">named</span> <span class="s2">&quot;$myName_u&quot;</span><span class="p">,</span> <span class="s2">&quot;$myName_d&quot;</span> <span class="n">etc</span><span class="o">.</span>
    <span class="n">plist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">myName</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">species_names</span><span class="p">[</span><span class="n">ispec</span><span class="p">]);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>where “num_species” and “species_name” can be local variables
initialized in the constructor. We should also initialize some local
arrays to hold temporary data.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">SpeciesKineticEnergy</span><span class="o">.</span><span class="n">h</span>
<span class="n">private</span><span class="p">:</span>
  <span class="nb">int</span> <span class="n">num_species</span><span class="p">;</span>
  <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">species_names</span><span class="p">;</span>
  <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RealType</span><span class="o">&gt;</span> <span class="n">species_kinetic</span><span class="p">,</span><span class="n">vec_minus_over_2m</span><span class="p">;</span>

<span class="o">//</span> <span class="n">In</span> <span class="n">SpeciesKineticEnergy</span><span class="o">.</span><span class="n">cpp</span>
<span class="n">SpeciesKineticEnergy</span><span class="p">::</span><span class="n">SpeciesKineticEnergy</span><span class="p">(</span><span class="n">ParticleSet</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">):</span><span class="n">tpset</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">SpeciesSet</span><span class="o">&amp;</span> <span class="n">tspecies</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">getSpeciesSet</span><span class="p">());</span>
  <span class="nb">int</span> <span class="n">massind</span> <span class="o">=</span> <span class="n">tspecies</span><span class="o">.</span><span class="n">getAttribute</span><span class="p">(</span><span class="s2">&quot;mass&quot;</span><span class="p">);</span>

  <span class="n">num_species</span> <span class="o">=</span> <span class="n">tspecies</span><span class="o">.</span><span class="n">size</span><span class="p">();</span>
  <span class="n">species_kinetic</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">num_species</span><span class="p">);</span>
  <span class="n">vec_minus_over_2m</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">num_species</span><span class="p">);</span>
  <span class="n">species_names</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">num_species</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">ispec</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">ispec</span><span class="o">&lt;</span><span class="n">num_species</span><span class="p">;</span> <span class="n">ispec</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">species_names</span><span class="p">[</span><span class="n">ispec</span><span class="p">]</span> <span class="o">=</span> <span class="n">tspecies</span><span class="o">.</span><span class="n">speciesName</span><span class="p">[</span><span class="n">ispec</span><span class="p">];</span>
    <span class="n">vec_minus_over_2m</span><span class="p">[</span><span class="n">ispec</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">tspecies</span><span class="p">(</span><span class="n">massind</span><span class="p">,</span><span class="n">ispec</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Next, we need to override the default behavior of <code class="docutils literal notranslate"><span class="pre">setObservables()</span></code> to transfer multiple values to the property list kept by the main particle set, which eventually goes into the <code class="docutils literal notranslate"><span class="pre">scalar.dat</span></code> file.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">SpeciesKineticEnergy</span><span class="o">.</span><span class="n">cpp</span>
<span class="n">void</span> <span class="n">SpeciesKineticEnergy</span><span class="p">::</span><span class="n">setObservables</span><span class="p">(</span><span class="n">PropertySetType</span><span class="o">&amp;</span> <span class="n">plist</span><span class="p">)</span>
<span class="p">{</span> <span class="o">//</span> <span class="n">slots</span> <span class="ow">in</span> <span class="n">plist</span> <span class="n">must</span> <span class="n">be</span> <span class="n">allocated</span> <span class="n">by</span> <span class="n">addObservables</span><span class="p">()</span> <span class="n">first</span>
  <span class="n">copy</span><span class="p">(</span><span class="n">species_kinetic</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">species_kinetic</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span><span class="n">plist</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">myIndex</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, we need to change the behavior of evaluate() to fill the local
vector “species_kinetic” with appropriate observable values.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SpeciesKineticEnergy</span><span class="p">::</span><span class="n">Return_t</span> <span class="n">SpeciesKineticEnergy</span><span class="p">::</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ParticleSet</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="p">::</span><span class="n">fill</span><span class="p">(</span><span class="n">species_kinetic</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">species_kinetic</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span><span class="mf">0.0</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">iat</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">iat</span><span class="o">&lt;</span><span class="n">P</span><span class="o">.</span><span class="n">getTotalNum</span><span class="p">();</span> <span class="n">iat</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="nb">int</span> <span class="n">ispec</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">GroupID</span><span class="p">(</span><span class="n">iat</span><span class="p">);</span>
    <span class="n">species_kinetic</span><span class="p">[</span><span class="n">ispec</span><span class="p">]</span> <span class="o">+=</span> <span class="n">vec_minus_over_2m</span><span class="p">[</span><span class="n">ispec</span><span class="p">]</span><span class="o">*</span><span class="n">laplacian</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">G</span><span class="p">[</span><span class="n">iat</span><span class="p">],</span><span class="n">P</span><span class="o">.</span><span class="n">L</span><span class="p">[</span><span class="n">iat</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="n">Value</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="o">//</span> <span class="n">Value</span> <span class="ow">is</span> <span class="n">no</span> <span class="n">longer</span> <span class="n">used</span>
  <span class="k">return</span> <span class="n">Value</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>That’s it! The SpeciesKineticEnergy estimator no longer needs the “group” input and will automatically output the kinetic energy of every species in the target particle set in multiple columns. You should now be able to run with
<code class="docutils literal notranslate"><span class="pre">&lt;estimator</span> <span class="pre">type=&quot;specieskinetic&quot;</span> <span class="pre">name=&quot;skinetic&quot;/&gt;</span></code> and check that the sum of all columns that start with “skinetic” is equal to the default “Kinetic” column.</p>
</div>
<div class="section" id="hdf5-output">
<h3>HDF5 output<a class="headerlink" href="#hdf5-output" title="Permalink to this headline">¶</a></h3>
<p>If we desire an observable that will output hundreds of scalars per simulation step (e.g., SkEstimator), then it is preferred to output to the <code class="docutils literal notranslate"><span class="pre">stat.h5</span></code> file instead of the <code class="docutils literal notranslate"><span class="pre">scalar.dat</span></code> file for better organization. A large chunk of data to be registered in the <code class="docutils literal notranslate"><span class="pre">stat.h5</span></code> file is called a “Collectable” in QMCPACK. In particular, if a OperatorBase object is initialized with <code class="docutils literal notranslate"><span class="pre">UpdateMode.set(COLLECTABLE,1)</span></code>, then the “Collectables” object carried by the main particle set will be processed and written to the <code class="docutils literal notranslate"><span class="pre">stat.h5</span></code> file, where “UpdateMode” is a bit set (i.e., a collection of flags) with the following enumeration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">OperatorBase</span><span class="o">.</span><span class="n">h</span>
<span class="o">///</span><span class="n">enum</span> <span class="k">for</span> <span class="n">UpdateMode</span>
<span class="n">enum</span> <span class="p">{</span><span class="n">PRIMARY</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
  <span class="n">OPTIMIZABLE</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
  <span class="n">RATIOUPDATE</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
  <span class="n">PHYSICAL</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
  <span class="n">COLLECTABLE</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
  <span class="n">NONLOCAL</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
  <span class="n">VIRTUALMOVES</span><span class="o">=</span><span class="mi">6</span>
<span class="p">};</span>
</pre></div>
</div>
<p>As a simple example, to put the two columns we produced in the previous section into the <code class="docutils literal notranslate"><span class="pre">stat.h5</span></code> file, we will first need to declare that our observable uses “Collectables.”</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">constructor</span> <span class="n">add</span><span class="p">:</span>
<span class="n">hdf5_out</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
<span class="n">UpdateMode</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">COLLECTABLE</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>Then make some room in the “Collectables” object carried by the target particle set.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">addObservables</span><span class="p">(</span><span class="n">PropertySetType</span><span class="o">&amp;</span> <span class="n">plist</span><span class="p">,</span> <span class="n">BufferType</span><span class="o">&amp;</span> <span class="n">collectables</span><span class="p">)</span> <span class="n">add</span><span class="p">:</span>
<span class="k">if</span> <span class="p">(</span><span class="n">hdf5_out</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">h5_index</span> <span class="o">=</span> <span class="n">collectables</span><span class="o">.</span><span class="n">size</span><span class="p">();</span>
  <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RealType</span><span class="o">&gt;</span> <span class="n">tmp</span><span class="p">(</span><span class="n">num_species</span><span class="p">);</span>
  <span class="n">collectables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">tmp</span><span class="o">.</span><span class="n">end</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Next, make some room in the <code class="docutils literal notranslate"><span class="pre">stat.h5</span></code> file by overriding the registerCollectables() method.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">SpeciesKineticEnergy</span><span class="o">.</span><span class="n">cpp</span>
<span class="n">void</span> <span class="n">SpeciesKineticEnergy</span><span class="p">::</span><span class="n">registerCollectables</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">observable_helper</span><span class="o">*&gt;&amp;</span> <span class="n">h5desc</span><span class="p">,</span> <span class="n">hid_t</span> <span class="n">gid</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">hdf5_out</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span> <span class="n">ndim</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">num_species</span><span class="p">);</span>
    <span class="n">observable_helper</span><span class="o">*</span> <span class="n">h5o</span><span class="o">=</span><span class="n">new</span> <span class="n">observable_helper</span><span class="p">(</span><span class="n">myName</span><span class="p">);</span>
    <span class="n">h5o</span><span class="o">-&gt;</span><span class="n">set_dimensions</span><span class="p">(</span><span class="n">ndim</span><span class="p">,</span><span class="n">h5_index</span><span class="p">);</span>
    <span class="n">h5o</span><span class="o">-&gt;</span><span class="nb">open</span><span class="p">(</span><span class="n">gid</span><span class="p">);</span>
    <span class="n">h5desc</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">h5o</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, edit evaluate() to use the space in the “Collectables” object.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// In SpeciesKineticEnergy.cpp
SpeciesKineticEnergy::Return_t SpeciesKineticEnergy::evaluate(ParticleSet&amp; P)
{
  RealType wgt = tWalker-&gt;Weight; // MUST explicitly use DMC weights in Collectables!
  std::fill(species_kinetic.begin(),species_kinetic.end(),0.0);

  for (int iat=0; iat&lt;P.getTotalNum(); iat++)
  {
    int ispec = P.GroupID(iat);
    species_kinetic[ispec] += vec_minus_over_2m[ispec]*laplacian(P.G[iat],P.L[iat]);
    P.Collectables[h5_index + ispec] += vec_minus_over_2m[ispec]*laplacian(P.G[iat],P.L[iat])*wgt;
  }

  Value = 0.0; // Value is no longer used
  return Value;
}
</pre></div>
</div>
<p>There should now be a new entry in the <code class="docutils literal notranslate"><span class="pre">stat.h5</span></code> file containing the same columns of data as the <code class="docutils literal notranslate"><span class="pre">stat.h5</span></code> file. After this check, we should clean up the code by</p>
<ul class="simple">
<li><p>making “hdf5_out” and input flag by editing the put() method and</p></li>
<li><p>disabling output to <code class="docutils literal notranslate"><span class="pre">scalar.dat</span></code> when the “hdf5_out” flag is on.</p></li>
</ul>
</div>
</div>
<div class="section" id="estimator-output">
<h2>Estimator output<a class="headerlink" href="#estimator-output" title="Permalink to this headline">¶</a></h2>
<div class="section" id="estimator-definition">
<h3>Estimator definition<a class="headerlink" href="#estimator-definition" title="Permalink to this headline">¶</a></h3>
<p>For simplicity, consider a local property <span class="math notranslate nohighlight">\(O(\bf{R})\)</span>, where
<span class="math notranslate nohighlight">\(\bf{R}\)</span> is the collection of all particle coordinates. An
<em>estimator</em> for <span class="math notranslate nohighlight">\(O(\bf{R})\)</span> is a weighted average over walkers:</p>
<div class="math notranslate nohighlight" id="equation-eq242">
<span class="eqno">(242)<a class="headerlink" href="#equation-eq242" title="Permalink to this equation">¶</a></span>\[ \begin{aligned}
 E[O] = \left(\sum\limits_{i=1}^{N^{tot}_{walker}} w_i O(\bf{R}_i) \right) / \left( \sum \limits_{i=1}^{N^{tot}_{walker}} w_i \right). \end{aligned}\]</div>
<p><span class="math notranslate nohighlight">\(N^{tot}_{walker}\)</span> is the total number of walkers collected in the
entire simulation. Notice that <span class="math notranslate nohighlight">\(N^{tot}_{walker}\)</span> is typically far
larger than the number of walkers held in memory at any given simulation
step. <span class="math notranslate nohighlight">\(w_i\)</span> is the weight of walker <span class="math notranslate nohighlight">\(i\)</span>.</p>
<p>In a VMC simulation, the weight of every walker is 1.0. Further, the
number of walkers is constant at each step. Therefore,
<a class="reference internal" href="#equation-eq242">(242)</a> simplifies to</p>
<div class="math notranslate nohighlight" id="equation-eq243">
<span class="eqno">(243)<a class="headerlink" href="#equation-eq243" title="Permalink to this equation">¶</a></span>\[ \begin{aligned}
 E_{VMC}[O] = \frac{1}{N_{step}N_{walker}^{ensemble}} \sum_{s,e} O(\bf{R}_{s,e})\:.\end{aligned}\]</div>
<p>Each walker <span class="math notranslate nohighlight">\(\bf{R}_{s,e}\)</span> is labeled by <em>step index</em> s and
<em>ensemble index</em> e.</p>
<p>In a DMC simulation, the weight of each walker is different and may
change from step to step. Further, the ensemble size varies from step to
step. Therefore, <a class="reference internal" href="#equation-eq242">(242)</a> simplifies to</p>
<div class="math notranslate nohighlight" id="equation-eq244">
<span class="eqno">(244)<a class="headerlink" href="#equation-eq244" title="Permalink to this equation">¶</a></span>\[ \begin{aligned}
 E_{DMC}[O] = \frac{1}{N_{step}} \sum_{s} \left\{ \left(\sum_e w_{s,e} O(\bf{R}_{s,e})  \right) / \left( \sum \limits_{e} w_{s,e} \right)  \right\}\:.\end{aligned}\]</div>
<p>We will refer to the average in the <span class="math notranslate nohighlight">\(\{\}\)</span> as <em>ensemble average</em>
and to the remaining averages as <em>block average</em>. The process of
calculating <span class="math notranslate nohighlight">\(O(\mathbf{R})\)</span> is <em>evaluate</em>.</p>
</div>
<div class="section" id="class-relations">
<h3>Class relations<a class="headerlink" href="#class-relations" title="Permalink to this headline">¶</a></h3>
<p>A large number of classes are involved in the estimator collection process. They often have misleading class or method names. Check out the document gotchas in the following list:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">EstimatorManager</span></code> is an unused copy of <code class="docutils literal notranslate"><span class="pre">EstimatorManagerBase</span></code>.
<code class="docutils literal notranslate"><span class="pre">EstimatorManagerBase</span></code> is the class used in the QMC drivers. (PR
#371 explains this.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EstimatorManagerBase::Estimators</span></code> is completely different from
<code class="docutils literal notranslate"><span class="pre">QMCDriver::Estimators</span></code>, which is subtly different from
<code class="docutils literal notranslate"><span class="pre">OperatorBase::Estimators</span></code>. The first is a list of pointers to
<code class="docutils literal notranslate"><span class="pre">ScalarEstimatorBase</span></code>. The second is the master estimator (one per
MPI group). The third is the slave estimator that exists one per
OpenMP thread.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">QMCHamiltonian</span></code> is NOT a parent class of <code class="docutils literal notranslate"><span class="pre">OperatorBase</span></code>.
Instead, <code class="docutils literal notranslate"><span class="pre">QMCHamiltonian</span></code> owns two lists of <code class="docutils literal notranslate"><span class="pre">OperatorBase</span></code> named
<code class="docutils literal notranslate"><span class="pre">H</span></code> and <code class="docutils literal notranslate"><span class="pre">auxH</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">QMCDriver::H</span></code> is NOT the same as <code class="docutils literal notranslate"><span class="pre">QMCHamiltonian::H</span></code>. The first
is a pointer to a <code class="docutils literal notranslate"><span class="pre">QMCHamiltonian</span></code>. <code class="docutils literal notranslate"><span class="pre">QMCHamiltonian::H</span></code> is a
list.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EstimatorManager::stopBlock(std::vector)</span></code> is completely different
from <code class="docutils literal notranslate"><span class="pre">EstimatorManager::</span></code> <code class="docutils literal notranslate"><span class="pre">stopBlock(RealType)</span></code>, which is the
same as <code class="docutils literal notranslate"><span class="pre">stopBlock(RealType,</span> <span class="pre">true)</span></code> but that is subtly different
from <code class="docutils literal notranslate"><span class="pre">stopBlock(RealType,</span> <span class="pre">false)</span></code>. The first three methods are
intended to be called by the master estimator, which exists one per
MPI group. The last method is intended to be called by the slave
estimator, which exists one per OpenMP thread.</p></li>
</ol>
</div>
<div class="section" id="estimator-output-stages">
<h3>Estimator output stages<a class="headerlink" href="#estimator-output-stages" title="Permalink to this headline">¶</a></h3>
<p>Estimators take four conceptual stages to propagate to the output files: evaluate, load ensemble, unload ensemble, and collect. They are easier to understand in reverse order.</p>
<div class="section" id="collect-stage">
<h4>Collect stage<a class="headerlink" href="#collect-stage" title="Permalink to this headline">¶</a></h4>
<p>File output is performed by the master <code class="docutils literal notranslate"><span class="pre">EstimatorManager</span></code> owned by <code class="docutils literal notranslate"><span class="pre">QMCDriver</span></code>. The first 8+ entries in <code class="docutils literal notranslate"><span class="pre">EstimatorManagerBase::AverageCache</span></code> will be written to <code class="docutils literal notranslate"><span class="pre">scalar.dat</span></code>. The remaining entries in <code class="docutils literal notranslate"><span class="pre">AverageCache</span></code> will be written to <code class="docutils literal notranslate"><span class="pre">stat.h5</span></code>. File writing is triggered by <code class="docutils literal notranslate"><span class="pre">EstimatorManagerBase</span></code> <code class="docutils literal notranslate"><span class="pre">::collectBlockAverages</span></code> inside <code class="docutils literal notranslate"><span class="pre">EstimatorManagerBase::stopBlock</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">EstimatorManagerBase</span><span class="o">.</span><span class="n">cpp</span><span class="p">::</span><span class="n">collectBlockAverages</span>
  <span class="k">if</span><span class="p">(</span><span class="n">Archive</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="o">*</span><span class="n">Archive</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">RecordCount</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">maxobjs</span><span class="o">=</span><span class="n">std</span><span class="p">::</span><span class="nb">min</span><span class="p">(</span><span class="n">BlockAverages</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span><span class="n">max4ascii</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">maxobjs</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="o">*</span><span class="n">Archive</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">setw</span><span class="p">(</span><span class="n">FieldWidth</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">AverageCache</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">PropertyCache</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="o">*</span><span class="n">Archive</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">setw</span><span class="p">(</span><span class="n">FieldWidth</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PropertyCache</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="o">*</span><span class="n">Archive</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">o</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">o</span><span class="o">&lt;</span><span class="n">h5desc</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">o</span><span class="p">)</span>
      <span class="n">h5desc</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">AverageCache</span><span class="o">.</span><span class="n">data</span><span class="p">(),</span><span class="n">SquaredAverageCache</span><span class="o">.</span><span class="n">data</span><span class="p">());</span>
    <span class="n">H5Fflush</span><span class="p">(</span><span class="n">h_file</span><span class="p">,</span><span class="n">H5F_SCOPE_LOCAL</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">EstimatorManagerBase::collectBlockAverages</span></code> is triggered from the master-thread estimator via either <code class="docutils literal notranslate"><span class="pre">stopBlock(std::vector)</span></code> or <code class="docutils literal notranslate"><span class="pre">stopBlock(RealType,</span> <span class="pre">true)</span></code>. Notice that file writing is NOT triggered by the slave-thread estimator method <code class="docutils literal notranslate"><span class="pre">stopBlock(RealType,</span> <span class="pre">false)</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">EstimatorManagerBase</span><span class="o">.</span><span class="n">cpp</span>
<span class="n">void</span> <span class="n">EstimatorManagerBase</span><span class="p">::</span><span class="n">stopBlock</span><span class="p">(</span><span class="n">RealType</span> <span class="n">accept</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">collectall</span><span class="p">)</span>
<span class="p">{</span>
  <span class="o">//</span><span class="n">take</span> <span class="n">block</span> <span class="n">averages</span> <span class="ow">and</span> <span class="n">update</span> <span class="n">properties</span> <span class="n">per</span> <span class="n">block</span>
  <span class="n">PropertyCache</span><span class="p">[</span><span class="n">weightInd</span><span class="p">]</span><span class="o">=</span><span class="n">BlockWeight</span><span class="p">;</span>
  <span class="n">PropertyCache</span><span class="p">[</span><span class="n">cpuInd</span><span class="p">]</span> <span class="o">=</span> <span class="n">MyTimer</span><span class="o">.</span><span class="n">elapsed</span><span class="p">();</span>
  <span class="n">PropertyCache</span><span class="p">[</span><span class="n">acceptInd</span><span class="p">]</span> <span class="o">=</span> <span class="n">accept</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">Estimators</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">Estimators</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">takeBlockAverage</span><span class="p">(</span><span class="n">AverageCache</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">SquaredAverageCache</span><span class="o">.</span><span class="n">begin</span><span class="p">());</span>
  <span class="k">if</span><span class="p">(</span><span class="n">Collectables</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Collectables</span><span class="o">-&gt;</span><span class="n">takeBlockAverage</span><span class="p">(</span><span class="n">AverageCache</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">SquaredAverageCache</span><span class="o">.</span><span class="n">begin</span><span class="p">());</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="n">collectall</span><span class="p">)</span>
    <span class="n">collectBlockAverages</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">ScalarEstimatorBase</span><span class="o">.</span><span class="n">h</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span> <span class="n">IT</span><span class="o">&gt;</span>
<span class="n">inline</span> <span class="n">void</span> <span class="n">takeBlockAverage</span><span class="p">(</span><span class="n">IT</span> <span class="n">first</span><span class="p">,</span> <span class="n">IT</span> <span class="n">first_sq</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">first</span> <span class="o">+=</span> <span class="n">FirstIndex</span><span class="p">;</span>
  <span class="n">first_sq</span> <span class="o">+=</span> <span class="n">FirstIndex</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">scalars</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="o">*</span><span class="n">first</span><span class="o">++</span> <span class="o">=</span> <span class="n">scalars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">();</span>
    <span class="o">*</span><span class="n">first_sq</span><span class="o">++</span> <span class="o">=</span> <span class="n">scalars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mean2</span><span class="p">();</span>
    <span class="n">scalars_saved</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">scalars</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="o">//</span><span class="n">save</span> <span class="n">current</span> <span class="n">block</span>
    <span class="n">scalars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>At the collect stage, <code class="docutils literal notranslate"><span class="pre">calarEstimatorBase::scalars</span></code> must be populated with ensemble-averaged data. Two derived classes of <code class="docutils literal notranslate"><span class="pre">ScalarEstimatorBase</span></code> are crucial: <code class="docutils literal notranslate"><span class="pre">LocalEnergyEstimator</span></code> will carry <code class="docutils literal notranslate"><span class="pre">Properties</span></code>, where as <code class="docutils literal notranslate"><span class="pre">CollectablesEstimator</span></code> will carry <code class="docutils literal notranslate"><span class="pre">Collectables</span></code>.</p>
</div>
<div class="section" id="unload-ensemble-stage">
<h4>Unload ensemble stage<a class="headerlink" href="#unload-ensemble-stage" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">LocalEnergyEstimator::scalars</span></code> are populated by
<code class="docutils literal notranslate"><span class="pre">ScalarEstimatorBase::accumulate</span></code>, whereas
<code class="docutils literal notranslate"><span class="pre">CollectablesEstimator::scalars</span></code> are populated by
<code class="docutils literal notranslate"><span class="pre">CollectablesEstimator::</span></code> <code class="docutils literal notranslate"><span class="pre">accumulate_all</span></code>. Both accumulate methods
are triggered by <code class="docutils literal notranslate"><span class="pre">EstimatorManagerBase::accumulate</span></code>. One confusing
aspect about the unload stage is that
<code class="docutils literal notranslate"><span class="pre">EstimatorManagerBase::accumulate</span></code> has a master and a slave call
signature. A slave estimator such as <code class="docutils literal notranslate"><span class="pre">QMCUpdateBase::Estimators</span></code>
should unload a subset of walkers. Thus, the slave estimator should call
<code class="docutils literal notranslate"><span class="pre">accumulate(W,it,it_end)</span></code>. However, the master estimator, such as
<code class="docutils literal notranslate"><span class="pre">SimpleFixedNodeBranch::myEstimator</span></code>, should unload data from the
entire walker ensemble. This is achieved by calling <code class="docutils literal notranslate"><span class="pre">accumulate(W)</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">EstimatorManagerBase</span><span class="p">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">MCWalkerConfiguration</span><span class="o">&amp;</span> <span class="n">W</span><span class="p">)</span>
<span class="p">{</span> <span class="o">//</span> <span class="n">intended</span> <span class="n">to</span> <span class="n">be</span> <span class="n">called</span> <span class="n">by</span> <span class="n">master</span> <span class="n">estimator</span> <span class="n">only</span>
  <span class="n">BlockWeight</span> <span class="o">+=</span> <span class="n">W</span><span class="o">.</span><span class="n">getActiveWalkers</span><span class="p">();</span>
  <span class="n">RealType</span> <span class="n">norm</span><span class="o">=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">W</span><span class="o">.</span><span class="n">getGlobalNumWalkers</span><span class="p">();</span>
  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">Estimators</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">Estimators</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">accumulate</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="n">W</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">W</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span><span class="n">norm</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">Collectables</span><span class="p">)</span><span class="o">//</span><span class="n">collectables</span> <span class="n">are</span> <span class="n">normalized</span> <span class="n">by</span> <span class="n">QMC</span> <span class="n">drivers</span>
    <span class="n">Collectables</span><span class="o">-&gt;</span><span class="n">accumulate_all</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">Collectables</span><span class="p">,</span><span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">EstimatorManagerBase</span><span class="p">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">MCWalkerConfiguration</span><span class="o">&amp;</span> <span class="n">W</span>
 <span class="p">,</span> <span class="n">MCWalkerConfiguration</span><span class="p">::</span><span class="n">iterator</span> <span class="n">it</span>
 <span class="p">,</span> <span class="n">MCWalkerConfiguration</span><span class="p">::</span><span class="n">iterator</span> <span class="n">it_end</span><span class="p">)</span>
<span class="p">{</span> <span class="o">//</span> <span class="n">intended</span> <span class="n">to</span> <span class="n">be</span> <span class="n">called</span> <span class="n">slaveEstimator</span> <span class="n">only</span>
  <span class="n">BlockWeight</span> <span class="o">+=</span> <span class="n">it_end</span><span class="o">-</span><span class="n">it</span><span class="p">;</span>
  <span class="n">RealType</span> <span class="n">norm</span><span class="o">=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">W</span><span class="o">.</span><span class="n">getGlobalNumWalkers</span><span class="p">();</span>
  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">Estimators</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">Estimators</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">accumulate</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="n">it</span><span class="p">,</span><span class="n">it_end</span><span class="p">,</span><span class="n">norm</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">Collectables</span><span class="p">)</span>
    <span class="n">Collectables</span><span class="o">-&gt;</span><span class="n">accumulate_all</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">Collectables</span><span class="p">,</span><span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">LocalEnergyEstimator</span><span class="o">.</span><span class="n">h</span>
<span class="n">inline</span> <span class="n">void</span> <span class="n">accumulate</span><span class="p">(</span><span class="n">const</span> <span class="n">Walker_t</span><span class="o">&amp;</span> <span class="n">awalker</span><span class="p">,</span> <span class="n">RealType</span> <span class="n">wgt</span><span class="p">)</span>
<span class="p">{</span> <span class="o">//</span> <span class="n">ensemble</span> <span class="n">average</span> <span class="n">W</span><span class="o">.</span><span class="n">Properties</span>
  <span class="o">//</span> <span class="n">expect</span> <span class="n">ePtr</span> <span class="n">to</span> <span class="n">be</span> <span class="n">W</span><span class="o">.</span><span class="n">Properties</span><span class="p">;</span> <span class="n">expect</span> <span class="n">wgt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">GlobalNumberOfWalkers</span>
  <span class="n">const</span> <span class="n">RealType</span><span class="o">*</span> <span class="n">restrict</span> <span class="n">ePtr</span> <span class="o">=</span> <span class="n">awalker</span><span class="o">.</span><span class="n">getPropertyBase</span><span class="p">();</span>
  <span class="n">RealType</span> <span class="n">wwght</span><span class="o">=</span> <span class="n">wgt</span><span class="o">*</span> <span class="n">awalker</span><span class="o">.</span><span class="n">Weight</span><span class="p">;</span>
  <span class="n">scalars</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">ePtr</span><span class="p">[</span><span class="n">WP</span><span class="p">::</span><span class="n">LOCALENERGY</span><span class="p">],</span><span class="n">wwght</span><span class="p">);</span>
  <span class="n">scalars</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="n">ePtr</span><span class="p">[</span><span class="n">WP</span><span class="p">::</span><span class="n">LOCALENERGY</span><span class="p">]</span><span class="o">*</span><span class="n">ePtr</span><span class="p">[</span><span class="n">WP</span><span class="p">::</span><span class="n">LOCALENERGY</span><span class="p">],</span><span class="n">wwght</span><span class="p">);</span>
  <span class="n">scalars</span><span class="p">[</span><span class="mi">2</span><span class="p">](</span><span class="n">ePtr</span><span class="p">[</span><span class="n">LOCALPOTENTIAL</span><span class="p">],</span><span class="n">wwght</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">target</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">FirstHamiltonian</span><span class="p">;</span> <span class="n">target</span><span class="o">&lt;</span><span class="n">scalars</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">target</span><span class="p">,</span> <span class="o">++</span><span class="n">source</span><span class="p">)</span>
    <span class="n">scalars</span><span class="p">[</span><span class="n">target</span><span class="p">](</span><span class="n">ePtr</span><span class="p">[</span><span class="n">source</span><span class="p">],</span><span class="n">wwght</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">CollectablesEstimator</span><span class="o">.</span><span class="n">h</span>
<span class="n">inline</span> <span class="n">void</span> <span class="n">accumulate_all</span><span class="p">(</span><span class="n">const</span> <span class="n">MCWalkerConfiguration</span><span class="p">::</span><span class="n">Buffer_t</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="n">RealType</span> <span class="n">wgt</span><span class="p">)</span>
<span class="p">{</span> <span class="o">//</span> <span class="n">ensemble</span> <span class="n">average</span> <span class="n">W</span><span class="o">.</span><span class="n">Collectables</span>
  <span class="o">//</span> <span class="n">expect</span> <span class="n">data</span> <span class="n">to</span> <span class="n">be</span> <span class="n">W</span><span class="o">.</span><span class="n">Collectables</span><span class="p">;</span> <span class="n">expect</span> <span class="n">wgt</span> <span class="o">=</span> <span class="mf">1.0</span>
  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">scalars</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">wgt</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>At the unload ensemble stage, the data structures <code class="docutils literal notranslate"><span class="pre">Properties</span></code> and <code class="docutils literal notranslate"><span class="pre">Collectables</span></code> must be populated by appropriately normalized values so that the ensemble average can be correctly taken. <code class="docutils literal notranslate"><span class="pre">QMCDriver</span></code> is responsible for the correct loading of data onto the walker ensemble.</p>
</div>
<div class="section" id="load-ensemble-stage">
<h4>Load ensemble stage<a class="headerlink" href="#load-ensemble-stage" title="Permalink to this headline">¶</a></h4>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">Properties</span></code> in the MC ensemble of walkers <code class="docutils literal notranslate"><span class="pre">QMCDriver::W</span></code> is
populated by <code class="docutils literal notranslate"><span class="pre">QMCHamiltonian</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">::saveProperties</span></code>. The master <code class="docutils literal notranslate"><span class="pre">QMCHamiltonian::LocalEnergy</span></code>,
<code class="docutils literal notranslate"><span class="pre">::KineticEnergy</span></code>, and <code class="docutils literal notranslate"><span class="pre">::Observables</span></code> must be properly populated
at the end of the evaluate stage.</div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">QMCHamiltonian</span><span class="o">.</span><span class="n">h</span>
  <span class="n">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">IT</span><span class="o">&gt;</span>
  <span class="n">inline</span>
  <span class="n">void</span> <span class="n">saveProperty</span><span class="p">(</span><span class="n">IT</span> <span class="n">first</span><span class="p">)</span>
  <span class="p">{</span> <span class="o">//</span> <span class="n">expect</span> <span class="n">first</span> <span class="n">to</span> <span class="n">be</span> <span class="n">W</span><span class="o">.</span><span class="n">Properties</span>
    <span class="n">first</span><span class="p">[</span><span class="n">LOCALPOTENTIAL</span><span class="p">]</span><span class="o">=</span> <span class="n">LocalEnergy</span><span class="o">-</span><span class="n">KineticEnergy</span><span class="p">;</span>
    <span class="n">copy</span><span class="p">(</span><span class="n">Observables</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">Observables</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span><span class="n">first</span><span class="o">+</span><span class="n">myIndex</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Collectables</span></code>’s load stage is combined with its evaluate stage.</p>
</div>
<div class="section" id="evaluate-stage">
<h4>Evaluate stage<a class="headerlink" href="#evaluate-stage" title="Permalink to this headline">¶</a></h4>
<div class="line-block">
<div class="line">The master <code class="docutils literal notranslate"><span class="pre">QMCHamiltonian::Observables</span></code> is populated by slave
<code class="docutils literal notranslate"><span class="pre">OperatorBase</span></code> <code class="docutils literal notranslate"><span class="pre">::setObservables</span></code>. However, the call signature
must be <code class="docutils literal notranslate"><span class="pre">OperatorBase::setObservables</span></code> <code class="docutils literal notranslate"><span class="pre">(QMCHamiltonian::</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">Observables)</span></code>. This call signature is enforced by
<code class="docutils literal notranslate"><span class="pre">QMCHamiltonian::evaluate</span></code> and <code class="docutils literal notranslate"><span class="pre">QMCHamiltonian::</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">auxHevaluate</span></code>.</div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">QMCHamiltonian</span><span class="o">.</span><span class="n">cpp</span>
<span class="n">QMCHamiltonian</span><span class="p">::</span><span class="n">Return_t</span>
<span class="n">QMCHamiltonian</span><span class="p">::</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ParticleSet</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">LocalEnergy</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">H</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">myTimers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">();</span>
    <span class="n">LocalEnergy</span> <span class="o">+=</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">evaluate</span><span class="p">(</span><span class="n">P</span><span class="p">);</span>
    <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setObservables</span><span class="p">(</span><span class="n">Observables</span><span class="p">);</span>
<span class="c1">#if !defined(REMOVE_TRACEMANAGER)</span>
    <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">collect_scalar_traces</span><span class="p">();</span>
<span class="c1">#endif</span>
    <span class="n">myTimers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">();</span>
    <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setParticlePropertyList</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">PropertyList</span><span class="p">,</span><span class="n">myIndex</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">KineticEnergy</span><span class="o">=</span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Value</span><span class="p">;</span>
  <span class="n">P</span><span class="o">.</span><span class="n">PropertyList</span><span class="p">[</span><span class="n">WP</span><span class="p">::</span><span class="n">LOCALENERGY</span><span class="p">]</span><span class="o">=</span><span class="n">LocalEnergy</span><span class="p">;</span>
  <span class="n">P</span><span class="o">.</span><span class="n">PropertyList</span><span class="p">[</span><span class="n">LOCALPOTENTIAL</span><span class="p">]</span><span class="o">=</span><span class="n">LocalEnergy</span><span class="o">-</span><span class="n">KineticEnergy</span><span class="p">;</span>
  <span class="o">//</span> <span class="n">auxHevaluate</span><span class="p">(</span><span class="n">P</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">LocalEnergy</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">QMCHamiltonian</span><span class="o">.</span><span class="n">cpp</span>
<span class="n">void</span> <span class="n">QMCHamiltonian</span><span class="p">::</span><span class="n">auxHevaluate</span><span class="p">(</span><span class="n">ParticleSet</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">,</span> <span class="n">Walker_t</span><span class="o">&amp;</span> <span class="n">ThisWalker</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">#if !defined(REMOVE_TRACEMANAGER)</span>
  <span class="n">collect_walker_traces</span><span class="p">(</span><span class="n">ThisWalker</span><span class="p">,</span><span class="n">P</span><span class="o">.</span><span class="n">current_step</span><span class="p">);</span>
<span class="c1">#endif</span>
  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">auxH</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">auxH</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setHistories</span><span class="p">(</span><span class="n">ThisWalker</span><span class="p">);</span>
    <span class="n">RealType</span> <span class="n">sink</span> <span class="o">=</span> <span class="n">auxH</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">evaluate</span><span class="p">(</span><span class="n">P</span><span class="p">);</span>
    <span class="n">auxH</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setObservables</span><span class="p">(</span><span class="n">Observables</span><span class="p">);</span>
<span class="c1">#if !defined(REMOVE_TRACEMANAGER)</span>
    <span class="n">auxH</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">collect_scalar_traces</span><span class="p">();</span>
<span class="c1">#endif</span>
    <span class="n">auxH</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setParticlePropertyList</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">PropertyList</span><span class="p">,</span><span class="n">myIndex</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="estimator-use-cases">
<h3>Estimator use cases<a class="headerlink" href="#estimator-use-cases" title="Permalink to this headline">¶</a></h3>
<div class="section" id="vmcsingleomp-pseudo-code">
<h4>VMCSingleOMP pseudo code<a class="headerlink" href="#vmcsingleomp-pseudo-code" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">bool</span> <span class="n">VMCSingleOMP</span><span class="p">::</span><span class="n">run</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">masterEstimator</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">nBlocks</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">ip</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">ip</span><span class="o">&lt;</span><span class="n">NumThreads</span><span class="p">;</span> <span class="o">++</span><span class="n">ip</span><span class="p">)</span>
    <span class="n">Movers</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">startRun</span><span class="p">(</span><span class="n">nBlocks</span><span class="p">,</span><span class="n">false</span><span class="p">);</span>  <span class="o">//</span> <span class="n">slaveEstimator</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="n">record</span><span class="p">)</span>

  <span class="n">do</span> <span class="o">//</span> <span class="n">block</span>
  <span class="p">{</span>
    <span class="c1">#pragma omp parallel</span>
    <span class="p">{</span>
      <span class="n">Movers</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">startBlock</span><span class="p">(</span><span class="n">nSteps</span><span class="p">);</span>  <span class="o">//</span> <span class="n">slaveEstimator</span><span class="o">-&gt;</span><span class="n">startBlock</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>
      <span class="n">RealType</span> <span class="n">cnorm</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="n">RealType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">wPerNode</span><span class="p">[</span><span class="n">ip</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">wPerNode</span><span class="p">[</span><span class="n">ip</span><span class="p">]);</span>
      <span class="n">do</span> <span class="o">//</span> <span class="n">step</span>
      <span class="p">{</span>
        <span class="n">wClones</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">resetCollectables</span><span class="p">();</span>
        <span class="n">Movers</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">advanceWalkers</span><span class="p">(</span><span class="n">wit</span><span class="p">,</span> <span class="n">wit_end</span><span class="p">,</span> <span class="n">recompute</span><span class="p">);</span>
        <span class="n">wClones</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Collectables</span> <span class="o">*=</span> <span class="n">cnorm</span><span class="p">;</span>
        <span class="n">Movers</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">accumulate</span><span class="p">(</span><span class="n">wit</span><span class="p">,</span> <span class="n">wit_end</span><span class="p">);</span>
      <span class="p">}</span> <span class="o">//</span> <span class="n">end</span> <span class="n">step</span>
      <span class="n">Movers</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">stopBlock</span><span class="p">(</span><span class="n">false</span><span class="p">);</span>  <span class="o">//</span> <span class="n">slaveEstimator</span><span class="o">-&gt;</span><span class="n">stopBlock</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">false</span><span class="p">)</span>
    <span class="p">}</span> <span class="o">//</span> <span class="n">end</span> <span class="n">omp</span>
    <span class="n">masterEstimator</span><span class="o">-&gt;</span><span class="n">stopBlock</span><span class="p">(</span><span class="n">estimatorClones</span><span class="p">);</span>  <span class="o">//</span> <span class="n">write</span> <span class="n">files</span>
  <span class="p">}</span> <span class="o">//</span> <span class="n">end</span> <span class="n">block</span>
  <span class="n">masterEstimator</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">(</span><span class="n">estimatorClones</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="dmcomp-pseudo-code">
<h4>DMCOMP  pseudo code<a class="headerlink" href="#dmcomp-pseudo-code" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">bool</span> <span class="n">DMCOMP</span><span class="p">::</span><span class="n">run</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">masterEstimator</span><span class="o">-&gt;</span><span class="n">setCollectionMode</span><span class="p">(</span><span class="n">true</span><span class="p">);</span>

  <span class="n">masterEstimator</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">nBlocks</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">ip</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">ip</span><span class="o">&lt;</span><span class="n">NumThreads</span><span class="p">;</span> <span class="n">ip</span><span class="o">++</span><span class="p">)</span>
    <span class="n">Movers</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">startRun</span><span class="p">(</span><span class="n">nBlocks</span><span class="p">,</span><span class="n">false</span><span class="p">);</span>  <span class="o">//</span> <span class="n">slaveEstimator</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="n">record</span><span class="p">)</span>

  <span class="n">do</span> <span class="o">//</span> <span class="n">block</span>
  <span class="p">{</span>
    <span class="n">masterEstimator</span><span class="o">-&gt;</span><span class="n">startBlock</span><span class="p">(</span><span class="n">nSteps</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">ip</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">ip</span><span class="o">&lt;</span><span class="n">NumThreads</span><span class="p">;</span> <span class="n">ip</span><span class="o">++</span><span class="p">)</span>
      <span class="n">Movers</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">startBlock</span><span class="p">(</span><span class="n">nSteps</span><span class="p">);</span>  <span class="o">//</span> <span class="n">slaveEstimator</span><span class="o">-&gt;</span><span class="n">startBlock</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

    <span class="n">do</span> <span class="o">//</span> <span class="n">step</span>
    <span class="p">{</span>
      <span class="c1">#pragma omp parallel</span>
      <span class="p">{</span>
      <span class="n">wClones</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">resetCollectables</span><span class="p">();</span>
      <span class="o">//</span> <span class="n">advanceWalkers</span>
      <span class="p">}</span> <span class="o">//</span> <span class="n">end</span> <span class="n">omp</span>

      <span class="o">//</span><span class="n">branchEngine</span><span class="o">-&gt;</span><span class="n">branch</span>
      <span class="p">{</span> <span class="o">//</span> <span class="n">In</span> <span class="n">WalkerControlMPI</span><span class="o">.</span><span class="n">cpp</span><span class="p">::</span><span class="n">branch</span>
      <span class="n">wgt_inv</span><span class="o">=</span><span class="n">WalkerController</span><span class="o">-&gt;</span><span class="n">NumContexts</span><span class="o">/</span><span class="n">WalkerController</span><span class="o">-&gt;</span><span class="n">EnsembleProperty</span><span class="o">.</span><span class="n">Weight</span><span class="p">;</span>
      <span class="n">walkers</span><span class="o">.</span><span class="n">Collectables</span> <span class="o">*=</span> <span class="n">wgt_inv</span><span class="p">;</span>
      <span class="n">slaveEstimator</span><span class="o">-&gt;</span><span class="n">accumulate</span><span class="p">(</span><span class="n">walkers</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">masterEstimator</span><span class="o">-&gt;</span><span class="n">stopBlock</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span>  <span class="o">//</span> <span class="n">write</span> <span class="n">files</span>
    <span class="p">}</span>  <span class="o">//</span> <span class="n">end</span> <span class="k">for</span> <span class="n">step</span>
  <span class="p">}</span>  <span class="o">//</span> <span class="n">end</span> <span class="k">for</span> <span class="n">block</span>

  <span class="n">masterEstimator</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h3>
<p>Two ensemble-level data structures, <code class="docutils literal notranslate"><span class="pre">ParticleSet::Properties</span></code> and
<code class="docutils literal notranslate"><span class="pre">::Collectables</span></code>, serve as intermediaries between evaluate classes and
output classes to <code class="docutils literal notranslate"><span class="pre">scalar.dat</span></code> and <code class="docutils literal notranslate"><span class="pre">stat.h5</span></code>. <code class="docutils literal notranslate"><span class="pre">Properties</span></code> appears
in both <code class="docutils literal notranslate"><span class="pre">scalar.dat</span></code> and <code class="docutils literal notranslate"><span class="pre">stat.h5</span></code>, whereas <code class="docutils literal notranslate"><span class="pre">Collectables</span></code> appears
only in <code class="docutils literal notranslate"><span class="pre">stat.h5</span></code>. <code class="docutils literal notranslate"><span class="pre">Properties</span></code> is overwritten by
<code class="docutils literal notranslate"><span class="pre">QMCHamiltonian::Observables</span></code> at the end of each step.
<code class="docutils literal notranslate"><span class="pre">QMCHamiltonian::Observables</span></code> is filled upon call to
<code class="docutils literal notranslate"><span class="pre">QMCHamiltonian::evaluate</span></code> and <code class="docutils literal notranslate"><span class="pre">::auxHevaluate</span></code>. <code class="docutils literal notranslate"><span class="pre">Collectables</span></code> is
zeroed at the beginning of each step and accumulated upon call to
<code class="docutils literal notranslate"><span class="pre">::auxHevaluate</span></code>.</p>
<div class="line-block">
<div class="line">Data are output to <code class="docutils literal notranslate"><span class="pre">scalar.dat</span></code> in four stages: evaluate, load,
unload, and collect. In the evaluate stage,
<code class="docutils literal notranslate"><span class="pre">QMCHamiltonian::Observables</span></code> is populated by a list of
<code class="docutils literal notranslate"><span class="pre">OperatorBase</span></code>. In the load stage, <code class="docutils literal notranslate"><span class="pre">QMCHamiltonian::Observables</span></code>
is transfered to <code class="docutils literal notranslate"><span class="pre">Properties</span></code> by <code class="docutils literal notranslate"><span class="pre">QMCDriver</span></code>. In the unload stage,
<code class="docutils literal notranslate"><span class="pre">Properties</span></code> is copied to <code class="docutils literal notranslate"><span class="pre">LocalEnergyEstimator::scalars</span></code>. In the
collect stage, <code class="docutils literal notranslate"><span class="pre">LocalEnergyEstimator::scalars</span></code> is block-averaged to
<code class="docutils literal notranslate"><span class="pre">EstimatorManagerBase</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">::AverageCache</span></code> and dumped to file. For <code class="docutils literal notranslate"><span class="pre">Collectables</span></code>, the
evaluate and load stages are combined in a call to
<code class="docutils literal notranslate"><span class="pre">QMCHamiltonian::auxHevaluate</span></code>. In the unload stage,
<code class="docutils literal notranslate"><span class="pre">Collectables</span></code> is copied to <code class="docutils literal notranslate"><span class="pre">CollectablesEstimator::scalars</span></code>. In
the collect stage, <code class="docutils literal notranslate"><span class="pre">CollectablesEstimator</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">::scalars</span></code> is block-averaged to
<code class="docutils literal notranslate"><span class="pre">EstimatorManagerBase::AverageCache</span></code> and dumped to file.</div>
</div>
</div>
<div class="section" id="appendix-dmc-dat">
<h3>Appendix: dmc.dat<a class="headerlink" href="#appendix-dmc-dat" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line">There is an additional data structure,
<code class="docutils literal notranslate"><span class="pre">ParticleSet::EnsembleProperty</span></code>, that is managed by
<code class="docutils literal notranslate"><span class="pre">WalkerControlBase::EnsembleProperty</span></code> and directly dumped to
<code class="docutils literal notranslate"><span class="pre">dmc.dat</span></code> via its own averaging procedure. <code class="docutils literal notranslate"><span class="pre">dmc.dat</span></code> is written by
<code class="docutils literal notranslate"><span class="pre">WalkerControlBase::measureProperties</span></code>, which is called by
<code class="docutils literal notranslate"><span class="pre">WalkerControlBase::branch</span></code>, which is called by
<code class="docutils literal notranslate"><span class="pre">SimpleFixedNodeBranch</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">::branch</span></code>, for example.</div>
</div>
</div>
</div>
<div class="section" id="slater-backflow-wavefunction-implementation-details">
<h2>Slater-backflow wavefunction implementation details<a class="headerlink" href="#slater-backflow-wavefunction-implementation-details" title="Permalink to this headline">¶</a></h2>
<p>For simplicity, consider <span class="math notranslate nohighlight">\(N\)</span> identical fermions of the same spin
(e.g., up electrons) at spatial locations
<span class="math notranslate nohighlight">\(\{\mathbf{r}_1,\mathbf{r}_2,\dots,\mathbf{r}_{N}\}\)</span>. Then the
Slater determinant can be written as</p>
<div class="math notranslate nohighlight" id="equation-eq245">
<span class="eqno">(245)<a class="headerlink" href="#equation-eq245" title="Permalink to this equation">¶</a></span>\[ S=\det M\:,\]</div>
<p>where each entry in the determinant is an SPO evaluated at a particle
position</p>
<div class="math notranslate nohighlight" id="equation-eq246">
<span class="eqno">(246)<a class="headerlink" href="#equation-eq246" title="Permalink to this equation">¶</a></span>\[ \begin{aligned}
 M_{ij} = \phi_i(\mathbf{r}_j)\:.\end{aligned}\]</div>
<p>When backflow transformation is applied to the determinant, the particle
coordinates <span class="math notranslate nohighlight">\(\mathbf{r}_i\)</span> that go into the SPOs are replaced by
quasi-particle coordinates <span class="math notranslate nohighlight">\(\mathbf{x}_i\)</span>:</p>
<div class="math notranslate nohighlight" id="equation-eq247">
<span class="eqno">(247)<a class="headerlink" href="#equation-eq247" title="Permalink to this equation">¶</a></span>\[ \begin{aligned}
 M_{ij} = \phi_i(\mathbf{x}_j)\:, \end{aligned}\]</div>
<p>where</p>
<div class="math notranslate nohighlight" id="equation-eq248">
<span class="eqno">(248)<a class="headerlink" href="#equation-eq248" title="Permalink to this equation">¶</a></span>\[ \begin{aligned}
 \mathbf{x}_i=\mathbf{r}_i+\sum\limits_{j=1,j\neq i}^N\eta(r_{ij})(\mathbf{r}_i-\mathbf{r}_j)\:. \end{aligned}\]</div>
<p><span class="math notranslate nohighlight">\(r_{ij}=\vert\mathbf{r}_i-\mathbf{r}_j\vert\)</span>. The integers i,j
label the particle/quasi-particle. There is a one-to-one correspondence
between the particles and the quasi-particles, which is simplest when
<span class="math notranslate nohighlight">\(\eta=0\)</span>.</p>
<div class="section" id="value">
<h3>Value<a class="headerlink" href="#value" title="Permalink to this headline">¶</a></h3>
<p>The evaluation of the Slater-backflow wavefunction is almost identical
to that of a Slater wavefunction. The only difference is that the
quasi-particle coordinates are used to evaluate the SPOs. The actual
value of the determinant is stored during the inversion of the matrix
<span class="math notranslate nohighlight">\(M\)</span> (<code class="docutils literal notranslate"><span class="pre">cgetrf</span></code><span class="math notranslate nohighlight">\(\rightarrow\)</span><code class="docutils literal notranslate"><span class="pre">cgetri</span></code>). Suppose
<span class="math notranslate nohighlight">\(M=LU\)</span>, then <span class="math notranslate nohighlight">\(S=\prod\limits_{i=1}^N L_{ii} U_{ii}\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">DiracDeterminantWithBackflow</span><span class="p">::</span><span class="n">evaluateLog</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>
<span class="n">Phi</span><span class="o">-&gt;</span><span class="n">evaluate</span><span class="p">(</span><span class="n">BFTrans</span><span class="o">-&gt;</span><span class="n">QP</span><span class="p">,</span> <span class="n">FirstIndex</span><span class="p">,</span> <span class="n">LastIndex</span><span class="p">,</span> <span class="n">psiM</span><span class="p">,</span><span class="n">dpsiM</span><span class="p">,</span><span class="n">grad_grad_psiM</span><span class="p">);</span>
<span class="n">psiMinv</span> <span class="o">=</span> <span class="n">psiM</span><span class="p">;</span>
<span class="n">LogValue</span><span class="o">=</span><span class="n">InvertWithLog</span><span class="p">(</span><span class="n">psiMinv</span><span class="o">.</span><span class="n">data</span><span class="p">(),</span><span class="n">NumPtcls</span><span class="p">,</span><span class="n">NumOrbitals</span>
  <span class="p">,</span><span class="n">WorkSpace</span><span class="o">.</span><span class="n">data</span><span class="p">(),</span><span class="n">Pivot</span><span class="o">.</span><span class="n">data</span><span class="p">(),</span><span class="n">PhaseValue</span><span class="p">);</span>
</pre></div>
</div>
<p>QMCPACK represents the complex value of the wavefunction in polar
coordinates <span class="math notranslate nohighlight">\(S=e^Ue^{i\theta}\)</span>. Specifically, <code class="docutils literal notranslate"><span class="pre">LogValue</span></code>
<span class="math notranslate nohighlight">\(U\)</span> and <code class="docutils literal notranslate"><span class="pre">PhaseValue</span></code> <span class="math notranslate nohighlight">\(\theta\)</span> are handled separately. In
the following, we will consider derivatives of the log value only.</p>
</div>
<div class="section" id="gradient">
<h3>Gradient<a class="headerlink" href="#gradient" title="Permalink to this headline">¶</a></h3>
<p>To evaluate particle gradient of the log value of the Slater-backflow
wavefunction, we can use the <span class="math notranslate nohighlight">\(\log\det\)</span> identity in
<a class="reference internal" href="#equation-eq249">(249)</a>. This identity maps the derivative of
<span class="math notranslate nohighlight">\(\log\det M\)</span> with respect to a real variable <span class="math notranslate nohighlight">\(p\)</span> to a trace
over <span class="math notranslate nohighlight">\(M^{-1}dM\)</span>:</p>
<div class="math notranslate nohighlight" id="equation-eq249">
<span class="eqno">(249)<a class="headerlink" href="#equation-eq249" title="Permalink to this equation">¶</a></span>\[ \begin{aligned}
 \frac{\partial}{\partial p}\log\det M = \text{tr}\left( M^{-1} \frac{\partial M}{\partial p} \right) .\end{aligned}\]</div>
<p>Following Kwon, Ceperley, and
Martin <a class="bibtex reference internal" href="#kwon1993backflow" id="id3">[KCM93]</a>, the particle gradient</p>
<div class="math notranslate nohighlight" id="equation-eq250">
<span class="eqno">(250)<a class="headerlink" href="#equation-eq250" title="Permalink to this equation">¶</a></span>\[ \begin{aligned}
 G_i^\alpha \equiv \frac{\partial}{\partial r_i^\alpha} \log\det M = \sum\limits_{j=1}^N \sum\limits_{\beta=1}^3 F_{jj}^\beta A_{jj}^{\alpha\beta}\:, \end{aligned}\]</div>
<p>where the quasi-particle gradient matrix</p>
<div class="math notranslate nohighlight" id="equation-eq251">
<span class="eqno">(251)<a class="headerlink" href="#equation-eq251" title="Permalink to this equation">¶</a></span>\[ \begin{aligned}
 A_{ij}^{\alpha\beta} \equiv \frac{\partial x_j^\beta}{\partial r_i^\alpha}\:,\end{aligned}\]</div>
<p>and the intermediate matrix</p>
<div class="math notranslate nohighlight" id="equation-eq252">
<span class="eqno">(252)<a class="headerlink" href="#equation-eq252" title="Permalink to this equation">¶</a></span>\[ \begin{aligned}
 F_{ij}^\alpha\equiv\sum\limits_k M^{-1}_{ik} dM_{kj}^\alpha\:,\end{aligned}\]</div>
<p>with the SPO derivatives (w.r. to quasi-particle coordinates)</p>
<div class="math notranslate nohighlight" id="equation-eq253">
<span class="eqno">(253)<a class="headerlink" href="#equation-eq253" title="Permalink to this equation">¶</a></span>\[ \begin{aligned}
 dM_{ij}^\alpha \equiv \frac{\partial M_{ij}}{\partial x_j^\alpha}\:.\end{aligned}\]</div>
<p>Notice that we have made the name change of <span class="math notranslate nohighlight">\(\phi\rightarrow M\)</span>
from the notations of ref. <a class="bibtex reference internal" href="#kwon1993backflow" id="id4">[KCM93]</a>. This
name change is intended to help the reader associate M with the QMCPACK
variable <code class="docutils literal notranslate"><span class="pre">psiM</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">DiracDeterminantWithBackflow</span><span class="p">::</span><span class="n">evaluateLog</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>
<span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="o">//</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">above</span> <span class="n">formula</span>
<span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">NumPtcls</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">OHMMS_DIM</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="o">//</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="n">above</span> <span class="n">formula</span>
    <span class="p">{</span>
      <span class="n">myG</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+=</span> <span class="n">dot</span><span class="p">(</span><span class="n">BFTrans</span><span class="o">-&gt;</span><span class="n">Amat</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">FirstIndex</span><span class="o">+</span><span class="n">j</span><span class="p">),</span><span class="n">Fmat</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference internal" href="#equation-eq250">(250)</a> is still relatively simple to understand. The
<span class="math notranslate nohighlight">\(A\)</span> matrix maps changes in particle coordinates
<span class="math notranslate nohighlight">\(d\mathbf{r}\)</span> to changes in quasi-particle coordinates
<span class="math notranslate nohighlight">\(d\mathbf{x}\)</span>. Dotting A into F propagates <span class="math notranslate nohighlight">\(d\mathbf{x}\)</span> to
<span class="math notranslate nohighlight">\(dM\)</span>. Thus <span class="math notranslate nohighlight">\(F\cdot A\)</span> is the term inside the trace operator
of <a class="reference internal" href="#equation-eq249">(249)</a>. Finally, performing the trace completes the
evaluation of the derivative.</p>
</div>
<div class="section" id="laplacian">
<h3>Laplacian<a class="headerlink" href="#laplacian" title="Permalink to this headline">¶</a></h3>
<p>The particle Laplacian is given in
<a class="bibtex reference internal" href="#kwon1993backflow" id="id5">[KCM93]</a> as</p>
<div class="math notranslate nohighlight" id="equation-eq254">
<span class="eqno">(254)<a class="headerlink" href="#equation-eq254" title="Permalink to this equation">¶</a></span>\[ \begin{aligned}
 L_i \equiv \sum\limits_{\beta} \frac{\partial^2}{\partial (r_i^\beta)^2} \log\det M = \sum\limits_{j\alpha} B_{ij}^\alpha F_{jj}^\alpha - \sum\limits_{jk}\sum\limits_{\alpha\beta\gamma} A_{ij}^{\alpha\beta}A_{ik}^{\alpha\gamma}\times\left(F_{kj}^\alpha F_{jk}^\gamma -\delta_{jk}\sum\limits_m M^{-1}_{jm} d2M_{mj}^{\beta\gamma}\right), \end{aligned}\]</div>
<p>where the quasi-particle Laplacian matrix</p>
<div class="math notranslate nohighlight" id="equation-eq255">
<span class="eqno">(255)<a class="headerlink" href="#equation-eq255" title="Permalink to this equation">¶</a></span>\[ \begin{aligned}
 B_{ij}^{\alpha} \equiv \sum\limits_\beta \frac{\partial^2 x_j^\alpha}{\partial (r_i^\beta)^2}\:,\end{aligned}\]</div>
<p>with the second derivatives of the single-particles orbitals being</p>
<div class="math notranslate nohighlight" id="equation-eq256">
<span class="eqno">(256)<a class="headerlink" href="#equation-eq256" title="Permalink to this equation">¶</a></span>\[ \begin{aligned}
 d2M_{ij}^{\alpha\beta} \equiv \frac{\partial^2 M_{ij}}{\partial x_j^\alpha\partial x_j^\beta}\:.\end{aligned}\]</div>
<p>Schematically, <span class="math notranslate nohighlight">\(L_i\)</span> has contributions from three terms of the
form <span class="math notranslate nohighlight">\(BF, AAFF, and tr(AA,Md2M)\)</span>, respectively.
<span class="math notranslate nohighlight">\(A, B, M ,d2M,\)</span> and <span class="math notranslate nohighlight">\(F\)</span> can be calculated and stored before
the calculations of <span class="math notranslate nohighlight">\(L_i\)</span>. The first <span class="math notranslate nohighlight">\(BF\)</span> term can be
directly calculated in a loop over quasi-particle coordinates
<span class="math notranslate nohighlight">\(j\alpha\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">DiracDeterminantWithBackflow</span><span class="p">::</span><span class="n">evaluateLog</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>
<span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">NumPtcls</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">a</span><span class="o">&lt;</span><span class="n">OHMMS_DIM</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
    <span class="n">myL</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+=</span> <span class="n">BFTrans</span><span class="o">-&gt;</span><span class="n">Bmat_full</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">FirstIndex</span><span class="o">+</span><span class="n">j</span><span class="p">)[</span><span class="n">a</span><span class="p">]</span><span class="o">*</span><span class="n">Fmat</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">)[</span><span class="n">a</span><span class="p">];</span>
</pre></div>
</div>
<p>Notice that <span class="math notranslate nohighlight">\(B_{ij}^\alpha\)</span> is stored in <code class="docutils literal notranslate"><span class="pre">Bmat_full</span></code>, NOT
<code class="docutils literal notranslate"><span class="pre">Bmat</span></code>.</p>
<p>The remaining two terms both involve <span class="math notranslate nohighlight">\(AA\)</span>. Thus, it is best to
define a temporary tensor <span class="math notranslate nohighlight">\(AA\)</span>:</p>
<div class="math notranslate nohighlight" id="equation-eq257">
<span class="eqno">(257)<a class="headerlink" href="#equation-eq257" title="Permalink to this equation">¶</a></span>\[ \begin{aligned}
 {}_iAA_{jk}^{\beta\gamma} \equiv \sum\limits_\alpha A_{ij}^{\alpha\beta} A_{ij}^{\alpha\gamma}\:,\end{aligned}\]</div>
<p>which we will overwrite for each particle <span class="math notranslate nohighlight">\(i\)</span>. Similarly, define
<span class="math notranslate nohighlight">\(FF\)</span>:</p>
<div class="math notranslate nohighlight" id="equation-eq258">
<span class="eqno">(258)<a class="headerlink" href="#equation-eq258" title="Permalink to this equation">¶</a></span>\[ \begin{aligned}
 FF_{jk}^{\alpha\gamma} \equiv F_{kj}^\alpha F_{jk}^\gamma\:,\end{aligned}\]</div>
<p>which is simply the outer product of <span class="math notranslate nohighlight">\(F\otimes F\)</span>. Then the
<span class="math notranslate nohighlight">\(AAFF\)</span> term can be calculated by fully contracting <span class="math notranslate nohighlight">\(AA\)</span> with
<span class="math notranslate nohighlight">\(FF\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">DiracDeterminantWithBackflow</span><span class="p">::</span><span class="n">evaluateLog</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>
<span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">NumPtcls</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">NumPtcls</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">Tensor</span><span class="o">&lt;</span><span class="n">RealType</span><span class="p">,</span><span class="n">OHMMS_DIM</span><span class="o">&gt;</span> <span class="n">AA</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">BFTrans</span><span class="o">-&gt;</span><span class="n">Amat</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">FirstIndex</span><span class="o">+</span><span class="n">j</span><span class="p">)),</span><span class="n">BFTrans</span><span class="o">-&gt;</span><span class="n">Amat</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">FirstIndex</span><span class="o">+</span><span class="n">k</span><span class="p">));</span>
      <span class="n">HessType</span> <span class="n">FF</span> <span class="o">=</span> <span class="n">outerProduct</span><span class="p">(</span><span class="n">Fmat</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="n">Fmat</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">));</span>
      <span class="n">myL</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-=</span> <span class="n">traceAtB</span><span class="p">(</span><span class="n">AA</span><span class="p">,</span><span class="n">FF</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>Finally, define the SPO derivative term:</p>
<div class="math notranslate nohighlight" id="equation-eq259">
<span class="eqno">(259)<a class="headerlink" href="#equation-eq259" title="Permalink to this equation">¶</a></span>\[ \begin{aligned}
 Md2M_j^{\beta\gamma} \equiv \sum\limits_m M^{-1}_{jm} d2M_{mj}^\beta\:,\end{aligned}\]</div>
<p>then the last term is given by the contraction of <span class="math notranslate nohighlight">\(Md2M\)</span> (<code class="docutils literal notranslate"><span class="pre">q_j</span></code>)
with the diagonal of <span class="math notranslate nohighlight">\(AA\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">NumPtcls</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">HessType</span> <span class="n">q_j</span><span class="p">;</span>
  <span class="n">q_j</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">NumPtcls</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
    <span class="n">q_j</span> <span class="o">+=</span> <span class="n">psiMinv</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">grad_grad_psiM</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Tensor</span><span class="o">&lt;</span><span class="n">RealType</span><span class="p">,</span><span class="n">OHMMS_DIM</span><span class="o">&gt;</span> <span class="n">AA</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span>
      <span class="n">transpose</span><span class="p">(</span><span class="n">BFTrans</span><span class="o">-&gt;</span><span class="n">Amat</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">FirstIndex</span><span class="o">+</span><span class="n">j</span><span class="p">)),</span>
      <span class="n">BFTrans</span><span class="o">-&gt;</span><span class="n">Amat</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">FirstIndex</span><span class="o">+</span><span class="n">j</span><span class="p">)</span>
    <span class="p">);</span>
    <span class="n">myL</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+=</span> <span class="n">traceAtB</span><span class="p">(</span><span class="n">AA</span><span class="p">,</span><span class="n">q_j</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="wavefunction-parameter-derivative">
<h3>Wavefunction parameter derivative<a class="headerlink" href="#wavefunction-parameter-derivative" title="Permalink to this headline">¶</a></h3>
<p>To use the robust linear optimization method of
<a class="bibtex reference internal" href="#toulouse2007linear" id="id6">[TU07]</a>, the trial wavefunction
needs to know its contributions to the overlap and hamiltonian matrices.
In particular, we need derivatives of these matrices with respect to
wavefunction parameters. As a consequence, the wavefunction <span class="math notranslate nohighlight">\(\psi\)</span>
needs to be able to evaluate
<span class="math notranslate nohighlight">\(\frac{\partial}{\partial p} \ln \psi\)</span> and
<span class="math notranslate nohighlight">\(\frac{\partial}{\partial p} \frac{\mathcal{H}\psi}{\psi}\)</span>, where
<span class="math notranslate nohighlight">\(p\)</span> is a parameter.</p>
<p>When 2-body backflow is considered, a wavefunction parameter <span class="math notranslate nohighlight">\(p\)</span>
enters the <span class="math notranslate nohighlight">\(\eta\)</span> function only (equation <a class="reference internal" href="#equation-eq248">(248)</a>).
<span class="math notranslate nohighlight">\(\mathbf{r}\)</span>, <span class="math notranslate nohighlight">\(\phi\)</span>, and <span class="math notranslate nohighlight">\(M\)</span> do not explicitly
dependent on <span class="math notranslate nohighlight">\(p\)</span>. Derivative of the log value is almost identical
to particle gradient. Namely, <a class="reference internal" href="#equation-eq250">(250)</a> applies upon the
substitution <span class="math notranslate nohighlight">\(r_i^\alpha\rightarrow p\)</span>.</p>
<div class="math notranslate nohighlight" id="equation-eq260">
<span class="eqno">(260)<a class="headerlink" href="#equation-eq260" title="Permalink to this equation">¶</a></span>\[ \begin{aligned}
 \frac{\partial}{\partial p} \ln\det M = \sum\limits_{j=1}^N \sum\limits_{\beta=1}^3 F_{jj}^\beta \left({}_pC_{j}^{\beta}\right)\:,\end{aligned}\]</div>
<p>where the quasi-particle derivatives are stored in <code class="docutils literal notranslate"><span class="pre">Cmat</span></code></p>
<div class="math notranslate nohighlight" id="equation-eq261">
<span class="eqno">(261)<a class="headerlink" href="#equation-eq261" title="Permalink to this equation">¶</a></span>\[ \begin{aligned}
 {}_pC_{i}^{\alpha} \equiv \frac{\partial}{\partial p} x_{i}^{\alpha}\:.\end{aligned}\]</div>
<p>The change in local kinetic energy is a lot more difficult to calculate</p>
<div class="math notranslate nohighlight" id="equation-eq262">
<span class="eqno">(262)<a class="headerlink" href="#equation-eq262" title="Permalink to this equation">¶</a></span>\[ \begin{aligned}
 \frac{\partial T_{\text{local}}}{\partial p} = \frac{\partial}{\partial p} \left\{ \left( \sum\limits_{i=1}^N \frac{1}{2m_i} \nabla^2_i \right) \ln \det M \right\} = \sum\limits_{i=1}^N \frac{1}{2m_i} \frac{\partial}{\partial p} L_i\:, \end{aligned}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_i\)</span> is the particle Laplacian defined in
<a class="reference internal" href="#equation-eq254">(254)</a> To evaluate <a class="reference internal" href="#equation-eq262">(262)</a>, we need to
calculate parameter derivatives of all three terms defined in the
Laplacian evaluation. Namely <span class="math notranslate nohighlight">\((B)(F)\)</span>, <span class="math notranslate nohighlight">\((AA)(FF)\)</span>, and
<span class="math notranslate nohighlight">\(\text{tr}(AA,Md2M)\)</span>, where we have put parentheses around previously
identified data structures. After <span class="math notranslate nohighlight">\(\frac{\partial}{\partial p}\)</span>
hits, each of the three terms will split into two terms by the product
rule. Each smaller term will contain a contraction of two data
structures. Therefore, we will need to calculate the parameter
derivatives of each data structure defined in the Laplacian evaluation:</p>
<div class="math notranslate nohighlight" id="equation-eq263">
<span class="eqno">(263)<a class="headerlink" href="#equation-eq263" title="Permalink to this equation">¶</a></span>\[\begin{split} \begin{aligned}
 {}_pX_{ij}^{\alpha\beta} \equiv \frac{\partial}{\partial p} A_{ij}^{\alpha\beta}\:, \\
 {}_pY_{ij}^{\alpha} \equiv \frac{\partial}{\partial p} B_{ij}^{\alpha}\:, \\
 {}_pdF_{ij}^{\alpha} \equiv \frac{\partial}{\partial p} F_{ij}^{\alpha}\:, \\
 {}_{pi}{AA'}_{jk}^{\beta\gamma} \equiv \frac{\partial}{\partial p}  {}_iAA_{jk}^{\beta\gamma}\:, \\
 {}_p {FF'}_{jk}^{\alpha\gamma} \equiv \frac{\partial}{\partial p} FF_{jk}^{\alpha\gamma}\:, \\
 {}_p {Md2M'}_{j}^{\beta\gamma} \equiv \frac{\partial}{\partial p} Md2M_j^{\beta\gamma}\:.\end{aligned}\end{split}\]</div>
<p>X and Y are stored as <code class="docutils literal notranslate"><span class="pre">Xmat</span></code> and <code class="docutils literal notranslate"><span class="pre">Ymat_full</span></code> (NOT <code class="docutils literal notranslate"><span class="pre">Ymat</span></code>) in the
code. dF is <code class="docutils literal notranslate"><span class="pre">dFa</span></code>. <span class="math notranslate nohighlight">\(AA'\)</span> is not fully stored; intermediate
values are stored in <code class="docutils literal notranslate"><span class="pre">Aij_sum</span></code> and <code class="docutils literal notranslate"><span class="pre">a_j_sum</span></code>. <span class="math notranslate nohighlight">\(FF'\)</span> is
calculated on the fly as <span class="math notranslate nohighlight">\(dF\otimes F+F\otimes dF\)</span>. <span class="math notranslate nohighlight">\(Md2M'\)</span>
is not stored; intermediate values are stored in <code class="docutils literal notranslate"><span class="pre">q_j_prime</span></code>.</p>
</div>
</div>
<div class="section" id="particles-and-distance-tables">
<span id="distance-tables"></span><h2>Particles and distance tables<a class="headerlink" href="#particles-and-distance-tables" title="Permalink to this headline">¶</a></h2>
<div class="section" id="particlesets">
<h3>ParticleSets<a class="headerlink" href="#particlesets" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ParticleSet</span></code> class stores particle positions and attributes
(charge, mass, etc).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">R</span></code> member stores positions. For calculations, the <code class="docutils literal notranslate"><span class="pre">R</span></code> variable
needs to be transferred to the structure-of-arrays (SoA) storage in
<code class="docutils literal notranslate"><span class="pre">RSoA</span></code>. This is done by the <code class="docutils literal notranslate"><span class="pre">update</span></code> method. In the future the
interface may change to use functions to set and retrieve positions so
the SoA transformation of the particle data can happen automatically.</p>
<p>A particular distance table is retrieved with <code class="docutils literal notranslate"><span class="pre">getDistTable</span></code>. Use
<code class="docutils literal notranslate"><span class="pre">addTable</span></code> to add a <code class="docutils literal notranslate"><span class="pre">ParticleSet</span></code> and return the index of the
distance table. If the table already exists the index of the existing
table will be returned.</p>
<p>The mass and charge of each particle is stored in <code class="docutils literal notranslate"><span class="pre">Mass</span></code> and <code class="docutils literal notranslate"><span class="pre">Z</span></code>.
The flag, <code class="docutils literal notranslate"><span class="pre">SameMass</span></code>, indicates if all the particles have the same
mass (true for electrons).</p>
<div class="section" id="groups">
<h4>Groups<a class="headerlink" href="#groups" title="Permalink to this headline">¶</a></h4>
<p>Particles can belong to different groups. For electrons, the groups are
up and down spins. For ions, the groups are the atomic element. The
group type for each particle can be accessed through the <code class="docutils literal notranslate"><span class="pre">GroupID</span></code>
member. The number of groups is returned from <code class="docutils literal notranslate"><span class="pre">groups()</span></code>. The total
number particles is accessed with <code class="docutils literal notranslate"><span class="pre">getTotalNum()</span></code>. The number of
particles in a group is <code class="docutils literal notranslate"><span class="pre">groupsize(int</span> <span class="pre">igroup)</span></code>.</p>
<p>The particle indices for each group are found with <code class="docutils literal notranslate"><span class="pre">first(int</span> <span class="pre">igroup)</span></code>
and <code class="docutils literal notranslate"><span class="pre">last(int</span> <span class="pre">igroup)</span></code>. These functions only work correctly if the
particles are packed according to group. The flag, <code class="docutils literal notranslate"><span class="pre">IsGrouped</span></code>,
indicates if the particles are grouped or not. The particles will not be
grouped if the elements are not grouped together in the input file. This
ordering is usually the responsibility of the converters.</p>
<p>Code can be written to only handle the grouped case, but put an assert
or failure check if the particles are not grouped. Otherwise the code
will give wrong answers and it can be time-consuming to debug.</p>
</div>
</div>
<div class="section" id="id7">
<h3>Distance tables<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>Distance tables store distances between particles. There are symmetric
(AA) tables for distance between like particles (electron-electron or
ion-ion) and asymmetric (BA) tables for distance between unlike
particles (electron-ion)</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Distances</span></code> and <code class="docutils literal notranslate"><span class="pre">Displacements</span></code> members contain the data. The
indexing order is target index first, then source. For electron-ion
tables, the sources are the ions and the targets are the electrons.</p>
</div>
<div class="section" id="looping-over-particles">
<h3>Looping over particles<a class="headerlink" href="#looping-over-particles" title="Permalink to this headline">¶</a></h3>
<p>Some sample code on how to loop over all the particles in an electron-ion distance table:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">d_table</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">electron</span><span class="o">-</span><span class="n">ion</span> <span class="n">distance</span> <span class="n">table</span>

<span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">jat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">d_table</span><span class="o">.</span><span class="n">targets</span><span class="p">();</span> <span class="n">jat</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="o">//</span> <span class="n">Loop</span> <span class="n">over</span> <span class="n">electrons</span>
  <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">iat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">d_table</span><span class="o">.</span><span class="n">sources</span><span class="p">();</span> <span class="n">iat</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="o">//</span> <span class="n">Loop</span> <span class="n">over</span> <span class="n">ions</span>
     <span class="n">d_table</span><span class="o">.</span><span class="n">Distances</span><span class="p">[</span><span class="n">jat</span><span class="p">][</span><span class="n">iat</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Interactions sometimes depend on the type of group of the particles. The
code can loop over all particles and use <code class="docutils literal notranslate"><span class="pre">GroupID[idx]</span></code> to choose the
interaction. Alternately, the code can loop over the number of groups
and then loop from the first to last index for those groups. This method
can attain higher performance by effectively hoisting tests for group ID
out of the loop.</p>
<p>An example of the first approach is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">P</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">ParticleSet</span>

<span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">iat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iat</span> <span class="o">&lt;</span> <span class="n">P</span><span class="o">.</span><span class="n">getTotalNum</span><span class="p">();</span> <span class="n">iat</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">group_idx</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">GroupID</span><span class="p">[</span><span class="n">iat</span><span class="p">];</span>
  <span class="o">//</span> <span class="n">Code</span> <span class="n">that</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">the</span> <span class="n">group</span> <span class="n">index</span>
<span class="p">}</span>
</pre></div>
</div>
<p>An example of the second approach is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">P</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">ParticleSet</span>
<span class="k">assert</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">IsGrouped</span> <span class="o">==</span> <span class="n">true</span><span class="p">);</span> <span class="o">//</span> <span class="n">ensure</span> <span class="n">particles</span> <span class="n">are</span> <span class="n">grouped</span>

<span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">ig</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ig</span> <span class="o">&lt;</span> <span class="n">P</span><span class="o">.</span><span class="n">groups</span><span class="p">();</span> <span class="n">ig</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="o">//</span> <span class="n">loop</span> <span class="n">over</span> <span class="n">groups</span>
  <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">iat</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">first</span><span class="p">(</span><span class="n">ig</span><span class="p">);</span> <span class="n">iat</span> <span class="o">&lt;</span> <span class="n">P</span><span class="o">.</span><span class="n">last</span><span class="p">(</span><span class="n">ig</span><span class="p">);</span> <span class="n">iat</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="o">//</span> <span class="n">loop</span> <span class="n">over</span> <span class="n">elements</span> <span class="ow">in</span> <span class="n">each</span> <span class="n">group</span>
     <span class="o">//</span> <span class="n">Code</span> <span class="n">that</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">group</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="adding-a-wavefunction">
<h2>Adding a wavefunction<a class="headerlink" href="#adding-a-wavefunction" title="Permalink to this headline">¶</a></h2>
<p>The total wavefunction is stored in <code class="docutils literal notranslate"><span class="pre">TrialWaveFunction</span></code> as a product
of all the components. Each component derives from
<code class="docutils literal notranslate"><span class="pre">WaveFunctionComponent</span></code>. The code contains an example of a
wavefunction component for a Helium atom using a simple form and is
described in <a class="reference internal" href="#helium-wavefunction-example"><span class="std std-ref">Helium Wavefunction Example</span></a></p>
<div class="section" id="mathematical-preliminaries">
<h3>Mathematical preliminaries<a class="headerlink" href="#mathematical-preliminaries" title="Permalink to this headline">¶</a></h3>
<p>The wavefunction evaluation functions compute the log of the
wavefunction, the gradient and the Laplacian of the log of the
wavefunction. Expanded, the gradient and Laplacian are</p>
<div class="math notranslate nohighlight" id="equation-eq264">
<span class="eqno">(264)<a class="headerlink" href="#equation-eq264" title="Permalink to this equation">¶</a></span>\[\begin{split} \begin{aligned}
 G &amp;=&amp; \nabla \log(\psi) = \frac{\nabla \psi}{\psi} \\
 L &amp;=&amp; {\nabla ^2} \log(\psi) = \frac{{\nabla ^2}\psi}{\psi} - \frac{\nabla \psi}{\psi} \cdot \frac{\nabla \psi}{\psi} \\
                 &amp;=&amp; \frac{{\nabla ^2} \psi}{\psi} - G \cdot G\end{aligned}\end{split}\]</div>
<p>However, the local energy formula needs <span class="math notranslate nohighlight">\(\frac{{\nabla ^2} \psi}{\psi}\)</span>.
The conversion from the Laplacian of the log of the wavefunction to the
local energy value is performed in
<code class="docutils literal notranslate"><span class="pre">QMCHamiltonians/BareKineticEnergy.h</span></code> (i.e. <span class="math notranslate nohighlight">\(L + G \cdot G\)</span>.)</p>
</div>
<div class="section" id="wavefunction-evaluation">
<h3>Wavefunction evaluation<a class="headerlink" href="#wavefunction-evaluation" title="Permalink to this headline">¶</a></h3>
<p>The process for creating a new wavefunction component class is to derive
from WaveFunctionComponent and implement a number pure virtual
functions. To start most of them can be empty.</p>
<p>The following four functions evaluate the wavefunction values and
spatial derivatives:</p>
<p><code class="docutils literal notranslate"><span class="pre">evaluateLog</span></code> Computes the log of the wavefunction and the gradient
and Laplacian (of the log of the wavefunction) for all particles. The
input is the<code class="docutils literal notranslate"><span class="pre">ParticleSet</span></code>(<code class="docutils literal notranslate"><span class="pre">P</span></code>) (of the electrons). The return
value is the log of wavefunction, and the gradient is in <code class="docutils literal notranslate"><span class="pre">G</span></code> and
Laplacian in <code class="docutils literal notranslate"><span class="pre">L</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">ratio</span></code> Computes the wavefunction ratio (not the log) for a single
particle move (<span class="math notranslate nohighlight">\(\psi_{new}/\psi_{old}\)</span>). The inputs are the
<code class="docutils literal notranslate"><span class="pre">ParticleSet</span></code>(<code class="docutils literal notranslate"><span class="pre">P</span></code>) and the particle index (<code class="docutils literal notranslate"><span class="pre">iat</span></code>).</p>
<p><code class="docutils literal notranslate"><span class="pre">evalGrad</span></code> Computes the gradient for a given particle. The inputs are
the <code class="docutils literal notranslate"><span class="pre">ParticleSet</span></code>(<code class="docutils literal notranslate"><span class="pre">P</span></code>) and the particle index (<code class="docutils literal notranslate"><span class="pre">iat</span></code>).</p>
<p><code class="docutils literal notranslate"><span class="pre">ratioGrad</span></code> Computes the wavefunction ratio and the gradient at the
new position for a single particle move. The inputs are the
<code class="docutils literal notranslate"><span class="pre">ParticleSet</span></code>(<code class="docutils literal notranslate"><span class="pre">P</span></code>) and the particle index (<code class="docutils literal notranslate"><span class="pre">iat</span></code>). The output
gradient is in <code class="docutils literal notranslate"><span class="pre">grad_iat</span></code>;</p>
<p>The <code class="docutils literal notranslate"><span class="pre">updateBuffer</span></code> function needs to be implemented, but to start it
can simply call <code class="docutils literal notranslate"><span class="pre">evaluateLog</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">put</span></code> function should be implemented to read parameter specifics
from the input XML file.</p>
</div>
<div class="section" id="function-use">
<h3>Function use<a class="headerlink" href="#function-use" title="Permalink to this headline">¶</a></h3>
<p>For debugging it can be helpful to know the under what conditions the
various routines are called.</p>
<p>The VMC and DMC loops initialize the walkers by calling <code class="docutils literal notranslate"><span class="pre">evaluateLog</span></code>.
For all-electron moves, each timestep advance calls <code class="docutils literal notranslate"><span class="pre">evaluateLog</span></code>. If
the <code class="docutils literal notranslate"><span class="pre">use_drift</span></code> parameter is no, then only the wavefunction value is
used for sampling. The gradient and Laplacian are used for computing the
local energy.</p>
<p>For particle-by-particle moves, each timestep advance</p>
<ol class="arabic simple">
<li><p>calls <code class="docutils literal notranslate"><span class="pre">evalGrad</span></code></p></li>
<li><p>computes a trial move</p></li>
<li><p>calls <code class="docutils literal notranslate"><span class="pre">ratioGrad</span></code> for the wavefunction ratio and the gradient at
the trial position. (If the <code class="docutils literal notranslate"><span class="pre">use_drift</span></code> parameter is no, the
<code class="docutils literal notranslate"><span class="pre">ratio</span></code> function is called instead.)</p></li>
</ol>
<p>The following example shows part of an input block for VMC with
all-electron moves and drift.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">qmc</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;vmc&quot;</span> <span class="n">target</span><span class="o">=</span><span class="s2">&quot;e&quot;</span> <span class="n">move</span><span class="o">=</span><span class="s2">&quot;alle&quot;</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;use_drift&quot;</span><span class="o">&gt;</span><span class="n">yes</span><span class="o">&lt;/</span><span class="n">parameter</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">qmc</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="particle-distances">
<h3>Particle distances<a class="headerlink" href="#particle-distances" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ParticleSet</span></code> parameter in these functions refers to the
electrons. The distance tables that store the inter-particle distances
are stored as an array.</p>
<p>To get the electron-ion distances, add the ion <code class="docutils literal notranslate"><span class="pre">ParticleSet</span></code> using
<code class="docutils literal notranslate"><span class="pre">addTable</span></code> and save the returned index. Use that index to get the
ion-electron distance table.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="nb">int</span> <span class="n">ei_id</span> <span class="o">=</span> <span class="n">elecs</span><span class="o">.</span><span class="n">addTable</span><span class="p">(</span><span class="n">ions</span><span class="p">,</span> <span class="n">DT_SOA</span><span class="p">);</span> <span class="o">//</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">constructor</span> <span class="n">only</span>
<span class="n">const</span> <span class="n">auto</span><span class="o">&amp;</span> <span class="n">ei_table</span> <span class="o">=</span> <span class="n">elecs</span><span class="o">.</span><span class="n">getDistTable</span><span class="p">(</span><span class="n">ei_id</span><span class="p">);</span> <span class="o">//</span> <span class="n">when</span> <span class="n">consuming</span> <span class="n">a</span> <span class="n">distance</span> <span class="n">table</span>
</pre></div>
</div>
<p>Getting the electron-electron distances is very similar, just add the
electron <code class="docutils literal notranslate"><span class="pre">ParticleSet</span></code> using <code class="docutils literal notranslate"><span class="pre">addTable</span></code>.</p>
<p>Only the lower triangle for the electron-electron table should be used.
It is the only part of the distance table valid throughout the run.
During particle-by-particle move, there are extra restrictions. When a
move of electron iel is proposed, only the lower triangle parts
[0,iel)[0,iel) [iel, Nelec)[iel, Nelec) and the row [iel][0:Nelec) are
valid. In fact, the current implementation of distance based two and
three body Jastrow factors in QMCPACK only needs the row [iel][0:Nelec).</p>
<p>In <code class="docutils literal notranslate"><span class="pre">ratioGrad</span></code>, the new distances are stored in the <code class="docutils literal notranslate"><span class="pre">Temp_r</span></code> and
<code class="docutils literal notranslate"><span class="pre">Temp_dr</span></code> members of the distance tables.</p>
</div>
<div class="section" id="setup">
<h3>Setup<a class="headerlink" href="#setup" title="Permalink to this headline">¶</a></h3>
<p>A builder processes XML input, creates the wavefunction, and adds it to
<code class="docutils literal notranslate"><span class="pre">targetPsi</span></code>. Builders derive from <code class="docutils literal notranslate"><span class="pre">WaveFunctionComponentBuilder</span></code>.</p>
<p>The new builder hooks into the XML processing in
<code class="docutils literal notranslate"><span class="pre">WaveFunctionFactory.cpp</span></code> in the <code class="docutils literal notranslate"><span class="pre">build</span></code> function.</p>
</div>
<div class="section" id="caching-values">
<h3>Caching values<a class="headerlink" href="#caching-values" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">acceptMove</span></code> and <code class="docutils literal notranslate"><span class="pre">restore</span></code> methods are called on accepted and
rejected moves for the component to update cached values.</p>
</div>
<div class="section" id="threading">
<h3>Threading<a class="headerlink" href="#threading" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">makeClone</span></code> function needs to be implemented to work correctly
with OpenMP threading. There will be one copy of the component created
for each thread. If there is no extra storage, calling the copy
constructor will be sufficient. If there are cached values, the clone
call may need to create space.</p>
</div>
<div class="section" id="parameter-optimization">
<h3>Parameter optimization<a class="headerlink" href="#parameter-optimization" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">checkInVariables</span></code>, <code class="docutils literal notranslate"><span class="pre">checkOutVariables</span></code>, and <code class="docutils literal notranslate"><span class="pre">resetParameters</span></code>
functions manage the variational parameters. Optimizable variables also
need to be registered when the XML is processed.</p>
<p>Variational parameter derivatives are computed in the
<code class="docutils literal notranslate"><span class="pre">evaluateDerivatives</span></code> function. The first output value is an array
with parameter derivatives of log of the wavefunction. The second output
values is an array with parameter derivatives of the Laplacian divided
by the wavefunction (and not the Laplacian of the log of the
wavefunction) The kinetic energy term contains a <span class="math notranslate nohighlight">\(-1/2m\)</span> factor.
The <span class="math notranslate nohighlight">\(1/m\)</span> factor is applied in <code class="docutils literal notranslate"><span class="pre">TrialWaveFunction.cpp</span></code>, but the
<span class="math notranslate nohighlight">\(-1/2\)</span> is not and must be accounted for in this function.</p>
</div>
<div class="section" id="helium-wavefunction-example">
<span id="id8"></span><h3>Helium Wavefunction Example<a class="headerlink" href="#helium-wavefunction-example" title="Permalink to this headline">¶</a></h3>
<p>The code contains an example of a wavefunction component for a Helium atom using STO orbitals and a Pade Jastrow.</p>
<p>to
The wavefunction is</p>
<div class="math notranslate nohighlight" id="equation-eq265">
<span class="eqno">(265)<a class="headerlink" href="#equation-eq265" title="Permalink to this equation">¶</a></span>\[\psi = \frac{1}{\sqrt{\pi}} \exp(-Z r_1) \exp(-Z r_2) \exp(A / (1 + B r_{12}))\]</div>
<p>where <span class="math notranslate nohighlight">\(Z = 2\)</span> is the nuclear charge, <span class="math notranslate nohighlight">\(A=1/2\)</span> is the
electron-electron cusp, and <span class="math notranslate nohighlight">\(B\)</span> is a variational parameter. The
electron-ion distances are <span class="math notranslate nohighlight">\(r_1\)</span> and <span class="math notranslate nohighlight">\(r_2\)</span>, and
<span class="math notranslate nohighlight">\(r_{12}\)</span> is the electron-electron distance. The wavefunction is
the same as the one expressed with built-in components in
<code class="docutils literal notranslate"><span class="pre">examples/molecules/He/he_simple_opt.xml</span></code>.</p>
<p>The code is in <code class="docutils literal notranslate"><span class="pre">src/QMCWaveFunctions/ExampleHeComponent.cpp</span></code>. The
builder is in <code class="docutils literal notranslate"><span class="pre">src/QMCWaveFunctions/ExampleHeBuilder.cpp</span></code>. The input
file is in <code class="docutils literal notranslate"><span class="pre">examples/molecules/He/he_example_wf.xml</span></code>. A unit test
compares results from the wavefunction evaluation functions for
consistency in <code class="docutils literal notranslate"><span class="pre">src/QMCWaveFunctions/tests/test_example_he.cpp</span></code>.</p>
<p>The recommended approach for creating a new wavefunction component is to
copy the example and the unit test. Implement the evaluation functions
and ensure the unit test passes.</p>
</div>
</div>
<div class="section" id="linear-algebra">
<h2>Linear Algebra<a class="headerlink" href="#linear-algebra" title="Permalink to this headline">¶</a></h2>
<p>Like in many methods which solve the Schrödinger equation, linear
algebra plays a critical role in QMC algorithms and thus is crucial to
the performance of QMCPACK. There are a few components in QMCPACK use
BLAS/LAPACK with their own characteristics.</p>
<div class="section" id="real-space-qmc">
<h3>Real space QMC<a class="headerlink" href="#real-space-qmc" title="Permalink to this headline">¶</a></h3>
<div class="section" id="single-particle-orbitals">
<h4>Single particle orbitals<a class="headerlink" href="#single-particle-orbitals" title="Permalink to this headline">¶</a></h4>
<p>Spline evaluation as commonly used in solid-state simulations does not use any dense linear algebra library calls.
LCAO evaluation as commonly used in molecular calculations relies on BLAS2 GEMV to compute SPOs from a basis set.</p>
</div>
<div class="section" id="slater-determinants">
<h4>Slater determinants<a class="headerlink" href="#slater-determinants" title="Permalink to this headline">¶</a></h4>
<p>Slater determinants are calculated on <span class="math notranslate nohighlight">\(N \times N\)</span> Slater
matrices. <span class="math notranslate nohighlight">\(N\)</span> is the number of electrons for a given spin. In the
actually implementation, operations on the inverse matrix of Slater
matrix for each walker dominate the computation. To initialize it,
DGETRF and DGETRI from LAPACK are called. The inverse matrix can be
stored out of place. During random walking, inverse matrices are updated
by either Sherman-Morrison rank-1 update or delayed update. Update
algorithms heavily relies on BLAS. All the BLAS operations require
S,C,D,Z cases.</p>
<p>Sherman-Morrison rank-1 update uses BLAS2 GEMV and GER on
<span class="math notranslate nohighlight">\(N \times N\)</span> matrices.</p>
<p>Delayed rank-K update uses</p>
<ul class="simple">
<li><p>BLAS1 SCOPY on <span class="math notranslate nohighlight">\(N\)</span> array.</p></li>
<li><p>BLAS2 GEMV, GER on <span class="math notranslate nohighlight">\(k \times N\)</span> and <span class="math notranslate nohighlight">\(k \times k\)</span>
matrices. <span class="math notranslate nohighlight">\(k\)</span> ranges from 1 to <span class="math notranslate nohighlight">\(K\)</span> when updates are
delayed and accumulated.</p></li>
<li><p>BLAS3 GEMM at the final update.</p>
<ul>
<li><p>’T’, ’N’, K, N, N</p></li>
<li><p>’N’, ’N’, N, K, K</p></li>
<li><p>’N’, ’N’, N, N, K</p></li>
</ul>
</li>
</ul>
<p>The optimal K depends on the hardware but it usually ranges from 32 to
256.</p>
<p>QMCPACK solves systems with a few to thousands of electrons. To make all
the BLAS/LAPACK operation efficient on accelerators. Batching is needed
and optimized for <span class="math notranslate nohighlight">\(N &lt; 2000\)</span>. Non-batched functions needs to be
optimized for <span class="math notranslate nohighlight">\(N &gt; 500\)</span>. Note: 2000 and 500 are only rough
estimates.</p>
</div>
<div class="section" id="wavefunction-optimizer">
<h4>Wavefunction optimizer<a class="headerlink" href="#wavefunction-optimizer" title="Permalink to this headline">¶</a></h4>
<p>to be added.</p>
</div>
</div>
<div class="section" id="auxiliary-field-qmc">
<h3>Auxiliary field QMC<a class="headerlink" href="#auxiliary-field-qmc" title="Permalink to this headline">¶</a></h3>
<p>The AFQMC implementation in QMCPACK relies heavily on linear algebra operations from BLAS/LAPACK. The performance of the code is netirely dependent on the performance of these libraries. See below for a detailed list of the main routines used from BLAS/LAPACK. Since the AFQMC code can work with both single and double precision builds, all 4 versions of these routines (S,C,D,Z) are generally needed, for this reason we omit the data type label.</p>
<ul class="simple">
<li><p>BLAS1: SCAL, COPY, DOT, AXPY</p></li>
<li><p>BLAS2: GEMV, GER</p></li>
<li><p>BLAS3: GEMM</p></li>
<li><p>LAPACK: GETRF, GETRI, GELQF, UNGLQ, ORGLQ, GESVD, HEEVR, HEGVX</p></li>
</ul>
<p>While the dimensions of the matrix operations will depend entirely on
the details of the calculation, typical matrix dimensions range from the
100s, for small system sizes, to over 20000 for the largest calculations
attempted so far. For builds with GPU accelerators, we make use of
batched and strided implementations of these routines. Batched
implementations of GEMM, GETRF, GETRI, GELQF and UNGLQ are particularly
important for the performance of the GPU build on small to medium size
problems. Batched implementations of DOT, AXPY and GEMV would also be
quite useful, but they are not yet generally available. On GPU builds,
the code uses batched implementations of these routines when available
by default.</p>
<p id="bibtex-bibliography-developing-0"><dl class="citation">
<dt class="bibtex label" id="kwon1993backflow"><span class="brackets">KCM93</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id4">2</a>,<a href="#id5">3</a>)</span></dt>
<dd><p>Yongkyung Kwon, D. M. Ceperley, and Richard M. Martin. Effects of three-body and backflow correlations in the two-dimensional electron gas. <em>Phys. Rev. B</em>, 48:12037–12046, October 1993. <a class="reference external" href="https://doi.org/10.1103/PhysRevB.48.12037">doi:10.1103/PhysRevB.48.12037</a>.</p>
</dd>
<dt class="bibtex label" id="toulouse2007linear"><span class="brackets"><a class="fn-backref" href="#id6">TU07</a></span></dt>
<dd><p>Julien Toulouse and C. J. Umrigar. Optimization of quantum monte carlo wave functions by energy minimization. <em>The Journal of Chemical Physics</em>, 126(8):084102, 2007. <a class="reference external" href="https://arxiv.org/abs/http://dx.doi.org/10.1063/1.2437215">arXiv:http://dx.doi.org/10.1063/1.2437215</a>, <a class="reference external" href="https://doi.org/10.1063/1.2437215">doi:10.1063/1.2437215</a>.</p>
</dd>
</dl>
</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="appendices.html" class="btn btn-neutral float-right" title="Appendices" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="design_features.html" class="btn btn-neutral float-left" title="QMCPACK Design and Feature Documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, QMCPACK Developers

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>